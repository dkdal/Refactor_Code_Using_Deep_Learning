{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.Invoker;\n\nimport java.io.*;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * CmdAgentImpl is the class that runs remote commands for the CmdService\n * This implementation provides a robust means of running remote\n * commands. All error messages from the remote commands are logged\n * to the error log, which should help in debugging.\n * The user is encouraged not to run huge shell scripts using this\n * interface as the debugging advantages will be lost. Rather, try and\n * break up the task to running Java/native apps as far as possible\n * and use shell scripts sparingly. If the shell scripts spit out\n * periodic status messages indicating the position in its execution\n * cycle, this will aid in debugging.\n * <ul>\n * <li> It implements the CmdAgent interface; see the\n *      CmdAgent.java file for its description.\n * <li> Application-defined exceptions.\n * <\/ul>\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.CmdService\n */\npublic class CmdAgentImpl extends UnicastRemoteObject\n        implements CmdAgent, CommandChecker, Unreferenced {\n\n    private static Logger logger =\n            Logger.getLogger(CmdAgentImpl.class.getName());\n\n    private final List<CommandHandle> handleList = Collections.synchronizedList(\n                                                new ArrayList<CommandHandle>());\n\n    private static HashMap<String, HashMap<String, List<String>>> servicesBinMap =\n                           new HashMap<String, HashMap<String, List<String>>>();\n\n    private static HashMap<String, List<String>> servicesClassPath =\n                                            new HashMap<String, List<String>>();\n\n    private Timer timer;\n\n    String[] baseClassPath;\n    String[] allClassPath; // All class paths including all services class paths\n    String libPath;\n    Map<String, List<String>> binMap;\n    private ArrayList<String> javaCmd;\n\n    static class CmdProcess {\n        String ident;\n        Process process;\n        String logs;\n\n        public CmdProcess() {\n        }\n\n        public CmdProcess(String ident, Process process, String logs) {\n            this.ident = ident;\n            this.process = process;\n            this.logs = logs;\n        }\n    }\n\n\n    // This class must be created only through the main method.\n    CmdAgentImpl() throws RemoteException {\n        super();\n    }\n\n    /**\n     * Sets the benchmark name in the command map file.\n     * @param benchName\n     * @param libPath\n     * @throws java.lang.Exception\n     */\n    void setBenchName(String benchName, List<String> libPath) throws Exception {\n        baseClassPath = getBaseClassPath(benchName);\n        this.libPath = getLibPath(benchName, libPath);\n        binMap = CmdMap.getCmdMap(benchName);\n        servicesBinMap = new HashMap<String, HashMap<String, List<String>>>();\n        servicesClassPath = new HashMap<String, List<String>>();\n    }\n\n    // CmdAgent implementation\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     * @return The hostname\n     */\n    public String getHostName() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Only Other Agents should access the command agent using this method.\n     * @return this Command Agent\n     */\n    public static CmdAgentImpl getHandle() {\n        return AgentBootstrap.cmd;\n    }\n\n    /**\n     * Obtains the tmp directory of a remote host.\n     *\n     * @return The tmp directory.\n     */\n    public String getTmpDir() {\n        return Config.TMP_DIR;\n    }\n\n    /**\n     * Set the logging level of the specified logger.\n     * @param name Name of the logger. If \"\" is passed the root logger level will be set.\n     * @param level The Log level to set\n     */\n    public void setLogLevel(String name, Level level) {\n        LogManager.getLogManager().getLogger(name).setLevel(level);\n\n        //Update logging.properties file which is used by faban driver\n\n    }\n\n    /**\n     * Updates the paths, usually in the local command agent.\n     * @param pathList The list of paths to download\n     */\n    public void updatePaths(List<String> pathList) {\n        ArrayList<String> allClassPathList = new ArrayList<String>();\n        for (String path : pathList)  {\n            try {\n                if (servicesBinMap.get(path) == null) {\n                    servicesBinMap.put(path, CmdMap.getServiceBinMap(path));\n                }\n            } catch (Exception ex) {\n                logger.log(Level.INFO, ex.getMessage() , ex);\n            }\n\n            ArrayList<String> libList = new ArrayList<String>();\n            getClassPath(Config.SERVICE_DIR + path + \"/lib/\", libList);\n            if (libList.size() > 0) {\n                if (servicesClassPath.get(path) == null) {\n                    servicesClassPath.put(path, libList);\n                    allClassPathList.addAll(libList);\n                }\n            }\n        }\n        for (String classPath : baseClassPath)\n            allClassPathList.add(classPath);\n\n        allClassPath = allClassPathList.toArray(\n                new String[allClassPathList.size()]);\n    }\n\n    /**\n     * Downloads the files used by services and tools to\n     * the remote agent system.\n     * @param pathList The list of service bundle paths\n     */\n    public void downloadServices(List<String> pathList) {\n        for (String path : pathList)  {\n            try {\n                new Download().loadService(path, AgentBootstrap.downloadURL);\n            } catch (Exception ex) {\n                logger.log(Level.INFO, ex.getMessage() , ex);\n            }\n        }\n        updatePaths(pathList);\n    }\n\n    /**\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command to execute, or null if not found.\n     */\n    public String which(String cmd, String svcPath) {\n        Map<String, List<String>> extMap = null;\n        extMap = servicesBinMap.get(svcPath);\n        if (extMap != null && cmd.indexOf(File.separator) == -1) {\n            List<String> realCmd = extMap.get(cmd);\n            if (realCmd != null) {\n                return Utilities.print(realCmd, \" \");\n            }\n        }\n        if (cmd.indexOf(File.separator) == -1) { // not an absolute path\n            List<String> realCmd = binMap.get(cmd);\n            if (realCmd != null) {\n                return Utilities.print(realCmd, \" \");\n            }\n        } else { // Check for pathext in case of absolute path...\n            File f = new File(cmd);\n            if (!f.exists()) {\n                logger.finer(cmd + \" does not exist as a file.\");\n                String[] exts = CmdMap.getPathExt();\n                if (exts != null) {\n                    for (String ext : exts) {\n                        String cext = cmd + ext;\n                        logger.finer(\"Trying \" + cext);\n                        f = new File(cext);\n                        if (f.exists()) {\n                            logger.finer(\"Found \" + cext);\n                            return cext;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     *\n     * @param c The command to be executed\n     * @param svcPath The service location, if any\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle execute(Command c, String svcPath)\n                throws IOException, InterruptedException {\n        Map<String, List<String>> extMap = null;\n        if (svcPath != null)\n            extMap = servicesBinMap.get(svcPath);\n\n        c.register(handleList);\n        try {\n            return c.execute(this, extMap);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        } catch (InterruptedException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        }\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param c The command containing the main class\n     * @param svcPath\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle java(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        List<String> extClassPath = null;\n        if (svcPath != null)\n            extClassPath = servicesClassPath.get(svcPath);\n\n        c.register(handleList);\n        try {\n            return c.executeJava(this, extClassPath);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        } catch (InterruptedException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        }\n    }\n\n    /**\n     * Executes the RemoteCallable on the target instance.\n     *\n     * @param callable The callable to execute\n     * @param contextLocation The context location of the invoker\n     * @return The type specified at creation of the callable.\n     * @throws Exception Any exception from the callable\n     */\n    public <V extends Serializable> V exec(RemoteCallable<V> callable,\n                                           String contextLocation)\n            throws Exception {\n        Invoker.setContextLocation(contextLocation);\n        try {\n            return callable.call();\n        } catch (Exception ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        } finally {\n            Invoker.setContextLocation(null);\n        }\n    }\n\n    /**\n     * Registers and starts agent.\n     * @param agentClass The agent class\n     * @param identifier The agent id\n     * @return always returns true\n     * @throws java.lang.Exception If an error occurs in registering the class\n     */\n    public boolean startAgent(Class agentClass, String identifier) throws Exception {\n        try {\n            Remote agent = (Remote)agentClass.newInstance();\n            logger.fine(\"Agent class \" + agent.getClass().getName() + \" created\");\n            AgentBootstrap.registry.reregister(identifier, agent);\n            logger.fine(\"Agent started and Registered as \" + identifier);\n        }catch(Exception e) {\n            logger.log(Level.WARNING, \"Failed to create \" +\n                    agentClass.getName(), e);\n        }\n        return true;\n    }\n\n    /**\n     * Kill off all processes started.\n     */\n    public void kill() {\n        // Now iterate the handle list and kill'em all.\n        synchronized (handleList) {\n            for (CommandHandle handle : handleList) {\n                try {\n                    handle.destroy();\n                } catch (RemoteException e) {\n                    logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                            \"local CommandHandle destroy. \" +\n                            \"Please report bug.\", e);\n                }\n            }\n\n            for (int retries = 0; handleList.size() > 0 && retries < 20;\n                 retries++){\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    logger.log(Level.WARNING, \"Sleep Interrupted. Strange!\", e);\n                }\n\n                // We need to use iterator instead of foreach loop as we need\n                // to remove handles from the list while going through it.\n                Iterator<CommandHandle> iter = handleList.iterator();\n                while (iter.hasNext()) {\n                    CommandHandle handle = iter.next();\n                    boolean terminated = false;\n                    try {\n                        int exitValue = handle.exitValue();\n                        logger.finer(\"Command exited with exit value \" +\n                                exitValue + '.');\n                        terminated = true;\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle exitValue. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER, \"Registry did not terminate! \",\n                                                                            e);\n                    }\n\n                    if (terminated)\n                        iter.remove();\n                    else\n                        try { // kill again...\n                            handle.destroy();\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE, \"Caught RemoteException\" +\n                                    \"on local CommandHandle destroy. \" +\n                                    \"Please report bug.\", e);\n                        }\n                }\n            }\n        }\n\n        int leftover = handleList.size();\n        if (leftover > 0) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Process termination/cleanup unsuccessful after \");\n            msg.append(\"20 attempts. \");\n            msg.append(leftover);\n            msg.append(\" processes remaining. \");\n            msg.append(\"This may affect subsequent runs:\");\n            synchronized(handleList) {\n                for (CommandHandle handle : handleList) {\n                    msg.append(\"<br>\\n\");\n                    try {\n                        msg.append(handle.getCommandString());\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle.getCommandString(). \" +\n                                \"Please report bug.\", e);\n                    }\n                }\n            }\n\n            logger.warning(msg.toString());\n            handleList.clear();\n        }\n\n        /* Exit application */\n        try {\n            AgentBootstrap.deregisterAgents();\n        } catch (RemoteException re){\n            logger.log(Level.WARNING, re.getMessage(), re);\n        }\n\n        logger.fine(\"Killing itself\");\n\n        // *** This is to gracefully return from this method.\n        // *** The Agent will exit after 5 seconds\n        // *** If the System.exit(0) is called in this method\n        // *** the Service will get a RemoteException\n        Thread exitThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(5000);\n                    AgentBootstrap.terminateAgents();\n                } catch (Exception e) {}\n            }\n        };\n        exitThread.start();\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     *\n     * @see         java.rmi.server.Unreferenced\n     *\n     */\n    public void unreferenced()\n    {\n        kill();\n    }\n\n    /**\n     * Obtains the registry.\n     * @return Registry\n     */\n    public static Registry getRegistry() {\n        return AgentBootstrap.registry;\n    }\n\n    /**\n     * Obtains the hostname.\n     * @return hostname\n     */\n    public static String getHost() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Obtains the master hostname.\n     * @return master hostname\n     */\n    public static String getMaster() {\n        return AgentBootstrap.master;\n    }\n\n    // Convert command and arguments to use OS-specific paths, if applicable.\n    private static void convertCommand(List<String> cmd) {\n        int size = cmd.size();\n        for (int i = 0; i < size; i++) {\n            String arg = cmd.get(i);\n            String converted = Utilities.convertPath(arg);\n            if (converted != arg) // Conversion is actually done.\n                cmd.set(i, converted);\n        }\n    }\n\n    /**\n     * Checks and completes the command list, if possible.\n     * @param cmd The command and arg list\n     * @param extMap The external map, if any\n     * @return The checked command\n     */\n    public List<String> checkCommand(List<String> cmd,\n                                     Map<String, List<String>> extMap) {\n\n        convertCommand(cmd);\n\n        String bin = cmd.get(0);\n        // Check for the external/service bin map first.\n        if (extMap != null && bin.indexOf(File.separator) == -1) {\n            List<String> mods = extMap.get(bin);\n            if (mods != null) {\n                CmdMap.replaceFirst(cmd, mods);\n            }\n        }\n        if (bin.indexOf(File.separator) == -1) { // not an absolute path\n            List<String> mods = binMap.get(bin);\n            // If we find modified commands, replace the command with the mods.\n            if (mods != null) {\n                CmdMap.replaceFirst(cmd, mods);\n            }\n        } else { // Check for pathext in case of absolute path...\n            File f = new File(bin);\n            if (!f.exists()) {\n                logger.finer(bin + \" does not exist as a file.\");\n                String[] exts = CmdMap.getPathExt();\n                if (exts != null) {\n                    for (String ext : exts) {\n                        String cext = bin + ext;\n                        logger.finer(\"Trying \" + cext);\n                        f = new File(cext);\n                        if (f.exists()) {\n                            cmd.set(0, cext);\n                            logger.finer(\"Found \" + cext);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return cmd;\n    }\n\n    /**\n     * Checks and completes the java command, if possible.\n     *\n     * @param cmd The original command\n     * @param extClassPath The extended classpath, if any\n     * @return The completed java command\n     */\n    public List<String> checkJavaCommand(List<String> cmd, List<String> extClassPath) {\n\n        convertCommand(cmd);\n\n        if (javaCmd == null) { // Initialize javaCmd if needed.\n            javaCmd = new ArrayList<String>();\n\n            StringBuilder buf = new StringBuilder(AgentBootstrap.javaHome);\n            buf.append(File.separator);\n            buf.append(\"bin\");\n            buf.append(File.separator);\n            buf.append(\"java\");\n            javaCmd.add(buf.toString());\n            buf.setLength(0);\n\n            javaCmd.addAll(AgentBootstrap.jvmOptions);\n\n            javaCmd.add(\"-cp\");\n\n            boolean falseEnding = false;\n            // Externally specified classpath takes precedence.\n            for (String pathElement : AgentBootstrap.extClassPath) {\n                buf.append(pathElement);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n            if (extClassPath != null) {\n                for (String pathElement : extClassPath) {\n                    buf.append(pathElement);\n                    buf.append(File.pathSeparator);\n                    falseEnding = true;\n                }\n            }\n            for (String pathElement : baseClassPath) {\n                buf.append(pathElement);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n            if (falseEnding)\n                buf.setLength(buf.length() - File.pathSeparator.length());\n            javaCmd.add(buf.toString());\n\n            if (libPath != null)\n                javaCmd.add(libPath);\n        }\n\n        ArrayList<String> tmp = new ArrayList<String>(cmd);\n        cmd.clear();\n        cmd.addAll(javaCmd);\n        cmd.addAll(tmp);\n        return cmd;\n    }\n\n    private static void getClassPath(String libDirPath,\n                                     ArrayList<String> libList) {\n        File libDir = new File(libDirPath);\n        if (libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n    }\n\n    private static String[] getBaseClassPath(String benchName) {\n        // The benchmark-specific libs take precedence, add first to list\n        ArrayList<String> libList = new ArrayList<String>();\n        getClassPath(Config.BENCHMARK_DIR + benchName + \"/lib/\", libList);\n        getClassPath(Config.LIB_DIR, libList);\n        String[] baseClassPath = new String[libList.size()];\n        baseClassPath = libList.toArray(baseClassPath);\n        return baseClassPath;\n    }\n\n    private static String getLibPath(String benchName, List<String> libPath) {\n        File libDir = new File(Config.BENCHMARK_DIR + benchName + \"/lib\");\n        File osLibDir = new File(libDir, Config.OS_DIR);\n        File archLibDir = new File(osLibDir, Config.ARCH_DIR);\n        if (containsNonJarFiles(archLibDir)) {\n            libPath.add(archLibDir.getAbsolutePath());\n        }\n        if (containsNonJarFiles(osLibDir)) {\n            libPath.add(osLibDir.getAbsolutePath());\n        }\n        if (containsNonJarFiles(libDir)) {\n            libPath.add(libDir.getAbsolutePath());\n        }\n\n        String libPathString = null;\n        if (libPath.size() > 0) {\n            StringBuilder b = new StringBuilder();\n            b.append(\"-Djava.library.path=\");\n            Iterator<String> iter = libPath.iterator();\n            b.append(iter.next());\n            while (iter.hasNext())\n                b.append(File.pathSeparator).append(iter.next());\n            libPathString = b.toString();\n        }\n        return libPathString;\n    }\n\n    private static boolean containsNonJarFiles(File dir) {\n        if (!dir.isDirectory())\n            return false;\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isFile() && !file.getName().toLowerCase().endsWith(\".jar\"))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets the time on the agent host, in GMT. The time string\n     * must be in the format MMddHHmmyyyy.ss according to Unix date specs\n     * and must be in GMT time.\n     *\n     * @param gmtTimeString Time string in format\n     * @throws IOException An I/O error occurred\n     */\n    public void setTime(String gmtTimeString) throws IOException {\n        Command c = new Command(\"date\", \"-u\", gmtTimeString);\n        c.setLogLevel(Command.STDOUT, Level.FINER);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            int exitValue = c.execute(this, null).exitValue();\n            if (exitValue != 0)\n                logger.log(Level.WARNING, \"Error on \\\"\" + c +\n                        \"\\\" command trying to set the date. Exit value: \" +\n                        exitValue);\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error setting date.\", e);\n            throw e;\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted setting date.\", e);\n        }\n    }\n\n    /**\n     * Gets the time on the agent host, in millis.\n     *\n     * @return The time on the remote system.\n     */\n    public long getTime() {\n        return System.currentTimeMillis();\n    }\n\n    /**\n     * Obtains the timer associated with this command agent.\n     * @return the timer for this command agent\n     */\n    public synchronized Timer getTimer() {\n        if (timer == null)\n            timer = new Timer(\"CmdAgent Timer\", true);\n        return timer;\n    }\n\n    // The class which spawns a thread to read the stream of the process\n    // and dumps it into the tmp file.\n    class LogWriter extends Thread {\n        BufferedReader in;\n        PrintStream out;\n\n        /**\n         * Constructor.\n         * Open files and start thread.\n         *\n         * @param is InputStream to read from\n         * @param logfile String filename to log to\n         * @throws IOException An I/O Error occurred\n         */\n        public LogWriter(InputStream is, String logfile) throws IOException {\n            in = new BufferedReader(new InputStreamReader(is));\n            out = new PrintStream(new FileOutputStream(logfile));\n            this.start();\n        }\n\n        /**\n         * Run, copying input stream's contents to output until no\n         * more data in input file. Exit thread automatically.\n         */\n        @Override\n        public void run() {\n            try {\n                String str = in.readLine();\n                while (str != null) {\n                    out.println(str);\n                    str = in.readLine();\n                }\n            } catch (IOException ie) {\n                return;\n            }\n            return;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.Invoker;\n\nimport java.io.*;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * CmdAgentImpl is the class that runs remote commands for the CmdService\n * This implementation provides a robust means of running remote\n * commands. All error messages from the remote commands are logged\n * to the error log, which should help in debugging.\n * The user is encouraged not to run huge shell scripts using this\n * interface as the debugging advantages will be lost. Rather, try and\n * break up the task to running Java/native apps as far as possible\n * and use shell scripts sparingly. If the shell scripts spit out\n * periodic status messages indicating the position in its execution\n * cycle, this will aid in debugging.\n * <ul>\n * <li> It implements the CmdAgent interface; see the\n *      CmdAgent.java file for its description.\n * <li> Application-defined exceptions.\n * <\/ul>\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.CmdService\n */\npublic class CmdAgentImpl extends UnicastRemoteObject\n        implements CmdAgent, CommandChecker, Unreferenced {\n\n    private static Logger logger =\n            Logger.getLogger(CmdAgentImpl.class.getName());\n\n    private final List<CommandHandle> handleList = Collections.synchronizedList(\n                                                new ArrayList<CommandHandle>());\n\n    private static HashMap<String, HashMap<String, List<String>>> servicesBinMap =\n                           new HashMap<String, HashMap<String, List<String>>>();\n\n    private static HashMap<String, List<String>> servicesClassPath =\n                                            new HashMap<String, List<String>>();\n\n    private Timer timer;\n\n    String[] baseClassPath;\n    String[] allClassPath; // All class paths including all services class paths\n    String libPath;\n    Map<String, List<String>> binMap;\n    private ArrayList<String> javaCmd;\n\n    static class CmdProcess {\n        String ident;\n        Process process;\n        String logs;\n\n        public CmdProcess() {\n        }\n\n        public CmdProcess(String ident, Process process, String logs) {\n            this.ident = ident;\n            this.process = process;\n            this.logs = logs;\n        }\n    }\n\n\n    // This class must be created only through the main method.\n    CmdAgentImpl() throws RemoteException {\n        super();\n    }\n\n    /**\n     * Sets the benchmark name in the command map file.\n     * @param benchName\n     * @param libPath\n     * @throws java.lang.Exception\n     */\n    void setBenchName(String benchName, List<String> libPath) throws Exception {\n        baseClassPath = getBaseClassPath(benchName);\n        this.libPath = getLibPath(benchName, libPath);\n        binMap = CmdMap.getCmdMap(benchName);\n        servicesBinMap = new HashMap<String, HashMap<String, List<String>>>();\n        servicesClassPath = new HashMap<String, List<String>>();\n    }\n\n    // CmdAgent implementation\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     * @return The hostname\n     */\n    public String getHostName() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Only Other Agents should access the command agent using this method.\n     * @return this Command Agent\n     */\n    public static CmdAgentImpl getHandle() {\n        return AgentBootstrap.cmd;\n    }\n\n    /**\n     * Obtains the tmp directory of a remote host.\n     *\n     * @return The tmp directory.\n     */\n    public String getTmpDir() {\n        return Config.TMP_DIR;\n    }\n\n    /**\n     * Set the logging level of the specified logger.\n     * @param name Name of the logger. If \"\" is passed the root logger level will be set.\n     * @param level The Log level to set\n     */\n    public void setLogLevel(String name, Level level) {\n        LogManager.getLogManager().getLogger(name).setLevel(level);\n\n        //Update logging.properties file which is used by faban driver\n\n    }\n\n    /**\n     * Updates the paths, usually in the local command agent.\n     * @param pathList The list of paths to download\n     */\n    public void updatePaths(List<String> pathList) {\n        ArrayList<String> allClassPathList = new ArrayList<String>();\n        for (String path : pathList)  {\n            try {\n                if (servicesBinMap.get(path) == null) {\n                    servicesBinMap.put(path, CmdMap.getServiceBinMap(path));\n                }\n            } catch (Exception ex) {\n                logger.log(Level.INFO, ex.getMessage() , ex);\n            }\n\n            List<String> libList = servicesClassPath.get(path);\n            //servicesClassPath will return null if the service has not been seen before\n            if (libList==null){\n            \tlibList = new ArrayList<String>();\n            \tgetClassPath(Config.SERVICE_DIR + path + \"/lib/\", libList);\n            \tservicesClassPath.put(path, libList);\n            }\n\n            allClassPathList.addAll(libList);\n            \n        }\n        for (String classPath : baseClassPath)\n            allClassPathList.add(classPath);\n\n        allClassPath = allClassPathList.toArray(\n                new String[allClassPathList.size()]);\n    }\n\n    /**\n     * Downloads the files used by services and tools to\n     * the remote agent system.\n     * @param pathList The list of service bundle paths\n     */\n    public void downloadServices(List<String> pathList) {\n        for (String path : pathList)  {\n            try {\n                new Download().loadService(path, AgentBootstrap.downloadURL);\n            } catch (Exception ex) {\n                logger.log(Level.INFO, ex.getMessage() , ex);\n            }\n        }\n        updatePaths(pathList);\n    }\n\n    /**\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command to execute, or null if not found.\n     */\n    public String which(String cmd, String svcPath) {\n        Map<String, List<String>> extMap = null;\n        extMap = servicesBinMap.get(svcPath);\n        if (extMap != null && cmd.indexOf(File.separator) == -1) {\n            List<String> realCmd = extMap.get(cmd);\n            if (realCmd != null) {\n                return Utilities.print(realCmd, \" \");\n            }\n        }\n        if (cmd.indexOf(File.separator) == -1) { // not an absolute path\n            List<String> realCmd = binMap.get(cmd);\n            if (realCmd != null) {\n                return Utilities.print(realCmd, \" \");\n            }\n        } else { // Check for pathext in case of absolute path...\n            File f = new File(cmd);\n            if (!f.exists()) {\n                logger.finer(cmd + \" does not exist as a file.\");\n                String[] exts = CmdMap.getPathExt();\n                if (exts != null) {\n                    for (String ext : exts) {\n                        String cext = cmd + ext;\n                        logger.finer(\"Trying \" + cext);\n                        f = new File(cext);\n                        if (f.exists()) {\n                            logger.finer(\"Found \" + cext);\n                            return cext;\n                        }\n                    }\n                }\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     *\n     * @param c The command to be executed\n     * @param svcPath The service location, if any\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle execute(Command c, String svcPath)\n                throws IOException, InterruptedException {\n        Map<String, List<String>> extMap = null;\n        if (svcPath != null)\n            extMap = servicesBinMap.get(svcPath);\n\n        c.register(handleList);\n        try {\n            return c.execute(this, extMap);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        } catch (InterruptedException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        }\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param c The command containing the main class\n     * @param svcPath\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle java(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        List<String> extClassPath = null;\n        if (svcPath != null)\n            extClassPath = servicesClassPath.get(svcPath);\n\n        c.register(handleList);\n        try {\n            return c.executeJava(this, extClassPath);\n        } catch (IOException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        } catch (InterruptedException ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        }\n    }\n\n    /**\n     * Executes the RemoteCallable on the target instance.\n     *\n     * @param callable The callable to execute\n     * @param contextLocation The context location of the invoker\n     * @return The type specified at creation of the callable.\n     * @throws Exception Any exception from the callable\n     */\n    public <V extends Serializable> V exec(RemoteCallable<V> callable,\n                                           String contextLocation)\n            throws Exception {\n        Invoker.setContextLocation(contextLocation);\n        try {\n            return callable.call();\n        } catch (Exception ex) {\n            logger.log(Level.WARNING, ex.getMessage(), ex);\n            throw ex;\n        } finally {\n            Invoker.setContextLocation(null);\n        }\n    }\n\n    /**\n     * Registers and starts agent.\n     * @param agentClass The agent class\n     * @param identifier The agent id\n     * @return always returns true\n     * @throws java.lang.Exception If an error occurs in registering the class\n     */\n    public boolean startAgent(Class agentClass, String identifier) throws Exception {\n        try {\n            Remote agent = (Remote)agentClass.newInstance();\n            logger.fine(\"Agent class \" + agent.getClass().getName() + \" created\");\n            AgentBootstrap.registry.reregister(identifier, agent);\n            logger.fine(\"Agent started and Registered as \" + identifier);\n        }catch(Exception e) {\n            logger.log(Level.WARNING, \"Failed to create \" +\n                    agentClass.getName(), e);\n        }\n        return true;\n    }\n\n    /**\n     * Kill off all processes started.\n     */\n    public void kill() {\n        // Now iterate the handle list and kill'em all.\n        synchronized (handleList) {\n            for (CommandHandle handle : handleList) {\n                try {\n                    handle.destroy();\n                } catch (RemoteException e) {\n                    logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                            \"local CommandHandle destroy. \" +\n                            \"Please report bug.\", e);\n                }\n            }\n\n            for (int retries = 0; handleList.size() > 0 && retries < 20;\n                 retries++){\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    logger.log(Level.WARNING, \"Sleep Interrupted. Strange!\", e);\n                }\n\n                // We need to use iterator instead of foreach loop as we need\n                // to remove handles from the list while going through it.\n                Iterator<CommandHandle> iter = handleList.iterator();\n                while (iter.hasNext()) {\n                    CommandHandle handle = iter.next();\n                    boolean terminated = false;\n                    try {\n                        int exitValue = handle.exitValue();\n                        logger.finer(\"Command exited with exit value \" +\n                                exitValue + '.');\n                        terminated = true;\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle exitValue. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER, \"Registry did not terminate! \",\n                                                                            e);\n                    }\n\n                    if (terminated)\n                        iter.remove();\n                    else\n                        try { // kill again...\n                            handle.destroy();\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE, \"Caught RemoteException\" +\n                                    \"on local CommandHandle destroy. \" +\n                                    \"Please report bug.\", e);\n                        }\n                }\n            }\n        }\n\n        int leftover = handleList.size();\n        if (leftover > 0) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Process termination/cleanup unsuccessful after \");\n            msg.append(\"20 attempts. \");\n            msg.append(leftover);\n            msg.append(\" processes remaining. \");\n            msg.append(\"This may affect subsequent runs:\");\n            synchronized(handleList) {\n                for (CommandHandle handle : handleList) {\n                    msg.append(\"<br>\\n\");\n                    try {\n                        msg.append(handle.getCommandString());\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle.getCommandString(). \" +\n                                \"Please report bug.\", e);\n                    }\n                }\n            }\n\n            logger.warning(msg.toString());\n            handleList.clear();\n        }\n\n        /* Exit application */\n        try {\n            AgentBootstrap.deregisterAgents();\n        } catch (RemoteException re){\n            logger.log(Level.WARNING, re.getMessage(), re);\n        }\n\n        logger.fine(\"Killing itself\");\n\n        // *** This is to gracefully return from this method.\n        // *** The Agent will exit after 5 seconds\n        // *** If the System.exit(0) is called in this method\n        // *** the Service will get a RemoteException\n        Thread exitThread = new Thread() {\n            @Override\n            public void run() {\n                try {\n                    Thread.sleep(5000);\n                    AgentBootstrap.terminateAgents();\n                } catch (Exception e) {}\n            }\n        };\n        exitThread.start();\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     *\n     * @see         java.rmi.server.Unreferenced\n     *\n     */\n    public void unreferenced()\n    {\n        kill();\n    }\n\n    /**\n     * Obtains the registry.\n     * @return Registry\n     */\n    public static Registry getRegistry() {\n        return AgentBootstrap.registry;\n    }\n\n    /**\n     * Obtains the hostname.\n     * @return hostname\n     */\n    public static String getHost() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Obtains the master hostname.\n     * @return master hostname\n     */\n    public static String getMaster() {\n        return AgentBootstrap.master;\n    }\n\n    // Convert command and arguments to use OS-specific paths, if applicable.\n    private static void convertCommand(List<String> cmd) {\n        int size = cmd.size();\n        for (int i = 0; i < size; i++) {\n            String arg = cmd.get(i);\n            String converted = Utilities.convertPath(arg);\n            if (converted != arg) // Conversion is actually done.\n                cmd.set(i, converted);\n        }\n    }\n\n    /**\n     * Checks and completes the command list, if possible.\n     * @param cmd The command and arg list\n     * @param extMap The external map, if any\n     * @return The checked command\n     */\n    public List<String> checkCommand(List<String> cmd,\n                                     Map<String, List<String>> extMap) {\n\n        convertCommand(cmd);\n\n        String bin = cmd.get(0);\n        // Check for the external/service bin map first.\n        if (extMap != null && bin.indexOf(File.separator) == -1) {\n            List<String> mods = extMap.get(bin);\n            if (mods != null) {\n                CmdMap.replaceFirst(cmd, mods);\n            }\n        }\n        if (bin.indexOf(File.separator) == -1) { // not an absolute path\n            List<String> mods = binMap.get(bin);\n            // If we find modified commands, replace the command with the mods.\n            if (mods != null) {\n                CmdMap.replaceFirst(cmd, mods);\n            }\n        } else { // Check for pathext in case of absolute path...\n            File f = new File(bin);\n            if (!f.exists()) {\n                logger.finer(bin + \" does not exist as a file.\");\n                String[] exts = CmdMap.getPathExt();\n                if (exts != null) {\n                    for (String ext : exts) {\n                        String cext = bin + ext;\n                        logger.finer(\"Trying \" + cext);\n                        f = new File(cext);\n                        if (f.exists()) {\n                            cmd.set(0, cext);\n                            logger.finer(\"Found \" + cext);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return cmd;\n    }\n\n    /**\n     * Checks and completes the java command, if possible.\n     *\n     * @param cmd The original command\n     * @param extClassPath The extended classpath, if any\n     * @return The completed java command\n     */\n    public List<String> checkJavaCommand(List<String> cmd, List<String> extClassPath) {\n\n        convertCommand(cmd);\n\n        if (javaCmd == null) { // Initialize javaCmd if needed.\n            javaCmd = new ArrayList<String>();\n\n            StringBuilder buf = new StringBuilder(AgentBootstrap.javaHome);\n            buf.append(File.separator);\n            buf.append(\"bin\");\n            buf.append(File.separator);\n            buf.append(\"java\");\n            javaCmd.add(buf.toString());\n            buf.setLength(0);\n\n            javaCmd.addAll(AgentBootstrap.jvmOptions);\n\n            javaCmd.add(\"-cp\");\n\n            boolean falseEnding = false;\n            // Externally specified classpath takes precedence.\n            for (String pathElement : AgentBootstrap.extClassPath) {\n                buf.append(pathElement);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n            if (extClassPath != null) {\n                for (String pathElement : extClassPath) {\n                    buf.append(pathElement);\n                    buf.append(File.pathSeparator);\n                    falseEnding = true;\n                }\n            }\n            for (String pathElement : baseClassPath) {\n                buf.append(pathElement);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n            if (falseEnding)\n                buf.setLength(buf.length() - File.pathSeparator.length());\n            javaCmd.add(buf.toString());\n\n            if (libPath != null)\n                javaCmd.add(libPath);\n        }\n\n        ArrayList<String> tmp = new ArrayList<String>(cmd);\n        cmd.clear();\n        cmd.addAll(javaCmd);\n        cmd.addAll(tmp);\n        return cmd;\n    }\n\n    private static void getClassPath(String libDirPath,\n                                     List<String> libList) {\n        File libDir = new File(libDirPath);\n        if (libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n    }\n\n    private static String[] getBaseClassPath(String benchName) {\n        // The benchmark-specific libs take precedence, add first to list\n        ArrayList<String> libList = new ArrayList<String>();\n        getClassPath(Config.BENCHMARK_DIR + benchName + \"/lib/\", libList);\n        getClassPath(Config.LIB_DIR, libList);\n        String[] baseClassPath = new String[libList.size()];\n        baseClassPath = libList.toArray(baseClassPath);\n        return baseClassPath;\n    }\n\n    private static String getLibPath(String benchName, List<String> libPath) {\n        File libDir = new File(Config.BENCHMARK_DIR + benchName + \"/lib\");\n        File osLibDir = new File(libDir, Config.OS_DIR);\n        File archLibDir = new File(osLibDir, Config.ARCH_DIR);\n        if (containsNonJarFiles(archLibDir)) {\n            libPath.add(archLibDir.getAbsolutePath());\n        }\n        if (containsNonJarFiles(osLibDir)) {\n            libPath.add(osLibDir.getAbsolutePath());\n        }\n        if (containsNonJarFiles(libDir)) {\n            libPath.add(libDir.getAbsolutePath());\n        }\n\n        String libPathString = null;\n        if (libPath.size() > 0) {\n            StringBuilder b = new StringBuilder();\n            b.append(\"-Djava.library.path=\");\n            Iterator<String> iter = libPath.iterator();\n            b.append(iter.next());\n            while (iter.hasNext())\n                b.append(File.pathSeparator).append(iter.next());\n            libPathString = b.toString();\n        }\n        return libPathString;\n    }\n\n    private static boolean containsNonJarFiles(File dir) {\n        if (!dir.isDirectory())\n            return false;\n        File[] files = dir.listFiles();\n        for (File file : files) {\n            if (file.isFile() && !file.getName().toLowerCase().endsWith(\".jar\"))\n                return true;\n        }\n        return false;\n    }\n\n    /**\n     * Sets the time on the agent host, in GMT. The time string\n     * must be in the format MMddHHmmyyyy.ss according to Unix date specs\n     * and must be in GMT time.\n     *\n     * @param gmtTimeString Time string in format\n     * @throws IOException An I/O error occurred\n     */\n    public void setTime(String gmtTimeString) throws IOException {\n        Command c = new Command(\"date\", \"-u\", gmtTimeString);\n        c.setLogLevel(Command.STDOUT, Level.FINER);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            int exitValue = c.execute(this, null).exitValue();\n            if (exitValue != 0)\n                logger.log(Level.WARNING, \"Error on \\\"\" + c +\n                        \"\\\" command trying to set the date. Exit value: \" +\n                        exitValue);\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error setting date.\", e);\n            throw e;\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted setting date.\", e);\n        }\n    }\n\n    /**\n     * Gets the time on the agent host, in millis.\n     *\n     * @return The time on the remote system.\n     */\n    public long getTime() {\n        return System.currentTimeMillis();\n    }\n\n    /**\n     * Obtains the timer associated with this command agent.\n     * @return the timer for this command agent\n     */\n    public synchronized Timer getTimer() {\n        if (timer == null)\n            timer = new Timer(\"CmdAgent Timer\", true);\n        return timer;\n    }\n\n    // The class which spawns a thread to read the stream of the process\n    // and dumps it into the tmp file.\n    class LogWriter extends Thread {\n        BufferedReader in;\n        PrintStream out;\n\n        /**\n         * Constructor.\n         * Open files and start thread.\n         *\n         * @param is InputStream to read from\n         * @param logfile String filename to log to\n         * @throws IOException An I/O Error occurred\n         */\n        public LogWriter(InputStream is, String logfile) throws IOException {\n            in = new BufferedReader(new InputStreamReader(is));\n            out = new PrintStream(new FileOutputStream(logfile));\n            this.start();\n        }\n\n        /**\n         * Run, copying input stream's contents to output until no\n         * more data in input file. Exit thread automatically.\n         */\n        @Override\n        public void run() {\n            try {\n                String str = in.readLine();\n                while (str != null) {\n                    out.println(str);\n                    str = in.readLine();\n                }\n            } catch (IOException ie) {\n                return;\n            }\n            return;\n        }\n    }\n}\n","lineNo":178}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.rmi.RMISecurityManager;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.RMISocketFactory;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * Bootstrap class for the CmdAgent and FileAgent.\n */\npublic class AgentBootstrap {\n\n    private static int daemonPort = 9981;\n\n    private static Logger logger =\n                            Logger.getLogger(AgentBootstrap.class.getName());\n    static AgentSocketFactory socketFactory;\n    static String progName;\n    static boolean daemon = false;\n    static String host;\n    static String ident;\n    static String master;\n    static Registry registry;\n    static String javaHome;\n    static String downloadURL;\n    // Initialize it to make sure it doesn't end up a 'null'\n    static ArrayList<String> jvmOptions = new ArrayList<String>();\n    static ArrayList<String> extClassPath = new ArrayList<String>();\n    static CmdAgentImpl cmd;\n    static FileAgentImpl file;\n    static final Set<String> registeredNames =\n                    Collections.synchronizedSet(new HashSet<String>());\n\n    /**\n     * Starts the agent bootstrap.\n     * @param args The command line arguments\n     */\n    public static void main(String[] args) {\n        System.setSecurityManager (new RMISecurityManager());\n\n        progName = System.getProperty(\"faban.cli.command\");\n        String usage = \"Usage: \" + progName + \" [port]\";\n\n        if (args.length < 2) {\n            if (args.length == 1) {\n                if (\"-h\".equals(args[0]) || \"--help\".equals(args[0]) ||\n                                            \"-?\".equals(args[0])) {\n                    System.err.println(usage);\n                    System.exit(0);\n                } else {\n                    daemonPort = Integer.parseInt(args[0]);\n                }\n            }\n            startDaemon();\n        } else if (args.length > 3) {\n            try {\n                startAgents(args);\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        } else {\n            // We do not expose the start params for agent mode as that\n            // is not supposed to be called by the user. The daemon mode\n            // has only one optional param - port.\n            System.err.println(usage);\n            System.exit(-1);\n        }\n    }\n\n    private static void startDaemon() {\n        daemon = true;\n        /* Note that the daemon is not designed to accept any concurrency at\n         * all and hence the accept/dispatch is not threaded. This is not a\n         * bug. It should only receive one and only one connection request per\n         * run. Requests to start an agent while one is running will return\n         * with an error. We don't care if a concurrent request has to wait.\n         * Simplicity is the goal here.\n         */\n        try {\n            ServerSocket serverSocket = new ServerSocket(daemonPort);\n            for (;;) {\n                Socket socket = serverSocket.accept();\n                ObjectInputStream in =\n                        new ObjectInputStream(socket.getInputStream());\n                OutputStream out = socket.getOutputStream();\n                ArrayList<String> argList = null;\n                try {\n                    argList = (ArrayList<String>) in.readObject();\n                } catch (ClassNotFoundException e) {\n                    System.err.println(\"WARNING: Object class not found.\");\n                    e.printStackTrace();\n                    continue;\n                }\n                int length = argList.size();\n                if (length > 0) {\n                    System.out.println(\"Agent(Daemon) starting agent with \" +\n                            \"options: \" + argList);\n                    Utilities.masterPathSeparator = argList.remove(--length);\n                    Utilities.masterFileSeparator = argList.remove(--length);\n\n                    if (length < 4) {\n                       out.write(\"400 ERROR: Inadequate params.\".getBytes());\n                       continue;\n                    }\n\n                    String[] args = new String[length];\n                    args = argList.toArray(args);\n\n                    try {\n                        startAgents(args);\n                        out.write(\"200 OK\".getBytes());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        out.write((\"500 ERROR: \" + e.getMessage()).getBytes());\n                    }\n                }\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n                try {\n                    out.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();  // We don't use logger here 'cause we don't\n            // know the harness at this time.\n            // The logger may not be configured properly.\n            System.exit(1);\n        }\n\n    }\n\n    private static synchronized void startAgents(String[] args)\n            throws Exception {\n\n        String hostname = args[0];\n        master = args[1];\n        String masterLocal = args[2];\n        javaHome = args[3];\n\n        String benchName = null;\n\n        // Setup the basic jvmOptions for this environment which may not\n        // be the same as passed down from the master.\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                                                        fs + \"faban.policy\");\n        host = InetAddress.getLocalHost().getHostName();\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                                        \"config\" + fs + \"logging.\" + host +\n                                        \".properties\");\n\n        ArrayList<String> libPath = new ArrayList<String>();\n        String libPrefix = \"-Djava.library.path=\";\n\n        // There may be optional JVM args\n        boolean isClassPath = false;\n        if(args.length > 4) {\n            for(int i = 4; i < args.length; i++)\n                if(args[i].startsWith(\"faban.download\")) {\n                    downloadURL = args[i].substring(\n                            args[i].indexOf('=') + 1);\n                }else if (args[i].startsWith(\"faban.benchmarkName\")) {\n                    benchName = args[i].substring(args[i].indexOf('=') + 1);\n                } else if (args[i].indexOf(\"faban.logging.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.LOGGING_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].indexOf(\"faban.registry.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.RMI_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].startsWith(\"-Dfaban.command.buffer=\")) {\n                    String[] prop = args[i].substring(2).split(\"=\");\n                    System.setProperty(prop[0], prop[1]);\n                    // Pass it along, too.\n                    jvmOptions.add(args[i]);\n                } else if (\"-server\".equals(args[i]) ||\n                        \"-client\".equals(args[i])) { // prepend these options\n                    jvmOptions.add(0, args[i]);\n                } else if (args[i].startsWith(\"-Dfaban.home=\") ||\n                        args[i].startsWith(\"-Djava.security.policy=\") ||\n                        args[i].startsWith(\"-Djava.util.logging.config.file=\")){\n                    // These are sometimes passed down from the master.\n                    // Ignore these. Use our local settings instead.\n                    // NOOP\n                } else if (\"-cp\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (\"-classpath\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (isClassPath) {\n                    String[] cp = pathSplit(args[i]);\n                    for (String cpElement : cp)\n                        extClassPath.add(Utilities.convertPath(cpElement));\n                    isClassPath = false;\n                } else if (args[i].startsWith(libPrefix)) {\n                    String[] lp = pathSplit(\n                            args[i].substring(libPrefix.length()));\n                    for (String lpElement : lp)\n                        libPath.add(Utilities.convertPath(lpElement));\n                } else {\n                    jvmOptions.add(args[i]);\n                }\n        }\n\n        setLogger();\n\n        // Ensure proper JAVA_HOME by searching for the java executable.\n        File java = null;\n        File javaBin = new File(javaHome, \"bin\");\n        if (javaBin.isDirectory()) {\n            String[] pathExts = CmdMap.getPathExt();\n            if (pathExts != null) {\n                for (String ext : pathExts) {\n                    ext = ext.trim();\n                    if (ext == null || ext.length() == 0)\n                        continue;\n                    File javaPath = new File(javaBin, \"java\" + ext);\n                    if (javaPath.exists()) {\n                        java = javaPath;\n                        break;\n                    }\n                }\n            }\n            if (java == null) {\n                java = new File(javaBin, \"java\");\n                if (!java.exists()) {\n                    java = null;\n                }\n            }\n        }\n\n        // If not found, just use the process' JAVA_HOME instead.\n        if (java == null) {\n            String newJavaHome = Utilities.getJavaHome();\n            if (!newJavaHome.equals(javaHome)) {\n                logger.warning(\"JAVA_HOME \" + javaHome +\n                        \" does not exist. Using \" + newJavaHome + \" instead.\");\n                javaHome = newJavaHome;\n            }\n        }\n\n        logger.finer(\"JVM options for child processes:\" + jvmOptions);\n\n        // We cannot set the socket factory twice. So we need to reconfigure it.\n        if (socketFactory == null) {\n            socketFactory = new AgentSocketFactory(master, masterLocal);\n            RMISocketFactory.setSocketFactory(socketFactory);\n        } else {\n            socketFactory.setMaster(master, masterLocal);\n        }\n\n        // Get hold of the registry\n        registry = RegistryLocator.getRegistry(master, Config.RMI_PORT);\n        logger.fine(\"Succeeded obtaining registry.\");\n\n        // Sometimes we get the host name with the whole domain baggage.\n        // The host name is widely used in result files, tools, etc. We\n        // do not want that baggage. So we make sure to crop it off.\n        // i.e. brazilian.sfbay.Sun.COM should just show as brazilian.\n        int dotIdx = host.indexOf('.');\n        if (dotIdx > 0)\n            host = host.substring(0, dotIdx);\n\n        //ident will be unique\n        ident = Config.CMD_AGENT + \"@\" + host;\n\n        // Make sure there is only one agent running in a machine\n        CmdAgent agent = (CmdAgent) registry.getService(ident);\n\n        if (agent == null) { // If not found, reregister new agent.\n            boolean agentCreated = false;\n            if (cmd == null) {\n                cmd = new CmdAgentImpl();\n                agentCreated = true;\n                logger.fine(hostname + \"(Realname: \" + host +\n                                                \") created CmdAgentImpl\");\n            }\n\n            if (register(ident, cmd)) { // Double check for race condition\n                agent = cmd;\n\n                // setBenchName scans all resources.\n                // Benchmark needs to be loaded first.\n                new Download().loadBenchmark(benchName, downloadURL);\n                cmd.setBenchName(benchName, libPath);\n\n                if(host.equals(master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                } else if (sameHost(host, master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                }\n\n                // Create and reregister FileAgent\n                if (file == null)\n                    file = new FileAgentImpl();\n                reregister(Config.FILE_AGENT + \"@\" + host, file);\n\n                // Register a blank Config.FILE_AGENT for the master's\n                // file agent.\n                if (sameHost(host, master))\n                    reregister(Config.FILE_AGENT, file);\n            } else { // If we run into that, we just grab the agent again.\n                if (agentCreated) {\n                    UnicastRemoteObject.unexportObject(cmd, true);\n                    agentCreated = false;\n                    logger.fine(hostname + \"(Realname: \" + host +\n                                                \") unexported CmdAgentImpl\");\n                }\n                agent = (CmdAgent) registry.getService(ident);\n            }\n        }\n\n        // Only if the 'hostname' is an interface name and not equal\n        // the actual host name, we re-reregister the agents with the 'hostname'\n        if (!host.equals(hostname)) {\n            reregister(Config.CMD_AGENT + \"@\" + hostname, agent);\n\n            // The FileAgent registration may have a significant lag time\n            // from the CmdAgent registration due to downloads, etc.\n            // We just need to wait.\n            FileAgent f = (FileAgent) registry.getService(\n                                            Config.FILE_AGENT + \"@\" + host);\n            int retry = 0;\n            while (f == null) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                }\n                f = (FileAgent) registry.getService(\n                        Config.FILE_AGENT + \"@\" + host);\n                if (++retry > 100)\n                    break;\n            }\n            if (f != null)\n                reregister(Config.FILE_AGENT + \"@\" + hostname, f);\n            else\n                logger.severe(\"Giving up re-registering file agent at \" + host +\n                        \" as \" + hostname +\" after \" + retry + \" retries.\");\n        }\n    }\n\n    private static boolean register(String name, Remote service)\n            throws RemoteException {\n        boolean success = false;\n        if (registeredNames.add(name)) {\n            success = registry.register(name, service);\n            if (success) {\n                logger.fine(\"Succeeded registering \" + name);\n            } else {\n                logger.fine(\"Failed registering \" + name +\n                                        \". Entry already exists.\");\n            }\n        }\n        return success;\n    }\n\n    private static void reregister(String name, Remote service)\n            throws RemoteException {\n        if (registeredNames.add(name)) {\n            registry.reregister(name, service);\n            logger.fine(\"Succeeded re-registering \" + name);\n        }\n    }\n\n    /**\n     * Unregisters all the registered services.\n     * @throws RemoteException A network error occurred\n     */\n    static void deregisterAgents() throws RemoteException {\n        synchronized(registeredNames) {\n            for (String name : registeredNames)\n                registry.unregister(name);\n\n            registeredNames.clear();\n        }\n    }\n\n    /**\n     * Terminates the agents.\n     */\n    static void terminateAgents() {\n        if (!daemon) {\n            System.exit(0);\n        }\n    }\n\n    /**\n     * This method is for splitting both Unix and Windows paths into their\n     * pathElements. It detects the path separator whether it is Unix or\n     * Windows style and takes care of the separators accordingly.\n     * @param path The path to split\n     * @return The splitted path\n     */\n    private static String[] pathSplit(String path) {\n        char pathSeparator = ':';  // Unix style by default.\n\n        // Check for '\\' used in Windows paths.\n        if (path.indexOf('\\\\') >= 0) {\n            pathSeparator=';';\n        }\n\n        // Check for \"c:/foo/bar\" sometimes used in Windows paths\n        if (pathSeparator == ':' ) {\n            Pattern p = Pattern.compile(\"\\\\A[a-zA-Z]:/\");\n            Matcher m = p.matcher(path);\n            if (m.find())\n                pathSeparator = ';';\n        }\n\n        // Check for ...;c:/foo/bar at any place in the path\n        if (pathSeparator == ':' ) {\n            Pattern p = Pattern.compile(\";[a-zA-Z]:/\");\n            Matcher m = p.matcher(path);\n            if (m.find())\n                pathSeparator = ';';\n        }\n\n        String delimiter = \"\" + pathSeparator;\n\n        return path.split(delimiter);\n    }\n\n    private static boolean sameHost(String host1, String host2) {\n        InetAddress[] host1Ip = new InetAddress[0];\n        try {\n            host1Ip = InetAddress.getAllByName(host1);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host1 + \" not found.\");\n            return false;\n        }\n        InetAddress[] host2Ip = new InetAddress[0];\n        try {\n            host2Ip = InetAddress.getAllByName(host2);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host2 + \" not found.\");\n            return false;\n        }\n        for (int i = 0; i < host1Ip.length; i++) {\n            for (int j = 0; j < host2Ip.length; j++) {\n                if (host1Ip[i].equals(host2Ip[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private static void setLogger() {\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            logger.fine(\"Updating \" + Config.CONFIG_DIR + \"logging.\" +\n                    host + \".properties\");\n            log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n            log.setProperty(\"java.util.logging.SocketHandler.port\",\n                    String.valueOf(Config.LOGGING_PORT));\n            FileOutputStream out = new FileOutputStream(\n                    new File(Config.CONFIG_DIR + \"logging.\" + host +\n                    \".properties\"));\n            log.store(out, \"Faban logging properties\");\n            out.close();\n\n            LogManager.getLogManager().readConfiguration(new FileInputStream(\n                    Config.CONFIG_DIR + \"logging.\" + host + \".properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.rmi.RMISecurityManager;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.RMISocketFactory;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * Bootstrap class for the CmdAgent and FileAgent.\n */\npublic class AgentBootstrap {\n\n    private static int daemonPort = 9981;\n\n    private static Logger logger =\n                            Logger.getLogger(AgentBootstrap.class.getName());\n    static AgentSocketFactory socketFactory;\n    static String progName;\n    static boolean daemon = false;\n    static String host;\n    static String ident;\n    static String master;\n    static Registry registry;\n    static String javaHome;\n    static String downloadURL;\n    // Initialize it to make sure it doesn't end up a 'null'\n    static ArrayList<String> jvmOptions = new ArrayList<String>();\n    static ArrayList<String> extClassPath = new ArrayList<String>();\n    static CmdAgentImpl cmd;\n    static FileAgentImpl file;\n    static final Set<String> registeredNames =\n                    Collections.synchronizedSet(new HashSet<String>());\n\n    /**\n     * Starts the agent bootstrap.\n     * @param args The command line arguments\n     */\n    public static void main(String[] args) {\n        System.setSecurityManager (new RMISecurityManager());\n\n        progName = System.getProperty(\"faban.cli.command\");\n        String usage = \"Usage: \" + progName + \" [port]\";\n\n        if (args.length < 2) {\n            if (args.length == 1) {\n                if (\"-h\".equals(args[0]) || \"--help\".equals(args[0]) ||\n                                            \"-?\".equals(args[0])) {\n                    System.err.println(usage);\n                    System.exit(0);\n                } else {\n                    daemonPort = Integer.parseInt(args[0]);\n                }\n            }\n            startDaemon();\n        } else if (args.length > 3) {\n            try {\n                startAgents(args);\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        } else {\n            // We do not expose the start params for agent mode as that\n            // is not supposed to be called by the user. The daemon mode\n            // has only one optional param - port.\n            System.err.println(usage);\n            System.exit(-1);\n        }\n    }\n\n    private static void startDaemon() {\n        daemon = true;\n        /* Note that the daemon is not designed to accept any concurrency at\n         * all and hence the accept/dispatch is not threaded. This is not a\n         * bug. It should only receive one and only one connection request per\n         * run. Requests to start an agent while one is running will return\n         * with an error. We don't care if a concurrent request has to wait.\n         * Simplicity is the goal here.\n         */\n        try {\n            ServerSocket serverSocket = new ServerSocket(daemonPort);\n            for (;;) {\n                Socket socket = serverSocket.accept();\n                ObjectInputStream in =\n                        new ObjectInputStream(socket.getInputStream());\n                OutputStream out = socket.getOutputStream();\n                ArrayList<String> argList = null;\n                try {\n                    argList = (ArrayList<String>) in.readObject();\n                } catch (ClassNotFoundException e) {\n                    System.err.println(\"WARNING: Object class not found.\");\n                    e.printStackTrace();\n                    continue;\n                }\n                int length = argList.size();\n                if (length > 0) {\n                    System.out.println(\"Agent(Daemon) starting agent with \" +\n                            \"options: \" + argList);\n                    Utilities.masterPathSeparator = argList.remove(--length);\n                    Utilities.masterFileSeparator = argList.remove(--length);\n\n                    if (length < 4) {\n                       out.write(\"400 ERROR: Inadequate params.\".getBytes());\n                       continue;\n                    }\n\n                    String[] args = new String[length];\n                    args = argList.toArray(args);\n\n                    try {\n                        startAgents(args);\n                        out.write(\"200 OK\".getBytes());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        out.write((\"500 ERROR: \" + e.getMessage()).getBytes());\n                    }\n                }\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n                try {\n                    out.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();  // We don't use logger here 'cause we don't\n            // know the harness at this time.\n            // The logger may not be configured properly.\n            System.exit(1);\n        }\n\n    }\n\n    private static synchronized void startAgents(String[] args)\n            throws Exception {\n\n        String hostname = args[0];\n        master = args[1];\n        String masterLocal = args[2];\n        javaHome = args[3];\n\n        String benchName = null;\n\n        // Setup the basic jvmOptions for this environment which may not\n        // be the same as passed down from the master.\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                                                        fs + \"faban.policy\");\n        host = InetAddress.getLocalHost().getHostName();\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                                        \"config\" + fs + \"logging.\" + host +\n                                        \".properties\");\n\n        ArrayList<String> libPath = new ArrayList<String>();\n        String libPrefix = \"-Djava.library.path=\";\n\n        // There may be optional JVM args\n        boolean isClassPath = false;\n        if(args.length > 4) {\n            for(int i = 4; i < args.length; i++)\n                if(args[i].startsWith(\"faban.download\")) {\n                    downloadURL = args[i].substring(\n                            args[i].indexOf('=') + 1);\n                }else if (args[i].startsWith(\"faban.benchmarkName\")) {\n                    benchName = args[i].substring(args[i].indexOf('=') + 1);\n                } else if (args[i].indexOf(\"faban.logging.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.LOGGING_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].indexOf(\"faban.registry.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.RMI_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].startsWith(\"-Dfaban.command.buffer=\")) {\n                    String[] prop = args[i].substring(2).split(\"=\");\n                    System.setProperty(prop[0], prop[1]);\n                    // Pass it along, too.\n                    jvmOptions.add(args[i]);\n                } else if (\"-server\".equals(args[i]) ||\n                        \"-client\".equals(args[i])) { // prepend these options\n                    jvmOptions.add(0, args[i]);\n                } else if (args[i].startsWith(\"-Dfaban.home=\") ||\n                        args[i].startsWith(\"-Djava.security.policy=\") ||\n                        args[i].startsWith(\"-Djava.util.logging.config.file=\")){\n                    // These are sometimes passed down from the master.\n                    // Ignore these. Use our local settings instead.\n                    // NOOP\n                } else if (\"-cp\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (\"-classpath\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (isClassPath) {\n                    String[] cp = pathSplit(args[i]);\n                    for (String cpElement : cp)\n                        extClassPath.add(Utilities.convertPath(cpElement));\n                    isClassPath = false;\n                } else if (args[i].startsWith(libPrefix)) {\n                    String[] lp = pathSplit(\n                            args[i].substring(libPrefix.length()));\n                    for (String lpElement : lp)\n                        libPath.add(Utilities.convertPath(lpElement));\n                } else {\n                    jvmOptions.add(args[i]);\n                }\n        }\n\n        setLogger();\n\n        // Ensure proper JAVA_HOME by searching for the java executable.\n        File java = null;\n        File javaBin = new File(javaHome, \"bin\");\n        if (javaBin.isDirectory()) {\n            String[] pathExts = CmdMap.getPathExt();\n            if (pathExts != null) {\n                for (String ext : pathExts) {\n                    ext = ext.trim();\n                    if (ext == null || ext.length() == 0)\n                        continue;\n                    File javaPath = new File(javaBin, \"java\" + ext);\n                    if (javaPath.exists()) {\n                        java = javaPath;\n                        break;\n                    }\n                }\n            }\n            if (java == null) {\n                java = new File(javaBin, \"java\");\n                if (!java.exists()) {\n                    java = null;\n                }\n            }\n        }\n\n        // If not found, just use the process' JAVA_HOME instead.\n        if (java == null) {\n            String newJavaHome = Utilities.getJavaHome();\n            if (!newJavaHome.equals(javaHome)) {\n                logger.warning(\"JAVA_HOME \" + javaHome +\n                        \" does not exist. Using \" + newJavaHome + \" instead.\");\n                javaHome = newJavaHome;\n            }\n        }\n\n        logger.finer(\"JVM options for child processes:\" + jvmOptions);\n\n        // We cannot set the socket factory twice. So we need to reconfigure it.\n        if (socketFactory == null) {\n            socketFactory = new AgentSocketFactory(master, masterLocal);\n            RMISocketFactory.setSocketFactory(socketFactory);\n        } else {\n            socketFactory.setMaster(master, masterLocal);\n        }\n\n        // Get hold of the registry\n        registry = RegistryLocator.getRegistry(master, Config.RMI_PORT);\n        logger.fine(\"Succeeded obtaining registry.\");\n\n        // Sometimes we get the host name with the whole domain baggage.\n        // The host name is widely used in result files, tools, etc. We\n        // do not want that baggage. So we make sure to crop it off.\n        // i.e. brazilian.sfbay.Sun.COM should just show as brazilian.\n\n        // Keep just the one dot after the host. In example above, brazilian.sfbay\n        logger.finer(\"Original host is \" + host);\n        int dotIdx = host.indexOf(\".\");\n        int nextDotIdx = host.substring(dotIdx+1).indexOf('.');\n        if (nextDotIdx > 0)\n            host = host.substring(0, dotIdx + nextDotIdx + 1);\n        logger.finer(\"dotIdx is \" + dotIdx + \", nextDotIdx is \" + nextDotIdx +\n                \", Modified Host is \" + host);\n        //ident will be unique\n        ident = Config.CMD_AGENT + \"@\" + host;\n\n        // Make sure there is only one agent running in a machine\n        CmdAgent agent = (CmdAgent) registry.getService(ident);\n\n        if (agent == null) { // If not found, reregister new agent.\n            boolean agentCreated = false;\n            if (cmd == null) {\n                cmd = new CmdAgentImpl();\n                agentCreated = true;\n                logger.fine(hostname + \"(Realname: \" + host +\n                                                \") created CmdAgentImpl\");\n            }\n\n            if (register(ident, cmd)) { // Double check for race condition\n                agent = cmd;\n\n                // setBenchName scans all resources.\n                // Benchmark needs to be loaded first.\n                new Download().loadBenchmark(benchName, downloadURL);\n                cmd.setBenchName(benchName, libPath);\n\n                if(host.equals(master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                } else if (sameHost(host, master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                }\n\n                // Create and reregister FileAgent\n                if (file == null)\n                    file = new FileAgentImpl();\n                reregister(Config.FILE_AGENT + \"@\" + host, file);\n\n                // Register a blank Config.FILE_AGENT for the master's\n                // file agent.\n                if (sameHost(host, master))\n                    reregister(Config.FILE_AGENT, file);\n            } else { // If we run into that, we just grab the agent again.\n                if (agentCreated) {\n                    UnicastRemoteObject.unexportObject(cmd, true);\n                    agentCreated = false;\n                    logger.fine(hostname + \"(Realname: \" + host +\n                                                \") unexported CmdAgentImpl\");\n                }\n                agent = (CmdAgent) registry.getService(ident);\n            }\n        }\n\n        // Only if the 'hostname' is an interface name and not equal\n        // the actual host name, we re-reregister the agents with the 'hostname'\n        if (!host.equals(hostname)) {\n            reregister(Config.CMD_AGENT + \"@\" + hostname, agent);\n\n            // The FileAgent registration may have a significant lag time\n            // from the CmdAgent registration due to downloads, etc.\n            // We just need to wait.\n            FileAgent f = (FileAgent) registry.getService(\n                                            Config.FILE_AGENT + \"@\" + host);\n            int retry = 0;\n            while (f == null) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                }\n                f = (FileAgent) registry.getService(\n                        Config.FILE_AGENT + \"@\" + host);\n                if (++retry > 100)\n                    break;\n            }\n            if (f != null)\n                reregister(Config.FILE_AGENT + \"@\" + hostname, f);\n            else\n                logger.severe(\"Giving up re-registering file agent at \" + host +\n                        \" as \" + hostname +\" after \" + retry + \" retries.\");\n        }\n    }\n\n    private static boolean register(String name, Remote service)\n            throws RemoteException {\n        boolean success = false;\n        if (registeredNames.add(name)) {\n            success = registry.register(name, service);\n            if (success) {\n                logger.fine(\"Succeeded registering \" + name);\n            } else {\n                logger.fine(\"Failed registering \" + name +\n                                        \". Entry already exists.\");\n            }\n        }\n        return success;\n    }\n\n    private static void reregister(String name, Remote service)\n            throws RemoteException {\n        if (registeredNames.add(name)) {\n            registry.reregister(name, service);\n            logger.fine(\"Succeeded re-registering \" + name);\n        }\n    }\n\n    /**\n     * Unregisters all the registered services.\n     * @throws RemoteException A network error occurred\n     */\n    static void deregisterAgents() throws RemoteException {\n        synchronized(registeredNames) {\n            for (String name : registeredNames)\n                registry.unregister(name);\n\n            registeredNames.clear();\n        }\n    }\n\n    /**\n     * Terminates the agents.\n     */\n    static void terminateAgents() {\n        if (!daemon) {\n            System.exit(0);\n        }\n    }\n\n    /**\n     * This method is for splitting both Unix and Windows paths into their\n     * pathElements. It detects the path separator whether it is Unix or\n     * Windows style and takes care of the separators accordingly.\n     * @param path The path to split\n     * @return The splitted path\n     */\n    private static String[] pathSplit(String path) {\n        char pathSeparator = ':';  // Unix style by default.\n\n        // Check for '\\' used in Windows paths.\n        if (path.indexOf('\\\\') >= 0) {\n            pathSeparator=';';\n        }\n\n        // Check for \"c:/foo/bar\" sometimes used in Windows paths\n        if (pathSeparator == ':' ) {\n            Pattern p = Pattern.compile(\"\\\\A[a-zA-Z]:/\");\n            Matcher m = p.matcher(path);\n            if (m.find())\n                pathSeparator = ';';\n        }\n\n        // Check for ...;c:/foo/bar at any place in the path\n        if (pathSeparator == ':' ) {\n            Pattern p = Pattern.compile(\";[a-zA-Z]:/\");\n            Matcher m = p.matcher(path);\n            if (m.find())\n                pathSeparator = ';';\n        }\n\n        String delimiter = \"\" + pathSeparator;\n\n        return path.split(delimiter);\n    }\n\n    private static boolean sameHost(String host1, String host2) {\n        InetAddress[] host1Ip = new InetAddress[0];\n        try {\n            host1Ip = InetAddress.getAllByName(host1);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host1 + \" not found.\");\n            return false;\n        }\n        InetAddress[] host2Ip = new InetAddress[0];\n        try {\n            host2Ip = InetAddress.getAllByName(host2);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host2 + \" not found.\");\n            return false;\n        }\n        for (int i = 0; i < host1Ip.length; i++) {\n            for (int j = 0; j < host2Ip.length; j++) {\n                if (host1Ip[i].equals(host2Ip[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private static void setLogger() {\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            logger.fine(\"Updating \" + Config.CONFIG_DIR + \"logging.\" +\n                    host + \".properties\");\n            log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n            log.setProperty(\"java.util.logging.SocketHandler.port\",\n                    String.valueOf(Config.LOGGING_PORT));\n            FileOutputStream out = new FileOutputStream(\n                    new File(Config.CONFIG_DIR + \"logging.\" + host +\n                    \".properties\"));\n            log.store(out, \"Faban logging properties\");\n            out.close();\n\n            LogManager.getLogManager().readConfiguration(new FileInputStream(\n                    Config.CONFIG_DIR + \"logging.\" + host + \".properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n","lineNo":311}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.Run;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.rmi.RemoteException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Class: ServerConfig.java\n * This class manages the configuration of the server machines.\n * It provides methods to capture system configuration, change\n * the number of processors, get system log messages during a\n * benchmark run, etc.\n * WARNING: It is specific to Solaris and non-portable.\n *\n * @see GenericBenchmark\n * @author Ramesh Ramachandran\n */\nclass ServerConfig {\n    Run run;\n    ParamRepository par;\n    static String linesep = \"<hr>\";\n    String master;\n    CmdService cmds;\n    Logger logger;\n    List<ParamRepository.HostConfig> hostConfigs;\n\n    public ServerConfig(Run r, ParamRepository par)\n            throws ConfigurationException {\n        this.par = par;\n        run = r;\n        cmds = CmdService.getHandle();\n        logger = Logger.getLogger(this.getClass().getName());\n        master = CmdService.getHandle().getMaster();\n        hostConfigs = par.getHostConfigs();\n    }\n\n    /**\n     * Get system configuration\n     * This method retrieves the various system parameters from the\n     * ParamRepository.\n     * It gather /etc/system, prtdiag, psrinfo, uname, ps , vxprint\n     * info from the server machines and logs them to the system log.\n     * @return Whether the system configuration was successfully obtained.\n     */\n    public boolean get() {\n        // Generate name of system log file - system.log\n        String syslogfile = run.getOutDir() + \"sysinfo.\";\n        boolean success = true;\n\n        for(ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for (String host : hostConfig.hosts) {\n                String machineName = cmds.getHostName(host);\n                try {\n                    File f = new File(syslogfile + machineName + \".html\");\n\n                    // In case we have multiple interfaces, the file may\n                    // already exist. We don't want to spend the time doing\n                    // the same thing over and over again.\n                    if (f.exists())\n                        continue;\n\n                    // Get system info\n                    PrintStream syslog =\n                                    new PrintStream(new FileOutputStream(f));\n                    Command sysinfo = new Command(\"sysinfo\");\n                    sysinfo.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    CommandHandle handle = cmds.execute(host, sysinfo, null);\n                    byte[] info = handle.fetchOutput(Command.STDOUT);\n\n                    // Write header and info to file.\n                    syslog.println(\"<html><head><title>System Info for Server \"\n                            + machineName + \"<\/title><\/head><body>\");\n\n                    syslog.write(info);\n\n                    // Get User Commands output if specified\n                    if (hostConfig.userCommands != null &&\n                            hostConfig.userCommands.trim().length() > 0) {\n                        String[] cmdStrings = hostConfig.userCommands.\n                                                            split(\";\");\n                        for (String cmdString : cmdStrings) {\n                            Command c = new Command(cmdString);\n                            c.setStreamHandling(Command.STDOUT,Command.CAPTURE);\n                            handle = cmds.execute(host, c, null);\n                            info = handle.fetchOutput(Command.STDOUT);\n                            if (info != null) {\n                                syslog.println(linesep);\n                                syslog.println(\"<h3>\" + hostConfig.userCommands+\n                                        \" on server \" + machineName + \"<\/h3>\");\n                                syslog.println(\"<pre>\\n\");\n                                syslog.write(info);\n                                syslog.println(\"\\n<\/pre>\");\n                            }\n                        }\n                    }\n                    syslog.println(\"<\/body><\/html>\");\n                    syslog.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Failed to collect system info \" +\n                                            \"for host \" + machineName + '.', e);\n                    success = false;\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Set system configuration.\n     * Currently the only thing we set is the number of cpus.\n     * @param cmds object to use\n     * @return true/false depending on whether we were successful or not\n     */\n    public boolean set(CmdService cmds) {\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] hosts = hostConfig.hosts;\n            int[] cpus = hostConfig.numCpus;\n            int numCPUs = 0;\n\n            if (cpus == null)\n                continue;\n\n            if (cpus.length == 1 && cpus[0] == 0)\n                continue;\n\n            // cpus can be of size 0 - don't set it, 1 - set the same for all,\n            // or the number of hosts.\n            if (cpus.length > 1 && cpus.length != hosts.length) {\n                logger.severe(\"Entries in the \\\"cpus\\\" field must be 1 or \" +\n                        \"the number of hosts, or blank. CPU entry mismatch. \" +\n                        \"Please check configuration.\");\n                return false;\n            }\n\n            for(int j = 0; j < hosts.length; j++) {\n                if(cpus.length == 1)\n                    numCPUs = cpus[0];\n                else\n                    numCPUs = cpus[j];\n\n                // User don't want to reconfigure this system.\n                if(numCPUs == 0)\n                    continue;\n\n                try {\n                    // We first turn on all cpus, then turn off enough of them\n                    // to get the required number\n                    Command cmd = new Command(Config.BIN_DIR + \"fastsu\",\n                            \"/usr/sbin/psradm\", \"-a\", \"-n\");\n                    logger.config(\"Turning on all cpus on \" + hosts[j]);\n                    cmds.execute(hosts[j], cmd, null);\n\n                    cmd = new Command(\"/usr/sbin/psrinfo\");\n                    cmd.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    logger.fine(\"Getting cpus\");\n                    CommandHandle handle = cmds.execute(hosts[j], cmd, null);\n                    byte[] buffer = handle.fetchOutput(Command.STDOUT);\n\n                    if (buffer != null) {\n                        StringTokenizer t =\n                                new StringTokenizer(new String(buffer), \"\\n\");\n\n                        ArrayList<Integer> cpuList = new ArrayList<Integer>();\n                        boolean isMultiCore = false;\n\n                        while (t.hasMoreTokens()) {\n                            String line = t.nextToken();\n                            // build list of cpus\n                            Integer cpuId = Integer.valueOf((\n                                    new StringTokenizer(line)).nextToken().\n                                    trim());\n                            if((isMultiCore == false) &&\n                                    (cpuId.intValue() > 511))\n                                isMultiCore = true;\n                            cpuList.add(cpuId);\n                        }\n                        logger.info(\"Total number of CPUs is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The index gets changed when you remove elements\n                        // Remove number of CPUs configured to be used for this\n                        // server\n                        for(int k = 0; k < numCPUs; k++) {\n                            if(isMultiCore) {\n                                Integer cpuId = new Integer(\n                                        (cpuList.get(0)).intValue() + 512);\n                                cpuList.remove(cpuId);\n                            }\n                            cpuList.remove(0);\n                        }\n\n                        logger.info(\"Number of CPUs turned off is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The remaining CPUs in the list have to be turned off.\n\n                        if (cpuList.size() > 0) {\n                            ArrayList<String> offlineCmd = new ArrayList<String>();\n                            offlineCmd.add(Config.BIN_DIR + \"fastsu\");\n                            offlineCmd.add(\"/usr/sbin/psradm\");\n                            offlineCmd.add(\"-f\");\n\n                            for(int k = 0; k < cpuList.size(); k++)\n                                offlineCmd.add(cpuList.get(k).toString());\n\n                            logger.info(\"Off-lining CPUs with command: \" +\n                                    offlineCmd);\n                            cmd = new Command(offlineCmd);\n                            cmds.execute(hosts[j], cmd, null);\n                        }\n                    } else {\n                        logger.severe(\"Could not set CPUs on server \" +\n                                hosts[j]);\n                    }\n                } catch (Exception ie) {\n                    logger.log(Level.SEVERE, \"Failed to set Server Config.\", ie);\n                    return(false);\n                }\n            }\n        }\n        return(true);\n    }\n\n    /**\n     * Get system logs for benchmark duration.\n     * This method captures the relevant portion of var/adm/messages\n     * to the system report file for the benchmark run.\n\n     * @param startTime of benchmark run\n     * @param endTime of benchmark run\n     */\n    public void report(long startTime, long endTime) {\n\n        String sysfile = run.getOutDir() + \"system.report\";\n        PrintStream syslog = null;\n        DateFormat df = DateFormat.getDateTimeInstance(\n                            DateFormat.MEDIUM, DateFormat.LONG, Locale.US);\n        String start = df.format(new Date(startTime));\n        String end = df.format(new Date(endTime));\n\n        String startMon = start.substring(0, 3);\n        int ind = start.indexOf(',');\n        String startDay = start.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String stime = start.substring(ind, start.indexOf(' ', ind));\n        logger.fine(\"Run started Month = \" + startMon +\n                \" Day = \" + startDay + \" Time = \" + stime);\n\n        String endMon = end.substring(0, 3);\n        ind = end.indexOf(',');\n        String endDay = end.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String etime = end.substring(ind, end.indexOf(' ', ind));\n        logger.fine(\"Run ended Month = \" + endMon\n                + \" Day = \" + endDay + \" Time = \" + etime);\n\n        // Now, get /var/adm/messages and look for messages between\n        // start and end\n        CommandHandle handle;\n        Command c = new Command(\"messages\", \"\\\"\" +\n                startMon + \" \" + startDay + \" \" + stime + \"\\\"\",\n                \"\\\"\"  + endMon + \" \" + endDay + \" \" + etime + \"\\\"\");\n        c.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n        logger.fine(\"Getting system messages\");\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for(String host : hostConfig.hosts) {\n                File f = new File(sysfile + \".\" + host);\n                f.delete();\n                try {\n                    syslog = new PrintStream(new FileOutputStream(f));\n                    handle = cmds.execute(host, c, null);\n                    byte[] messages = handle.fetchOutput(Command.STDOUT);\n                    syslog.println(linesep);\n                    syslog.println(\"System messages during run from server \" +\n                            host);\n                    syslog.println(\"\\n\");\n                    if (messages != null) // Null if no messages.\n                        syslog.write(messages);\n                    syslog.println(\"\\n\");\n                } catch (RemoteException e) {\n                    Throwable t = e;\n                    Throwable cause = t.getCause();\n                    while (cause != null) {\n                        t = cause;\n                        cause = t.getCause();\n                    }\n                    String message = \"Error processing system messages for \" +\n                                                                    host;\n                    // A remote IOException usually means the messages script\n                    // is not available for the target OS. We want to log\n                    // at a lower level.\n                    if (t instanceof IOException)\n                        logger.log(Level.FINE, message, t);\n                    else\n                        logger.log(Level.WARNING, message, t);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING,\n                            \"Error collecting system messages from \" + host,\n                            e);\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.Run;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.rmi.RemoteException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Class: ServerConfig.java\n * This class manages the configuration of the server machines.\n * It provides methods to capture system configuration, change\n * the number of processors, get system log messages during a\n * benchmark run, etc.\n * WARNING: It is specific to Solaris and non-portable.\n *\n * @see GenericBenchmark\n * @author Ramesh Ramachandran\n */\nclass ServerConfig {\n    Run run;\n    ParamRepository par;\n    static String linesep = \"<hr>\";\n    String master;\n    CmdService cmds;\n    Logger logger;\n    List<ParamRepository.HostConfig> hostConfigs;\n\n    public ServerConfig(Run r, ParamRepository par)\n            throws ConfigurationException {\n        this.par = par;\n        run = r;\n        cmds = CmdService.getHandle();\n        logger = Logger.getLogger(this.getClass().getName());\n        master = CmdService.getHandle().getMaster();\n        hostConfigs = par.getHostConfigs();\n    }\n\n    /**\n     * Get system configuration\n     * This method retrieves the various system parameters from the\n     * ParamRepository.\n     * It gather /etc/system, prtdiag, psrinfo, uname, ps , vxprint\n     * info from the server machines and logs them to the system log.\n     * @return Whether the system configuration was successfully obtained.\n     */\n    public boolean get() {\n        // Generate name of system log file - system.log\n        String syslogfile = run.getOutDir() + \"sysinfo.\";\n        boolean success = true;\n\n        for(ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for (String host : hostConfig.hosts) {\n                String machineName = cmds.getHostName(host);\n                try {\n                    File f = new File(syslogfile + machineName + \".html\");\n\n                    // In case we have multiple interfaces, the file may\n                    // already exist. We don't want to spend the time doing\n                    // the same thing over and over again.\n                    if (f.exists())\n                        continue;\n\n                    // Get system info\n                    PrintStream syslog =\n                                    new PrintStream(new FileOutputStream(f));\n                    Command sysinfo = new Command(\"sysinfo\");\n                    sysinfo.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    CommandHandle handle = cmds.execute(host, sysinfo, null);\n                    byte[] info = handle.fetchOutput(Command.STDOUT);\n\n                    // Write header and info to file.\n                    syslog.println(\"<html><head><title>System Info for Server \"\n                            + machineName + \"<\/title><\/head><body>\");\n\n                    syslog.write(info);\n\n                    // Get User Commands output if specified\n                    if (hostConfig.userCommands != null &&\n                            hostConfig.userCommands.trim().length() > 0) {\n                        String[] cmdStrings = hostConfig.userCommands.\n                                                            split(\";\");\n                        for (String cmdString : cmdStrings) {\n                            Command c = new Command(cmdString);\n                            c.setStreamHandling(Command.STDOUT,Command.CAPTURE);\n                            handle = cmds.execute(host, c, null);\n                            info = handle.fetchOutput(Command.STDOUT);\n                            if (info != null) {\n                                syslog.println(linesep);\n                                syslog.println(\"<h3>\" + hostConfig.userCommands+\n                                        \" on server \" + machineName + \"<\/h3>\");\n                                syslog.println(\"<pre>\\n\");\n                                syslog.write(info);\n                                syslog.println(\"\\n<\/pre>\");\n                            }\n                        }\n                    }\n                    syslog.println(\"<\/body><\/html>\");\n                    syslog.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Failed to collect system info \" +\n                                            \"for host \" + machineName + '.', e);\n                    success = false;\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Set system configuration.\n     * Currently the only thing we set is the number of cpus.\n     * @param cmds object to use\n     * @return true/false depending on whether we were successful or not\n     */\n    public boolean set(CmdService cmds) {\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] hosts = hostConfig.hosts;\n            int[] cpus = hostConfig.numCpus;\n            int numCPUs = 0;\n\n            if (cpus == null)\n                continue;\n\n            if (cpus.length == 1 && cpus[0] == 0)\n                continue;\n\n            // cpus can be of size 0 - don't set it, 1 - set the same for all,\n            // or the number of hosts.\n            if (cpus.length > 1 && cpus.length != hosts.length) {\n                logger.severe(\"Entries in the \\\"cpus\\\" field must be 1 or \" +\n                        \"the number of hosts, or blank. CPU entry mismatch. \" +\n                        \"Please check configuration.\");\n                return false;\n            }\n\n            for(int j = 0; j < hosts.length; j++) {\n                if(cpus.length == 1)\n                    numCPUs = cpus[0];\n                else\n                    numCPUs = cpus[j];\n\n                // User don't want to reconfigure this system.\n                if(numCPUs == 0)\n                    continue;\n\n                try {\n                    // We first turn on all cpus, then turn off enough of them\n                    // to get the required number\n                    Command cmd = new Command(Config.BIN_DIR + \"fastsu\",\n                            \"/usr/sbin/psradm\", \"-a\", \"-n\");\n                    logger.config(\"Turning on all cpus on \" + hosts[j]);\n                    cmds.execute(hosts[j], cmd, null);\n\n                    cmd = new Command(\"/usr/sbin/psrinfo\");\n                    cmd.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    logger.fine(\"Getting cpus\");\n                    CommandHandle handle = cmds.execute(hosts[j], cmd, null);\n                    byte[] buffer = handle.fetchOutput(Command.STDOUT);\n\n                    if (buffer != null) {\n                        StringTokenizer t =\n                                new StringTokenizer(new String(buffer), \"\\n\");\n\n                        ArrayList<Integer> cpuList = new ArrayList<Integer>();\n                        boolean isMultiCore = false;\n\n                        while (t.hasMoreTokens()) {\n                            String line = t.nextToken();\n                            // build list of cpus\n                            Integer cpuId = Integer.valueOf((\n                                    new StringTokenizer(line)).nextToken().\n                                    trim());\n                            if((isMultiCore == false) &&\n                                    (cpuId.intValue() > 511))\n                                isMultiCore = true;\n                            cpuList.add(cpuId);\n                        }\n                        logger.info(\"Total number of CPUs is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The index gets changed when you remove elements\n                        // Remove number of CPUs configured to be used for this\n                        // server\n                        for(int k = 0; k < numCPUs; k++) {\n                            if(isMultiCore) {\n                                Integer cpuId = new Integer(\n                                        (cpuList.get(0)).intValue() + 512);\n                                cpuList.remove(cpuId);\n                            }\n                            cpuList.remove(0);\n                        }\n\n                        logger.info(\"Number of CPUs turned off is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The remaining CPUs in the list have to be turned off.\n\n                        if (cpuList.size() > 0) {\n                            ArrayList<String> offlineCmd = new ArrayList<String>();\n                            offlineCmd.add(Config.BIN_DIR + \"fastsu\");\n                            offlineCmd.add(\"/usr/sbin/psradm\");\n                            offlineCmd.add(\"-f\");\n\n                            for(int k = 0; k < cpuList.size(); k++)\n                                offlineCmd.add(cpuList.get(k).toString());\n\n                            logger.info(\"Off-lining CPUs with command: \" +\n                                    offlineCmd);\n                            cmd = new Command(offlineCmd);\n                            cmds.execute(hosts[j], cmd, null);\n                        }\n                    } else {\n                        logger.severe(\"Could not set CPUs on server \" +\n                                hosts[j]);\n                    }\n                } catch (Exception ie) {\n                    logger.log(Level.SEVERE, \"Failed to set Server Config.\", ie);\n                    return(false);\n                }\n            }\n        }\n        return(true);\n    }\n\n    /**\n     * Get system logs for benchmark duration.\n     * This method captures the relevant portion of var/adm/messages\n     * to the system report file for the benchmark run.\n\n     * @param startTime of benchmark run\n     * @param endTime of benchmark run\n     */\n    public void report(long startTime, long endTime) {\n\n        String sysfile = run.getOutDir() + \"system.report\";\n        PrintStream syslog = null;\n        DateFormat df = DateFormat.getDateTimeInstance(\n                            DateFormat.MEDIUM, DateFormat.LONG, Locale.US);\n        String start = df.format(new Date(startTime));\n        String end = df.format(new Date(endTime));\n\n        String startMon = start.substring(0, 3);\n        int ind = start.indexOf(',');\n        String startDay = start.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String stime = start.substring(ind, start.indexOf(' ', ind));\n        logger.fine(\"Run started Month = \" + startMon +\n                \" Day = \" + startDay + \" Time = \" + stime);\n\n        String endMon = end.substring(0, 3);\n        ind = end.indexOf(',');\n        String endDay = end.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String etime = end.substring(ind, end.indexOf(' ', ind));\n        logger.fine(\"Run ended Month = \" + endMon\n                + \" Day = \" + endDay + \" Time = \" + etime);\n\n        // Now, get /var/adm/messages and look for messages between\n        // start and end\n        CommandHandle handle;\n        Command c = new Command(\"messages\", \"\\\"\" +\n                startMon + \" \" + startDay + \" \" + stime + \"\\\"\",\n                \"\\\"\"  + endMon + \" \" + endDay + \" \" + etime + \"\\\"\");\n        c.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n        logger.fine(\"Getting system messages\");\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for(String host : hostConfig.hosts) {\n                String machineName = cmds.getHostName(host);\n                File f = new File(sysfile + \".\" + machineName);\n                f.delete();\n                try {\n                    syslog = new PrintStream(new FileOutputStream(f));\n                    handle = cmds.execute(host, c, null);\n                    byte[] messages = handle.fetchOutput(Command.STDOUT);\n                    syslog.println(linesep);\n                    syslog.println(\"System messages during run from server \" +\n                            host);\n                    syslog.println(\"\\n\");\n                    if (messages != null) // Null if no messages.\n                        syslog.write(messages);\n                    syslog.println(\"\\n\");\n                } catch (RemoteException e) {\n                    Throwable t = e;\n                    Throwable cause = t.getCause();\n                    while (cause != null) {\n                        t = cause;\n                        cause = t.getCause();\n                    }\n                    String message = \"Error processing system messages for \" +\n                                                                    host;\n                    // A remote IOException usually means the messages script\n                    // is not available for the target OS. We want to log\n                    // at a lower level.\n                    if (t instanceof IOException)\n                        logger.log(Level.FINE, message, t);\n                    else\n                        logger.log(Level.WARNING, message, t);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING,\n                            \"Error collecting system messages from \" + host,\n                            e);\n                }\n            }\n        }\n    }\n}\n","lineNo":305}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.Run;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.rmi.RemoteException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Class: ServerConfig.java\n * This class manages the configuration of the server machines.\n * It provides methods to capture system configuration, change\n * the number of processors, get system log messages during a\n * benchmark run, etc.\n * WARNING: It is specific to Solaris and non-portable.\n *\n * @see GenericBenchmark\n * @author Ramesh Ramachandran\n */\nclass ServerConfig {\n    Run run;\n    ParamRepository par;\n    static String linesep = \"<hr>\";\n    String master;\n    CmdService cmds;\n    Logger logger;\n    List<ParamRepository.HostConfig> hostConfigs;\n\n    public ServerConfig(Run r, ParamRepository par)\n            throws ConfigurationException {\n        this.par = par;\n        run = r;\n        cmds = CmdService.getHandle();\n        logger = Logger.getLogger(this.getClass().getName());\n        master = CmdService.getHandle().getMaster();\n        hostConfigs = par.getHostConfigs();\n    }\n\n    /**\n     * Get system configuration\n     * This method retrieves the various system parameters from the\n     * ParamRepository.\n     * It gather /etc/system, prtdiag, psrinfo, uname, ps , vxprint\n     * info from the server machines and logs them to the system log.\n     * @return Whether the system configuration was successfully obtained.\n     */\n    public boolean get() {\n        // Generate name of system log file - system.log\n        String syslogfile = run.getOutDir() + \"sysinfo.\";\n        boolean success = true;\n\n        for(ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for (String host : hostConfig.hosts) {\n                String machineName = cmds.getHostName(host);\n                try {\n                    File f = new File(syslogfile + machineName + \".html\");\n\n                    // In case we have multiple interfaces, the file may\n                    // already exist. We don't want to spend the time doing\n                    // the same thing over and over again.\n                    if (f.exists())\n                        continue;\n\n                    // Get system info\n                    PrintStream syslog =\n                                    new PrintStream(new FileOutputStream(f));\n                    Command sysinfo = new Command(\"sysinfo\");\n                    sysinfo.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    CommandHandle handle = cmds.execute(host, sysinfo, null);\n                    byte[] info = handle.fetchOutput(Command.STDOUT);\n\n                    // Write header and info to file.\n                    syslog.println(\"<html><head><title>System Info for Server \"\n                            + machineName + \"<\/title><\/head><body>\");\n\n                    syslog.write(info);\n\n                    // Get User Commands output if specified\n                    if (hostConfig.userCommands != null &&\n                            hostConfig.userCommands.trim().length() > 0) {\n                        String[] cmdStrings = hostConfig.userCommands.\n                                                            split(\";\");\n                        for (String cmdString : cmdStrings) {\n                            Command c = new Command(cmdString);\n                            c.setStreamHandling(Command.STDOUT,Command.CAPTURE);\n                            handle = cmds.execute(host, c, null);\n                            info = handle.fetchOutput(Command.STDOUT);\n                            if (info != null) {\n                                syslog.println(linesep);\n                                syslog.println(\"<h3>\" + hostConfig.userCommands+\n                                        \" on server \" + machineName + \"<\/h3>\");\n                                syslog.println(\"<pre>\\n\");\n                                syslog.write(info);\n                                syslog.println(\"\\n<\/pre>\");\n                            }\n                        }\n                    }\n                    syslog.println(\"<\/body><\/html>\");\n                    syslog.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Failed to collect system info \" +\n                                            \"for host \" + machineName + '.', e);\n                    success = false;\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Set system configuration.\n     * Currently the only thing we set is the number of cpus.\n     * @param cmds object to use\n     * @return true/false depending on whether we were successful or not\n     */\n    public boolean set(CmdService cmds) {\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] hosts = hostConfig.hosts;\n            int[] cpus = hostConfig.numCpus;\n            int numCPUs = 0;\n\n            if (cpus == null)\n                continue;\n\n            if (cpus.length == 1 && cpus[0] == 0)\n                continue;\n\n            // cpus can be of size 0 - don't set it, 1 - set the same for all,\n            // or the number of hosts.\n            if (cpus.length > 1 && cpus.length != hosts.length) {\n                logger.severe(\"Entries in the \\\"cpus\\\" field must be 1 or \" +\n                        \"the number of hosts, or blank. CPU entry mismatch. \" +\n                        \"Please check configuration.\");\n                return false;\n            }\n\n            for(int j = 0; j < hosts.length; j++) {\n                if(cpus.length == 1)\n                    numCPUs = cpus[0];\n                else\n                    numCPUs = cpus[j];\n\n                // User don't want to reconfigure this system.\n                if(numCPUs == 0)\n                    continue;\n\n                try {\n                    // We first turn on all cpus, then turn off enough of them\n                    // to get the required number\n                    Command cmd = new Command(Config.BIN_DIR + \"fastsu\",\n                            \"/usr/sbin/psradm\", \"-a\", \"-n\");\n                    logger.config(\"Turning on all cpus on \" + hosts[j]);\n                    cmds.execute(hosts[j], cmd, null);\n\n                    cmd = new Command(\"/usr/sbin/psrinfo\");\n                    cmd.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    logger.fine(\"Getting cpus\");\n                    CommandHandle handle = cmds.execute(hosts[j], cmd, null);\n                    byte[] buffer = handle.fetchOutput(Command.STDOUT);\n\n                    if (buffer != null) {\n                        StringTokenizer t =\n                                new StringTokenizer(new String(buffer), \"\\n\");\n\n                        ArrayList<Integer> cpuList = new ArrayList<Integer>();\n                        boolean isMultiCore = false;\n\n                        while (t.hasMoreTokens()) {\n                            String line = t.nextToken();\n                            // build list of cpus\n                            Integer cpuId = Integer.valueOf((\n                                    new StringTokenizer(line)).nextToken().\n                                    trim());\n                            if((isMultiCore == false) &&\n                                    (cpuId.intValue() > 511))\n                                isMultiCore = true;\n                            cpuList.add(cpuId);\n                        }\n                        logger.info(\"Total number of CPUs is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The index gets changed when you remove elements\n                        // Remove number of CPUs configured to be used for this\n                        // server\n                        for(int k = 0; k < numCPUs; k++) {\n                            if(isMultiCore) {\n                                Integer cpuId = new Integer(\n                                        (cpuList.get(0)).intValue() + 512);\n                                cpuList.remove(cpuId);\n                            }\n                            cpuList.remove(0);\n                        }\n\n                        logger.info(\"Number of CPUs turned off is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The remaining CPUs in the list have to be turned off.\n\n                        if (cpuList.size() > 0) {\n                            ArrayList<String> offlineCmd = new ArrayList<String>();\n                            offlineCmd.add(Config.BIN_DIR + \"fastsu\");\n                            offlineCmd.add(\"/usr/sbin/psradm\");\n                            offlineCmd.add(\"-f\");\n\n                            for(int k = 0; k < cpuList.size(); k++)\n                                offlineCmd.add(cpuList.get(k).toString());\n\n                            logger.info(\"Off-lining CPUs with command: \" +\n                                    offlineCmd);\n                            cmd = new Command(offlineCmd);\n                            cmds.execute(hosts[j], cmd, null);\n                        }\n                    } else {\n                        logger.severe(\"Could not set CPUs on server \" +\n                                hosts[j]);\n                    }\n                } catch (Exception ie) {\n                    logger.log(Level.SEVERE, \"Failed to set Server Config.\", ie);\n                    return(false);\n                }\n            }\n        }\n        return(true);\n    }\n\n    /**\n     * Get system logs for benchmark duration.\n     * This method captures the relevant portion of var/adm/messages\n     * to the system report file for the benchmark run.\n\n     * @param startTime of benchmark run\n     * @param endTime of benchmark run\n     */\n    public void report(long startTime, long endTime) {\n\n        String sysfile = run.getOutDir() + \"system.report\";\n        PrintStream syslog = null;\n        DateFormat df = DateFormat.getDateTimeInstance(\n                            DateFormat.MEDIUM, DateFormat.LONG, Locale.US);\n        String start = df.format(new Date(startTime));\n        String end = df.format(new Date(endTime));\n\n        String startMon = start.substring(0, 3);\n        int ind = start.indexOf(',');\n        String startDay = start.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String stime = start.substring(ind, start.indexOf(' ', ind));\n        logger.fine(\"Run started Month = \" + startMon +\n                \" Day = \" + startDay + \" Time = \" + stime);\n\n        String endMon = end.substring(0, 3);\n        ind = end.indexOf(',');\n        String endDay = end.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String etime = end.substring(ind, end.indexOf(' ', ind));\n        logger.fine(\"Run ended Month = \" + endMon\n                + \" Day = \" + endDay + \" Time = \" + etime);\n\n        // Now, get /var/adm/messages and look for messages between\n        // start and end\n        CommandHandle handle;\n        Command c = new Command(\"messages\", \"\\\"\" +\n                startMon + \" \" + startDay + \" \" + stime + \"\\\"\",\n                \"\\\"\"  + endMon + \" \" + endDay + \" \" + etime + \"\\\"\");\n        c.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n        logger.fine(\"Getting system messages\");\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for(String host : hostConfig.hosts) {\n                File f = new File(sysfile + \".\" + host);\n                f.delete();\n                try {\n                    syslog = new PrintStream(new FileOutputStream(f));\n                    handle = cmds.execute(host, c, null);\n                    byte[] messages = handle.fetchOutput(Command.STDOUT);\n                    syslog.println(linesep);\n                    syslog.println(\"System messages during run from server \" +\n                            host);\n                    syslog.println(\"\\n\");\n                    if (messages != null) // Null if no messages.\n                        syslog.write(messages);\n                    syslog.println(\"\\n\");\n                } catch (RemoteException e) {\n                    Throwable cause = e.getCause();\n                    while (cause != null)\n                        cause = cause.getCause();\n                    String message = \"Error processing system messages for \" +\n                                                                    host;\n                    // A remote IOException usually means the messages script\n                    // is not available for the target OS. We want to log\n                    // at a lower level.\n                    if (cause instanceof IOException)\n                        logger.log(Level.FINE, message, cause);\n                    else\n                        logger.log(Level.WARNING, message, cause);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING,\n                            \"Error collecting system messages from \" + host,\n                            e);\n                }\n            }\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.Run;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.rmi.RemoteException;\nimport java.text.DateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Class: ServerConfig.java\n * This class manages the configuration of the server machines.\n * It provides methods to capture system configuration, change\n * the number of processors, get system log messages during a\n * benchmark run, etc.\n * WARNING: It is specific to Solaris and non-portable.\n *\n * @see GenericBenchmark\n * @author Ramesh Ramachandran\n */\nclass ServerConfig {\n    Run run;\n    ParamRepository par;\n    static String linesep = \"<hr>\";\n    String master;\n    CmdService cmds;\n    Logger logger;\n    List<ParamRepository.HostConfig> hostConfigs;\n\n    public ServerConfig(Run r, ParamRepository par)\n            throws ConfigurationException {\n        this.par = par;\n        run = r;\n        cmds = CmdService.getHandle();\n        logger = Logger.getLogger(this.getClass().getName());\n        master = CmdService.getHandle().getMaster();\n        hostConfigs = par.getHostConfigs();\n    }\n\n    /**\n     * Get system configuration\n     * This method retrieves the various system parameters from the\n     * ParamRepository.\n     * It gather /etc/system, prtdiag, psrinfo, uname, ps , vxprint\n     * info from the server machines and logs them to the system log.\n     * @return Whether the system configuration was successfully obtained.\n     */\n    public boolean get() {\n        // Generate name of system log file - system.log\n        String syslogfile = run.getOutDir() + \"sysinfo.\";\n        boolean success = true;\n\n        for(ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for (String host : hostConfig.hosts) {\n                String machineName = cmds.getHostName(host);\n                try {\n                    File f = new File(syslogfile + machineName + \".html\");\n\n                    // In case we have multiple interfaces, the file may\n                    // already exist. We don't want to spend the time doing\n                    // the same thing over and over again.\n                    if (f.exists())\n                        continue;\n\n                    // Get system info\n                    PrintStream syslog =\n                                    new PrintStream(new FileOutputStream(f));\n                    Command sysinfo = new Command(\"sysinfo\");\n                    sysinfo.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    CommandHandle handle = cmds.execute(host, sysinfo, null);\n                    byte[] info = handle.fetchOutput(Command.STDOUT);\n\n                    // Write header and info to file.\n                    syslog.println(\"<html><head><title>System Info for Server \"\n                            + machineName + \"<\/title><\/head><body>\");\n\n                    syslog.write(info);\n\n                    // Get User Commands output if specified\n                    if (hostConfig.userCommands != null &&\n                            hostConfig.userCommands.trim().length() > 0) {\n                        String[] cmdStrings = hostConfig.userCommands.\n                                                            split(\";\");\n                        for (String cmdString : cmdStrings) {\n                            Command c = new Command(cmdString);\n                            c.setStreamHandling(Command.STDOUT,Command.CAPTURE);\n                            handle = cmds.execute(host, c, null);\n                            info = handle.fetchOutput(Command.STDOUT);\n                            if (info != null) {\n                                syslog.println(linesep);\n                                syslog.println(\"<h3>\" + hostConfig.userCommands+\n                                        \" on server \" + machineName + \"<\/h3>\");\n                                syslog.println(\"<pre>\\n\");\n                                syslog.write(info);\n                                syslog.println(\"\\n<\/pre>\");\n                            }\n                        }\n                    }\n                    syslog.println(\"<\/body><\/html>\");\n                    syslog.close();\n                } catch (Exception e) {\n                    logger.log(Level.SEVERE, \"Failed to collect system info \" +\n                                            \"for host \" + machineName + '.', e);\n                    success = false;\n                }\n            }\n        }\n        return success;\n    }\n\n    /**\n     * Set system configuration.\n     * Currently the only thing we set is the number of cpus.\n     * @param cmds object to use\n     * @return true/false depending on whether we were successful or not\n     */\n    public boolean set(CmdService cmds) {\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] hosts = hostConfig.hosts;\n            int[] cpus = hostConfig.numCpus;\n            int numCPUs = 0;\n\n            if (cpus == null)\n                continue;\n\n            if (cpus.length == 1 && cpus[0] == 0)\n                continue;\n\n            // cpus can be of size 0 - don't set it, 1 - set the same for all,\n            // or the number of hosts.\n            if (cpus.length > 1 && cpus.length != hosts.length) {\n                logger.severe(\"Entries in the \\\"cpus\\\" field must be 1 or \" +\n                        \"the number of hosts, or blank. CPU entry mismatch. \" +\n                        \"Please check configuration.\");\n                return false;\n            }\n\n            for(int j = 0; j < hosts.length; j++) {\n                if(cpus.length == 1)\n                    numCPUs = cpus[0];\n                else\n                    numCPUs = cpus[j];\n\n                // User don't want to reconfigure this system.\n                if(numCPUs == 0)\n                    continue;\n\n                try {\n                    // We first turn on all cpus, then turn off enough of them\n                    // to get the required number\n                    Command cmd = new Command(Config.BIN_DIR + \"fastsu\",\n                            \"/usr/sbin/psradm\", \"-a\", \"-n\");\n                    logger.config(\"Turning on all cpus on \" + hosts[j]);\n                    cmds.execute(hosts[j], cmd, null);\n\n                    cmd = new Command(\"/usr/sbin/psrinfo\");\n                    cmd.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n                    logger.fine(\"Getting cpus\");\n                    CommandHandle handle = cmds.execute(hosts[j], cmd, null);\n                    byte[] buffer = handle.fetchOutput(Command.STDOUT);\n\n                    if (buffer != null) {\n                        StringTokenizer t =\n                                new StringTokenizer(new String(buffer), \"\\n\");\n\n                        ArrayList<Integer> cpuList = new ArrayList<Integer>();\n                        boolean isMultiCore = false;\n\n                        while (t.hasMoreTokens()) {\n                            String line = t.nextToken();\n                            // build list of cpus\n                            Integer cpuId = Integer.valueOf((\n                                    new StringTokenizer(line)).nextToken().\n                                    trim());\n                            if((isMultiCore == false) &&\n                                    (cpuId.intValue() > 511))\n                                isMultiCore = true;\n                            cpuList.add(cpuId);\n                        }\n                        logger.info(\"Total number of CPUs is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The index gets changed when you remove elements\n                        // Remove number of CPUs configured to be used for this\n                        // server\n                        for(int k = 0; k < numCPUs; k++) {\n                            if(isMultiCore) {\n                                Integer cpuId = new Integer(\n                                        (cpuList.get(0)).intValue() + 512);\n                                cpuList.remove(cpuId);\n                            }\n                            cpuList.remove(0);\n                        }\n\n                        logger.info(\"Number of CPUs turned off is \" +\n                                cpuList.size()/(isMultiCore ? 2 : 1));\n\n                        // The remaining CPUs in the list have to be turned off.\n\n                        if (cpuList.size() > 0) {\n                            ArrayList<String> offlineCmd = new ArrayList<String>();\n                            offlineCmd.add(Config.BIN_DIR + \"fastsu\");\n                            offlineCmd.add(\"/usr/sbin/psradm\");\n                            offlineCmd.add(\"-f\");\n\n                            for(int k = 0; k < cpuList.size(); k++)\n                                offlineCmd.add(cpuList.get(k).toString());\n\n                            logger.info(\"Off-lining CPUs with command: \" +\n                                    offlineCmd);\n                            cmd = new Command(offlineCmd);\n                            cmds.execute(hosts[j], cmd, null);\n                        }\n                    } else {\n                        logger.severe(\"Could not set CPUs on server \" +\n                                hosts[j]);\n                    }\n                } catch (Exception ie) {\n                    logger.log(Level.SEVERE, \"Failed to set Server Config.\", ie);\n                    return(false);\n                }\n            }\n        }\n        return(true);\n    }\n\n    /**\n     * Get system logs for benchmark duration.\n     * This method captures the relevant portion of var/adm/messages\n     * to the system report file for the benchmark run.\n\n     * @param startTime of benchmark run\n     * @param endTime of benchmark run\n     */\n    public void report(long startTime, long endTime) {\n\n        String sysfile = run.getOutDir() + \"system.report\";\n        PrintStream syslog = null;\n        DateFormat df = DateFormat.getDateTimeInstance(\n                            DateFormat.MEDIUM, DateFormat.LONG, Locale.US);\n        String start = df.format(new Date(startTime));\n        String end = df.format(new Date(endTime));\n\n        String startMon = start.substring(0, 3);\n        int ind = start.indexOf(',');\n        String startDay = start.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String stime = start.substring(ind, start.indexOf(' ', ind));\n        logger.fine(\"Run started Month = \" + startMon +\n                \" Day = \" + startDay + \" Time = \" + stime);\n\n        String endMon = end.substring(0, 3);\n        ind = end.indexOf(',');\n        String endDay = end.substring(4, ind);\n        ind = ind + 7; // skip over ' 1999 ' to get to time\n        String etime = end.substring(ind, end.indexOf(' ', ind));\n        logger.fine(\"Run ended Month = \" + endMon\n                + \" Day = \" + endDay + \" Time = \" + etime);\n\n        // Now, get /var/adm/messages and look for messages between\n        // start and end\n        CommandHandle handle;\n        Command c = new Command(\"messages\", \"\\\"\" +\n                startMon + \" \" + startDay + \" \" + stime + \"\\\"\",\n                \"\\\"\"  + endMon + \" \" + endDay + \" \" + etime + \"\\\"\");\n        c.setStreamHandling(Command.STDOUT, Command.CAPTURE);\n        logger.fine(\"Getting system messages\");\n\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            for(String host : hostConfig.hosts) {\n                File f = new File(sysfile + \".\" + host);\n                f.delete();\n                try {\n                    syslog = new PrintStream(new FileOutputStream(f));\n                    handle = cmds.execute(host, c, null);\n                    byte[] messages = handle.fetchOutput(Command.STDOUT);\n                    syslog.println(linesep);\n                    syslog.println(\"System messages during run from server \" +\n                            host);\n                    syslog.println(\"\\n\");\n                    if (messages != null) // Null if no messages.\n                        syslog.write(messages);\n                    syslog.println(\"\\n\");\n                } catch (RemoteException e) {\n                    Throwable t = e;\n                    Throwable cause = t.getCause();\n                    while (cause != null) {\n                        t = cause;\n                        cause = t.getCause();\n                    }\n                    String message = \"Error processing system messages for \" +\n                                                                    host;\n                    // A remote IOException usually means the messages script\n                    // is not available for the target OS. We want to log\n                    // at a lower level.\n                    if (t instanceof IOException)\n                        logger.log(Level.FINE, message, t);\n                    else\n                        logger.log(Level.WARNING, message, t);\n                } catch (Exception e) {\n                    logger.log(Level.WARNING,\n                            \"Error collecting system messages from \" + host,\n                            e);\n                }\n            }\n        }\n    }\n}\n","lineNo":319}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.HostRoles;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    /** Sequential flag in FG mode. */\n    public static final int SEQUENTIAL = 1;\n\n    /** Parallel flag in FG mode. */\n    public static final int PARALLEL = 2;\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines. */\n    private ArrayList<String> machinesList = new ArrayList<String>();\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private List<String> jvmOptions;\n    private HashMap<String, List<String>> binMap =\n            new HashMap<String, List<String>>();\n    private Map<String, String> ifMap;\n    private List<String> rsh,  agent;\n    private HostRoles hostRoles;\n\n    CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n        cmds = this;\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        return cmds;\n    }\n\n    /**\n     * Obtains the name of the master machine.\n     * @return The master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines.\n     * This method can be called multiple times to initialize multiple\n     * classes of machines.\n     * @param benchName The name of the benchmark\n     * @param par The parameter repository\n     * @return true if successful, false if setup failed\n     */\n    public boolean setup(String benchName, ParamRepository par) {\n\n        String home = par.getParameter(\"fh:jvmConfig/fh:home\");\n\n        if (home != null)\n            home = home.trim();\n\n        if (home == null || home.length() == 0) {\n            home = Utilities.getJavaHome();\n            logger.config(\"JAVA_HOME set to \" + home);\n        }\n\n        if(!(new File(home)).isDirectory()) {\n            logger.severe(\"Cannot set JAVA_HOME. \" + home +\n                    \" is not a valid JAVA_HOME. Exiting\");\n            return false;\n        }\n\n        javaHome = home;\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        jvmOptions = new ArrayList<String>();\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                fs + \"faban.policy\");\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties\");\n        jvmOptions.add(\"-Dfaban.registry.port=\" + Config.RMI_PORT);\n        jvmOptions.add(\"-Dfaban.logging.port=\" + Config.LOGGING_PORT);\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if (!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                    log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))) {\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                        String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < libs.length; i++) {\n                if (libs[i].isFile()) {\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n                }\n            }\n            buf.setLength(buf.length() - 1);\n            if (buf.indexOf(\" \") != -1) {\n                buf.insert(0, '\"');\n                buf.append('\"');\n            }\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            List<String> cmd = new ArrayList<String>();\n            cmd.add(javaHome + File.separator + \"bin\" + File.separator +\n                    \"java\");\n            cmd.addAll(jvmOptions);\n            cmd.add(\"-Xms32m\");\n            cmd.add(\"-Xmx1024m\");\n            cmd.add(\"-cp\");\n            cmd.add(classpath);\n            cmd.add(\"com.sun.faban.common.RegistryImpl\");\n\n            logger.info(\"Starting Registry.\");\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        String jvmOpts =\n                par.getParameter(\"fh:jvmConfig/fh:jvmOptions\");\n\n        final String disableEGC = \"-XX:+DisableExplicitGC\";\n\n        if (jvmOpts != null)\n            jvmOpts = jvmOpts.trim();\n\n        if((jvmOpts == null) || (jvmOpts.length() == 0))\n            jvmOpts = \"\";\n\n        List<String> usrOpts = Command.parseArgs(jvmOpts);\n        if (!usrOpts.contains(disableEGC))\n            usrOpts.add(disableEGC);\n        jvmOptions.addAll(usrOpts);\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Unable to connect to Registry.\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        List<ParamRepository.HostConfig> hostConfigs = null;\n        try {\n            hostConfigs = par.getHostConfigs();\n        } catch (ConfigurationException e) {\n            logger.log(Level.SEVERE, \"Problem reading parameter file\", e);\n        }\n\n        outer:\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 || // localhost\n                            machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\", e);\n        }\n\n        if (rsh == null) {\n            rsh = new ArrayList<String>();\n            rsh.add(\"rsh\");\n        }\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master)) {\n                return false;\n            }\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if (\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if (machinesList.contains(machines[i])) {\n                    continue;\n                }\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0) {\n                    return false;\n                }\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress)) {\n                    return false;\n                }\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++) {\n            if (!getCmdAgent((String) machinesList.get(i))) {\n                return false;\n            }\n        }\n\n        if (par.getBooleanValue(\"fa:runConfig/fh:timeSync\", true)) {\n            setClocks();\n        }\n\n        return true;\n    }\n\n    void setHostRoles(HostRoles hr) {\n        hostRoles = hr;\n\n        // We need to populate the machinesList and cmdp with\n        // the real host names.\n\n        // First get the real names.\n        String[] realHosts = hostRoles.getHostsInOrder();\n        \n        // For each real host name not in machinesList, we take the first alias\n        // and look it up in the machinesList. Fetch the command agent and add\n        // the real name to the machinesList -> cmdp mapping.\n        for (String hostName : realHosts) {\n            if (!machinesList.contains(hostName)) {\n                String[] aliases = hostRoles.getAliasesByHost(hostName);\n                CmdAgent a = findCmdAgent(aliases[0]); // Just one is enough\n                machinesList.add(hostName);\n                cmdp.add(a);\n            }\n        }\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n            Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host : hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            } catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                        retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return (false);\n            }\n\n            cmdp.add(c);\n\n            /* Note the agent registration process:\n             * 1. Create and register the command agent.\n             * 2. Download benchmark code\n             * 3. Create the lib classpath\n             * 4. Create and register file agent\n             * So it may take quite some time between the registration of\n             * the command agent and the file agent. But we can be pretty\n             * sure it'll happen. So just wait. Timeout after 100 retries.             \n             */\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"FileService: Connecting to \" + s);\n            retry = 1;\n            FileAgent f = (FileAgent) registry.getService(s);\n            for (; f == null && retry <= 100; retry++) {\n                Thread.sleep(1000);\n                logger.fine(\"Retry obtaining file service from \" + s +\n                        \", count \" + retry + '.');\n                f = (FileAgent) registry.getService(s);\n            }\n            if (f == null) {\n                logger.severe(\"Timed out obtaining file service from \" + s);\n                return (false);\n            }\n            filep.add(f);\n\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" +\n                    c.getHostName());\n            return true;\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \" + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n     * We use a script 'cmd' which will setup the CLASSPATH before\n     * invoking CmdAgent\n     */\n    private boolean startCmdAgent(String benchName, String mach,\n            String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        List<String> cmd = new ArrayList<String>();\n\n        List<String> agentParams = new ArrayList<String>();\n        agentParams.add(mach);\n        agentParams.add(interfaceAddress);\n        agentParams.add(masterAddress);\n        agentParams.add(javaHome);\n        agentParams.addAll(jvmOptions);\n        agentParams.add(\"faban.benchmarkName=\" + benchName);\n        try {\n            if (mach.equals(master)) {\n                cmd.addAll(agent);\n                cmd.addAll(agentParams);\n                logger.fine(\"Executing \" + cmd);\n                Command cmdAgent = new Command(cmd);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams.add(\"faban.download=\" + downloadURL.toString());\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    ObjectOutputStream socketOut =\n                            new ObjectOutputStream(socket.getOutputStream());\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n\n                    ArrayList<String> agentExtParams = \n                            new ArrayList<String>(agentParams);\n                    agentExtParams.add(File.separator);\n                    agentExtParams.add(File.pathSeparator);\n                    socketOut.writeObject(agentExtParams);\n\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200:\n                            agentStarted = true;\n                            logger.fine(\"Found Agent(daemon)@\" + mach +\n                                    \". Registering agent.\");\n                            break;\n                        case 500:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response +\n                                    \" Please report the issue \" +\n                                    \"and provide logs from \" + mach +\n                                    \":FABAN_HOME/logs/agent.log\");\n                            break;\n                        case 409:\n                            logger.severe(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                            // We do not fall back in the conflict case.\n                            return false;\n                        default:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmd.clear();\n                    cmd.addAll(rsh);\n                    cmd.add(mach);\n                    cmd.addAll(agent);\n                    cmd.addAll(agentParams);\n                    Command cmdAgent = new Command(cmd);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<NameValuePair<Future<Boolean>>> tasks =\n                new ArrayList<NameValuePair<Future<Boolean>>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    NameValuePair<Future<Boolean>> future =\n                            new NameValuePair<Future<Boolean>>();\n                    future.name = hostName;\n                    future.value = Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat));\n                    tasks.add(future);\n                }\n            } catch (RemoteException e) {\n                logger.log(Level.WARNING,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n        for (NameValuePair<Future<Boolean>> future : tasks) {\n            try {\n                future.value.get(300, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                logger.log(Level.WARNING, \"Timed out setting clock for \" +\n                        future.name);\n            } catch (Throwable t) {\n                Throwable cause = t.getCause();\n                while (cause != null) {\n                    t = cause;\n                    cause = t.getCause();\n                }\n                logger.log(Level.WARNING, t.getMessage(), t);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws IOException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                    ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \" cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \" cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100) {\n                            ++nextSec; // If not, we go to the next sec.\n                        }\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                System.currentTimeMillis();\n                        if (sleepTime > 0) {\n                            Thread.sleep(sleepTime);\n                        }\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            if (wakeBefore > 700) {\n                                logger.warning(hostName + \" wakeup-before \" +\n                                        \"time reached 700ms limit. System is \" +\n                                        \"too busy. Giving up.\");\n                                return false;\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                        ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Obtains the cached HostType object. Note that this is not a public API.\n     * @return The cached HostType object;\n     */\n    public HostRoles getHostRoles() {\n        return hostRoles;\n    }\n\n    /**\n     * Returns the hostname of this machine as known to the machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     * @param machineName The target machine to check the host name\n     * @return The host name of the remote machine\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0) {\n            return machineName; // Cannot resolve\n        }\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        } catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                    re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Updates the paths in the local command agent.\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void updatePaths(List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(master).updatePaths(pathList);\n    }\n\n    /**\n     * Downloads files used by deploy images, especially services and tools.\n     * The pathList contains a list of resources in the form type/resource.\n     * @param machine The host name to initiate the download\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void downloadServices(String machine, List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(machine).downloadServices(pathList);\n    }\n\n    /**\n     * Returns the location of this command on the master system.\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command to execute, or null if not found.\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public String which(String cmd, String svcPath) throws RemoteException {\n        return which(master, cmd, svcPath);\n    }\n\n    /**\n     * Returns the location of this command on the target system.\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param machine The machine to search\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command to execute, or null if not found.\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public String which(String machine, String cmd, String svcPath)\n            throws RemoteException {\n        return findCmdAgent(machine).which(cmd, svcPath);\n    }\n\n    /**\n     * Returns the location of this command on the target systems.\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param machines The machines to search\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command paths to execute, or null elements if not found.\n     */\n    public String[] which(String[] machines, String cmd, String svcPath) {\n        String[] paths = new String[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            try {\n                paths[i] = which(machines[i], cmd, svcPath);\n            } catch (RemoteException e) {\n                logger.warning(\"Error searching for command \" + cmd + \" on \" +\n                                machines[i] + '.');\n            }\n        return paths;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return execute(master, c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).execute(c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return java(master, c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).java(c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a job in a remote command agent.\n     * @param machine The host to execute the command\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return value of the job\n     * @throws Exception An error occured executing the remote job\n     */\n    public <V extends Serializable> V execute(String machine,\n                                              RemoteCallable<V> callable,\n                                              String svcPath)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable, svcPath);\n    }\n\n    /**\n     * Executes a job on remote command agents on a list of systems.\n     * @param machines The host names to execute the job\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return values of the job, in sequence\n     * @throws Exception An error occurred executing the job\n     */\n    public <V extends Serializable> List<V> execute(String[] machines,\n                                                    RemoteCallable<V> callable,\n                                                    String svcPath)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable, svcPath));\n        return rl;\n    }\n\n    /**\n     * Start the agent on a single machine.\n     * @param machine on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if the command completed successfully, else false\n     * @throws Exception An error occurred starting the command\n     */\n    public boolean startAgent(String machine, Class agentClass,\n                              String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return (startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if all commands completed successfully, else false\n     * @throws Exception An error occurred starting the commands\n     */\n    public boolean startAgent(String machines[], Class agentClass,\n                              String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n    /**\n     * Gets a property from a given file.\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n    /**\n     * Kill all commands currently running and cleanup.\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++) {\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                }\n                if (retry == 20) {\n                    logger.severe(\"Registry did not terminate \" +\n                            \"after 20 termination attempts, giving up! \" +\n                            \"Subsequent runs may have problems.\");\n                }\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name, relative to the out dir\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n            String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        }\n        \n        // Ensure the file is accessed from the right place.\n        File src = new File(srcfile);\n        if (!src.isAbsolute())\n            src = new File(Config.OUT_DIR, srcfile);\n        srcfile = src.getAbsolutePath();\n\n        try {\n            String srcHost = InetAddress.getLocalHost().getHostName();\n            String destHost = hostRoles.getHostByAlias(destmachine);\n            if (destHost.equals(srcHost)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent destf = filep.get(didx);\n        try {\n            FileTransfer transfer = new FileTransfer(srcfile, destfile);\n            logger.fine(\"Transferring \" + transfer.getSource() + \"->\" +\n                    transfer.getDest() + \" size \" +\n                    transfer.getSize() + \" bytes.\");\n            if (destf.push(transfer) != transfer.getSize()) {\n                throw new IOException(\"Invalid transfer size\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name, always full path\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n            String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        }\n        try {\n            String src = InetAddress.getLocalHost().getHostName();\n            String dest = hostRoles.getHostByAlias(srcmachine);\n            if (dest.equals(src)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() != transfer.getTransferSize()) {\n                throw new IOException(\"Received \" + transfer.getSource() +\n                        \"->\" + transfer.getDest() + \", \" +\n                        transfer.getTransferSize() + \" out of \" +\n                        transfer.getSize() + \" bytes\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     * @deprecated\n     */\n    @Deprecated public synchronized boolean copy(String srcmachine, String destmachine,\n            String srcfile, String destfile,\n            boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile)) {\n            return (true);\n        }\n\n        if (srcfile.equals(destfile)) {\n            try {\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src) {\n                    return true;\n                }\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append) {\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            } else {\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n            }\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile + \" to \" + destmachine + \":\" +\n                    destfile, ie);\n            return (false);\n        }\n        return true;\n    }\n\n    /**\n     * Obtains the temporary dircteroy for the given machine.\n     *\n     * @param machine The machine name\n     * @return The temporary directory to use on the machine\n     */\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return filep.get(index);\n    }\n\n    /**\n     * Deletes the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n    /**\n     * Deletes the file from the machine based on the filter provided.\n     *\n     * @param srcmachine The machine name\n     * @param dir The directory name\n     * @param filter The file filter to use\n     * @return true if akk files selected by the filter has been removed\n     */\n    public synchronized boolean delete(String srcmachine, String dir,\n            com.sun.faban.harness.FileFilter filter) {\n        try {\n            return findFileAgent(srcmachine).removeFiles(dir, filter);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete files on \" +\n                    srcmachine + \":\" + dir);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n    /**\n     * Truncates the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean truncate(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).truncateFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not truncate \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile,\n            OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile, ie);\n            return (false);\n        }\n        return (true);\n    }\n\n    /**\n     * Set the Log level for Agents.\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * Obtains the registry.\n     * @return The registry\n     */\n    public Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.HostRoles;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    /** Sequential flag in FG mode. */\n    public static final int SEQUENTIAL = 1;\n\n    /** Parallel flag in FG mode. */\n    public static final int PARALLEL = 2;\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines. */\n    private ArrayList<String> machinesList = new ArrayList<String>();\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private List<String> jvmOptions;\n    private HashMap<String, List<String>> binMap =\n            new HashMap<String, List<String>>();\n    private Map<String, String> ifMap;\n    private List<String> rsh,  agent;\n    private HostRoles hostRoles;\n\n    CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n        cmds = this;\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        return cmds;\n    }\n\n    /**\n     * Obtains the name of the master machine.\n     * @return The master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines.\n     * This method can be called multiple times to initialize multiple\n     * classes of machines.\n     * @param benchName The name of the benchmark\n     * @param par The parameter repository\n     * @return true if successful, false if setup failed\n     */\n    public boolean setup(String benchName, ParamRepository par) {\n\n        String home = par.getParameter(\"fh:jvmConfig/fh:home\");\n\n        if (home != null)\n            home = home.trim();\n\n        if (home == null || home.length() == 0) {\n            home = Utilities.getJavaHome();\n            logger.config(\"JAVA_HOME set to \" + home);\n        }\n\n        if(!(new File(home)).isDirectory()) {\n            logger.severe(\"Cannot set JAVA_HOME. \" + home +\n                    \" is not a valid JAVA_HOME. Exiting\");\n            return false;\n        }\n\n        javaHome = home;\n\n        // Check whether the target JVM supports -XX:+DisableExplicitGC or not.\n        String egc = \"-XX:+DisableExplicitGC\";\n        Command probeCmd = new Command(javaHome + File.separator + \"bin\" +\n                File.separator + \"java\", \"-version\", egc);\n        probeCmd.setLogLevel(Command.STDOUT, Level.FINER);\n        probeCmd.setLogLevel(Command.STDERR, Level.FINER);\n        try {\n            CommandHandle handle = probeCmd.execute();\n            if (handle.exitValue() != 0)\n                egc = null;\n        } catch (IOException e) {\n            egc = null;\n        } catch (InterruptedException e) {\n        }\n\n        final String disableEGC = egc;\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        jvmOptions = new ArrayList<String>();\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                fs + \"faban.policy\");\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties\");\n        jvmOptions.add(\"-Dfaban.registry.port=\" + Config.RMI_PORT);\n        jvmOptions.add(\"-Dfaban.logging.port=\" + Config.LOGGING_PORT);\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if (!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                    log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))) {\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                        String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < libs.length; i++) {\n                if (libs[i].isFile()) {\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n                }\n            }\n            buf.setLength(buf.length() - 1);\n            if (buf.indexOf(\" \") != -1) {\n                buf.insert(0, '\"');\n                buf.append('\"');\n            }\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            List<String> cmd = new ArrayList<String>();\n            cmd.add(javaHome + File.separator + \"bin\" + File.separator +\n                    \"java\");\n            cmd.addAll(jvmOptions);\n            cmd.add(\"-Xms32m\");\n            cmd.add(\"-Xmx1024m\");\n            cmd.add(\"-cp\");\n            cmd.add(classpath);\n            cmd.add(\"com.sun.faban.common.RegistryImpl\");\n\n            logger.info(\"Starting Registry.\");\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        String jvmOpts =\n                par.getParameter(\"fh:jvmConfig/fh:jvmOptions\");\n\n        if (jvmOpts != null)\n            jvmOpts = jvmOpts.trim();\n\n        if((jvmOpts == null) || (jvmOpts.length() == 0))\n            jvmOpts = \"\";\n\n        List<String> usrOpts = Command.parseArgs(jvmOpts);\n        if (disableEGC != null && !usrOpts.contains(disableEGC))\n            usrOpts.add(disableEGC);\n        jvmOptions.addAll(usrOpts);\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Unable to connect to Registry.\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        List<ParamRepository.HostConfig> hostConfigs = null;\n        try {\n            hostConfigs = par.getHostConfigs();\n        } catch (ConfigurationException e) {\n            logger.log(Level.SEVERE, \"Problem reading parameter file\", e);\n        }\n\n        outer:\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 || // localhost\n                            machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\", e);\n        }\n\n        if (rsh == null) {\n            rsh = new ArrayList<String>();\n            rsh.add(\"rsh\");\n        }\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master)) {\n                return false;\n            }\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if (\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if (machinesList.contains(machines[i])) {\n                    continue;\n                }\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0) {\n                    return false;\n                }\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress)) {\n                    return false;\n                }\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++) {\n            if (!getCmdAgent((String) machinesList.get(i))) {\n                return false;\n            }\n        }\n\n        if (par.getBooleanValue(\"fa:runConfig/fh:timeSync\", true)) {\n            setClocks();\n        }\n\n        return true;\n    }\n\n    void setHostRoles(HostRoles hr) {\n        hostRoles = hr;\n\n        // We need to populate the machinesList and cmdp with\n        // the real host names.\n\n        // First get the real names.\n        String[] realHosts = hostRoles.getHostsInOrder();\n        \n        // For each real host name not in machinesList, we take the first alias\n        // and look it up in the machinesList. Fetch the command agent and add\n        // the real name to the machinesList -> cmdp mapping.\n        for (String hostName : realHosts) {\n            if (!machinesList.contains(hostName)) {\n                String[] aliases = hostRoles.getAliasesByHost(hostName);\n                CmdAgent a = findCmdAgent(aliases[0]); // Just one is enough\n                machinesList.add(hostName);\n                cmdp.add(a);\n            }\n        }\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n            Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host : hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            } catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                        retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return (false);\n            }\n\n            cmdp.add(c);\n\n            /* Note the agent registration process:\n             * 1. Create and register the command agent.\n             * 2. Download benchmark code\n             * 3. Create the lib classpath\n             * 4. Create and register file agent\n             * So it may take quite some time between the registration of\n             * the command agent and the file agent. But we can be pretty\n             * sure it'll happen. So just wait. Timeout after 100 retries.             \n             */\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"FileService: Connecting to \" + s);\n            retry = 1;\n            FileAgent f = (FileAgent) registry.getService(s);\n            for (; f == null && retry <= 100; retry++) {\n                Thread.sleep(1000);\n                logger.fine(\"Retry obtaining file service from \" + s +\n                        \", count \" + retry + '.');\n                f = (FileAgent) registry.getService(s);\n            }\n            if (f == null) {\n                logger.severe(\"Timed out obtaining file service from \" + s);\n                return (false);\n            }\n            filep.add(f);\n\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" +\n                    c.getHostName());\n            return true;\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \" + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n     * We use a script 'cmd' which will setup the CLASSPATH before\n     * invoking CmdAgent\n     */\n    private boolean startCmdAgent(String benchName, String mach,\n            String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        List<String> cmd = new ArrayList<String>();\n\n        List<String> agentParams = new ArrayList<String>();\n        agentParams.add(mach);\n        agentParams.add(interfaceAddress);\n        agentParams.add(masterAddress);\n        agentParams.add(javaHome);\n        agentParams.addAll(jvmOptions);\n        agentParams.add(\"faban.benchmarkName=\" + benchName);\n        try {\n            if (mach.equals(master)) {\n                cmd.addAll(agent);\n                cmd.addAll(agentParams);\n                logger.fine(\"Executing \" + cmd);\n                Command cmdAgent = new Command(cmd);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams.add(\"faban.download=\" + downloadURL.toString());\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    ObjectOutputStream socketOut =\n                            new ObjectOutputStream(socket.getOutputStream());\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n\n                    ArrayList<String> agentExtParams = \n                            new ArrayList<String>(agentParams);\n                    agentExtParams.add(File.separator);\n                    agentExtParams.add(File.pathSeparator);\n                    socketOut.writeObject(agentExtParams);\n\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200:\n                            agentStarted = true;\n                            logger.fine(\"Found Agent(daemon)@\" + mach +\n                                    \". Registering agent.\");\n                            break;\n                        case 500:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response +\n                                    \" Please report the issue \" +\n                                    \"and provide logs from \" + mach +\n                                    \":FABAN_HOME/logs/agent.log\");\n                            break;\n                        case 409:\n                            logger.severe(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                            // We do not fall back in the conflict case.\n                            return false;\n                        default:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmd.clear();\n                    cmd.addAll(rsh);\n                    cmd.add(mach);\n                    cmd.addAll(agent);\n                    cmd.addAll(agentParams);\n                    Command cmdAgent = new Command(cmd);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<NameValuePair<Future<Boolean>>> tasks =\n                new ArrayList<NameValuePair<Future<Boolean>>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    NameValuePair<Future<Boolean>> future =\n                            new NameValuePair<Future<Boolean>>();\n                    future.name = hostName;\n                    future.value = Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat));\n                    tasks.add(future);\n                }\n            } catch (RemoteException e) {\n                logger.log(Level.WARNING,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n        for (NameValuePair<Future<Boolean>> future : tasks) {\n            try {\n                future.value.get(300, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                logger.log(Level.WARNING, \"Timed out setting clock for \" +\n                        future.name);\n            } catch (Throwable t) {\n                Throwable cause = t.getCause();\n                while (cause != null) {\n                    t = cause;\n                    cause = t.getCause();\n                }\n                logger.log(Level.WARNING, t.getMessage(), t);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws IOException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                    ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \" cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \" cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100) {\n                            ++nextSec; // If not, we go to the next sec.\n                        }\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                System.currentTimeMillis();\n                        if (sleepTime > 0) {\n                            Thread.sleep(sleepTime);\n                        }\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            if (wakeBefore > 700) {\n                                logger.warning(hostName + \" wakeup-before \" +\n                                        \"time reached 700ms limit. System is \" +\n                                        \"too busy. Giving up.\");\n                                return false;\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                        ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Obtains the cached HostType object. Note that this is not a public API.\n     * @return The cached HostType object;\n     */\n    public HostRoles getHostRoles() {\n        return hostRoles;\n    }\n\n    /**\n     * Returns the hostname of this machine as known to the machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     * @param machineName The target machine to check the host name\n     * @return The host name of the remote machine\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0) {\n            return machineName; // Cannot resolve\n        }\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        } catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                    re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Updates the paths in the local command agent.\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void updatePaths(List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(master).updatePaths(pathList);\n    }\n\n    /**\n     * Downloads files used by deploy images, especially services and tools.\n     * The pathList contains a list of resources in the form type/resource.\n     * @param machine The host name to initiate the download\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void downloadServices(String machine, List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(machine).downloadServices(pathList);\n    }\n\n    /**\n     * Returns the location of this command on the master system.\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command to execute, or null if not found.\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public String which(String cmd, String svcPath) throws RemoteException {\n        return which(master, cmd, svcPath);\n    }\n\n    /**\n     * Returns the location of this command on the target system.\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param machine The machine to search\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command to execute, or null if not found.\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public String which(String machine, String cmd, String svcPath)\n            throws RemoteException {\n        return findCmdAgent(machine).which(cmd, svcPath);\n    }\n\n    /**\n     * Returns the location of this command on the target systems.\n     * Similar to the which shell command, 'which' returns the actual path\n     * to the given command. If it maps to a series of commands, they will\n     * be returned as a single string separated by spaces. Note that 'which'\n     * does not actually try to check the underlying system for commands\n     * in the search path. It only checks the Faban infrastructure for\n     * existence of such a command.\n     * @param machines The machines to search\n     * @param cmd The command to search for\n     * @param svcPath The service path, if any\n     * @return The actual command paths to execute, or null elements if not found.\n     */\n    public String[] which(String[] machines, String cmd, String svcPath) {\n        String[] paths = new String[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            try {\n                paths[i] = which(machines[i], cmd, svcPath);\n            } catch (RemoteException e) {\n                logger.warning(\"Error searching for command \" + cmd + \" on \" +\n                                machines[i] + '.');\n            }\n        return paths;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return execute(master, c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).execute(c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return java(master, c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).java(c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a job in a remote command agent.\n     * @param machine The host to execute the command\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return value of the job\n     * @throws Exception An error occured executing the remote job\n     */\n    public <V extends Serializable> V execute(String machine,\n                                              RemoteCallable<V> callable,\n                                              String svcPath)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable, svcPath);\n    }\n\n    /**\n     * Executes a job on remote command agents on a list of systems.\n     * @param machines The host names to execute the job\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return values of the job, in sequence\n     * @throws Exception An error occurred executing the job\n     */\n    public <V extends Serializable> List<V> execute(String[] machines,\n                                                    RemoteCallable<V> callable,\n                                                    String svcPath)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable, svcPath));\n        return rl;\n    }\n\n    /**\n     * Start the agent on a single machine.\n     * @param machine on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if the command completed successfully, else false\n     * @throws Exception An error occurred starting the command\n     */\n    public boolean startAgent(String machine, Class agentClass,\n                              String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return (startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if all commands completed successfully, else false\n     * @throws Exception An error occurred starting the commands\n     */\n    public boolean startAgent(String machines[], Class agentClass,\n                              String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n    /**\n     * Gets a property from a given file.\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n    /**\n     * Kill all commands currently running and cleanup.\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++) {\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                }\n                if (retry == 20) {\n                    logger.severe(\"Registry did not terminate \" +\n                            \"after 20 termination attempts, giving up! \" +\n                            \"Subsequent runs may have problems.\");\n                }\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name, relative to the out dir\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n            String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        }\n        \n        // Ensure the file is accessed from the right place.\n        File src = new File(srcfile);\n        if (!src.isAbsolute())\n            src = new File(Config.OUT_DIR, srcfile);\n        srcfile = src.getAbsolutePath();\n\n        try {\n            String srcHost = InetAddress.getLocalHost().getHostName();\n            String destHost = hostRoles.getHostByAlias(destmachine);\n            if (destHost.equals(srcHost)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent destf = filep.get(didx);\n        try {\n            FileTransfer transfer = new FileTransfer(srcfile, destfile);\n            logger.fine(\"Transferring \" + transfer.getSource() + \"->\" +\n                    transfer.getDest() + \" size \" +\n                    transfer.getSize() + \" bytes.\");\n            if (destf.push(transfer) != transfer.getSize()) {\n                throw new IOException(\"Invalid transfer size\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name, always full path\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n            String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        }\n        try {\n            String src = InetAddress.getLocalHost().getHostName();\n            String dest = hostRoles.getHostByAlias(srcmachine);\n            if (dest.equals(src)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() != transfer.getTransferSize()) {\n                throw new IOException(\"Received \" + transfer.getSource() +\n                        \"->\" + transfer.getDest() + \", \" +\n                        transfer.getTransferSize() + \" out of \" +\n                        transfer.getSize() + \" bytes\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     * @deprecated\n     */\n    @Deprecated public synchronized boolean copy(String srcmachine, String destmachine,\n            String srcfile, String destfile,\n            boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile)) {\n            return (true);\n        }\n\n        if (srcfile.equals(destfile)) {\n            try {\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src) {\n                    return true;\n                }\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append) {\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            } else {\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n            }\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile + \" to \" + destmachine + \":\" +\n                    destfile, ie);\n            return (false);\n        }\n        return true;\n    }\n\n    /**\n     * Obtains the temporary dircteroy for the given machine.\n     *\n     * @param machine The machine name\n     * @return The temporary directory to use on the machine\n     */\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return filep.get(index);\n    }\n\n    /**\n     * Deletes the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n    /**\n     * Deletes the file from the machine based on the filter provided.\n     *\n     * @param srcmachine The machine name\n     * @param dir The directory name\n     * @param filter The file filter to use\n     * @return true if akk files selected by the filter has been removed\n     */\n    public synchronized boolean delete(String srcmachine, String dir,\n            com.sun.faban.harness.FileFilter filter) {\n        try {\n            return findFileAgent(srcmachine).removeFiles(dir, filter);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete files on \" +\n                    srcmachine + \":\" + dir);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n    /**\n     * Truncates the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean truncate(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).truncateFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not truncate \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile,\n            OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile, ie);\n            return (false);\n        }\n        return (true);\n    }\n\n    /**\n     * Set the Log level for Agents.\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * Obtains the registry.\n     * @return The registry\n     */\n    public Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","lineNo":204}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.common.FabanNamespaceContext;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CustomTableMetrics;\nimport com.sun.faban.driver.Timing;\nimport static com.sun.faban.driver.engine.AgentThread.TIME_NOT_SET;\nimport com.sun.faban.driver.util.Random;\nimport com.sun.faban.driver.util.Timer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.logging.Logger;\n\n/**\n * DriverContext is the point of communication between the\n * developer-provided driver and the Faban driver framework.\n * Each thread has it's own context.<p>\n * This class provides the actual implementation and is\n * located in the engine package to get direct access to all\n * the restricted/needed classes and members.\n *\n * @author Akara Sucharitakul\n */\npublic class DriverContext extends com.sun.faban.driver.DriverContext {\n\n    /** Thread local used for obtaining the context. */\n    private static ThreadLocal<DriverContext> localContext = new InheritableThreadLocal<DriverContext>();\n\n    /** The thread associated with this context. */\n    AgentThread agentThread;\n    \n    /** The timing structure for this thread/context. */\n    TimingInfo timingInfo = new TimingInfo();\n\n    /** The central timer. */\n    Timer timer;\n\n    /**\n     * Flag whether pause is supported with the current protocol.\n     * Default is true. Protocols that may not be request/response but\n     * may have concurrent inbound and outbound traffic, AND wishes to\n     * support auto timing should set this flag to false. The default is true.\n     */\n    boolean pauseSupported = true;\n\n    /** Context-specific logger. */\n    Logger logger;\n\n    /** The properties hashmap. It is lazy initialized. */\n    static HashMap<String, String[]> properties;\n\n    /** Class name of this class. */\n    private String className;\n\n    /** The XPath instance used to evaluate the XPaths. */\n    private XPath xPathInstance;\n\n\t/** Desired upload speed of this context */\n\tprivate int kbpsUpload = -1;\n\n\t/** Desired download speed of this context */\n\tprivate int kbpsDownload = -1;\n\n    /**\n     * Obtains the DriverContext associated with this thread.\n     * @return the associated DriverContext\n     */\n    public static DriverContext getContext() {\n        return localContext.get();\n    }\n\n    /**\n     * Constructs a DriverContext. Called only from AgentThread.\n     * @param thread The AgentThread used by this context\n     * @param timer The timer used by this thread\n     */\n    DriverContext(AgentThread thread, Timer timer) {\n        className = getClass().getName();\n        agentThread = thread;\n        this.timer = timer;\n        localContext.set(this);\n    }\n\n    /**\n     * Obtains the scale or scaling rate of the current run.\n     *\n     * @return the current run's scaling rate\n     */\n\tpublic int getScale() {\n        return agentThread.runInfo.scale;\n    }\n\n    /**\n     * Obtains the number of client threads in this agent.\n     *\n     * @return the number of client threads\n     */\n    public int getClientsInAgent() {\n        return agentThread.runInfo.agentInfo.threads;\n    }\n\n    /**\n     * Obtains the total number of clients threads for this driver.\n     *\n     * @return the number of client threads for this driver\n     */\n    public int getClientsInDriver() {\n        return agentThread.runInfo.driverConfig.numThreads;\n    }\n\n    /**\n     * Obtains the global thread id for this context's thread. The thread id\n     * is unique for each driver type.\n     * @return the global agentImpl thread id\n     */\n\tpublic int getThreadId() {\n        return agentThread.id;\n    }\n\n    /**\n     * Obtains the agent id for this agentImpl.\n     * @return the current agentImpl's id\n     */\n\tpublic int getAgentId() {\n        return agentThread.runInfo.agentInfo.agentNumber;\n    }\n\n    /**\n     * Obtains the driver's name as annotated in the driver class.\n     * @return the driver name\n     */\n\tpublic String getDriverName() {\n        return agentThread.driverConfig.name;\n    }\n\n    /**\n     * Obtains the logger to be used by the calling driver.\n     * @return the appropriate logger\n     */\n\tpublic Logger getLogger() {\n        if (logger == null) {\n            logger = Logger.getLogger(agentThread.driverConfig.\n                    className + '.' + agentThread.id);\n            if (agentThread.runInfo.logHandler != null) {\n\t\t\t\tlogger.addHandler(agentThread.runInfo.logHandler);\n\t\t\t}\n        }\n        return logger;\n    }\n\n    /**\n     * Obtains the name of the operation currently executing.\n     * @return the current operation's name,\n     *         or null if called from outside an operation.\n     */\n\tpublic String getCurrentOperation() {\n        if (agentThread.currentOperation == -1)\n            return null;\n        return agentThread.driverConfig.operations[\n                agentThread.currentOperation].name;\n    }\n\n    /**\n     * Obtains the unique id assigned to the current operation type.\n     * This id is commonly used to index into array structures containing\n     * operation-specific information such as stats. The id ranges from 0 to\n     * n where n is the number of operations in the driver less one.\n     *\n     * @return The unique id assigned to this operation type,\n     *         or -1 if called from outside an operation.\n     */\n\tpublic int getOperationId() {\n        return agentThread.currentOperation;\n    }\n\n    /**\n     * Obtains the number of operations active in this driver.\n     *\n     * @return The number of active operations\n     */\n\tpublic int getOperationCount() {\n        return agentThread.driverConfig.operations.length;\n    }\n\n    /**\n     * Obtains the per-thread random value generator. Drivers\n     * should use this random value generator and not instantiate\n     * their own.\n     * @return The random value generator\n     */\n\tpublic Random getRandom() {\n        return agentThread.random;\n    }\n\n    /**\n     * Resets the state of the current mix to start off at the beginning\n     * of the mix. For stateless mixes such as FlatMix, this operation\n     * does nothing.\n     */\n\tpublic void resetMix() {\n        agentThread.selector[agentThread.mixId].reset();\n    }\n\n    /**\n     * Attaches a custom metrics object to the primary metrics.\n     * This should be done by the driver at initialization time.\n     * Only one custom metrics can be attached. Subsequent calls\n     * to this method replaces the previously attached metrics.\n     * @param metrics The custom metrics to be replaced\n     */\n\tpublic void attachMetrics(CustomMetrics metrics) {\n        attachMetrics(\"Miscellaneous Statistics\", metrics);\n    }\n\n    /**\n     * Attaches a custom metrics object to the primary metrics,\n     * given a name or description. The name/description must be unique.\n     * This should be done by the driver at initialization time.\n     * Only one custom metrics can be attached. Subsequent calls\n     * to this method replaces the previously attached metrics.\n     * @param name    The name or description of this metrics\n     * @param metrics The custom metrics to be replaced\n     */\n    public void attachMetrics(String name, CustomMetrics metrics) {\n        if (agentThread.metrics.metricAttachments == null)\n            agentThread.metrics.metricAttachments =\n                    new LinkedHashMap<String, CustomMetrics>();\n        agentThread.metrics.metricAttachments.put(name, metrics);\n    }\n\n    /**\n     * Attaches a custom table metrics object to the primary metrics,\n     * given a name or description. The name/description must be unique.\n     * This should be done by the driver at initialization time.\n     * Only one custom metrics can be attached. Subsequent calls\n     * to this method replaces the previously attached metrics.\n     * @param name    The name or description of this metrics\n     * @param metrics The custom metrics to be replaced\n     */\n    public void attachMetrics(String name, CustomTableMetrics metrics) {\n        if (agentThread.metrics.tableAttachments == null)\n            agentThread.metrics.tableAttachments =\n                    new LinkedHashMap<String, CustomTableMetrics>();\n        agentThread.metrics.tableAttachments.put(name, metrics);\n    }\n\n    /**\n     * Parses the properties DOM tree in puts the output into a HashMap.\n     * Returns properties so that we do not have the effect of double-checks.\n     * @param propertiesElement The DOM element containing the properties\n     * @return The resulting map\n     */\n    private static synchronized HashMap<String, String[]> parseProperties(\n            Element propertiesElement) {\n        if (properties == null) {\n            NodeList list = propertiesElement.getElementsByTagNameNS(\n                                            RunInfo.DRIVERURI, \"property\");\n            int length = list.getLength();\n            HashMap<String, String[]> props =\n                    new HashMap<String, String[]>(length);\n            for (int i = 0; i < length; i++) {\n                Element propertyElement = (Element) list.item(i);\n                Attr attr = propertyElement.getAttributeNodeNS(null, \"name\");\n                if (attr != null) {\n\t\t\t\t\tprops.put(attr.getValue(), getValue(propertyElement));\n\t\t\t\t}\n                NodeList nameList =\n                        propertyElement.getElementsByTagNameNS(\n                                                RunInfo.DRIVERURI, \"name\");\n                if (nameList.getLength() != 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                Element nameElement = (Element) nameList.item(0);\n                String name = nameElement.getFirstChild().getNodeValue();\n                if (name != null) {\n\t\t\t\t\tprops.put(name, getValue(propertyElement));\n\t\t\t\t}\n            }\n            properties = props;\n        }\n        return properties;\n    }\n\n    /**\n     * Gets the value of a property DOM element.\n     * @param propertyElement The DOM element\n     * @return The list of associated values\n     */\n    private static String[] getValue(Element propertyElement) {\n        NodeList valueList = propertyElement.getElementsByTagNameNS(\n                                                RunInfo.DRIVERURI, \"value\");\n        String[] values;\n        int length = valueList.getLength();\n        if (length >= 1) {\n            values = new String[length];\n            for (int i = 0; i < length; i++) {\n                Node valueNode = valueList.item(i).getFirstChild();\n                values[i] = valueNode == null ? \"\" : valueNode.getNodeValue();\n            }\n        } else {\n            values = new String[1];\n            Node valueNode = propertyElement.getFirstChild();\n            values[0] = valueNode == null ? \"\" : valueNode.getNodeValue();\n        }\n        return values;\n    }\n\n    /**\n     * Obtains a single-value property from the configuration. If the name\n     * of a multi-value property is given, only one value is returned.\n     * It is undefined as to which value in the list is returned.\n     *\n     * @param name The property name\n     * @return The property value, or null if there is no such property\n     */\n\tpublic String getProperty(String name) {\n        if (properties == null) {\n\t\t\tproperties = parseProperties(getPropertiesNode());\n\t\t}\n        String[] value = properties.get(name);\n        if (value == null) {\n\t\t\treturn null;\n\t\t}\n        return value[0];\n    }\n\n    /**\n     * Obtains a multiple-value property from the configuration. A\n     * single-value property will be returned as an array of dimension 1.\n     *\n     * @param name The property name\n     * @return The property values\n     */\n\tpublic String[] getPropertyValues(String name) {\n        if (properties == null) {\n\t\t\tproperties = parseProperties(getPropertiesNode());\n\t\t}\n        return properties.get(name);\n    }\n\n    /**\n     * Obtains the reference to the whole properties element as configured\n     * in the driverConfig element of this driver in the config file. This\n     * method allows custom free-form structures but the driver will need\n     * to spend the effort walking the DOM tree.\n     *\n     * @return The DOM tree representing the properties node\n     */\n\tpublic Element getPropertiesNode() {\n        return agentThread.driverConfig.properties;\n    }\n\n    /**\n     * Checks whether the driver is currently in steady state or not.\n     * This method needs to be called after the critical section of the\n     * operation. The transaction times must have been recorded in order\n     * to establish whether or not the transaction is in steady state.\n     * @return True if in steady state, false if not.\n     */\n\tpublic boolean isTxSteadyState() {\n        return agentThread.isSteadyState();\n    }\n\n    /**\n     * Reads the element or attribute by it's XPath. The XPath is evaluated\n     * from the root of the configuration file.\n     *\n     * @param xPath The XPath to evaluate.\n     * @return The element or attribute value defined by the XPath\n     * @exception XPathExpressionException If the given XPath has an error\n     */\n\tpublic String getXPathValue(String xPath) throws XPathExpressionException {\n        if (xPathInstance == null) {\n            XPathFactory xf = XPathFactory.newInstance();\n            FabanNamespaceContext nsCtx = new FabanNamespaceContext();            \n            xPathInstance = xf.newXPath();\n            xPathInstance.setNamespaceContext(nsCtx);\n        }\n        return xPathInstance.evaluate(xPath,\n                agentThread.driverConfig.rootElement);\n    }\n\n    /**\n     * Records the start and end time of the critical section of an operation.\n     * This operation may block until the appropriate start time for the\n     * operation has arrived. There is no blocking for the end time.\n     * This method is for use in the driver code to demarcate critical\n     * sections.\n     * @throws IllegalStateException if the operation uses auto timing\n     */\n\tpublic void recordTime() {\n        if (agentThread.currentOperation == -1)\n            throw new IllegalStateException(\"DriverContext.recordTime called \" +\n                                            \"outside an operation\");\n        if (agentThread.driverConfig.operations[agentThread.currentOperation].\n                timing != Timing.MANUAL) {\n            String msg = \"Driver: \" + getDriverName() + \", Operation: \" +\n                    getCurrentOperation() + \", timing: MANUAL illegal call \" +\n                    \"to recordTime() in driver code.\";\n            logger.severe(msg);\n            IllegalStateException e = new IllegalStateException(msg);\n            logger.throwing(className, \"recordTime\", e);\n            throw e;\n        }\n        if (timingInfo != null) {\n\t\t\tif (timingInfo.invokeTime == TIME_NOT_SET) {\n                timer.wakeupAt(timingInfo.intendedInvokeTime);\n                // But since sleep may not be exact, we get the time again here.\n                timingInfo.invokeTime = System.nanoTime();\n            } else if (timingInfo.lastRespondTime != TIME_NOT_SET) {\n                // The critical section was paused.\n                timingInfo.pauseTime +=\n                        System.nanoTime() - timingInfo.lastRespondTime;\n                timingInfo.lastRespondTime = TIME_NOT_SET;\n            } else {\n                timingInfo.respondTime = System.nanoTime();\n            }\n\t\t}\n    }\n\n    /**\n     * Pauses the critical section so that operations made during the pause\n     * do not count into the response time. If Timing.AUTO is used, the pause\n     * ends automatically when the next request is sent to the server. For\n     * manual timing, the next call to recordTime ends the pause. Calls\n     * pauseTime when the critical section is already paused are simply ignored. \n     */\n\tpublic void pauseTime() {\n        if (agentThread.currentOperation == -1)\n            throw new IllegalStateException(\"DriverContext.pauseTime called \" +\n                                            \"outside an operation\");\n        if (agentThread.driverConfig.operations[agentThread.currentOperation].\n                timing != Timing.MANUAL) {\n            String msg = \"Driver: \" + getDriverName() + \", Operation: \" +\n                    getCurrentOperation() + \", timing: MANUAL illegal call \" +\n                    \"to pauseTime() in driver code.\";\n            logger.severe(msg);\n            IllegalStateException e = new IllegalStateException(msg);\n            logger.throwing(className, \"recordTime\", e);\n            throw e;\n        }\n        if (timingInfo.lastRespondTime == TIME_NOT_SET) {\n            timingInfo.lastRespondTime = System.nanoTime();\n\t\t}\n    }\n\n    /**\n     * Obtains a relative time, in milliseconds. This time is relative to\n     * a certain time at the beginning of the benchmark run and does not\n     * represent a wall clock time. All agents will have the same reference\n     * time. Use this time to check time durations during the benchmark run.\n     *\n     * @return The relative time of the benchmark run\n     */\n\tpublic int getTime() {\n        return timer.getTime();\n    }\n\n    /**\n     * Obtains the relative time - in milliseconds - that steady state starts,\n     * if set. The if the time is not yet set, it will return 0.\n     *\n     * @return The relative time steady state starts\n     */\n\tpublic int getSteadyStateStart() {\n        return (int) (timer.toRelTime(agentThread.endRampUp) / 1000000l);\n    }\n\n    /**\n     * Obtains a relative time, in nanosecs. This time is relative to\n     * a certain time at the beginning of the benchmark run and does not\n     * represent a wall clock time. All agents will have the same reference\n     * time. Use this time to check time durations during the benchmark run.\n     *\n     * @return The relative time of the benchmark run\n     */\n    public long getNanoTime() {\n       return timer.toRelTime(System.nanoTime());\n    }\n\n    /**\n     * Obtains the relative time - in nanosecs - that steady state starts,\n     * if set. The if the time is not yet set, it will return 0.\n     *\n     * @return The relative time steady state starts\n     */\n    public long getSteadyStateStartNanos() {\n        return timer.toRelTime(agentThread.endRampUp);\n    }\n\n    /**\n     * Obtains the configured ramp up time.\n     *\n     * @return The configured ramp up time, in seconds\n     */\n\tpublic int getRampUp() {\n        return agentThread.runInfo.rampUp;\n    }\n\n    /**\n     * Obtains the configured steady state time.\n     *\n     * @return The configured steady state time, in seconds\n     */\n\tpublic int getSteadyState() {\n        return agentThread.runInfo.stdyState;\n    }\n\n    /**\n     * Obtains the configured ramp down time.\n     *\n     * @return The configured ramp down time, in seconds\n     */\n\tpublic int getRampDown() {\n        return agentThread.runInfo.rampDown;\n    }\n\n    /**\n     * Property whether pause is supported with the current protocol.\n     * Default is true. Protocols that may not be request/response but\n     * may have concurrent inbound and outbound traffic, AND wishes to\n     * support auto timing should set this flag to false. The default is true.\n     *\n     * @return The current setting of the pauseSupported property.\n     */\n    public boolean isPauseSupported() {\n        return pauseSupported;\n    }\n\n    /**\n     * Property whether pause is supported with the current protocol.\n     * Default is true. Protocols that may not be request/response but\n     * may have concurrent inbound and outbound traffic, AND wishes to\n     * support auto timing should set this flag to false. The default is true.\n     *\n     * @param pause The new setting of the pauseSupported property.\n     */\n    public void setPauseSupported(boolean pause) {\n        pauseSupported = pause;\n    }\n\n    /**\n     * Records the start time of an operation. This method is not\n     * exposed through the interface and is only used by the transport\n     * facilities.\n     */\n    public void recordStartTime() {\n        // Not in an operation, don't record time.\n        if (agentThread.currentOperation == -1)\n            return;\n        if (timingInfo != null && agentThread.driverConfig.operations[\n                agentThread.currentOperation].timing == Timing.AUTO) {\n            if (timingInfo.invokeTime == TIME_NOT_SET) {\n                if (timingInfo.respondTime != TIME_NOT_SET)\n                    logger.warning(\"Respond time already set before \" +\n                                   \"sleeping. Please report a bug.\");\n                timer.wakeupAt(timingInfo.intendedInvokeTime);\n                // But since sleep may not be exact, we get the time again here.\n                timingInfo.invokeTime = System.nanoTime();\n            } else if (pauseSupported && timingInfo.respondTime != TIME_NOT_SET) {\n                if (timingInfo.respondTime < timingInfo.invokeTime)\n                    logger.warning(\"Respond time (\" + timingInfo.respondTime +\n                            \") less than invoke time (\" +\n                            timingInfo.invokeTime + \"). Please report a bug.\");\n\n                // Some response already read, then transmit again.\n                // In this case the time from last receive to this transmit\n                // is the pause time ...\n                timingInfo.lastRespondTime = timingInfo.respondTime;\n\n                // We set the pause time only on the first byte transmitted.\n                timingInfo.respondTime = TIME_NOT_SET;\n\n                timingInfo.pauseTime +=\n                        System.nanoTime() - timingInfo.lastRespondTime;\n            }\n            // Otherwise this can be a subsequent write.\n            // Invoke time already set and respond time not set.\n        }\n    }\n\n    /**\n     * Records the end time of an operation. This method is not\n     * exposed through the interface and is only used by the transport\n     * facilities.\n     */\n    public void recordEndTime() {\n        // Not in an operation, don't record time.\n        if (agentThread.currentOperation == -1)\n            return;\n        if (timingInfo != null && agentThread.driverConfig.operations[\n                agentThread.currentOperation].timing == Timing.AUTO ) {\n            // Some stacks clear the connection by doing a read before a write\n            // in a request, normally a read of 0 bytes. We need to make sure\n            // such reads are not part of the response time.\n            if (timingInfo.invokeTime == TIME_NOT_SET) {\n                int[] previousOps = agentThread.previousOperation;\n                String name = agentThread.driverConfig.mix[0].\n                                operations[previousOps[0]].name;\n                if (previousOps.length > 1)\n                    name += ',' + agentThread.driverConfig.mix[1].\n                                  operations[previousOps[1]].name;\n                logger.warning(\"Read before write! Some input may still be in\" +\n                        \" the buffer from previous operation \" + name +\n                        \". Ignoring such input.\");\n            } else {\n\t\t\t    timingInfo.respondTime = System.nanoTime();\n            }\n\t\t}\n    }\n\n    /**\n     * Sets the intended invocation time for the next invocation\n     * on this thread. This is called from AgentThread only.\n     * @param time The time to invoke\n     */\n    void setInvokeTime(long time) {\n\n        // Then set the intended start time.\n        timingInfo.intendedInvokeTime = time;\n        // And set the other times to invalid.\n        timingInfo.invokeTime = TIME_NOT_SET;\n        timingInfo.respondTime = TIME_NOT_SET;\n        timingInfo.lastRespondTime = TIME_NOT_SET;\n        timingInfo.pauseTime = 0l;\n    }\n\n    /**\n     * TimingInfo is a value object that contains individual\n     * timing records for each operation.\n     */\n    public static class TimingInfo {\n\n    \t/** Intended Invoke Time. */\n        public long intendedInvokeTime = TIME_NOT_SET;\n\n        /** Actual Invoke Time. */\n        public long invokeTime = TIME_NOT_SET;\n\n        /** Respond Time. */\n        public long respondTime = TIME_NOT_SET;\n\n        /** Last respond time, if any. */\n        public long lastRespondTime = TIME_NOT_SET;\n\n        /** Pause Time. */\n        public long pauseTime = 0l;\n    }\n\n    /**\n     * Obtains the base directory where the benchmark currently being run\n     * is installed.\n     *\n     * @return The benchmark's base directory\n     */\n    public String getBaseDir() {\n        return agentThread.agent.driverBase;\n    }\n\n    /**\n     * Obtains the resource directory used for this benchmark, if exists.\n     * @return The resource directory for this benchmark\n     */\n    public String getResourceDir() {\n        return agentThread.agent.driverBase + File.separator + \"resources\";\n    }\n\n    /**\n     * Set the desired upload speed for the thread using this context.\n     * This method is intended for use only by transport classes; drivers\n     * should call an apporpriate method on the transport to set this\n     * value. Note that not all transports support bandwidth throttling\n     * (so drivers that do call this method will have no idea if the value\n     * is used or not).\n     *\n     * @param kbps desired speed in kilobytes per second. If kbps is < 0,\n     * speed will be unlimited.\n     */\n    public void setUploadSpeed(int kbps) {\n        this.kbpsUpload = kbps;\n    }\n\n    /**\n     * Return the desired upload speed for the thread using this context.\n     *\n     * @return desired speed in kilobytes per second\n     */\n    public int getUploadSpeed() {\n        return kbpsUpload;\n    }\n\n    /**\n     * Set the desired downoad speed for the thread using this context.\n     * This method is intended for use only by transport classes; drivers\n     * should call an apporpriate method on the transport to set this\n     * value. Note that not all transports support bandwidth throttling\n     * (so drivers that do call this method will have no idea if the value\n     * is used or not).\n     *\n     * @param kbps desired speed in kilobytes per second. If kbps is < 0,\n     * speed will be unlimited.\n     */\n    public void setDownloadSpeed(int kbps) {\n        this.kbpsDownload = kbps;\n    }\n\n    /**\n     * Return the desired download speed for the thread using this context.\n     *\n     * @return desired speed in kilobytes per second\n     */\n    public int getDownloadSpeed() {\n        return kbpsDownload;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.common.FabanNamespaceContext;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CustomTableMetrics;\nimport com.sun.faban.driver.Timing;\nimport static com.sun.faban.driver.engine.AgentThread.TIME_NOT_SET;\nimport com.sun.faban.driver.util.Random;\nimport com.sun.faban.driver.util.Timer;\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathExpressionException;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.File;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.logging.Logger;\n\n/**\n * DriverContext is the point of communication between the\n * developer-provided driver and the Faban driver framework.\n * Each thread has it's own context.<p>\n * This class provides the actual implementation and is\n * located in the engine package to get direct access to all\n * the restricted/needed classes and members.\n *\n * @author Akara Sucharitakul\n */\npublic class DriverContext extends com.sun.faban.driver.DriverContext {\n\n    /** Thread local used for obtaining the context. */\n    private static ThreadLocal<DriverContext> localContext = new InheritableThreadLocal<DriverContext>();\n\n    /** The thread associated with this context. */\n    AgentThread agentThread;\n    \n    /** The timing structure for this thread/context. */\n    TimingInfo timingInfo = new TimingInfo();\n\n    /** The central timer. */\n    Timer timer;\n\n    /**\n     * Flag whether pause is supported with the current protocol.\n     * Default is true. Protocols that may not be request/response but\n     * may have concurrent inbound and outbound traffic, AND wishes to\n     * support auto timing should set this flag to false. The default is true.\n     */\n    boolean pauseSupported = true;\n\n    /** Context-specific logger. */\n    Logger logger;\n\n    /** The properties hashmap. It is lazy initialized. */\n    static HashMap<String, String[]> properties;\n\n    /** Class name of this class. */\n    private String className;\n\n    /** The XPath instance used to evaluate the XPaths. */\n    private XPath xPathInstance;\n\n\t/** Desired upload speed of this context */\n\tprivate int kbpsUpload = -1;\n\n\t/** Desired download speed of this context */\n\tprivate int kbpsDownload = -1;\n\n    /**\n     * Obtains the DriverContext associated with this thread.\n     * @return the associated DriverContext\n     */\n    public static DriverContext getContext() {\n        return localContext.get();\n    }\n\n    /**\n     * Constructs a DriverContext. Called only from AgentThread.\n     * @param thread The AgentThread used by this context\n     * @param timer The timer used by this thread\n     */\n    DriverContext(AgentThread thread, Timer timer) {\n        className = getClass().getName();\n        agentThread = thread;\n        this.timer = timer;\n        localContext.set(this);\n    }\n\n    /**\n     * Obtains the scale or scaling rate of the current run.\n     *\n     * @return the current run's scaling rate\n     */\n\tpublic int getScale() {\n        return agentThread.runInfo.scale;\n    }\n\n    /**\n     * Obtains the number of client threads in this agent.\n     *\n     * @return the number of client threads\n     */\n    public int getClientsInAgent() {\n        return agentThread.runInfo.agentInfo.threads;\n    }\n\n    /**\n     * Obtains the total number of clients threads for this driver.\n     *\n     * @return the number of client threads for this driver\n     */\n    public int getClientsInDriver() {\n        return agentThread.runInfo.driverConfig.numThreads;\n    }\n\n    /**\n     * Obtains the global thread id for this context's thread. The thread id\n     * is unique for each driver type.\n     * @return the global agentImpl thread id\n     */\n\tpublic int getThreadId() {\n        return agentThread.id;\n    }\n\n    /**\n     * Obtains the agent id for this agentImpl.\n     * @return the current agentImpl's id\n     */\n\tpublic int getAgentId() {\n        return agentThread.runInfo.agentInfo.agentNumber;\n    }\n\n    /**\n     * Obtains the driver's name as annotated in the driver class.\n     * @return the driver name\n     */\n\tpublic String getDriverName() {\n        return agentThread.driverConfig.name;\n    }\n\n    /**\n     * Obtains the logger to be used by the calling driver.\n     * @return the appropriate logger\n     */\n\tpublic Logger getLogger() {\n        if (logger == null) {\n            logger = Logger.getLogger(agentThread.driverConfig.\n                    className + '.' + agentThread.id);\n            if (agentThread.runInfo.logHandler != null) {\n\t\t\t\tlogger.addHandler(agentThread.runInfo.logHandler);\n\t\t\t}\n        }\n        return logger;\n    }\n\n    /**\n     * Obtains the name of the operation currently executing.\n     * @return the current operation's name,\n     *         or null if called from outside an operation.\n     */\n\tpublic String getCurrentOperation() {\n        if (agentThread.currentOperation == -1)\n            return null;\n        return agentThread.driverConfig.operations[\n                agentThread.currentOperation].name;\n    }\n\n    /**\n     * Obtains the unique id assigned to the current operation type.\n     * This id is commonly used to index into array structures containing\n     * operation-specific information such as stats. The id ranges from 0 to\n     * n where n is the number of operations in the driver less one.\n     *\n     * @return The unique id assigned to this operation type,\n     *         or -1 if called from outside an operation.\n     */\n\tpublic int getOperationId() {\n        return agentThread.currentOperation;\n    }\n\n    /**\n     * Obtains the number of operations active in this driver.\n     *\n     * @return The number of active operations\n     */\n\tpublic int getOperationCount() {\n        return agentThread.driverConfig.operations.length;\n    }\n\n    /**\n     * Obtains the per-thread random value generator. Drivers\n     * should use this random value generator and not instantiate\n     * their own.\n     * @return The random value generator\n     */\n\tpublic Random getRandom() {\n        return agentThread.random;\n    }\n\n    /**\n     * Resets the state of the current mix to start off at the beginning\n     * of the mix. For stateless mixes such as FlatMix, this operation\n     * does nothing.\n     */\n\tpublic void resetMix() {\n        agentThread.selector[agentThread.mixId].reset();\n    }\n\n    /**\n     * Attaches a custom metrics object to the primary metrics.\n     * This should be done by the driver at initialization time.\n     * Only one custom metrics can be attached. Subsequent calls\n     * to this method replaces the previously attached metrics.\n     * @param metrics The custom metrics to be replaced\n     */\n\tpublic void attachMetrics(CustomMetrics metrics) {\n        attachMetrics(\"Miscellaneous Statistics\", metrics);\n    }\n\n    /**\n     * Attaches a custom metrics object to the primary metrics,\n     * given a name or description. The name/description must be unique.\n     * This should be done by the driver at initialization time.\n     * Only one custom metrics can be attached. Subsequent calls\n     * to this method replaces the previously attached metrics.\n     * @param name    The name or description of this metrics\n     * @param metrics The custom metrics to be replaced\n     */\n    public void attachMetrics(String name, CustomMetrics metrics) {\n        if (agentThread.metrics.metricAttachments == null)\n            agentThread.metrics.metricAttachments =\n                    new LinkedHashMap<String, CustomMetrics>();\n        agentThread.metrics.metricAttachments.put(name, metrics);\n    }\n\n    /**\n     * Attaches a custom table metrics object to the primary metrics,\n     * given a name or description. The name/description must be unique.\n     * This should be done by the driver at initialization time.\n     * Only one custom metrics can be attached. Subsequent calls\n     * to this method replaces the previously attached metrics.\n     * @param name    The name or description of this metrics\n     * @param metrics The custom metrics to be replaced\n     */\n    public void attachMetrics(String name, CustomTableMetrics metrics) {\n        if (agentThread.metrics.tableAttachments == null)\n            agentThread.metrics.tableAttachments =\n                    new LinkedHashMap<String, CustomTableMetrics>();\n        agentThread.metrics.tableAttachments.put(name, metrics);\n    }\n\n    /**\n     * Parses the properties DOM tree in puts the output into a HashMap.\n     * Returns properties so that we do not have the effect of double-checks.\n     * @param propertiesElement The DOM element containing the properties\n     * @return The resulting map\n     */\n    private static synchronized HashMap<String, String[]> parseProperties(\n            Element propertiesElement) {\n        if (properties == null) {\n            NodeList list = propertiesElement.getElementsByTagNameNS(\n                                            RunInfo.DRIVERURI, \"property\");\n            int length = list.getLength();\n            HashMap<String, String[]> props =\n                    new HashMap<String, String[]>(length);\n            for (int i = 0; i < length; i++) {\n                Element propertyElement = (Element) list.item(i);\n                Attr attr = propertyElement.getAttributeNodeNS(null, \"name\");\n                if (attr != null) {\n\t\t\t\t\tprops.put(attr.getValue(), getValue(propertyElement));\n\t\t\t\t}\n                NodeList nameList =\n                        propertyElement.getElementsByTagNameNS(\n                                                RunInfo.DRIVERURI, \"name\");\n                if (nameList.getLength() != 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                Element nameElement = (Element) nameList.item(0);\n                String name = nameElement.getFirstChild().getNodeValue();\n                if (name != null) {\n\t\t\t\t\tprops.put(name, getValue(propertyElement));\n\t\t\t\t}\n            }\n            properties = props;\n        }\n        return properties;\n    }\n\n    /**\n     * Gets the value of a property DOM element.\n     * @param propertyElement The DOM element\n     * @return The list of associated values\n     */\n    private static String[] getValue(Element propertyElement) {\n        NodeList valueList = propertyElement.getElementsByTagNameNS(\n                                                RunInfo.DRIVERURI, \"value\");\n        String[] values;\n        int length = valueList.getLength();\n        if (length >= 1) {\n            values = new String[length];\n            for (int i = 0; i < length; i++) {\n                Node valueNode = valueList.item(i).getFirstChild();\n                values[i] = valueNode == null ? \"\" : valueNode.getNodeValue();\n            }\n        } else {\n            values = new String[1];\n            Node valueNode = propertyElement.getFirstChild();\n            values[0] = valueNode == null ? \"\" : valueNode.getNodeValue();\n        }\n        return values;\n    }\n\n    /**\n     * Obtains a single-value property from the configuration. If the name\n     * of a multi-value property is given, only one value is returned.\n     * It is undefined as to which value in the list is returned.\n     *\n     * @param name The property name\n     * @return The property value, or null if there is no such property\n     */\n\tpublic String getProperty(String name) {\n        if (properties == null) {\n\t\t\tproperties = parseProperties(getPropertiesNode());\n\t\t}\n        String[] value = properties.get(name);\n        if (value == null) {\n\t\t\treturn null;\n\t\t}\n        return value[0];\n    }\n\n    /**\n     * Obtains a multiple-value property from the configuration. A\n     * single-value property will be returned as an array of dimension 1.\n     *\n     * @param name The property name\n     * @return The property values\n     */\n\tpublic String[] getPropertyValues(String name) {\n        if (properties == null) {\n\t\t\tproperties = parseProperties(getPropertiesNode());\n\t\t}\n        return properties.get(name);\n    }\n\n    /**\n     * Obtains the reference to the whole properties element as configured\n     * in the driverConfig element of this driver in the config file. This\n     * method allows custom free-form structures but the driver will need\n     * to spend the effort walking the DOM tree.\n     *\n     * @return The DOM tree representing the properties node\n     */\n\tpublic Element getPropertiesNode() {\n        return agentThread.driverConfig.properties;\n    }\n\n    /**\n     * Checks whether the driver is currently in steady state or not.\n     * This method needs to be called after the critical section of the\n     * operation. The transaction times must have been recorded in order\n     * to establish whether or not the transaction is in steady state.\n     * @return True if in steady state, false if not.\n     */\n\tpublic boolean isTxSteadyState() {\n        return agentThread.isSteadyState();\n    }\n\n    /**\n     * Reads the element or attribute by it's XPath. The XPath is evaluated\n     * from the root of the configuration file.\n     *\n     * @param xPath The XPath to evaluate.\n     * @return The element or attribute value defined by the XPath\n     * @exception XPathExpressionException If the given XPath has an error\n     */\n\tpublic String getXPathValue(String xPath) throws XPathExpressionException {\n        if (xPathInstance == null) {\n            XPathFactory xf = XPathFactory.newInstance();\n            FabanNamespaceContext nsCtx = new FabanNamespaceContext();            \n            xPathInstance = xf.newXPath();\n            xPathInstance.setNamespaceContext(nsCtx);\n        }\n        return xPathInstance.evaluate(xPath,\n                agentThread.driverConfig.rootElement);\n    }\n\n    /**\n     * Records the start and end time of the critical section of an operation.\n     * This operation may block until the appropriate start time for the\n     * operation has arrived. There is no blocking for the end time.\n     * This method is for use in the driver code to demarcate critical\n     * sections.\n     * @throws IllegalStateException if the operation uses auto timing\n     */\n\tpublic void recordTime() {\n        if (agentThread.currentOperation == -1)\n            throw new IllegalStateException(\"DriverContext.recordTime called \" +\n                                            \"outside an operation\");\n        if (agentThread.driverConfig.operations[agentThread.currentOperation].\n                timing != Timing.MANUAL) {\n            String msg = \"Driver: \" + getDriverName() + \", Operation: \" +\n                    getCurrentOperation() + \", timing: MANUAL illegal call \" +\n                    \"to recordTime() in driver code.\";\n            logger.severe(msg);\n            IllegalStateException e = new IllegalStateException(msg);\n            logger.throwing(className, \"recordTime\", e);\n            throw e;\n        }\n        if (timingInfo != null) {\n\t\t\tif (timingInfo.invokeTime == TIME_NOT_SET) {\n                timer.wakeupAt(timingInfo.intendedInvokeTime);\n                // But since sleep may not be exact, we get the time again here.\n                timingInfo.invokeTime = System.nanoTime();\n            } else if (timingInfo.lastRespondTime != TIME_NOT_SET) {\n                // The critical section was paused.\n                timingInfo.pauseTime +=\n                        System.nanoTime() - timingInfo.lastRespondTime;\n                timingInfo.lastRespondTime = TIME_NOT_SET;\n            } else {\n                timingInfo.respondTime = System.nanoTime();\n            }\n\t\t}\n    }\n\n    /**\n     * Pauses the critical section so that operations made during the pause\n     * do not count into the response time. If Timing.AUTO is used, the pause\n     * ends automatically when the next request is sent to the server. For\n     * manual timing, the next call to recordTime ends the pause. Calls\n     * pauseTime when the critical section is already paused are simply ignored. \n     */\n\tpublic void pauseTime() {\n        if (agentThread.currentOperation == -1)\n            throw new IllegalStateException(\"DriverContext.pauseTime called \" +\n                                            \"outside an operation\");\n        if (agentThread.driverConfig.operations[agentThread.currentOperation].\n                timing != Timing.MANUAL) {\n            String msg = \"Driver: \" + getDriverName() + \", Operation: \" +\n                    getCurrentOperation() + \", timing: MANUAL illegal call \" +\n                    \"to pauseTime() in driver code.\";\n            logger.severe(msg);\n            IllegalStateException e = new IllegalStateException(msg);\n            logger.throwing(className, \"recordTime\", e);\n            throw e;\n        }\n        if (timingInfo.lastRespondTime == TIME_NOT_SET) {\n            timingInfo.lastRespondTime = System.nanoTime();\n\t\t}\n    }\n\n    /**\n     * Obtains a relative time, in milliseconds. This time is relative to\n     * a certain time at the beginning of the benchmark run and does not\n     * represent a wall clock time. All agents will have the same reference\n     * time. Use this time to check time durations during the benchmark run.\n     *\n     * @return The relative time of the benchmark run\n     */\n\tpublic int getTime() {\n        return timer.getTime();\n    }\n\n    /**\n     * Wakes up closest to a system nanosec time.\n     * @param time The time to wake up\n     */\n    public void wakeupAt(long time) {\n        timer.wakeupAt(time);\n    }\n\n    /**\n     * Obtains the relative time - in milliseconds - that steady state starts,\n     * if set. The if the time is not yet set, it will return 0.\n     *\n     * @return The relative time steady state starts\n     */\n\tpublic int getSteadyStateStart() {\n        return (int) (timer.toRelTime(agentThread.endRampUp) / 1000000l);\n    }\n\n    /**\n     * Obtains a relative time, in nanosecs. This time is relative to\n     * a certain time at the beginning of the benchmark run and does not\n     * represent a wall clock time. All agents will have the same reference\n     * time. Use this time to check time durations during the benchmark run.\n     *\n     * @return The relative time of the benchmark run\n     */\n    public long getNanoTime() {\n       return timer.toRelTime(System.nanoTime());\n    }\n\n    /**\n     * Obtains the relative time - in nanosecs - that steady state starts,\n     * if set. The if the time is not yet set, it will return 0.\n     *\n     * @return The relative time steady state starts\n     */\n    public long getSteadyStateStartNanos() {\n        return timer.toRelTime(agentThread.endRampUp);\n    }\n\n    /**\n     * Obtains the configured ramp up time.\n     *\n     * @return The configured ramp up time, in seconds\n     */\n\tpublic int getRampUp() {\n        return agentThread.runInfo.rampUp;\n    }\n\n    /**\n     * Obtains the configured steady state time.\n     *\n     * @return The configured steady state time, in seconds\n     */\n\tpublic int getSteadyState() {\n        return agentThread.runInfo.stdyState;\n    }\n\n    /**\n     * Obtains the configured ramp down time.\n     *\n     * @return The configured ramp down time, in seconds\n     */\n\tpublic int getRampDown() {\n        return agentThread.runInfo.rampDown;\n    }\n\n    /**\n     * Property whether pause is supported with the current protocol.\n     * Default is true. Protocols that may not be request/response but\n     * may have concurrent inbound and outbound traffic, AND wishes to\n     * support auto timing should set this flag to false. The default is true.\n     *\n     * @return The current setting of the pauseSupported property.\n     */\n    public boolean isPauseSupported() {\n        return pauseSupported;\n    }\n\n    /**\n     * Property whether pause is supported with the current protocol.\n     * Default is true. Protocols that may not be request/response but\n     * may have concurrent inbound and outbound traffic, AND wishes to\n     * support auto timing should set this flag to false. The default is true.\n     *\n     * @param pause The new setting of the pauseSupported property.\n     */\n    public void setPauseSupported(boolean pause) {\n        pauseSupported = pause;\n    }\n\n    /**\n     * Records the start time of an operation. This method is not\n     * exposed through the interface and is only used by the transport\n     * facilities.\n     * @return The recorded time - system nanotime, or TIME_NOT_SET if not set\n     */\n    public long recordStartTime() {\n        // Not in an operation, don't record time.\n        if (agentThread.currentOperation == -1)\n            return TIME_NOT_SET;\n        if (timingInfo != null && agentThread.driverConfig.operations[\n                agentThread.currentOperation].timing == Timing.AUTO) {\n            if (timingInfo.invokeTime == TIME_NOT_SET) {\n                if (timingInfo.respondTime != TIME_NOT_SET)\n                    logger.warning(\"Respond time already set before \" +\n                                   \"sleeping. Please report a bug.\");\n                timer.wakeupAt(timingInfo.intendedInvokeTime);\n                // But since sleep may not be exact, we get the time again here.\n                timingInfo.invokeTime = System.nanoTime();\n                return timingInfo.invokeTime;\n            } else if (pauseSupported && timingInfo.respondTime != TIME_NOT_SET) {\n                if (timingInfo.respondTime < timingInfo.invokeTime)\n                    logger.warning(\"Respond time (\" + timingInfo.respondTime +\n                            \") less than invoke time (\" +\n                            timingInfo.invokeTime + \"). Please report a bug.\");\n\n                // Some response already read, then transmit again.\n                // In this case the time from last receive to this transmit\n                // is the pause time ...\n                timingInfo.lastRespondTime = timingInfo.respondTime;\n\n                // We set the pause time only on the first byte transmitted.\n                timingInfo.respondTime = TIME_NOT_SET;\n\n                long time = System.nanoTime();\n                timingInfo.pauseTime += time - timingInfo.lastRespondTime;\n                return time;\n            }\n            // Otherwise this can be a subsequent write.\n            // Invoke time already set and respond time not set.\n        }\n        return TIME_NOT_SET;\n    }\n\n    /**\n     * Records the end time of an operation. This method is not\n     * exposed through the interface and is only used by the transport\n     * facilities.\n     * @return The recorded time - system nanotime, or TIME_NOT_SET if not set\n     */\n    public long recordEndTime() {\n        long tstamp = TIME_NOT_SET;\n        // Not in an operation, don't record time.\n        if (agentThread.currentOperation != -1) {\n            if (timingInfo != null && agentThread.driverConfig.operations[\n                    agentThread.currentOperation].timing == Timing.AUTO ) {\n                // Some stacks clear the connection by doing a read before a\n                // write in a request, normally a read of 0 bytes. We need to\n                // make sure such reads are not part of the response time.\n                if (timingInfo.invokeTime == TIME_NOT_SET) {\n                    int[] previousOps = agentThread.previousOperation;\n                    String name = agentThread.driverConfig.mix[0].\n                            operations[previousOps[0]].name;\n                    if (previousOps.length > 1)\n                        name += ',' + agentThread.driverConfig.mix[1].\n                                operations[previousOps[1]].name;\n                    logger.warning(\"Read before write! Some input may still \" +\n                            \"be in the buffer from previous operation \" +\n                            name + \". Ignoring such input.\");\n                } else {\n                    timingInfo.respondTime = tstamp = System.nanoTime();\n                }\n            }\n        }\n        return tstamp;\n    }\n\n    /**\n     * Sets the intended invocation time for the next invocation\n     * on this thread. This is called from AgentThread only.\n     * @param time The time to invoke\n     */\n    void setInvokeTime(long time) {\n\n        // Then set the intended start time.\n        timingInfo.intendedInvokeTime = time;\n        // And set the other times to invalid.\n        timingInfo.invokeTime = TIME_NOT_SET;\n        timingInfo.respondTime = TIME_NOT_SET;\n        timingInfo.lastRespondTime = TIME_NOT_SET;\n        timingInfo.pauseTime = 0l;\n    }\n\n    /**\n     * TimingInfo is a value object that contains individual\n     * timing records for each operation.\n     */\n    public static class TimingInfo {\n\n    \t/** Intended Invoke Time. */\n        public long intendedInvokeTime = TIME_NOT_SET;\n\n        /** Actual Invoke Time. */\n        public long invokeTime = TIME_NOT_SET;\n\n        /** Respond Time. */\n        public long respondTime = TIME_NOT_SET;\n\n        /** Last respond time, if any. */\n        public long lastRespondTime = TIME_NOT_SET;\n\n        /** Pause Time. */\n        public long pauseTime = 0l;\n    }\n\n    /**\n     * Obtains the base directory where the benchmark currently being run\n     * is installed.\n     *\n     * @return The benchmark's base directory\n     */\n    public String getBaseDir() {\n        return agentThread.agent.driverBase;\n    }\n\n    /**\n     * Obtains the resource directory used for this benchmark, if exists.\n     * @return The resource directory for this benchmark\n     */\n    public String getResourceDir() {\n        return agentThread.agent.driverBase + File.separator + \"resources\";\n    }\n\n    /**\n     * Set the desired upload speed for the thread using this context.\n     * This method is intended for use only by transport classes; drivers\n     * should call an apporpriate method on the transport to set this\n     * value. Note that not all transports support bandwidth throttling\n     * (so drivers that do call this method will have no idea if the value\n     * is used or not).\n     *\n     * @param kbps desired speed in kilobytes per second. If kbps is < 0,\n     * speed will be unlimited.\n     */\n    public void setUploadSpeed(int kbps) {\n        this.kbpsUpload = kbps;\n    }\n\n    /**\n     * Return the desired upload speed for the thread using this context.\n     *\n     * @return desired speed in kilobytes per second\n     */\n    public int getUploadSpeed() {\n        return kbpsUpload;\n    }\n\n    /**\n     * Set the desired downoad speed for the thread using this context.\n     * This method is intended for use only by transport classes; drivers\n     * should call an apporpriate method on the transport to set this\n     * value. Note that not all transports support bandwidth throttling\n     * (so drivers that do call this method will have no idea if the value\n     * is used or not).\n     *\n     * @param kbps desired speed in kilobytes per second. If kbps is < 0,\n     * speed will be unlimited.\n     */\n    public void setDownloadSpeed(int kbps) {\n        this.kbpsDownload = kbps;\n    }\n\n    /**\n     * Return the desired download speed for the thread using this context.\n     *\n     * @return desired speed in kilobytes per second\n     */\n    public int getDownloadSpeed() {\n        return kbpsDownload;\n    }\n}\n","lineNo":616}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\npackage com.sun.faban.driver.transport.util;\n\nimport com.sun.faban.driver.engine.DriverContext;\nimport com.sun.faban.driver.transport.util.Throttle.Direction;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\n\n/**\n * A pass-through input stream that records the time of the input.\n * Note that the client-side time recording for reads is\n * always after the read happens.\n *\n * @author Akara Sucharitakul\n */\npublic class TimedInputStream extends FilterInputStream {\n\n    DriverContext ctx;\n    private Throttle throttle;\n\n    /**\n     * Creates a <code>FilterInputStream<\/code>\n     * by assigning the  argument <code>in<\/code>\n     * to the field <code>this.in<\/code> so as\n     * to remember it for later use.\n     *\n     * @param in the underlying input stream, or <code>null<\/code> if\n     *           this instance is to be created without an underlying stream.\n     */\n    public TimedInputStream(InputStream in) {\n        super(in);\n        ctx = DriverContext.getContext();\n        throttle = new Throttle(ctx);\n    }\n\n    /**\n     * Reads the next byte of data from this input stream. The value\n     * byte is returned as an <code>int<\/code> in the range\n     * <code>0<\/code> to <code>255<\/code>. If no byte is available\n     * because the end of the stream has been reached, the value\n     * <code>-1<\/code> is returned. This method blocks until input data\n     * is available, the end of the stream is detected, or an exception\n     * is thrown.\n     * <p/>\n     * This method\n     * simply performs <code>in.read()<\/code> and returns the result.\n     *\n     * @return the next byte of data, or <code>-1<\/code> if the end of the\n     *         stream is reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read() throws IOException {\n        long startReadAt = 0L;\n\t\tif (throttle.isThrottled(Direction.DOWN))\n\t    \tstartReadAt = ctx.getNanoTime();\n\n        int b = super.read();\n        if (ctx != null && b != -1) {\n            ctx.recordEndTime();\n\t\t\tif (throttle.isThrottled(Direction.DOWN))\n\t    \t\tthrottle.throttle(1, ctx.getNanoTime() - startReadAt,\n                                    Direction.DOWN);\n        }\n        return b;\n    }\n\n    /**\n     * Reads up to <code>byte.length<\/code> bytes of data from this\n     * input stream into an array of bytes. This method blocks until some\n     * input is available.\n     * <p/>\n     * This method simply performs the call\n     * <code>read(b, 0, b.length)<\/code> and returns\n     * the  result. It is important that it does\n     * <i>not<\/i> do <code>in.read(b)<\/code> instead;\n     * certain subclasses of  <code>FilterInputStream<\/code>\n     * depend on the implementation strategy actually\n     * used.\n     *\n     * @param b the buffer into which the data is read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#read(byte[], int, int)\n     */\n    @Override\n\tpublic int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n\n    }\n\n    /**\n     * Reads up to <code>len<\/code> bytes of data from this input stream\n     * into an array of bytes. This method blocks until some input is\n     * available.\n     * <p/>\n     * This method simply performs <code>in.read(b, off, len)<\/code>\n     * and returns the result.\n     *\n     * @param b   the buffer into which the data is read.\n     * @param off the start offset of the data.\n     * @param len the maximum number of bytes read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read(byte b[], int off, int len) throws IOException {\n        \t\tlong startReadAt = 0L;\n        \t\tif (throttle.isThrottled(Direction.DOWN))\n        \t    \tstartReadAt = ctx.getNanoTime();\n\n        int bytes = super.read(b, off, len);\n        if (ctx != null && bytes > 0) {\n            ctx.recordEndTime();\n\t    \tif (throttle.isThrottled(Direction.DOWN))\n\t\t\t\tthrottle.throttle(bytes, ctx.getNanoTime() - startReadAt,\n                                    Direction.DOWN);\n        }\n        return bytes;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\npackage com.sun.faban.driver.transport.util;\n\nimport com.sun.faban.driver.engine.DriverContext;\nimport com.sun.faban.driver.transport.util.Throttle.Direction;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\n\n/**\n * A pass-through input stream that records the time of the input.\n * Note that the client-side time recording for reads is\n * always after the read happens.\n *\n * @author Akara Sucharitakul\n */\npublic class TimedInputStream extends FilterInputStream {\n\n    DriverContext ctx;\n    private Throttle throttle;\n\n    /**\n     * Creates a <code>FilterInputStream<\/code>\n     * by assigning the  argument <code>in<\/code>\n     * to the field <code>this.in<\/code> so as\n     * to remember it for later use.\n     *\n     * @param in the underlying input stream, or <code>null<\/code> if\n     *           this instance is to be created without an underlying stream.\n     */\n    public TimedInputStream(InputStream in) {\n        super(in);\n        ctx = DriverContext.getContext();\n        if (ctx != null)\n            throttle = new Throttle(ctx);\n    }\n\n    /**\n     * Reads the next byte of data from this input stream. The value\n     * byte is returned as an <code>int<\/code> in the range\n     * <code>0<\/code> to <code>255<\/code>. If no byte is available\n     * because the end of the stream has been reached, the value\n     * <code>-1<\/code> is returned. This method blocks until input data\n     * is available, the end of the stream is detected, or an exception\n     * is thrown.\n     * <p/>\n     * This method\n     * simply performs <code>in.read()<\/code> and returns the result.\n     *\n     * @return the next byte of data, or <code>-1<\/code> if the end of the\n     *         stream is reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read() throws IOException {\n        long startReadAt = 0L;\n        boolean isThrottled = false;\n        if (ctx != null) {\n            isThrottled = throttle.isThrottled(Direction.DOWN);\n            if (isThrottled)\n\t    \t    startReadAt = ctx.getNanoTime();\n        }\n        int b = super.read();\n        if (ctx != null && b != -1) {\n            ctx.recordEndTime();\n\t\t\tif (isThrottled)\n\t    \t\tthrottle.throttle(1, startReadAt, Direction.DOWN);\n        }\n        return b;\n    }\n\n    /**\n     * Reads up to <code>byte.length<\/code> bytes of data from this\n     * input stream into an array of bytes. This method blocks until some\n     * input is available.\n     * <p/>\n     * This method simply performs the call\n     * <code>read(b, 0, b.length)<\/code> and returns\n     * the  result. It is important that it does\n     * <i>not<\/i> do <code>in.read(b)<\/code> instead;\n     * certain subclasses of  <code>FilterInputStream<\/code>\n     * depend on the implementation strategy actually\n     * used.\n     *\n     * @param b the buffer into which the data is read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#read(byte[], int, int)\n     */\n    @Override\n\tpublic int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n\n    }\n\n    /**\n     * Reads up to <code>len<\/code> bytes of data from this input stream\n     * into an array of bytes. This method blocks until some input is\n     * available.\n     * <p/>\n     * This method simply performs <code>in.read(b, off, len)<\/code>\n     * and returns the result.\n     *\n     * @param b   the buffer into which the data is read.\n     * @param off the start offset of the data.\n     * @param len the maximum number of bytes read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read(byte b[], int off, int len) throws IOException {\n        long startReadAt = 0L;\n        boolean isThrottled = false;\n        if (ctx != null) {\n            isThrottled = throttle.isThrottled(Direction.DOWN);\n            if (isThrottled)\n                startReadAt = ctx.getNanoTime();\n        }\n        int bytes = super.read(b, off, len);\n        if (ctx != null && bytes > 0) {\n            ctx.recordEndTime();\n            if (isThrottled)\n                throttle.throttle(bytes, startReadAt, Direction.DOWN);\n        }\n        return bytes;\n    }\n}\n","lineNo":105}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\npackage com.sun.faban.driver.transport.util;\n\nimport com.sun.faban.driver.engine.DriverContext;\nimport com.sun.faban.driver.transport.util.Throttle.Direction;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\n\n/**\n * A pass-through input stream that records the time of the input.\n * Note that the client-side time recording for reads is\n * always after the read happens.\n *\n * @author Akara Sucharitakul\n */\npublic class TimedInputStream extends FilterInputStream {\n\n    DriverContext ctx;\n    private Throttle throttle;\n\n    /**\n     * Creates a <code>FilterInputStream<\/code>\n     * by assigning the  argument <code>in<\/code>\n     * to the field <code>this.in<\/code> so as\n     * to remember it for later use.\n     *\n     * @param in the underlying input stream, or <code>null<\/code> if\n     *           this instance is to be created without an underlying stream.\n     */\n    public TimedInputStream(InputStream in) {\n        super(in);\n        ctx = DriverContext.getContext();\n        throttle = new Throttle(ctx);\n    }\n\n    /**\n     * Reads the next byte of data from this input stream. The value\n     * byte is returned as an <code>int<\/code> in the range\n     * <code>0<\/code> to <code>255<\/code>. If no byte is available\n     * because the end of the stream has been reached, the value\n     * <code>-1<\/code> is returned. This method blocks until input data\n     * is available, the end of the stream is detected, or an exception\n     * is thrown.\n     * <p/>\n     * This method\n     * simply performs <code>in.read()<\/code> and returns the result.\n     *\n     * @return the next byte of data, or <code>-1<\/code> if the end of the\n     *         stream is reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read() throws IOException {\n        long startReadAt = 0L;\n\t\tif (throttle.isThrottled(Direction.DOWN))\n\t    \tstartReadAt = ctx.getNanoTime();\n\n        int b = super.read();\n        if (ctx != null && b != -1) {\n            ctx.recordEndTime();\n\t\t\tif (throttle.isThrottled(Direction.DOWN))\n\t    \t\tthrottle.throttle(1, ctx.getNanoTime() - startReadAt,\n                                    Direction.DOWN);\n        }\n        return b;\n    }\n\n    /**\n     * Reads up to <code>byte.length<\/code> bytes of data from this\n     * input stream into an array of bytes. This method blocks until some\n     * input is available.\n     * <p/>\n     * This method simply performs the call\n     * <code>read(b, 0, b.length)<\/code> and returns\n     * the  result. It is important that it does\n     * <i>not<\/i> do <code>in.read(b)<\/code> instead;\n     * certain subclasses of  <code>FilterInputStream<\/code>\n     * depend on the implementation strategy actually\n     * used.\n     *\n     * @param b the buffer into which the data is read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#read(byte[], int, int)\n     */\n    @Override\n\tpublic int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n\n    }\n\n    /**\n     * Reads up to <code>len<\/code> bytes of data from this input stream\n     * into an array of bytes. This method blocks until some input is\n     * available.\n     * <p/>\n     * This method simply performs <code>in.read(b, off, len)<\/code>\n     * and returns the result.\n     *\n     * @param b   the buffer into which the data is read.\n     * @param off the start offset of the data.\n     * @param len the maximum number of bytes read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read(byte b[], int off, int len) throws IOException {\n        \t\tlong startReadAt = 0L;\n        \t\tif (throttle.isThrottled(Direction.DOWN))\n        \t    \tstartReadAt = ctx.getNanoTime();\n\n        int bytes = super.read(b, off, len);\n        if (ctx != null && bytes > 0) {\n            ctx.recordEndTime();\n\t    \tif (throttle.isThrottled(Direction.DOWN))\n\t\t\t\tthrottle.throttle(bytes, ctx.getNanoTime() - startReadAt,\n                                    Direction.DOWN);\n        }\n        return bytes;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\npackage com.sun.faban.driver.transport.util;\n\nimport com.sun.faban.driver.engine.DriverContext;\nimport com.sun.faban.driver.transport.util.Throttle.Direction;\n\nimport java.io.FilterInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2010 Sun Microsystems Inc. All Rights Reserved\n */\n\n\n/**\n * A pass-through input stream that records the time of the input.\n * Note that the client-side time recording for reads is\n * always after the read happens.\n *\n * @author Akara Sucharitakul\n */\npublic class TimedInputStream extends FilterInputStream {\n\n    DriverContext ctx;\n    private Throttle throttle;\n\n    /**\n     * Creates a <code>FilterInputStream<\/code>\n     * by assigning the  argument <code>in<\/code>\n     * to the field <code>this.in<\/code> so as\n     * to remember it for later use.\n     *\n     * @param in the underlying input stream, or <code>null<\/code> if\n     *           this instance is to be created without an underlying stream.\n     */\n    public TimedInputStream(InputStream in) {\n        super(in);\n        ctx = DriverContext.getContext();\n        if (ctx != null)\n            throttle = new Throttle(ctx);\n    }\n\n    /**\n     * Reads the next byte of data from this input stream. The value\n     * byte is returned as an <code>int<\/code> in the range\n     * <code>0<\/code> to <code>255<\/code>. If no byte is available\n     * because the end of the stream has been reached, the value\n     * <code>-1<\/code> is returned. This method blocks until input data\n     * is available, the end of the stream is detected, or an exception\n     * is thrown.\n     * <p/>\n     * This method\n     * simply performs <code>in.read()<\/code> and returns the result.\n     *\n     * @return the next byte of data, or <code>-1<\/code> if the end of the\n     *         stream is reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read() throws IOException {\n        long startReadAt = 0L;\n        boolean isThrottled = false;\n        if (ctx != null) {\n            isThrottled = throttle.isThrottled(Direction.DOWN);\n            if (isThrottled)\n\t    \t    startReadAt = ctx.getNanoTime();\n        }\n        int b = super.read();\n        if (ctx != null && b != -1) {\n            ctx.recordEndTime();\n\t\t\tif (isThrottled)\n\t    \t\tthrottle.throttle(1, startReadAt, Direction.DOWN);\n        }\n        return b;\n    }\n\n    /**\n     * Reads up to <code>byte.length<\/code> bytes of data from this\n     * input stream into an array of bytes. This method blocks until some\n     * input is available.\n     * <p/>\n     * This method simply performs the call\n     * <code>read(b, 0, b.length)<\/code> and returns\n     * the  result. It is important that it does\n     * <i>not<\/i> do <code>in.read(b)<\/code> instead;\n     * certain subclasses of  <code>FilterInputStream<\/code>\n     * depend on the implementation strategy actually\n     * used.\n     *\n     * @param b the buffer into which the data is read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#read(byte[], int, int)\n     */\n    @Override\n\tpublic int read(byte b[]) throws IOException {\n        return read(b, 0, b.length);\n\n    }\n\n    /**\n     * Reads up to <code>len<\/code> bytes of data from this input stream\n     * into an array of bytes. This method blocks until some input is\n     * available.\n     * <p/>\n     * This method simply performs <code>in.read(b, off, len)<\/code>\n     * and returns the result.\n     *\n     * @param b   the buffer into which the data is read.\n     * @param off the start offset of the data.\n     * @param len the maximum number of bytes read.\n     * @return the total number of bytes read into the buffer, or\n     *         <code>-1<\/code> if there is no more data because the end of\n     *         the stream has been reached.\n     * @throws java.io.IOException if an I/O error occurs.\n     * @see java.io.FilterInputStream#in\n     */\n    @Override\n\tpublic int read(byte b[], int off, int len) throws IOException {\n        long startReadAt = 0L;\n        boolean isThrottled = false;\n        if (ctx != null) {\n            isThrottled = throttle.isThrottled(Direction.DOWN);\n            if (isThrottled)\n                startReadAt = ctx.getNanoTime();\n        }\n        int bytes = super.read(b, off, len);\n        if (ctx != null && bytes > 0) {\n            ctx.recordEndTime();\n            if (isThrottled)\n                throttle.throttle(bytes, startReadAt, Direction.DOWN);\n        }\n        return bytes;\n    }\n}\n","lineNo":166}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.common.NameValuePair;\nimport com.sun.faban.harness.util.XMLReader;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Collections;\n\n/**\n * The ParamRepository is the programmatic representation of the\n * configuration file. It allows access to the xml file via xpath.\n * In addition, the ParamRepository also allows updating the configuration\n * file. Such updates should be made during the validation stage.\n */\npublic class ParamRepository {\n\n\n    private XMLReader reader;\n    private List<HostConfig> hostConfigs;\n\n    /**\n     * Constructor: Open specified repository.\n     * @param file Name of repository\n     * @param warnDeprecated Log warning when config file is deprecated\n     */\n    public ParamRepository(String file, boolean warnDeprecated) {\n        reader = new XMLReader(file, true, warnDeprecated);\n        reader.processHostPorts(); //Pre-scan the hosts:ports fields\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return value of the parameter of type string\n     */\n    public String getParameter(String xpath) {\n        return reader.getValue(xpath);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath string\n     * @param top element\n     * @return value of the parameter\n     */\n    public String getParameter(String xpath, Element top) {\n        return reader.getValue(xpath, top);\n    }\n\n    /**\n     * Generic method to get NodeList for a given tagName.\n     * @param tagName of type string\n     * @return NodeList for the tagName\n     */\n    public NodeList getNodeListForTagName(String tagName){\n        return reader.getNodeListForTagName(tagName);\n    }\n\n    /**\n     * Generic method to get a list of top level nodes.\n     * @return NodeList\n     */\n    public NodeList getTopLevelElements() {\n        NodeList topLevelElements = reader.getTopLevelElements();\n        return topLevelElements;\n    }\n\n     /**\n     * Generic method to get NodeList for a given xpath.\n     * @param xPath string\n     * @return NodeList for the xpath\n     */\n    public NodeList getNodes(String xPath) {\n        return reader.getNodes(xPath);\n    }\n\n    /**\n     * Generic method to get NodeList for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return NodeList\n     */\n    public NodeList getNodes(String xPath, Element top) {\n        return reader.getNodes(xPath, top);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath.\n     * @param xPath string\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath) {\n        return reader.getNode(xPath);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath, Element top) {\n        return reader.getNode(xPath, top);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String paramName) {\n        return reader.addNode(baseXPath, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(baseXPath, namespace, prefix, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String paramName) {\n        return reader.addNode(parent, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(parent, namespace, prefix, paramName);\n    }\n\n    /**\n     * Sets or replaces the parameter referenced by the XPath.\n     * @param xpath The xpath referencing the parameter\n     * @param newValue The new value to set\n     */\n    public void setParameter(String xpath, String newValue) {\n        reader.setValue(xpath, newValue);\n    }\n\n    /**\n     * Sets the parameter for a newly added DOM element.\n     * @param element The newly added element\n     * @param value The value to assign to the element\n     */\n    public void setParameter(Element element, String value) {\n        reader.setValue(element, value);\n    }\n\n    /**\n     * Saves the parameter repository back to file if it has been modified.\n     *\n     * @throws Exception If there is an exception saving the repository.\n     */\n    public void save() throws Exception {\n        reader.save(null);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return list containing all paramters with the xpath\n     */\n    public List<String> getParameters(String xpath) {\n        return reader.getValues(xpath);\n    }\n\n    /**\n     * Gets the attribute values for the specified attribute of a certain XPath.\n     *\n     * @param elementPath The XPath of the element\n     * @param attributeName The name of the attribute\n     * @return A list of attribute values\n     */\n    public List<String> getAttributeValues(String elementPath, String attributeName) {\n        return reader.getAttributeValues(elementPath, attributeName);\n    }\n\n    /**\n     * HostConfig structure holding a hostConfig element from the config file.\n     */\n    public static class HostConfig {\n        public String[] hosts;\n        public int[] numCpus;\n        public String tools;\n        public String userCommands;\n    }\n\n    private void readHostConfigs() throws ConfigurationException {\n        ArrayList<HostConfig> hostConfigs = new ArrayList<HostConfig>();\n        NodeList topLevelElements = getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n\n            if(\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            HostConfig hostConfig = new HostConfig();\n            hostConfig.hosts = hosts;\n            String[] vals = getTokenizedValue(\"fa:hostConfig/fh:cpus\", ti);\n            if (vals != null) {\n                hostConfig.numCpus = new int[vals.length];\n                for (int j = 0; j < vals.length; j++) {\n                    try {\n                        hostConfig.numCpus[j] = Integer.parseInt(vals[j]);\n                    } catch (NumberFormatException e) {\n                        throw new ConfigurationException(\n                                \"fa:hostConfig/fh:cpus under \" +\n                                node.getNodeName() +\n                                \" has a non-integer value: \" + vals[j] + '.',\n                                e);\n                    }\n                }\n            }\n\n            hostConfig.tools = getParameter(\"fa:hostConfig/fh:tools\", ti);\n            if (hostConfig.tools != null)\n                hostConfig.tools = hostConfig.tools.trim();\n            if (hostConfig.tools.length() == 0)\n                hostConfig.tools = null;\n\n            hostConfig.userCommands =\n                    getParameter(\"fa:hostConfig/fh:userCommands\", ti);\n            if (hostConfig.userCommands != null)\n                hostConfig.userCommands = hostConfig.userCommands.trim();\n            if (hostConfig.userCommands.length() == 0)\n                hostConfig.userCommands = null;\n\n            hostConfigs.add(hostConfig);\n        }\n        this.hostConfigs = Collections.unmodifiableList(hostConfigs);\n    }\n\n    /**\n     * Obtains the list of enabled host configurations.\n     * @return A list of enabled hosts configurations\n     * @throws ConfigurationException Error reading the configuration\n     */\n    public List<HostConfig> getHostConfigs() throws ConfigurationException {\n        if (hostConfigs == null)\n            readHostConfigs();\n        return hostConfigs;\n    }\n\n    /**\n     * Obtains the list of enabled hosts.\n     * @param base element\n     * @return A list of enabled hosts, grouped by host type.\n     * @throws ConfigurationException\n     */\n    public String[] getEnabledHosts(Element base) throws ConfigurationException {\n        String[] enabledHosts;\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base, true))\n            enabledHosts = getTokenizedValue(\"fa:hostConfig/fa:host\", base);\n        else\n            enabledHosts = new String[0];\n       return enabledHosts;\n    }\n\n    /**\n     * Obtains the list of enabled hostports.\n     * @param base element\n     * @return A list of enabled hostports.\n     * @throws ConfigurationException\n     */\n    public List<NameValuePair<Integer>> getEnabledHostPorts(Element base)\n            throws ConfigurationException {\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base))\n            return getHostPorts(base);\n        else\n            return null;\n    }\n\n    /**\n     * This returns tokenized values of parameters in a list.\n     * Mainly used to get host(s)\n     * @param xpath The xpath to the parameters\n     * @return List of tokenized values\n     */\n    public List<String[]> getTokenizedParameters(String xpath) {\n        ArrayList<String[]> params = new ArrayList<String[]>();\n        List<String> entries = reader.getValues(xpath);\n        for (String entry : entries) {\n            StringTokenizer st = new StringTokenizer(entry);\n            String[] values = new String[st.countTokens()];\n            for (int i = 0; st.hasMoreTokens(); i++)\n                values[i] = st.nextToken();\n            params.add(values);\n        }\n        return params;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath) {\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array, from a specific\n     * base node in the document.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @param base The base element.\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath, Element base) {\n        String value = reader.getValue(xpath, base);\n        if (value == null)\n            return null;\n        value = value.trim();\n        if (value.length() == 0)\n            return null;\n        StringTokenizer st = new StringTokenizer(value);\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains xpath values matching an xpath, broken into tokens.\n     * @param xpath XPath expression to get  ',' and SPACE seperated \n     * values from a single parameter. For Example sutConfig/instances\n     * The values are seperated by ',' and then by SPACE\n     * @return List of arrays of hostnames\n     */\n    public List<String[]> getTokenizedList(String xpath) {\n        // Each value should be passed as , and SPACE seperated strings\n        ArrayList<String[]> list = new ArrayList<String[]>();\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        while (st.hasMoreTokens()) {\n            ArrayList<String> l = new ArrayList<String>();\n            StringTokenizer st2 = new  StringTokenizer(st.nextToken(), \",\");\n            while (st2.hasMoreTokens())\n                l.add(st2.nextToken());\n\n            list.add(l.toArray(new String[1]));\n        }\n        return list;\n    }\n\n    /**\n     * Obtains the host:port name value pair list from the element\n     * matching this XPath.\n     * @param xPathExpr\n     * @return The list of host:port elements, or null if the XPath does\n     * not exist or does not point to a host:port node.\n     */\n    public List<NameValuePair<Integer>> getHostPorts(String xPathExpr) {\n        return reader.getHostPorts(xPathExpr);\n    }\n\n    /**\n     * Obtains the host:port pairs at this element.\n     * @param base The base element\n     * @return The list of host:port pairs\n     */\n    public List<NameValuePair<Integer>> getHostPorts(Element base) {\n        return reader.getHostPorts(base);\n    }\n\n    /**\n     * Obtains the host/role mappings.\n     * @return The host/role mappings\n     * @throws ConfigurationException Invalid host/role mapping\n     */\n    public List<NameValuePair<String>> getHostRoles()\n            throws ConfigurationException {\n\n        ArrayList<NameValuePair<String>> hostTypeList =\n                new ArrayList<NameValuePair<String>>();\n        NodeList topLevelElements = getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n            if (\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            // Get the type of that host. This is the top level element name.\n            String type = ti.getNodeName();\n\n            // Then add the host and type pair to the list.\n            for (String host : hosts) {\n                NameValuePair<String> hostType = new NameValuePair<String>();\n                hostType.name = host;\n                hostType.value = type;\n                hostTypeList.add(hostType);\n            }\n        }\n        return hostTypeList;\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath) {\n        return  Boolean.valueOf(reader.getValue(xpath)).booleanValue();\n    }\n\n    /**\n     * Obtains the boolean value at the given xpath, providing a default\n     * value if it does not exist or is not a boolean.\n     * @param xpath The given xpath\n     * @param defaultValue The default value\n     * @return The boolean at the xpath, or the given default\n     */\n    public boolean getBooleanValue(String xpath, boolean defaultValue) {\n        String s = reader.getValue(xpath);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base) {\n        return  Boolean.valueOf(reader.getValue(xpath, base)).booleanValue();\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @param defaultValue\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base,\n                                   boolean defaultValue) {\n        String s = reader.getValue(xpath, base);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n}\n\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.common.NameValuePair;\nimport com.sun.faban.harness.util.XMLReader;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Collections;\n\n/**\n * The ParamRepository is the programmatic representation of the\n * configuration file. It allows access to the xml file via xpath.\n * In addition, the ParamRepository also allows updating the configuration\n * file. Such updates should be made during the validation stage.\n */\npublic class ParamRepository {\n\n\n    private XMLReader reader;\n    private List<HostConfig> hostConfigs;\n\n    /**\n     * Constructor: Open specified repository.\n     * @param file Name of repository\n     * @param warnDeprecated Log warning when config file is deprecated\n     */\n    public ParamRepository(String file, boolean warnDeprecated) {\n        reader = new XMLReader(file, true, warnDeprecated);\n        reader.processHostPorts(); //Pre-scan the hosts:ports fields\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return value of the parameter of type string\n     */\n    public String getParameter(String xpath) {\n        return reader.getValue(xpath);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath string\n     * @param top element\n     * @return value of the parameter\n     */\n    public String getParameter(String xpath, Element top) {\n        return reader.getValue(xpath, top);\n    }\n\n    /**\n     * Generic method to get NodeList for a given tagName.\n     * @param tagName of type string\n     * @return NodeList for the tagName\n     */\n    public NodeList getNodeListForTagName(String tagName){\n        return reader.getNodeListForTagName(tagName);\n    }\n\n    /**\n     * Generic method to get a list of top level nodes.\n     * @return NodeList\n     */\n    public NodeList getTopLevelElements() {\n        NodeList topLevelElements = reader.getTopLevelElements();\n        return topLevelElements;\n    }\n\n     /**\n     * Generic method to get NodeList for a given xpath.\n     * @param xPath string\n     * @return NodeList for the xpath\n     */\n    public NodeList getNodes(String xPath) {\n        return reader.getNodes(xPath);\n    }\n\n    /**\n     * Generic method to get NodeList for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return NodeList\n     */\n    public NodeList getNodes(String xPath, Element top) {\n        return reader.getNodes(xPath, top);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath.\n     * @param xPath string\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath) {\n        return reader.getNode(xPath);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath, Element top) {\n        return reader.getNode(xPath, top);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String paramName) {\n        return reader.addNode(baseXPath, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(baseXPath, namespace, prefix, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String paramName) {\n        return reader.addNode(parent, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(parent, namespace, prefix, paramName);\n    }\n\n    /**\n     * Sets or replaces the parameter referenced by the XPath.\n     * @param xpath The xpath referencing the parameter\n     * @param newValue The new value to set\n     */\n    public void setParameter(String xpath, String newValue) {\n        reader.setValue(xpath, newValue);\n    }\n\n    /**\n     * Sets the parameter for a newly added DOM element.\n     * @param element The newly added element\n     * @param value The value to assign to the element\n     */\n    public void setParameter(Element element, String value) {\n        reader.setValue(element, value);\n    }\n\n    /**\n     * Saves the parameter repository back to file if it has been modified.\n     *\n     * @throws Exception If there is an exception saving the repository.\n     */\n    public void save() throws Exception {\n        reader.save(null);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return list containing all paramters with the xpath\n     */\n    public List<String> getParameters(String xpath) {\n        return reader.getValues(xpath);\n    }\n\n    /**\n     * Gets the attribute values for the specified attribute of a certain XPath.\n     *\n     * @param elementPath The XPath of the element\n     * @param attributeName The name of the attribute\n     * @return A list of attribute values\n     */\n    public List<String> getAttributeValues(String elementPath, String attributeName) {\n        return reader.getAttributeValues(elementPath, attributeName);\n    }\n\n    /**\n     * HostConfig structure holding a hostConfig element from the config file.\n     */\n    public static class HostConfig {\n        public String[] hosts;\n        public int[] numCpus;\n        public String tools;\n        public String userCommands;\n    }\n\n    private void readHostConfigs() throws ConfigurationException {\n        ArrayList<HostConfig> hostConfigs = new ArrayList<HostConfig>();\n        NodeList topLevelElements = getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n\n            if(\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            HostConfig hostConfig = new HostConfig();\n            hostConfig.hosts = hosts;\n            String[] vals = getTokenizedValue(\"fa:hostConfig/fh:cpus\", ti);\n            if (vals != null) {\n                hostConfig.numCpus = new int[vals.length];\n                for (int j = 0; j < vals.length; j++) {\n                    try {\n                        hostConfig.numCpus[j] = Integer.parseInt(vals[j]);\n                    } catch (NumberFormatException e) {\n                        throw new ConfigurationException(\n                                \"fa:hostConfig/fh:cpus under \" +\n                                node.getNodeName() +\n                                \" has a non-integer value: \" + vals[j] + '.',\n                                e);\n                    }\n                }\n            }\n\n            hostConfig.tools = getParameter(\"fa:hostConfig/fh:tools\", ti);\n            if (hostConfig.tools != null)\n                hostConfig.tools = hostConfig.tools.trim();\n            if (hostConfig.tools.length() == 0)\n                hostConfig.tools = null;\n\n            hostConfig.userCommands =\n                    getParameter(\"fa:hostConfig/fh:userCommands\", ti);\n            if (hostConfig.userCommands != null)\n                hostConfig.userCommands = hostConfig.userCommands.trim();\n            if (hostConfig.userCommands.length() == 0)\n                hostConfig.userCommands = null;\n\n            hostConfigs.add(hostConfig);\n        }\n        this.hostConfigs = Collections.unmodifiableList(hostConfigs);\n    }\n\n    /**\n     * Obtains the list of enabled host configurations.\n     * @return A list of enabled hosts configurations\n     * @throws ConfigurationException Error reading the configuration\n     */\n    public List<HostConfig> getHostConfigs() throws ConfigurationException {\n        if (hostConfigs == null)\n            readHostConfigs();\n        return hostConfigs;\n    }\n\n    /**\n     * Obtains the list of enabled hosts.\n     * @param base element\n     * @return A list of enabled hosts, grouped by host type.\n     * @throws ConfigurationException\n     */\n    public String[] getEnabledHosts(Element base) throws ConfigurationException {\n        String[] enabledHosts;\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base, true))\n            enabledHosts = getTokenizedValue(\"fa:hostConfig/fa:host\", base);\n        else\n            enabledHosts = new String[0];\n       return enabledHosts;\n    }\n\n    /**\n     * Obtains the list of enabled hostports.\n     * @param base element\n     * @return A list of enabled hostports.\n     * @throws ConfigurationException\n     */\n    public List<NameValuePair<Integer>> getEnabledHostPorts(Element base)\n            throws ConfigurationException {\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base))\n            return getHostPorts(base);\n        else\n            return null;\n    }\n\n    /**\n     * This returns tokenized values of parameters in a list.\n     * Mainly used to get host(s)\n     * @param xpath The xpath to the parameters\n     * @return List of tokenized values\n     */\n    public List<String[]> getTokenizedParameters(String xpath) {\n        ArrayList<String[]> params = new ArrayList<String[]>();\n        List<String> entries = reader.getValues(xpath);\n        for (String entry : entries) {\n            StringTokenizer st = new StringTokenizer(entry);\n            String[] values = new String[st.countTokens()];\n            for (int i = 0; st.hasMoreTokens(); i++)\n                values[i] = st.nextToken();\n            params.add(values);\n        }\n        return params;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath) {\n        String val = reader.getValue(xpath);\n        String[] hosts = null;\n        if (val != null) {\n            val = val.trim();\n            if (val.length() > 0) {\n                StringTokenizer st = new StringTokenizer(val);\n                hosts = new String[st.countTokens()];\n                for (int i = 0; st.hasMoreTokens(); i++)\n                    hosts[i] = st.nextToken();\n            }\n        }\n\n        if (hosts == null)\n            hosts = new String[0];\n        return hosts;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array, from a specific\n     * base node in the document.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @param base The base element.\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath, Element base) {\n        String value = reader.getValue(xpath, base);\n        if (value == null)\n            return null;\n        value = value.trim();\n        if (value.length() == 0)\n            return null;\n        StringTokenizer st = new StringTokenizer(value);\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains xpath values matching an xpath, broken into tokens.\n     * @param xpath XPath expression to get  ',' and SPACE seperated \n     * values from a single parameter. For Example sutConfig/instances\n     * The values are seperated by ',' and then by SPACE\n     * @return List of arrays of hostnames\n     */\n    public List<String[]> getTokenizedList(String xpath) {\n        // Each value should be passed as , and SPACE seperated strings\n        ArrayList<String[]> list = new ArrayList<String[]>();\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        while (st.hasMoreTokens()) {\n            ArrayList<String> l = new ArrayList<String>();\n            StringTokenizer st2 = new  StringTokenizer(st.nextToken(), \",\");\n            while (st2.hasMoreTokens())\n                l.add(st2.nextToken());\n\n            list.add(l.toArray(new String[1]));\n        }\n        return list;\n    }\n\n    /**\n     * Obtains the host:port name value pair list from the element\n     * matching this XPath.\n     * @param xPathExpr\n     * @return The list of host:port elements, or null if the XPath does\n     * not exist or does not point to a host:port node.\n     */\n    public List<NameValuePair<Integer>> getHostPorts(String xPathExpr) {\n        return reader.getHostPorts(xPathExpr);\n    }\n\n    /**\n     * Obtains the host:port pairs at this element.\n     * @param base The base element\n     * @return The list of host:port pairs\n     */\n    public List<NameValuePair<Integer>> getHostPorts(Element base) {\n        return reader.getHostPorts(base);\n    }\n\n    /**\n     * Obtains the host/role mappings.\n     * @return The host/role mappings\n     * @throws ConfigurationException Invalid host/role mapping\n     */\n    public List<NameValuePair<String>> getHostRoles()\n            throws ConfigurationException {\n\n        ArrayList<NameValuePair<String>> hostTypeList =\n                new ArrayList<NameValuePair<String>>();\n        NodeList topLevelElements = getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n            if (\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            // Get the type of that host. This is the top level element name.\n            String type = ti.getNodeName();\n\n            // Then add the host and type pair to the list.\n            for (String host : hosts) {\n                NameValuePair<String> hostType = new NameValuePair<String>();\n                hostType.name = host;\n                hostType.value = type;\n                hostTypeList.add(hostType);\n            }\n        }\n        return hostTypeList;\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath) {\n        return  Boolean.valueOf(reader.getValue(xpath)).booleanValue();\n    }\n\n    /**\n     * Obtains the boolean value at the given xpath, providing a default\n     * value if it does not exist or is not a boolean.\n     * @param xpath The given xpath\n     * @param defaultValue The default value\n     * @return The boolean at the xpath, or the given default\n     */\n    public boolean getBooleanValue(String xpath, boolean defaultValue) {\n        String s = reader.getValue(xpath);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base) {\n        return  Boolean.valueOf(reader.getValue(xpath, base)).booleanValue();\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @param defaultValue\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base,\n                                   boolean defaultValue) {\n        String s = reader.getValue(xpath, base);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n}\n\n","lineNo":365}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.HostRoles;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    /** Sequential flag in FG mode. */\n    public static final int SEQUENTIAL = 1;\n\n    /** Parallel flag in FG mode. */\n    public static final int PARALLEL = 2;\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines. */\n    private ArrayList<String> machinesList = new ArrayList<String>();\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private List<String> jvmOptions;\n    private HashMap<String, List<String>> binMap =\n            new HashMap<String, List<String>>();\n    private Map<String, String> ifMap;\n    private List<String> rsh,  agent;\n    private HostRoles hostRoles;\n\n    CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n        cmds = this;\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        return cmds;\n    }\n\n    /**\n     * Obtains the name of the master machine.\n     * @return The master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines.\n     * This method can be called multiple times to initialize multiple\n     * classes of machines.\n     * @param benchName The name of the benchmark\n     * @param par The parameter repository\n     * @return true if successful, false if setup failed\n     */\n    public boolean setup(String benchName, ParamRepository par) {\n\n        String home = par.getParameter(\"fh:jvmConfig/fh:home\");\n\n        if (home != null)\n            home = home.trim();\n\n        if (home == null || home.length() == 0) {\n            home = Utilities.getJavaHome();\n            logger.config(\"JAVA_HOME set to \" + home);\n        }\n\n        if(!(new File(home)).isDirectory()) {\n            logger.severe(\"Cannot set JAVA_HOME. \" + home +\n                    \" is not a valid JAVA_HOME. Exiting\");\n            return false;\n        }\n\n        javaHome = home;\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        jvmOptions = new ArrayList<String>();\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                fs + \"faban.policy\");\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties\");\n        jvmOptions.add(\"-Dfaban.registry.port=\" + Config.RMI_PORT);\n        jvmOptions.add(\"-Dfaban.logging.port=\" + Config.LOGGING_PORT);\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if (!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                    log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))) {\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                        String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < libs.length; i++) {\n                if (libs[i].isFile()) {\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n                }\n            }\n            buf.setLength(buf.length() - 1);\n            if (buf.indexOf(\" \") != -1) {\n                buf.insert(0, '\"');\n                buf.append('\"');\n            }\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            List<String> cmd = new ArrayList<String>();\n            cmd.add(javaHome + File.separator + \"bin\" + File.separator +\n                    \"java\");\n            cmd.addAll(jvmOptions);\n            cmd.add(\"-Xms32m\");\n            cmd.add(\"-Xmx1024m\");\n            cmd.add(\"-cp\");\n            cmd.add(classpath);\n            cmd.add(\"com.sun.faban.common.RegistryImpl\");\n\n            logger.info(\"Starting Registry.\");\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        String jvmOpts =\n                par.getParameter(\"fh:jvmConfig/fh:jvmOptions\");\n\n        if (jvmOpts != null)\n            jvmOpts = jvmOpts.trim();\n\n        if((jvmOpts == null) || (jvmOpts.length() == 0))\n            jvmOpts = \"-XX:+DisableExplicitGC\";\n\n        jvmOptions.addAll(Command.parseArgs(jvmOpts));\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Unable to connect to Registry.\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        List<ParamRepository.HostConfig> hostConfigs = null;\n        try {\n            hostConfigs = par.getHostConfigs();\n        } catch (ConfigurationException e) {\n            logger.log(Level.SEVERE, \"Problem reading parameter file\", e);\n        }\n\n        outer:\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 || // localhost\n                            machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\", e);\n        }\n\n        if (rsh == null) {\n            rsh = new ArrayList<String>();\n            rsh.add(\"rsh\");\n        }\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master)) {\n                return false;\n            }\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if (\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if (machinesList.contains(machines[i])) {\n                    continue;\n                }\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0) {\n                    return false;\n                }\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress)) {\n                    return false;\n                }\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++) {\n            if (!getCmdAgent((String) machinesList.get(i))) {\n                return false;\n            }\n        }\n\n        if (par.getBooleanValue(\"fa:runConfig/fh:timeSync\", true)) {\n            setClocks();\n        }\n\n        return true;\n    }\n\n    void setHostRoles(HostRoles hr) {\n        hostRoles = hr;\n\n        // We need to populate the machinesList and cmdp with\n        // the real host names.\n\n        // First get the real names.\n        String[] realHosts = hostRoles.getHostsInOrder();\n        \n        // For each real host name not in machinesList, we take the first alias\n        // and look it up in the machinesList. Fetch the command agent and add\n        // the real name to the machinesList -> cmdp mapping.\n        for (String hostName : realHosts) {\n            if (!machinesList.contains(hostName)) {\n                String[] aliases = hostRoles.getAliasesByHost(hostName);\n                CmdAgent a = findCmdAgent(aliases[0]); // Just one is enough\n                machinesList.add(hostName);\n                cmdp.add(a);\n            }\n        }\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n            Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host : hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            } catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                        retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return (false);\n            }\n\n            cmdp.add(c);\n\n            /* Note the agent registration process:\n             * 1. Create and register the command agent.\n             * 2. Download benchmark code\n             * 3. Create the lib classpath\n             * 4. Create and register file agent\n             * So it may take quite some time between the registration of\n             * the command agent and the file agent. But we can be pretty\n             * sure it'll happen. So just wait. Timeout after 100 retries.             \n             */\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"FileService: Connecting to \" + s);\n            retry = 1;\n            FileAgent f = (FileAgent) registry.getService(s);\n            for (; f == null && retry <= 100; retry++) {\n                Thread.sleep(1000);\n                logger.fine(\"Retry obtaining file service from \" + s +\n                        \", count \" + retry + '.');\n                f = (FileAgent) registry.getService(s);\n            }\n            if (f == null) {\n                logger.severe(\"Timed out obtaining file service from \" + s);\n                return (false);\n            }\n            filep.add(f);\n\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" +\n                    c.getHostName());\n            return true;\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \" + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n     * We use a script 'cmd' which will setup the CLASSPATH before\n     * invoking CmdAgent\n     */\n    private boolean startCmdAgent(String benchName, String mach,\n            String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        List<String> cmd = new ArrayList<String>();\n\n        List<String> agentParams = new ArrayList<String>();\n        agentParams.add(mach);\n        agentParams.add(interfaceAddress);\n        agentParams.add(masterAddress);\n        agentParams.add(javaHome);\n        agentParams.addAll(jvmOptions);\n        agentParams.add(\"faban.benchmarkName=\" + benchName);\n        try {\n            if (mach.equals(master)) {\n                cmd.addAll(agent);\n                cmd.addAll(agentParams);\n                logger.fine(\"Executing \" + cmd);\n                Command cmdAgent = new Command(cmd);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams.add(\"faban.download=\" + downloadURL.toString());\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    ObjectOutputStream socketOut =\n                            new ObjectOutputStream(socket.getOutputStream());\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n\n                    ArrayList<String> agentExtParams = \n                            new ArrayList<String>(agentParams);\n                    agentExtParams.add(File.separator);\n                    agentExtParams.add(File.pathSeparator);\n                    socketOut.writeObject(agentExtParams);\n\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200:\n                            agentStarted = true;\n                            logger.fine(\"Found Agent(daemon)@\" + mach +\n                                    \". Registering agent.\");\n                            break;\n                        case 500:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response +\n                                    \" Please report the issue \" +\n                                    \"and provide logs from \" + mach +\n                                    \":FABAN_HOME/logs/agent.log\");\n                            break;\n                        case 409:\n                            logger.severe(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                            // We do not fall back in the conflict case.\n                            return false;\n                        default:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmd.clear();\n                    cmd.addAll(rsh);\n                    cmd.add(mach);\n                    cmd.addAll(agent);\n                    cmd.addAll(agentParams);\n                    Command cmdAgent = new Command(cmd);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<NameValuePair<Future<Boolean>>> tasks =\n                new ArrayList<NameValuePair<Future<Boolean>>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    NameValuePair<Future<Boolean>> future =\n                            new NameValuePair<Future<Boolean>>();\n                    future.name = hostName;\n                    future.value = Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat));\n                    tasks.add(future);\n                }\n            } catch (RemoteException e) {\n                logger.log(Level.WARNING,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n        for (NameValuePair<Future<Boolean>> future : tasks) {\n            try {\n                future.value.get(300, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                logger.log(Level.WARNING, \"Timed out setting clock for \" +\n                        future.name);\n            } catch (Throwable t) {\n                Throwable cause = t.getCause();\n                while (cause != null) {\n                    t = cause;\n                    cause = t.getCause();\n                }\n                logger.log(Level.WARNING, t.getMessage(), t);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws IOException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                    ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \" cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \" cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100) {\n                            ++nextSec; // If not, we go to the next sec.\n                        }\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                System.currentTimeMillis();\n                        if (sleepTime > 0) {\n                            Thread.sleep(sleepTime);\n                        }\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            if (wakeBefore > 700) {\n                                logger.warning(hostName + \" wakeup-before \" +\n                                        \"time reached 700ms limit. System is \" +\n                                        \"too busy. Giving up.\");\n                                return false;\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                        ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Obtains the cached HostType object. Note that this is not a public API.\n     * @return The cached HostType object;\n     */\n    public HostRoles getHostRoles() {\n        return hostRoles;\n    }\n\n    /**\n     * Returns the hostname of this machine as known to the machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     * @param machineName The target machine to check the host name\n     * @return The host name of the remote machine\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0) {\n            return machineName; // Cannot resolve\n        }\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        } catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                    re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Updates the paths in the local command agent.\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void updatePaths(List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(master).updatePaths(pathList);\n    }\n\n    /**\n     * Downloads files used by deploy images, especially services and tools.\n     * The pathList contains a list of resources in the form type/resource.\n     * @param machine The host name to initiate the download\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void downloadServices(String machine, List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(machine).downloadServices(pathList);\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return execute(master, c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).execute(c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return java(master, c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).java(c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a job in a remote command agent.\n     * @param machine The host to execute the command\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return value of the job\n     * @throws Exception An error occured executing the remote job\n     */\n    public <V extends Serializable> V execute(String machine,\n                                              RemoteCallable<V> callable,\n                                              String svcPath)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable, svcPath);\n    }\n\n    /**\n     * Executes a job on remote command agents on a list of systems.\n     * @param machines The host names to execute the job\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return values of the job, in sequence\n     * @throws Exception An error occurred executing the job\n     */\n    public <V extends Serializable> List<V> execute(String[] machines,\n                                                    RemoteCallable<V> callable,\n                                                    String svcPath)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable, svcPath));\n        return rl;\n    }\n\n    /**\n     * Start the agent on a single machine.\n     * @param machine on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if the command completed successfully, else false\n     * @throws Exception An error occurred starting the command\n     */\n    public boolean startAgent(String machine, Class agentClass,\n                              String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return (startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if all commands completed successfully, else false\n     * @throws Exception An error occurred starting the commands\n     */\n    public boolean startAgent(String machines[], Class agentClass,\n                              String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n    /**\n     * Gets a property from a given file.\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n    /**\n     * Kill all commands currently running and cleanup.\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++) {\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                }\n                if (retry == 20) {\n                    logger.severe(\"Registry did not terminate \" +\n                            \"after 20 termination attempts, giving up! \" +\n                            \"Subsequent runs may have problems.\");\n                }\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name, relative to the out dir\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n            String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        }\n        \n        // Ensure the file is accessed from the right place.\n        File src = new File(srcfile);\n        if (!src.isAbsolute())\n            src = new File(Config.OUT_DIR, srcfile);\n        srcfile = src.getAbsolutePath();\n\n        try {\n            String srcHost = InetAddress.getLocalHost().getHostName();\n            String destHost = hostRoles.getHostByAlias(destmachine);\n            if (destHost.equals(srcHost)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent destf = filep.get(didx);\n        try {\n            FileTransfer transfer = new FileTransfer(srcfile, destfile);\n            logger.fine(\"Transferring \" + transfer.getSource() + \"->\" +\n                    transfer.getDest() + \" size \" +\n                    transfer.getSize() + \" bytes.\");\n            if (destf.push(transfer) != transfer.getSize()) {\n                throw new IOException(\"Invalid transfer size\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name, always full path\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n            String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        }\n        try {\n            String src = InetAddress.getLocalHost().getHostName();\n            String dest = hostRoles.getHostByAlias(srcmachine);\n            if (dest.equals(src)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() != transfer.getTransferSize()) {\n                throw new IOException(\"Received \" + transfer.getSource() +\n                        \"->\" + transfer.getDest() + \", \" +\n                        transfer.getTransferSize() + \" out of \" +\n                        transfer.getSize() + \" bytes\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     * @deprecated\n     */\n    @Deprecated public synchronized boolean copy(String srcmachine, String destmachine,\n            String srcfile, String destfile,\n            boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile)) {\n            return (true);\n        }\n\n        if (srcfile.equals(destfile)) {\n            try {\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src) {\n                    return true;\n                }\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append) {\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            } else {\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n            }\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile + \" to \" + destmachine + \":\" +\n                    destfile, ie);\n            return (false);\n        }\n        return true;\n    }\n\n    /**\n     * Obtains the temporary dircteroy for the given machine.\n     *\n     * @param machine The machine name\n     * @return The temporary directory to use on the machine\n     */\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return filep.get(index);\n    }\n\n    /**\n     * Deletes the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n    /**\n     * Deletes the file from the machine based on the filter provided.\n     *\n     * @param srcmachine The machine name\n     * @param dir The directory name\n     * @param filter The file filter to use\n     * @return true if akk files selected by the filter has been removed\n     */\n    public synchronized boolean delete(String srcmachine, String dir,\n            com.sun.faban.harness.FileFilter filter) {\n        try {\n            return findFileAgent(srcmachine).removeFiles(dir, filter);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete files on \" +\n                    srcmachine + \":\" + dir);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n    /**\n     * Truncates the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean truncate(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).truncateFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not truncate \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile,\n            OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile, ie);\n            return (false);\n        }\n        return (true);\n    }\n\n    /**\n     * Set the Log level for Agents.\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * Obtains the registry.\n     * @return The registry\n     */\n    public Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.HostRoles;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    /** Sequential flag in FG mode. */\n    public static final int SEQUENTIAL = 1;\n\n    /** Parallel flag in FG mode. */\n    public static final int PARALLEL = 2;\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines. */\n    private ArrayList<String> machinesList = new ArrayList<String>();\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private List<String> jvmOptions;\n    private HashMap<String, List<String>> binMap =\n            new HashMap<String, List<String>>();\n    private Map<String, String> ifMap;\n    private List<String> rsh,  agent;\n    private HostRoles hostRoles;\n\n    CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n        cmds = this;\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        return cmds;\n    }\n\n    /**\n     * Obtains the name of the master machine.\n     * @return The master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines.\n     * This method can be called multiple times to initialize multiple\n     * classes of machines.\n     * @param benchName The name of the benchmark\n     * @param par The parameter repository\n     * @return true if successful, false if setup failed\n     */\n    public boolean setup(String benchName, ParamRepository par) {\n\n        String home = par.getParameter(\"fh:jvmConfig/fh:home\");\n\n        if (home != null)\n            home = home.trim();\n\n        if (home == null || home.length() == 0) {\n            home = Utilities.getJavaHome();\n            logger.config(\"JAVA_HOME set to \" + home);\n        }\n\n        if(!(new File(home)).isDirectory()) {\n            logger.severe(\"Cannot set JAVA_HOME. \" + home +\n                    \" is not a valid JAVA_HOME. Exiting\");\n            return false;\n        }\n\n        javaHome = home;\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        jvmOptions = new ArrayList<String>();\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                fs + \"faban.policy\");\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties\");\n        jvmOptions.add(\"-Dfaban.registry.port=\" + Config.RMI_PORT);\n        jvmOptions.add(\"-Dfaban.logging.port=\" + Config.LOGGING_PORT);\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if (!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                    log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))) {\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                        String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < libs.length; i++) {\n                if (libs[i].isFile()) {\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n                }\n            }\n            buf.setLength(buf.length() - 1);\n            if (buf.indexOf(\" \") != -1) {\n                buf.insert(0, '\"');\n                buf.append('\"');\n            }\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            List<String> cmd = new ArrayList<String>();\n            cmd.add(javaHome + File.separator + \"bin\" + File.separator +\n                    \"java\");\n            cmd.addAll(jvmOptions);\n            cmd.add(\"-Xms32m\");\n            cmd.add(\"-Xmx1024m\");\n            cmd.add(\"-cp\");\n            cmd.add(classpath);\n            cmd.add(\"com.sun.faban.common.RegistryImpl\");\n\n            logger.info(\"Starting Registry.\");\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        String jvmOpts =\n                par.getParameter(\"fh:jvmConfig/fh:jvmOptions\");\n\n        final String disableEGC = \"-XX:+DisableExplicitGC\";\n\n        if (jvmOpts != null)\n            jvmOpts = jvmOpts.trim();\n\n        if((jvmOpts == null) || (jvmOpts.length() == 0))\n            jvmOpts = \"\";\n\n        List<String> usrOpts = Command.parseArgs(jvmOpts);\n        if (!usrOpts.contains(disableEGC))\n            usrOpts.add(disableEGC);\n        jvmOptions.addAll(usrOpts);\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch (InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Unable to connect to Registry.\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        List<ParamRepository.HostConfig> hostConfigs = null;\n        try {\n            hostConfigs = par.getHostConfigs();\n        } catch (ConfigurationException e) {\n            logger.log(Level.SEVERE, \"Problem reading parameter file\", e);\n        }\n\n        outer:\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 || // localhost\n                            machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\");\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\", e);\n        }\n\n        if (rsh == null) {\n            rsh = new ArrayList<String>();\n            rsh.add(\"rsh\");\n        }\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master)) {\n                return false;\n            }\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if (\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (ParamRepository.HostConfig hostConfig : hostConfigs) {\n            String[] machines = hostConfig.hosts;\n            for (int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if (machinesList.contains(machines[i])) {\n                    continue;\n                }\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0) {\n                    return false;\n                }\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress)) {\n                    return false;\n                }\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++) {\n            if (!getCmdAgent((String) machinesList.get(i))) {\n                return false;\n            }\n        }\n\n        if (par.getBooleanValue(\"fa:runConfig/fh:timeSync\", true)) {\n            setClocks();\n        }\n\n        return true;\n    }\n\n    void setHostRoles(HostRoles hr) {\n        hostRoles = hr;\n\n        // We need to populate the machinesList and cmdp with\n        // the real host names.\n\n        // First get the real names.\n        String[] realHosts = hostRoles.getHostsInOrder();\n        \n        // For each real host name not in machinesList, we take the first alias\n        // and look it up in the machinesList. Fetch the command agent and add\n        // the real name to the machinesList -> cmdp mapping.\n        for (String hostName : realHosts) {\n            if (!machinesList.contains(hostName)) {\n                String[] aliases = hostRoles.getAliasesByHost(hostName);\n                CmdAgent a = findCmdAgent(aliases[0]); // Just one is enough\n                machinesList.add(hostName);\n                cmdp.add(a);\n            }\n        }\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n            Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host : hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            } catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                        retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return (false);\n            }\n\n            cmdp.add(c);\n\n            /* Note the agent registration process:\n             * 1. Create and register the command agent.\n             * 2. Download benchmark code\n             * 3. Create the lib classpath\n             * 4. Create and register file agent\n             * So it may take quite some time between the registration of\n             * the command agent and the file agent. But we can be pretty\n             * sure it'll happen. So just wait. Timeout after 100 retries.             \n             */\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"FileService: Connecting to \" + s);\n            retry = 1;\n            FileAgent f = (FileAgent) registry.getService(s);\n            for (; f == null && retry <= 100; retry++) {\n                Thread.sleep(1000);\n                logger.fine(\"Retry obtaining file service from \" + s +\n                        \", count \" + retry + '.');\n                f = (FileAgent) registry.getService(s);\n            }\n            if (f == null) {\n                logger.severe(\"Timed out obtaining file service from \" + s);\n                return (false);\n            }\n            filep.add(f);\n\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" +\n                    c.getHostName());\n            return true;\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \" + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n     * We use a script 'cmd' which will setup the CLASSPATH before\n     * invoking CmdAgent\n     */\n    private boolean startCmdAgent(String benchName, String mach,\n            String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        List<String> cmd = new ArrayList<String>();\n\n        List<String> agentParams = new ArrayList<String>();\n        agentParams.add(mach);\n        agentParams.add(interfaceAddress);\n        agentParams.add(masterAddress);\n        agentParams.add(javaHome);\n        agentParams.addAll(jvmOptions);\n        agentParams.add(\"faban.benchmarkName=\" + benchName);\n        try {\n            if (mach.equals(master)) {\n                cmd.addAll(agent);\n                cmd.addAll(agentParams);\n                logger.fine(\"Executing \" + cmd);\n                Command cmdAgent = new Command(cmd);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams.add(\"faban.download=\" + downloadURL.toString());\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    ObjectOutputStream socketOut =\n                            new ObjectOutputStream(socket.getOutputStream());\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n\n                    ArrayList<String> agentExtParams = \n                            new ArrayList<String>(agentParams);\n                    agentExtParams.add(File.separator);\n                    agentExtParams.add(File.pathSeparator);\n                    socketOut.writeObject(agentExtParams);\n\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200:\n                            agentStarted = true;\n                            logger.fine(\"Found Agent(daemon)@\" + mach +\n                                    \". Registering agent.\");\n                            break;\n                        case 500:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response +\n                                    \" Please report the issue \" +\n                                    \"and provide logs from \" + mach +\n                                    \":FABAN_HOME/logs/agent.log\");\n                            break;\n                        case 409:\n                            logger.severe(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                            // We do not fall back in the conflict case.\n                            return false;\n                        default:\n                            logger.warning(\"Agent(daemon)@\" + mach +\n                                    \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                            e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmd.clear();\n                    cmd.addAll(rsh);\n                    cmd.add(mach);\n                    cmd.addAll(agent);\n                    cmd.addAll(agentParams);\n                    Command cmdAgent = new Command(cmd);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<NameValuePair<Future<Boolean>>> tasks =\n                new ArrayList<NameValuePair<Future<Boolean>>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    NameValuePair<Future<Boolean>> future =\n                            new NameValuePair<Future<Boolean>>();\n                    future.name = hostName;\n                    future.value = Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat));\n                    tasks.add(future);\n                }\n            } catch (RemoteException e) {\n                logger.log(Level.WARNING,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n        for (NameValuePair<Future<Boolean>> future : tasks) {\n            try {\n                future.value.get(300, TimeUnit.SECONDS);\n            } catch (TimeoutException e) {\n                logger.log(Level.WARNING, \"Timed out setting clock for \" +\n                        future.name);\n            } catch (Throwable t) {\n                Throwable cause = t.getCause();\n                while (cause != null) {\n                    t = cause;\n                    cause = t.getCause();\n                }\n                logger.log(Level.WARNING, t.getMessage(), t);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws IOException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                    ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \" cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \" cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100) {\n                            ++nextSec; // If not, we go to the next sec.\n                        }\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                System.currentTimeMillis();\n                        if (sleepTime > 0) {\n                            Thread.sleep(sleepTime);\n                        }\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            if (wakeBefore > 700) {\n                                logger.warning(hostName + \" wakeup-before \" +\n                                        \"time reached 700ms limit. System is \" +\n                                        \"too busy. Giving up.\");\n                                return false;\n                            }\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                        ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Obtains the cached HostType object. Note that this is not a public API.\n     * @return The cached HostType object;\n     */\n    public HostRoles getHostRoles() {\n        return hostRoles;\n    }\n\n    /**\n     * Returns the hostname of this machine as known to the machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     * @param machineName The target machine to check the host name\n     * @return The host name of the remote machine\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0) {\n            return machineName; // Cannot resolve\n        }\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        } catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                    re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Updates the paths in the local command agent.\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void updatePaths(List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(master).updatePaths(pathList);\n    }\n\n    /**\n     * Downloads files used by deploy images, especially services and tools.\n     * The pathList contains a list of resources in the form type/resource.\n     * @param machine The host name to initiate the download\n     * @param pathList The list of paths to download\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public void downloadServices(String machine, List<String> pathList)\n            throws RemoteException {\n        findCmdAgent(machine).downloadServices(pathList);\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return execute(master, c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).execute(c, svcPath);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return java(master, c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        return findCmdAgent(machine).java(c, svcPath);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @param svcPath The location of the invoking service, if any\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c, String svcPath)\n            throws IOException, InterruptedException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c, svcPath);\n        return result;\n    }\n\n    /**\n     * Executes a job in a remote command agent.\n     * @param machine The host to execute the command\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return value of the job\n     * @throws Exception An error occured executing the remote job\n     */\n    public <V extends Serializable> V execute(String machine,\n                                              RemoteCallable<V> callable,\n                                              String svcPath)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable, svcPath);\n    }\n\n    /**\n     * Executes a job on remote command agents on a list of systems.\n     * @param machines The host names to execute the job\n     * @param callable The job\n     * @param svcPath The location of the invoking service, if any\n     * @return The return values of the job, in sequence\n     * @throws Exception An error occurred executing the job\n     */\n    public <V extends Serializable> List<V> execute(String[] machines,\n                                                    RemoteCallable<V> callable,\n                                                    String svcPath)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable, svcPath));\n        return rl;\n    }\n\n    /**\n     * Start the agent on a single machine.\n     * @param machine on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if the command completed successfully, else false\n     * @throws Exception An error occurred starting the command\n     */\n    public boolean startAgent(String machine, Class agentClass,\n                              String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return (startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     * @return true if all commands completed successfully, else false\n     * @throws Exception An error occurred starting the commands\n     */\n    public boolean startAgent(String machines[], Class agentClass,\n                              String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n    /**\n     * Gets a property from a given file.\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n    /**\n     * Kill all commands currently running and cleanup.\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++) {\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                }\n                if (retry == 20) {\n                    logger.severe(\"Registry did not terminate \" +\n                            \"after 20 termination attempts, giving up! \" +\n                            \"Subsequent runs may have problems.\");\n                }\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name, relative to the out dir\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n            String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        }\n        \n        // Ensure the file is accessed from the right place.\n        File src = new File(srcfile);\n        if (!src.isAbsolute())\n            src = new File(Config.OUT_DIR, srcfile);\n        srcfile = src.getAbsolutePath();\n\n        try {\n            String srcHost = InetAddress.getLocalHost().getHostName();\n            String destHost = hostRoles.getHostByAlias(destmachine);\n            if (destHost.equals(srcHost)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent destf = filep.get(didx);\n        try {\n            FileTransfer transfer = new FileTransfer(srcfile, destfile);\n            logger.fine(\"Transferring \" + transfer.getSource() + \"->\" +\n                    transfer.getDest() + \" size \" +\n                    transfer.getSize() + \" bytes.\");\n            if (destf.push(transfer) != transfer.getSize()) {\n                throw new IOException(\"Invalid transfer size\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name, always full path\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n            String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        }\n        try {\n            String src = InetAddress.getLocalHost().getHostName();\n            String dest = hostRoles.getHostByAlias(srcmachine);\n            if (dest.equals(src)) {\n                if (srcfile.equals(destfile)) {\n                    return true;\n                } else {\n                    return FileHelper.copyFile(srcfile, destfile, true);\n                }\n            }\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"CmdService: Cannot determine own\" +\n                    \"host name\", e);\n            return false;\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() != transfer.getTransferSize()) {\n                throw new IOException(\"Received \" + transfer.getSource() +\n                        \"->\" + transfer.getDest() + \", \" +\n                        transfer.getTransferSize() + \" out of \" +\n                        transfer.getSize() + \" bytes\");\n            }\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n            }\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     * @deprecated\n     */\n    @Deprecated public synchronized boolean copy(String srcmachine, String destmachine,\n            String srcfile, String destfile,\n            boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile)) {\n            return (true);\n        }\n\n        if (srcfile.equals(destfile)) {\n            try {\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src) {\n                    return true;\n                }\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append) {\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            } else {\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n            }\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile + \" to \" + destmachine + \":\" +\n                    destfile, ie);\n            return (false);\n        }\n        return true;\n    }\n\n    /**\n     * Obtains the temporary dircteroy for the given machine.\n     *\n     * @param machine The machine name\n     * @return The temporary directory to use on the machine\n     */\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0) {\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        }\n        int index = machinesList.indexOf(machine);\n        if (index == -1) {\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        }\n        return filep.get(index);\n    }\n\n    /**\n     * Deletes the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n    /**\n     * Deletes the file from the machine based on the filter provided.\n     *\n     * @param srcmachine The machine name\n     * @param dir The directory name\n     * @param filter The file filter to use\n     * @return true if akk files selected by the filter has been removed\n     */\n    public synchronized boolean delete(String srcmachine, String dir,\n            com.sun.faban.harness.FileFilter filter) {\n        try {\n            return findFileAgent(srcmachine).removeFiles(dir, filter);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not delete files on \" +\n                    srcmachine + \":\" + dir);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n    /**\n     * Truncates the file from the machine.\n     *\n     * @param srcmachine The machine name\n     * @param srcfile The file name\n     * @return true if the file has been deleted, false otherwise\n     */\n    public synchronized boolean truncate(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).truncateFile(srcfile);\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not truncate \" + srcmachine +\n                    \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines.\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile,\n            OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.log(Level.WARNING, \"CmdService: Could not copy \" +\n                    srcmachine + \":\" + srcfile, ie);\n            return (false);\n        }\n        return (true);\n    }\n\n    /**\n     * Set the Log level for Agents.\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * Obtains the registry.\n     * @return The registry\n     */\n    public Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n            logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                    hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","lineNo":299}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2008-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.services;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.*;\nimport com.sun.faban.harness.services.ClearLogs;\nimport com.sun.faban.harness.services.GetLogs;\nimport com.sun.faban.harness.services.ServiceContext;\nimport com.sun.faban.harness.util.FileHelper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class implements the service to start/stop ApacheHttpd instances.\n * It also provides functionality to transfer the portion of the apache\n * error_log for a run to the run output directory.\n * It can be used by any Apache benchmark to manage apache servers and\n * perform these operations remotely using this Service.\n *\n * @author Sheetal Patil based on work done by Shanti Subramanyam\n * \n */\npublic class ApacheHttpdService {\n\n    /** Injected service context. */\n    @Context public ServiceContext ctx;\n    private static Logger logger =\n            Logger.getLogger(ApacheHttpdService.class.getName());\n    private String[] myServers;\n    private static String apacheCmd,  errlogFile,  acclogFile, sessionDir,\n            iniFile, confFile;\n    CommandHandle apacheHandles[];\n\n    /**\n     * Configures the service.\n     */\n    @Configure public void configure() throws ConfigurationException {\n        myServers = ctx.getUniqueHosts();\n        if(myServers == null){\n            throw new ConfigurationException(\"Apache hostname is not provided\");\n        }\n        apacheCmd = ctx.getProperty(\"cmdPath\");\n        if(apacheCmd != null && apacheCmd.trim().length() > 0) {\n            apacheCmd = apacheCmd + \" \";\n        }else{\n            throw new ConfigurationException(\"Apache cmdPath is not provided\");\n        }\n        \n        String logsDir = ctx.getProperty(\"logsDir\");\n        if(logsDir != null && logsDir.trim().length() > 0) {\n            if (!logsDir.endsWith(File.separator))\n                logsDir = logsDir + File.separator;\n        }else{\n            throw new ConfigurationException(\"Apache logsDir is not provided\");\n        }\n\n        sessionDir = ctx.getProperty(\"sessionDir\");\n        if(sessionDir != null && sessionDir.trim().length() > 0) {\n            if (sessionDir.endsWith(File.separator)) {\n                sessionDir = sessionDir.substring(0,\n                        sessionDir.length() - File.separator.length());\n            }\n        }else{\n            logger.warning(\"Apache sessionDir is not provided\");\n        }\n\n        iniFile = ctx.getProperty(\"iniPath\");\n        if(iniFile == null || iniFile.trim().length() <= 0){\n            logger.warning(\"iniPath is not provided\");\n        }\n\n        confFile = ctx.getProperty(\"confPath\");\n        if(confFile == null || confFile.trim().length() <= 0){\n            logger.warning(\"confPath is not provided\");\n        }\n\n        errlogFile = logsDir + \"error_log\";\n        acclogFile = logsDir + \"access_log\";\n        logger.fine(\"ApacheHttpdService setup complete.\");\n    }\n\n    \n    /**\n     * Starts up the Apache web server.\n     */\n    @Start public void startup() {\n        String cmd = apacheCmd + \"start\";\n        logger.fine(\"Starting Apache Service with command = \"+ cmd);\n        Command startCmd = new Command(cmd);\n        startCmd.setSynchronous(false); // to run in bg\n \n        for (int i = 0; i < myServers.length; i++) {\n            String server = myServers[i];\n            try {\n                // Run the command in the foreground and wait for the start\n                RunContext.exec(server, startCmd);\n                /*\n                 * Read the log file to make sure the server has started.\n                 * We do this by running the code block on the server via\n                 * RemoteCallable\n                 */\n                if (checkServerStarted(server)) {\n                    logger.fine(\"Completed apache httpd server(s) startup \" +\n                            \"successfully on \" + server);\n                } else {\n                    logger.severe(\"Failed to find start message in \" +\n                            errlogFile + \" on \" + server);\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to start apache server on \" +\n                        server, e);\n            }\n        }\n    }\n\n    /*\n\t * Check if apache server started by looking in the error_log\n\t */\n    private static boolean checkServerStarted(String hostName)\n            throws Exception {\n        Integer val = 0;\n        final String err = errlogFile;\n\n        val = RunContext.exec(hostName, new RemoteCallable<Integer>() {\n\n            static final int RETRIES = 30;\n\n            public Integer call() throws Exception {\n                Integer retVal = 0;\n                String msg = \"resuming normal operations\";\n\n                // Ensure filenames are not impacted by path differences.\n                File errFile = new File(Utilities.convertPath(err));\n                for (int retry = 0;retry < RETRIES; retry++) {\n                    if (errFile.exists()) {\n                        if (FileHelper.hasString(errFile, msg)) {\n                            retVal = 1;\n                            break;\n                        } \n                    }\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                }\n                return retVal;\n            }\n        });\n        if (val == 1) {\n            return (true);\n        } else {\n            return (false);\n        }\n    }\n\n    /**\n     * Shuts down the Apache web server.\n     * @throws IOException Error executing the shutdown\n     * @throws InterruptedException Interrupted waiting for the shutdown\n     */\n    @Stop public void shutdown() throws IOException, InterruptedException {\n        for (int i = 0; i < myServers.length; i++) {\n                //Try to Stop it.\n                try {\n                    String cmd = apacheCmd + \"stop\";\n                    Command stopCmd = new Command(cmd);\n                    stopCmd.setLogLevel(Command.STDOUT, Level.FINE);\n                    stopCmd.setLogLevel(Command.STDERR, Level.FINE);\n\n                    // Run the command in the foreground\n                    CommandHandle ch = RunContext.exec(myServers[i], stopCmd);\n                    // Check if the server was running before stop was issued\n                    // If not running, apachectl will print that on stdout\n                    byte[] output = ch.fetchOutput(Command.STDOUT);\n\n                    if (output != null)\n                        if ((output.toString()).indexOf(\"not running\") != -1) {\n                           continue;\n                        }\n\n                    if (checkServerStopped(myServers[i])) {\n                        logger.fine(\"Completed apache httpd server(s) \" +\n                                \"shutdown successfully on \" + myServers[i]);\n                        continue;\n                    } \n\n                } catch (Exception e) {\n                        logger.log(Level.WARNING,\n                                \"Failed to stop Apache httpd server\" +\n                                myServers[i] + \" with \" + e.toString(), e);\n                }                \n        }\n    }\n\n    /*\n\t * Check if apache server stopped by scanning error_log\n\t */\n    private static boolean checkServerStopped(String hostName)\n            throws Exception {\n        Integer val = 0;\n        final String err = errlogFile;\n        val = RunContext.exec(hostName, new RemoteCallable<Integer>() {\n\n            static final int RETRIES = 30;\n\n            public Integer call() throws Exception {\n                Integer retVal = 0;\n                // Read the log file to make sure the server has shutdown\n                String msg = \"shutting down\";\n\n                // Ensure filenames are not impacted by path differences.\n                File errFile = new File(Utilities.convertPath(err));\n                for (int retry = 0;retry < RETRIES; retry++) {\n                    if (errFile.exists()) {\n                        if (FileHelper.hasString(errFile, msg)) {\n                            retVal = 1;\n                            break;\n                        }\n                    }\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                }\n                return retVal;\n            }\n        });\n        if (val == 1) {\n            return (true);\n        } else {\n            return (false);\n        }\n    }\n\n    /**\n     * Clears the Apache web server logs.\n     */\n    @ClearLogs public void clearLogs() {\n\n        for (int i = 0; i < myServers.length; i++) {\n            if (RunContext.isFile(myServers[i], errlogFile)) {\n                if (!RunContext.deleteFile(myServers[i], errlogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + errlogFile +\n                            \" failed on \" + myServers[i]);\n                }\n            }\n            if (RunContext.isFile(myServers[i], acclogFile)) {\n                if (!RunContext.deleteFile(myServers[i], acclogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + acclogFile +\n                            \" failed on \" + myServers[i]);\n                }\n            }\n\n            logger.fine(\"Logs cleared for \" + myServers[i]);\n            if(sessionDir != null && sessionDir.trim().length() > 0) {\n                try {\n                    // Now delete the session files\n                    if (RunContext.deleteFiles(myServers[i], sessionDir,\n                            new WildcardFileFilter(\"sess*\")))\n                        logger.fine(\"Deleted session files for \" + myServers[i]);\n                    else\n                        logger.warning(\"Error deleting session files for \" +\n                                myServers[i]);\n\n                } catch (Exception e) {\n                    logger.log(Level.FINE, \"Delete session files failed on \" +\n                            myServers[i] + \".\", e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Transfer log files.\n     * This method copies over the error_log to the run output directory\n     * and keeps only the portion of the log relevant for this run.\n     */\n    @GetLogs public void getLogs() {\n        for (int i = 0; i < myServers.length; i++) {\n            String outFile = RunContext.getOutDir() + \"httpd_err.log.\" +\n                             RunContext.getHostName(myServers[i]);\n\n            // copy the error_log to the master\n            if (!RunContext.getFile(myServers[i], errlogFile, outFile)) {\n                logger.warning(\"Could not copy \" + errlogFile + \" to \" +\n                        outFile);\n                return;\n            }\n\n            if(iniFile != null && iniFile.trim().length() > 0) {\n                String outIniFile = RunContext.getOutDir() + \"ini.log.\" +\n                                 RunContext.getHostName(myServers[i]);\n\n                // copy the iniFile to the master\n                if (!RunContext.getFile(myServers[i], iniFile, outIniFile)) {\n                    logger.warning(\"Could not copy \" + iniFile + \" to \" + outIniFile);\n                }\n            }\n\n            RunContext.truncateFile(myServers[i], errlogFile);\n            logger.fine(\"XferLog Completed for \" + myServers[i]);\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2008-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.services;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.*;\nimport com.sun.faban.harness.services.ClearLogs;\nimport com.sun.faban.harness.services.GetLogs;\nimport com.sun.faban.harness.services.ServiceContext;\nimport com.sun.faban.harness.util.FileHelper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class implements the service to start/stop ApacheHttpd instances.\n * It also provides functionality to transfer the portion of the apache\n * error_log for a run to the run output directory.\n * It can be used by any Apache benchmark to manage apache servers and\n * perform these operations remotely using this Service.\n *\n * @author Sheetal Patil based on work done by Shanti Subramanyam\n * \n */\npublic class ApacheHttpdService {\n\n    /** Injected service context. */\n    @Context public ServiceContext ctx;\n    private static Logger logger =\n            Logger.getLogger(ApacheHttpdService.class.getName());\n    private String[] myServers;\n    private static String apacheCmd,  errlogFile,  acclogFile, sessionDir,\n            iniFile, confFile;\n    CommandHandle apacheHandles[];\n\n    /**\n     * Configures the service.\n     */\n    @Configure public void configure() throws ConfigurationException {\n        myServers = ctx.getUniqueHosts();\n        if(myServers == null){\n            throw new ConfigurationException(\"Apache hostname is not provided\");\n        }\n        apacheCmd = ctx.getProperty(\"cmdPath\");\n        if(apacheCmd != null && apacheCmd.trim().length() > 0) {\n            apacheCmd = apacheCmd + \" \";\n        }else{\n            throw new ConfigurationException(\"Apache cmdPath is not provided\");\n        }\n        \n        String logsDir = ctx.getProperty(\"logsDir\");\n        if(logsDir != null && logsDir.trim().length() > 0) {\n            if (!logsDir.endsWith(File.separator))\n                logsDir = logsDir + File.separator;\n        }else{\n            throw new ConfigurationException(\"Apache logsDir is not provided\");\n        }\n\n        sessionDir = ctx.getProperty(\"sessionDir\");\n        if(sessionDir != null && sessionDir.trim().length() > 0) {\n            if (sessionDir.endsWith(File.separator)) {\n                sessionDir = sessionDir.substring(0,\n                        sessionDir.length() - File.separator.length());\n            }\n        }else{\n            logger.warning(\"Apache sessionDir is not provided\");\n        }\n\n        iniFile = ctx.getProperty(\"phpIniPath\");\n        if(iniFile == null || iniFile.trim().length() <= 0){\n            logger.warning(\"iniPath is not provided\");\n        }\n\n        confFile = ctx.getProperty(\"confPath\");\n        if(confFile == null || confFile.trim().length() <= 0){\n            logger.warning(\"confPath is not provided\");\n        }\n\n        errlogFile = logsDir + \"error_log\";\n        acclogFile = logsDir + \"access_log\";\n        logger.fine(\"ApacheHttpdService setup complete.\");\n    }\n\n    \n    /**\n     * Starts up the Apache web server.\n     */\n    @Start public void startup() {\n        String cmd = apacheCmd + \"start\";\n        logger.fine(\"Starting Apache Service with command = \"+ cmd);\n        Command startCmd = new Command(cmd);\n        startCmd.setSynchronous(false); // to run in bg\n \n        for (int i = 0; i < myServers.length; i++) {\n            String server = myServers[i];\n            try {\n                // Run the command in the foreground and wait for the start\n                RunContext.exec(server, startCmd);\n                /*\n                 * Read the log file to make sure the server has started.\n                 * We do this by running the code block on the server via\n                 * RemoteCallable\n                 */\n                if (checkServerStarted(server)) {\n                    logger.fine(\"Completed apache httpd server(s) startup \" +\n                            \"successfully on \" + server);\n                } else {\n                    logger.severe(\"Failed to find start message in \" +\n                            errlogFile + \" on \" + server);\n                }\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to start apache server on \" +\n                        server, e);\n            }\n        }\n    }\n\n    /*\n\t * Check if apache server started by looking in the error_log\n\t */\n    private static boolean checkServerStarted(String hostName)\n            throws Exception {\n        Integer val = 0;\n        final String err = errlogFile;\n\n        val = RunContext.exec(hostName, new RemoteCallable<Integer>() {\n\n            static final int RETRIES = 30;\n\n            public Integer call() throws Exception {\n                Integer retVal = 0;\n                String msg = \"resuming normal operations\";\n\n                // Ensure filenames are not impacted by path differences.\n                File errFile = new File(Utilities.convertPath(err));\n                for (int retry = 0;retry < RETRIES; retry++) {\n                    if (errFile.exists()) {\n                        if (FileHelper.hasString(errFile, msg)) {\n                            retVal = 1;\n                            break;\n                        } \n                    }\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                }\n                return retVal;\n            }\n        });\n        if (val == 1) {\n            return (true);\n        } else {\n            return (false);\n        }\n    }\n\n    /**\n     * Shuts down the Apache web server.\n     * @throws IOException Error executing the shutdown\n     * @throws InterruptedException Interrupted waiting for the shutdown\n     */\n    @Stop public void shutdown() throws IOException, InterruptedException {\n        for (int i = 0; i < myServers.length; i++) {\n                //Try to Stop it.\n                try {\n                    String cmd = apacheCmd + \"stop\";\n                    Command stopCmd = new Command(cmd);\n                    stopCmd.setLogLevel(Command.STDOUT, Level.FINE);\n                    stopCmd.setLogLevel(Command.STDERR, Level.FINE);\n\n                    // Run the command in the foreground\n                    CommandHandle ch = RunContext.exec(myServers[i], stopCmd);\n                    // Check if the server was running before stop was issued\n                    // If not running, apachectl will print that on stdout\n                    byte[] output = ch.fetchOutput(Command.STDOUT);\n\n                    if (output != null)\n                        if ((output.toString()).indexOf(\"not running\") != -1) {\n                           continue;\n                        }\n\n                    if (checkServerStopped(myServers[i])) {\n                        logger.fine(\"Completed apache httpd server(s) \" +\n                                \"shutdown successfully on \" + myServers[i]);\n                        continue;\n                    } \n\n                } catch (Exception e) {\n                        logger.log(Level.WARNING,\n                                \"Failed to stop Apache httpd server\" +\n                                myServers[i] + \" with \" + e.toString(), e);\n                }                \n        }\n    }\n\n    /*\n\t * Check if apache server stopped by scanning error_log\n\t */\n    private static boolean checkServerStopped(String hostName)\n            throws Exception {\n        Integer val = 0;\n        final String err = errlogFile;\n        val = RunContext.exec(hostName, new RemoteCallable<Integer>() {\n\n            static final int RETRIES = 30;\n\n            public Integer call() throws Exception {\n                Integer retVal = 0;\n                // Read the log file to make sure the server has shutdown\n                String msg = \"shutting down\";\n\n                // Ensure filenames are not impacted by path differences.\n                File errFile = new File(Utilities.convertPath(err));\n                for (int retry = 0;retry < RETRIES; retry++) {\n                    if (errFile.exists()) {\n                        if (FileHelper.hasString(errFile, msg)) {\n                            retVal = 1;\n                            break;\n                        }\n                    }\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                    }\n                }\n                return retVal;\n            }\n        });\n        if (val == 1) {\n            return (true);\n        } else {\n            return (false);\n        }\n    }\n\n    /**\n     * Clears the Apache web server logs.\n     */\n    @ClearLogs public void clearLogs() {\n\n        for (int i = 0; i < myServers.length; i++) {\n            if (RunContext.isFile(myServers[i], errlogFile)) {\n                if (!RunContext.deleteFile(myServers[i], errlogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + errlogFile +\n                            \" failed on \" + myServers[i]);\n                }\n            }\n            if (RunContext.isFile(myServers[i], acclogFile)) {\n                if (!RunContext.deleteFile(myServers[i], acclogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + acclogFile +\n                            \" failed on \" + myServers[i]);\n                }\n            }\n\n            logger.fine(\"Logs cleared for \" + myServers[i]);\n            if(sessionDir != null && sessionDir.trim().length() > 0) {\n                try {\n                    // Now delete the session files\n                    if (RunContext.deleteFiles(myServers[i], sessionDir,\n                            new WildcardFileFilter(\"sess*\")))\n                        logger.fine(\"Deleted session files for \" + myServers[i]);\n                    else\n                        logger.warning(\"Error deleting session files for \" +\n                                myServers[i]);\n\n                } catch (Exception e) {\n                    logger.log(Level.FINE, \"Delete session files failed on \" +\n                            myServers[i] + \".\", e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Transfer log files.\n     * This method copies over the error_log to the run output directory\n     * and keeps only the portion of the log relevant for this run.\n     */\n    @GetLogs public void getLogs() {\n        String outDir = RunContext.getOutDir();\n        for (int i = 0; i < myServers.length; i++) {\n            String outFile = outDir + \"httpd_err.log.\" +\n                             RunContext.getHostName(myServers[i]);\n\n            // copy the error_log to the master\n            if (!RunContext.getFile(myServers[i], errlogFile, outFile)) {\n                logger.warning(\"Could not copy \" + errlogFile + \" to \" +\n                        outFile);\n                return;\n            }\n            // copy the php.ini file if it has been specified\n            if(iniFile != null && iniFile.trim().length() > 0) {\n                String outIniFile = outDir + \"php_ini.log.\" +\n                                 RunContext.getHostName(myServers[i]);\n                if (!RunContext.getFile(myServers[i], iniFile, outIniFile)) {\n                    logger.warning(\"Could not copy \" + iniFile + \" to \" + outIniFile);\n                }\n            }\n            // copy the httpd.conf file if it has been specified\n            if(confFile != null && confFile.trim().length() > 0) {\n                outFile = outDir + \"httpd_conf.log.\" +\n                                 RunContext.getHostName(myServers[i]);\n                if (!RunContext.getFile(myServers[i], confFile, outFile)) {\n                    logger.warning(\"Could not copy \" + confFile + \" to \" + outFile);\n                }\n            }\n            RunContext.truncateFile(myServers[i], errlogFile);\n            logger.fine(\"XferLog Completed for \" + myServers[i]);\n        }\n    }\n}\n","lineNo":307}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The default benchmark class for use with benchmarks implemented with the\n * Faban Driver Framework. This class is designed to be extended if additional\n * features are desired. Do not use the DefaultFabanBenchmark if the actual\n * driver is not implemented using the Faban Driver Framework. Implement the\n * Benchmark interface directly in such cases.\n *\n * @author Akara Sucharitakul\n * @deprecated Replaced by DefaultFabanBenchmark2, this class is provided for\n *             backward compatibility and is to be removed in the future.\n */\n@Deprecated public class DefaultFabanBenchmark implements Benchmark {\n\n    private Logger logger = Logger.getLogger(getClass().getName());;\n\n    /** The param repository. */\n    protected ParamRepository params;\n\n    /** The agent list. */\n    protected List<String> agents;\n\n    /** The agent hosts. */\n    protected String[] agentHosts;\n\n    /** The map from host to agents. */\n    protected Map<String, List<String>> hostAgents;\n\n    /** Environment to pass to agents when starting. */\n    protected Map<String, List<String>> agentEnv;\n\n    /** Command handle to the master. */\n    protected CommandHandle masterHandle;\n\n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n            \n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Empty agents field, throw exception.\n                    String msg = \"Number of agents for \" + agentName +\n                                            \" driver must not be empty.\";\n                    ConfigurationException ce = new ConfigurationException(msg);\n                    logger.log(Level.SEVERE, msg, ce);\n                    throw ce;\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost.equals(previousHost))\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n            // Update the output directory to the one assigned by the harness.\n            params.setParameter(\"fa:runConfig/fd:outputDir\", getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void configure() throws Exception {\n        // No configuration needed.\n    }\n\n    /**\n     * This method is responsible for starting the benchmark run.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n                \n                String masterIP = getMasterIP(hostName);\n                if (masterIP == null) {\n                    masterIP = getMasterIP();\n                }\n\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        masterIP);\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.w3c.dom.Element;\n\n/**\n * The default benchmark class for use with benchmarks implemented with the\n * Faban Driver Framework. This class is designed to be extended if additional\n * features are desired. Do not use the DefaultFabanBenchmark if the actual\n * driver is not implemented using the Faban Driver Framework. Implement the\n * Benchmark interface directly in such cases.\n *\n * @author Akara Sucharitakul\n * @deprecated Replaced by DefaultFabanBenchmark2, this class is provided for\n *             backward compatibility and is to be removed in the future.\n */\n@Deprecated public class DefaultFabanBenchmark implements Benchmark {\n\n    private Logger logger = Logger.getLogger(getClass().getName());;\n\n    /** The param repository. */\n    protected ParamRepository params;\n\n    /** The agent list. */\n    protected List<String> agents;\n\n    /** The agent hosts. */\n    protected String[] agentHosts;\n\n    /** The map from host to agents. */\n    protected Map<String, List<String>> hostAgents;\n\n    /** Environment to pass to agents when starting. */\n    protected Map<String, List<String>> agentEnv;\n\n    /** Command handle to the master. */\n    protected CommandHandle masterHandle;\n\n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n            \n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Default to 1 agent\n                    String[] defaultAgentSpecs = { \"1\" };\n                    agentSpecs = defaultAgentSpecs; // fall thru to case 1.\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            String msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ConfigurationException ce =\n                                    new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            String msg = \"Invalid agents spec \" + agentSpec;\n                            ConfigurationException ce =\n                                    new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            String msg = \"Invalid agents spec \" + agentSpec;\n                            ConfigurationException ce =\n                                    new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost.equals(previousHost))\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n\n            // Update the output directory to the one assigned by the harness.\n            Element outputDirNode = (Element)\n                    params.getNode(\"fa:runConfig/fd:outputDir\");\n\n            if (outputDirNode == null)\n                outputDirNode = params.addParameter(\"fa:runConfig\",\n                        \"http://faban.sunsource.net/ns/fabandriver\", null,\n                        \"outputDir\");\n\n            params.setParameter(outputDirNode, getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void configure() throws Exception {\n        // No configuration needed.\n    }\n\n    /**\n     * This method is responsible for starting the benchmark run.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n                \n                String masterIP = getMasterIP(hostName);\n                if (masterIP == null) {\n                    masterIP = getMasterIP();\n                }\n\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        masterIP);\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    }\n}\n","lineNo":258}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The default benchmark class(based on annotations) for use with benchmarks\n * implemented with the Faban Driver Framework. This class is designed to be\n * extended if additional features are desired. Do not use the\n * DefaultFabanBenchmark2 if the actual driver is not implemented using the\n * Faban Driver Framework.\n *\n * @author Akara Sucharitakul\n */\npublic class DefaultFabanBenchmark2 {\n\n    private Logger logger = Logger.getLogger(getClass().getName());\n\n    /** The param repository. */\n    protected ParamRepository params;\n\n    /** The agent list. */\n    protected List<String> agents;\n\n    /** The agent hosts. */\n    protected String[] agentHosts;\n\n    /** The map from host to agents. */\n    protected Map<String, List<String>> hostAgents;\n\n    /** Environment to pass to agents when starting. */\n    protected Map<String, List<String>> agentEnv;\n\n    /** Command handle to the master. */\n    protected CommandHandle masterHandle;\n    \n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    @Validate public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n\n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Empty agents field, throw exception.\n                    String msg = \"Number of agents for \" + agentName +\n                                            \" driver must not be empty.\";\n                    ConfigurationException ce = new ConfigurationException(msg);\n                    logger.log(Level.SEVERE, msg, ce);\n                    throw ce;\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost.equals(previousHost))\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n            // Update the output directory to the one assigned by the harness.\n            params.setParameter(\"fa:runConfig/fd:outputDir\", getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void configure() throws Exception {\n        // No configuration needed.\n    //}\n\n    /**\n     * This method is responsible for starting the benchmark run.\n     *\n     * @throws Exception if any error occurred.\n     */\n    @StartRun public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n\n                String masterIP = getMasterIP(hostName);\n                if (masterIP == null) {\n                    masterIP = getMasterIP();\n                }\n\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        masterIP);\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    @EndRun public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    //}\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport org.w3c.dom.Element;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static com.sun.faban.harness.RunContext.*;\n\n/**\n * The default benchmark class(based on annotations) for use with benchmarks\n * implemented with the Faban Driver Framework. This class is designed to be\n * extended if additional features are desired. Do not use the\n * DefaultFabanBenchmark2 if the actual driver is not implemented using the\n * Faban Driver Framework.\n *\n * @author Akara Sucharitakul\n */\npublic class DefaultFabanBenchmark2 {\n\n    private Logger logger = Logger.getLogger(getClass().getName());\n\n    /** The param repository. */\n    protected ParamRepository params;\n\n    /** The agent list. */\n    protected List<String> agents;\n\n    /** The agent hosts. */\n    protected String[] agentHosts;\n\n    /** The map from host to agents. */\n    protected Map<String, List<String>> hostAgents;\n\n    /** Environment to pass to agents when starting. */\n    protected Map<String, List<String>> agentEnv;\n\n    /** Command handle to the master. */\n    protected CommandHandle masterHandle;\n    \n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    @Validate public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n\n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Default to 1 agent\n                    String[] defaultAgentSpecs = { \"1\" };\n                    agentSpecs = defaultAgentSpecs; // fall thru to case 1.\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            String msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ConfigurationException ce =\n                                    new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            String msg = \"Invalid agents spec \" + agentSpec;\n                            ConfigurationException ce =\n                                    new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            String msg = \"Invalid agents spec \" + agentSpec;\n                            ConfigurationException ce =\n                                    new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost.equals(previousHost))\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n\n            // Update the output directory to the one assigned by the harness.\n            Element outputDirNode = (Element)                                      \n                    params.getNode(\"fa:runConfig/fd:outputDir\");\n\n            if (outputDirNode == null)\n                outputDirNode = params.addParameter(\"fa:runConfig\",\n                        \"http://faban.sunsource.net/ns/fabandriver\", null,\n                        \"outputDir\");\n\n            params.setParameter(outputDirNode, getOutDir());\n\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void configure() throws Exception {\n        // No configuration needed.\n    //}\n\n    /**\n     * This method is responsible for starting the benchmark run.\n     *\n     * @throws Exception if any error occurred.\n     */\n    @StartRun public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n\n                String masterIP = getMasterIP(hostName);\n                if (masterIP == null) {\n                    masterIP = getMasterIP();\n                }\n\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        masterIP);\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    @EndRun public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    //}\n}\n","lineNo":255}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id$\n*\n* Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.BenchmarkDescription;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\nimport com.sun.faban.harness.util.FileHelper;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.multipart.FilePart;\nimport org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;\nimport org.apache.commons.httpclient.methods.multipart.Part;\nimport org.apache.commons.httpclient.methods.multipart.StringPart;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.net.URL;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * Controller handling actions from the result list screen.\n */\npublic class ResultAction {\n\n    private static Logger logger =\n            Logger.getLogger(ResultAction.class.getName());\n    private SimpleDateFormat dateFormat = new SimpleDateFormat(\n                              \"EEE MM/dd/yy HH:mm:ss z\");\n\n    /**\n     * Checks for actions the user asked to perform and take the appropriate\n     * action.\n     * @param request The request\n     * @param response The response\n     * @return The name of the jsp view to forward this request\n     * @throws IOException If there are problems reading or writing data\n     * @throws ParseException Error parsing input\n     */\n    public String takeAction(HttpServletRequest request,\n                           HttpServletResponse response)\n            throws IOException, ParseException {\n        String process = request.getParameter(\"process\");\n        if (\"Compare\".equals(process))\n            return editAnalysis(process, request, response);\n        if (\"Average\".equals(process))\n            return editAnalysis(process, request, response);\n        if (\"Archive\".equals(process))\n            return editArchive(request, response);\n        return null;\n    }\n\n    /**\n     * The model object for the EditArchive screen view.\n     * This is according to the MVC pattern.\n     */\n    public class EditArchiveModel implements Serializable {\n\n        /** The display header. */\n        public String head;\n\n        /** The run id of the runs to archive. */\n        public String[] runIds;\n\n        /** The set of duplicate runs. */\n        public Set<String> duplicates;\n\n        /** The list of run result objects. */\n        public RunResult[] results;\n    }\n\n    String editArchive(HttpServletRequest request,\n                              HttpServletResponse response) throws IOException,\n                              FileNotFoundException, ParseException {\n        String[] runIds = request.getParameterValues(\"select\");\n\n        if (runIds == null || runIds.length < 1) {\n            String msg;\n            msg = \"Select at least one runs to archive.\";\n            response.getOutputStream().println(msg);\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);\n            return null;\n        }\n        \n        EditArchiveModel model = new EditArchiveModel();\n        model.runIds = runIds;\n        model.duplicates = checkArchivedRuns(runIds);\n\n        if (Config.repositoryURLs != null &&\n                Config.repositoryURLs.length > 1)\n            model.head = \"Repositories\";\n        else\n            model.head = \"Repository\";\n\n        model.results = new RunResult[runIds.length];\n        for (int i = 0; i < runIds.length; i++) {\n            model.results[i] = RunResult.getInstance(new RunId(runIds[i]));\n        }\n        // We use request attributes as not to reflect session state.\n        request.setAttribute(\"editarchive.model\", model);\n        return \"/edit_archive.jsp\";\n    }\n\n    /**\n     * Obtains the tags list for each profile.\n     * @param req\n     * @param resp\n     * @throws java.io.IOException\n     */\n    public void profileTagList (HttpServletRequest req,\n            HttpServletResponse resp) throws IOException {\n        String profile = req.getParameter(\"profileselected\");\n        File tagsFile = new File(Config.PROFILES_DIR + profile + \"/tags\");\n        String tagsForProfile = \"\";\n        if(tagsFile.exists() && tagsFile.length()>0){\n            tagsForProfile = FileHelper.readContentFromFile(tagsFile).trim();\n        }\n        Writer w = resp.getWriter();\n        w.write(tagsForProfile);\n        w.flush();\n        w.close();\n    }\n\n    /*private Set<String> checkArchivedRuns(String[] runIds) throws IOException{\n        StringBuilder b = new StringBuilder();\n        b.append(\"/controller/uploader/check_runs\");\n        int endPath = b.length();      \n        for (String runId : runIds)\n            b.append(\"&select=\").append(runId);\n        b.setCharAt(endPath, '?');\n        HttpURLConnection c = (HttpURLConnection) request.openConnection();\n                if (c.getResponseCode() != 404){\n                    existingRuns.add(runId);\n         }\n\n        HashSet<String> existingRuns = new HashSet<String>();\n        for (String runId : runIds){\n            for (URL repository : Config.repositoryURLs) {\n                URL request = new URL(repository, \"/output/\"+\n                                                 Config.FABAN_HOST+\".\"+runId);\n                URLConnection c = request.openConnection();\n                int len = c.getContentLength();\n                if (len < 0){\n                        existingRuns.add(runId);\n                }\n            }\n        }\n        return existingRuns;\n    }*/\n\n    private String editResultInfo(String runID)\n            throws FileNotFoundException, IOException {\n        RunId runId = new RunId(runID);\n        String ts = null;\n        String[] status = new String[2];\n        File file = new File(Config.OUT_DIR + runID + '/' + Config.RESULT_INFO);\n        RandomAccessFile rf = new RandomAccessFile(file, \"rwd\");\n        long size = rf.length();\n        byte[] buffer = new byte[(int) size];\n        rf.readFully(buffer);\n        String content = new String(buffer, 0, (int) size );\n        int idx = content.indexOf('\\t');\n        if (idx != -1) {\n                status[0] = content.substring(0, idx).trim();\n                status[1] = content.substring(++idx).trim();\n        } else {\n                status[0] = content.trim();\n                int lastIdxln = status[0].lastIndexOf(\"\\n\");\n                if(lastIdxln != -1)\n                    status[0] = status[0].substring(0, lastIdxln-1);\n        }\n        if (status[1] != null) {\n            ts = status[1];\n        }else{\n            String paramFileName = runId.getResultDir().getAbsolutePath() +\n                    File.separator + \"run.xml\";\n            File paramFile = new File(paramFileName);\n            long dt = paramFile.lastModified();\n            ts = dateFormat.format(new Date(dt));\n            rf.seek(rf.length());\n            rf.writeBytes('\\t' + ts.trim());\n        }\n        rf.close();\n        return ts;\n    }\n\n    private Set<String> checkArchivedRuns(String[] runIds) throws\n                            FileNotFoundException, IOException {\n        HashSet<String> existingRuns = new HashSet<String>();\n        String[] runIdTimeStamps = new  String[runIds.length];\n        for (int r=0; r< runIds.length ; r++){\n            String runId = runIds[r];\n            runIdTimeStamps[r] = editResultInfo(runId);\n        }\n        for (URL repository : Config.repositoryURLs) {\n            URL repos = new URL(repository, \"/controller/uploader/check_runs\");\n            PostMethod post = new PostMethod(repos.toString());\n            post.addParameter(\"host\",Config.FABAN_HOST);\n            for (String runId : runIds){\n                post.addParameter(\"runId\",runId);\n            }\n            for (String ts : runIdTimeStamps){\n                post.addParameter(\"ts\",ts);\n            }\n            HttpClient client = new HttpClient();\n            client.getHttpConnectionManager().getParams().\n                    setConnectionTimeout(5000);\n            int status = client.executeMethod(post);\n            if (status != HttpStatus.SC_OK)\n                logger.info(\"SC_OK not ok\");\n\n            String response = post.getResponseBodyAsString();\n            StringTokenizer t = new StringTokenizer(response.trim(),\"\\n\");\n            while (t.hasMoreTokens()) {\n                existingRuns.add(t.nextToken().trim());\n            }\n        }\n        return existingRuns;\n    }\n\n    /**\n     * The model object for the EditAnalysis screen view.\n     * This is according to the MVC pattern.\n     */\n    public static class EditAnalysisModel implements Serializable {\n        /** The header, usually the process type. */\n        public String head;\n\n        /** The type string in all lowercase. */\n        public String type;\n\n        /** The string representation of the list of runs to analyze. */\n        public String runList;\n\n        /** The analysis name. */\n        public String name;\n\n        /** The run ids to analyze. */\n        public String[] runIds;\n    }\n\n    String editAnalysis(String process, HttpServletRequest request,\n                              HttpServletResponse response)\n            throws IOException {\n\n        EditAnalysisModel model = new EditAnalysisModel();\n        model.head = process;\n        model.type = process.toLowerCase();\n\n        model.runIds = request.getParameterValues(\"select\");\n        if (model.runIds == null || model.runIds.length < 2) {\n            String msg;\n            msg = \"Select at least 2 runs to \" + model.type + \".\";\n            response.getOutputStream().println(msg);\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);\n            return null;\n        }\n\n        StringBuilder runList = new StringBuilder();\n\n        for (String runId : model.runIds)\n            runList.append(runId).append(\", \");\n\n        runList.setLength(runList.length() - 2); //Strip off the last comma\n        model.runList = runList.toString();\n\n        model.name = RunAnalyzer.suggestName(RunAnalyzer.Type.COMPARE,\n                model.runIds);\n        request.setAttribute(\"editanalysis.model\", model);\n\n        return \"/edit_analysis.jsp\";\n    }\n\n    /**\n     * This method is responsible for analyzing the runs.\n     * @param request\n     * @param response\n     * @return string\n     * @throws java.io.IOException\n     */\n    public String analyze(HttpServletRequest request,\n                          HttpServletResponse response) throws IOException {\n\n        EditAnalysisModel model = new EditAnalysisModel();\n        model.name = request.getParameter(\"output\");\n        model.type = request.getParameter(\"type\");\n        RunAnalyzer.Type type;\n        if (\"compare\".equals(model.type)) {\n            type = RunAnalyzer.Type.COMPARE;\n        } else if (\"average\".equals(model.type)) {\n            type = RunAnalyzer.Type.AVERAGE;\n        } else {\n            String msg = \"Invalid analysis: \" + model.name;\n            response.getWriter().println(msg);\n            logger.severe(msg);\n            response.sendError(HttpServletResponse.SC_CONFLICT, msg);\n            return null;\n        }\n\n        model.runIds = request.getParameterValues(\"select\");\n        boolean analyze = false;\n        boolean redirect = false;\n        if (RunAnalyzer.exists(model.name)) {\n            String replace = request.getParameter(\"replace\");\n            if (replace == null) {\n                request.setAttribute(\"editanalysis.model\", model);\n                return \"/confirm_analysis.jsp\";\n            } else if (\"Replace\".equals(replace)) {\n                analyze = true;\n                redirect = true;\n            } else {\n                redirect = true;\n            }\n        } else {\n            analyze = true;\n            redirect = true;\n        }\n        if (analyze)\n            try {\n                RunAnalyzer.clear(model.name);\n                UserEnv usrEnv = (UserEnv) request.getSession().\n                                                getAttribute(\"usrEnv\");\n                RunAnalyzer.analyze(type, model.runIds, model.name,\n                                                    usrEnv.getUser());\n            } catch (IOException e) {\n                String msg = e.getMessage();\n                response.getWriter().println(msg);\n                logger.log(Level.SEVERE, msg, e);\n                response.sendError(HttpServletResponse.SC_CONFLICT, msg);\n                return null;\n            }\n\n        if (redirect)\n            response.sendRedirect(\"/analysis/\" + model.name + \"/index.html\");\n\n        return null;\n    }\n\n    /**\n     * This method is responsible for archiving the runs to the repository.\n     * @param request\n     * @param response\n     * @return String\n     * @throws java.io.IOException\n     * @throws java.io.FileNotFoundException\n     * @throws java.text.ParseException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public String archive(HttpServletRequest request,\n                        HttpServletResponse response) throws IOException,\n                        FileNotFoundException, ParseException, ClassNotFoundException {\n        //Reading values from request\n        String[] duplicateIds = request.getParameterValues(\"duplicates\");\n        String[] replaceIds = request.getParameterValues(\"replace\");\n        String[] runIds = request.getParameterValues(\"select\");\n        String submitAction = request.getParameter(\"process\");\n\n        HashSet<String> modelDuplicates = new HashSet<String>();\n        HashSet<String> replaceSet = new HashSet<String>();\n        HashSet<File> uploadSet = new HashSet<File>();\n        HashSet<String> uploadedRuns = new HashSet<String>();\n        HashSet<String> duplicateSet = new HashSet<String>();\n        if(replaceIds != null) {\n            for(String replaceId : replaceIds){\n                replaceSet.add(replaceId);\n            }\n        }\n        \n        EditArchiveModel model = new EditArchiveModel();\n        model.runIds = runIds;\n        if (duplicateIds != null) {\n            for (String duplicateId : duplicateIds){\n                modelDuplicates.add(duplicateId);\n            }\n        }\n        model.duplicates = modelDuplicates;\n        if (Config.repositoryURLs != null &&\n                Config.repositoryURLs.length > 1)\n            model.head = \"Repositories\";\n        else\n            model.head = \"Repository\";\n\n        model.results = new RunResult[runIds.length];\n        for (int i = 0; i < runIds.length; i++) {\n            model.results[i] = RunResult.getInstance(new RunId(runIds[i]));\n        }\n\n        if (submitAction.equals(\"Archive\")) {\n            for (int i = 0; i < model.runIds.length; i++) {\n                String runId = model.runIds[i];\n                if (model.duplicates.contains(runId)) {\n                    if (replaceIds != null) {\n                        if (replaceSet.contains(runId)) {\n                            prepareUpload(request, model.results[i],\n                                    uploadedRuns, uploadSet);\n                        } else { // Description or tags got changed, replace anyway...\n                            if (!model.results[i].description.equals(request.\n                                    getParameter(runId + \"_description\")) ||\n                                !model.results[i].tags.toString().equals(request.\n                                    getParameter(runId + \"_tags\"))) {\n                                replaceSet.add(runId);\n                                prepareUpload(request, model.results[i],\n                                        uploadedRuns, uploadSet);\n                            }\n                        }\n                    } else { // Single run, description changed, replace anyway.\n                        if (!model.results[i].description.equals(\n                                request.getParameter(runId + \"_description\")) ||\n                                !model.results[i].tags.toString().equals(request.\n                                    getParameter(runId + \"_tags\"))) {\n                            replaceSet.add(runId);\n                            prepareUpload(request, model.results[i],\n                                    uploadedRuns, uploadSet);\n                        }\n                    }\n                } else {\n                    prepareUpload(request, model.results[i],\n                            uploadedRuns, uploadSet);\n                }\n            }\n        }\n        duplicateSet = uploadRuns(uploadSet,replaceSet);\n        request.setAttribute(\"archive.model\", model);\n        request.setAttribute(\"uploadedRuns\", uploadedRuns);\n        request.setAttribute(\"duplicateRuns\", duplicateSet);\n        return \"/archive_results.jsp\";\n    }\n\n    @SuppressWarnings(\"empty-statement\")\n    private void prepareUpload(HttpServletRequest request, RunResult result,\n                    HashSet<String> uploadedRuns, HashSet<File> uploadSet)\n            throws IOException, ClassNotFoundException {\n        String runId = result.runId.toString();\n        StringBuilder formattedTags = new StringBuilder();\n        File runTagFile = new File(Config.OUT_DIR + runId + \"/META-INF/tags\");\n        String tags = request.getParameter(runId + \"_tags\").trim();\n        TagEngine te = TagEngine.getInstance();\n        if (tags != null && !\"\".equals(tags)) {\n            StringTokenizer t = new StringTokenizer(tags,\" \\n,\");\n            ArrayList<String> tagList = new ArrayList<String>(t.countTokens());\n            while (t.hasMoreTokens()) {\n                String nextT = t.nextToken().trim();\n                if( nextT != null && !\"\".equals(nextT) ){\n                    formattedTags.append(nextT + \"\\n\");\n                    tagList.add(nextT);\n                }\n            }          \n            FileHelper.writeContentToFile(formattedTags.toString(), runTagFile);\n            result.tags = tagList.toArray(new String[tagList.size()]);\n            \n            boolean tagsChanged = true;\n            if (result.tags == null && result.tags.length == 0) {\n                if (tags == null || \"\".equals(tags)) {\n                    tagsChanged = false;\n                }\n            }\n\n            if (tagsChanged) {\n                te.add(runId, result.tags);\n                te.save();\n            }\n        } else {\n            runTagFile.delete();\n            result.tags = new String[1];\n            result.tags[0] = \"&nbsp;\";\n            te.add(runId, new String[0]);\n            te.save();\n        }\n        result.description = request.getParameter(runId + \"_description\");\n        editXML(result);\n        uploadedRuns.add(runId);\n        uploadSet.add(jarUpRun(runId));\n    }\n\n    /**\n     * Edit run.xml file.\n     * @param result The run result object to edit\n     */\n    public static void editXML(RunResult result){\n        try {\n            File resultDir = result.runId.getResultDir();\n            String shortName = result.runId.getBenchName();\n            BenchmarkDescription desc = BenchmarkDescription.readDescription(\n                                        shortName, resultDir.getAbsolutePath());\n            String paramFileName = resultDir.getAbsolutePath() + File.separator\n                                                          + desc.configFileName;\n            ParamRepository param = new ParamRepository(paramFileName, false);\n            param.setParameter(\"fa:runConfig/fh:description\",\n                                                            result.description);\n            param.save();\n        } catch (Exception ex) {\n            Logger.getLogger(ResultAction.class.getName()).\n                    log(Level.SEVERE, null, ex);\n        }\n    }\n\n    /**\n     * Jar up the run by runId.\n     * @param runId\n     * @return File\n     * @throws IOException \n     */\n    private File jarUpRun(String runId) throws IOException{\n    \tString[] files = new File(Config.OUT_DIR, runId).list();\n        File jarFile = new File(Config.TMP_DIR, runId + \".jar\");\n        jar(Config.OUT_DIR + runId, files, jarFile.getAbsolutePath());\n        return jarFile;      \n        //return new File(Config.TMP_DIR, \"test.jar\");\n    }   \n\n    /**\n     * This method is responsible for uploading the runs to repository.\n     * @param uploadSet\n     * @param replaceSet\n     * @return HashSet\n     * @throws java.io.IOException\n     */\n    public static HashSet<String> uploadRuns(HashSet<File> uploadSet,\n                                             HashSet<String> replaceSet)\n            throws IOException {\n        // 3. Upload the run\n        HashSet<String> duplicates = new HashSet<String>();\n\n        // Prepare the parts for the request.\n        ArrayList<Part> params = new ArrayList<Part>();\n        params.add(new StringPart(\"host\", Config.FABAN_HOST));\n        for (String replaceId : replaceSet) {\n            params.add(new StringPart(\"replace\", replaceId));\n        }\n        for (File jarFile : uploadSet) {\n            params.add(new FilePart(\"jarfile\", jarFile));\n        }\n        Part[] parts = new Part[params.size()];\n        parts = params.toArray(parts);\n\n        // Send the request for each reposotory.\n        for (URL repository : Config.repositoryURLs) {\n            URL repos = new URL(repository, \"/controller/uploader/upload_runs\");\n            PostMethod post = new PostMethod(repos.toString());\n            post.setRequestEntity(\n                    new MultipartRequestEntity(parts, post.getParams()));\n\n            HttpClient client = new HttpClient();\n            client.getHttpConnectionManager().getParams().\n                    setConnectionTimeout(5000);\n            int status = client.executeMethod(post);\n\n            if (status == HttpStatus.SC_FORBIDDEN)\n                logger.severe(\"Server denied permission to upload run !\");\n            else if (status == HttpStatus.SC_NOT_ACCEPTABLE)\n                logger.severe(\"Run origin error!\");\n            else if (status != HttpStatus.SC_CREATED)\n                logger.severe(\"Server responded with status code \" +\n                        status + \". Status code 201 (SC_CREATED) expected.\");\n            for (File jarFile : uploadSet) {\n                jarFile.delete();\n            }\n            String response = post.getResponseBodyAsString();\n            StringTokenizer t = new StringTokenizer(response.trim(),\"\\n\");\n            while (t.hasMoreTokens()) {\n                duplicates.add(t.nextToken().trim());\n            }\n        }\n        return duplicates;\n    }\n\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id$\n*\n* Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.BenchmarkDescription;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\nimport com.sun.faban.harness.util.FileHelper;\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.multipart.FilePart;\nimport org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;\nimport org.apache.commons.httpclient.methods.multipart.Part;\nimport org.apache.commons.httpclient.methods.multipart.StringPart;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.net.URL;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * Controller handling actions from the result list screen.\n */\npublic class ResultAction {\n\n    private static Logger logger =\n            Logger.getLogger(ResultAction.class.getName());\n    private SimpleDateFormat dateFormat = new SimpleDateFormat(\n                              \"EEE MM/dd/yy HH:mm:ss z\");\n\n    /**\n     * Checks for actions the user asked to perform and take the appropriate\n     * action.\n     * @param request The request\n     * @param response The response\n     * @return The name of the jsp view to forward this request\n     * @throws IOException If there are problems reading or writing data\n     * @throws ParseException Error parsing input\n     */\n    public String takeAction(HttpServletRequest request,\n                           HttpServletResponse response)\n            throws IOException, ParseException {\n        String process = request.getParameter(\"process\");\n        if (\"Compare\".equals(process))\n            return editAnalysis(process, request, response);\n        if (\"Average\".equals(process))\n            return editAnalysis(process, request, response);\n        if (\"Archive\".equals(process))\n            return editArchive(request, response);\n        return null;\n    }\n\n    /**\n     * The model object for the EditArchive screen view.\n     * This is according to the MVC pattern.\n     */\n    public class EditArchiveModel implements Serializable {\n\n        /** The display header. */\n        public String head;\n\n        /** The run id of the runs to archive. */\n        public String[] runIds;\n\n        /** The set of duplicate runs. */\n        public Set<String> duplicates;\n\n        /** The list of run result objects. */\n        public RunResult[] results;\n    }\n\n    String editArchive(HttpServletRequest request,\n                              HttpServletResponse response) throws IOException,\n                              FileNotFoundException, ParseException {\n        String[] runIds = request.getParameterValues(\"select\");\n\n        if (runIds == null || runIds.length < 1) {\n            String msg;\n            msg = \"Select at least one runs to archive.\";\n            response.getOutputStream().println(msg);\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);\n            return null;\n        }\n        \n        EditArchiveModel model = new EditArchiveModel();\n        model.runIds = runIds;\n        model.duplicates = checkArchivedRuns(runIds);\n\n        if (Config.repositoryURLs != null &&\n                Config.repositoryURLs.length > 1)\n            model.head = \"Repositories\";\n        else\n            model.head = \"Repository\";\n\n        model.results = new RunResult[runIds.length];\n        for (int i = 0; i < runIds.length; i++) {\n            model.results[i] = RunResult.getInstance(new RunId(runIds[i]));\n        }\n        // We use request attributes as not to reflect session state.\n        request.setAttribute(\"editarchive.model\", model);\n        return \"/edit_archive.jsp\";\n    }\n\n    /**\n     * Obtains the tags list for each profile.\n     * @param req\n     * @param resp\n     * @throws java.io.IOException\n     */\n    public void profileTagList (HttpServletRequest req,\n            HttpServletResponse resp) throws IOException {\n        String profile = req.getParameter(\"profileselected\");\n        File tagsFile = new File(Config.PROFILES_DIR + profile + \"/tags\");\n        String tagsForProfile = \"\";\n        if(tagsFile.exists() && tagsFile.length()>0){\n            tagsForProfile = FileHelper.readContentFromFile(tagsFile).trim();\n        }\n        Writer w = resp.getWriter();\n        w.write(tagsForProfile);\n        w.flush();\n        w.close();\n    }\n\n    /*private Set<String> checkArchivedRuns(String[] runIds) throws IOException{\n        StringBuilder b = new StringBuilder();\n        b.append(\"/controller/uploader/check_runs\");\n        int endPath = b.length();      \n        for (String runId : runIds)\n            b.append(\"&select=\").append(runId);\n        b.setCharAt(endPath, '?');\n        HttpURLConnection c = (HttpURLConnection) request.openConnection();\n                if (c.getResponseCode() != 404){\n                    existingRuns.add(runId);\n         }\n\n        HashSet<String> existingRuns = new HashSet<String>();\n        for (String runId : runIds){\n            for (URL repository : Config.repositoryURLs) {\n                URL request = new URL(repository, \"/output/\"+\n                                                 Config.FABAN_HOST+\".\"+runId);\n                URLConnection c = request.openConnection();\n                int len = c.getContentLength();\n                if (len < 0){\n                        existingRuns.add(runId);\n                }\n            }\n        }\n        return existingRuns;\n    }*/\n\n    private String editResultInfo(String runID)\n            throws FileNotFoundException, IOException {\n        RunId runId = new RunId(runID);\n        String ts = null;\n        String[] status = new String[2];\n        File file = new File(Config.OUT_DIR + runID + '/' + Config.RESULT_INFO);\n        RandomAccessFile rf = new RandomAccessFile(file, \"rwd\");\n        long size = rf.length();\n        byte[] buffer = new byte[(int) size];\n        rf.readFully(buffer);\n        String content = new String(buffer, 0, (int) size );\n        int idx = content.indexOf('\\t');\n        if (idx != -1) {\n                status[0] = content.substring(0, idx).trim();\n                status[1] = content.substring(++idx).trim();\n        } else {\n                status[0] = content.trim();\n                int lastIdxln = status[0].lastIndexOf(\"\\n\");\n                if(lastIdxln != -1)\n                    status[0] = status[0].substring(0, lastIdxln-1);\n        }\n        if (status[1] != null) {\n            ts = status[1];\n        }else{\n            String paramFileName = runId.getResultDir().getAbsolutePath() +\n                    File.separator + \"run.xml\";\n            File paramFile = new File(paramFileName);\n            long dt = paramFile.lastModified();\n            ts = dateFormat.format(new Date(dt));\n            rf.seek(rf.length());\n            rf.writeBytes('\\t' + ts.trim());\n        }\n        rf.close();\n        return ts;\n    }\n\n    private Set<String> checkArchivedRuns(String[] runIds) throws\n                            FileNotFoundException, IOException {\n        HashSet<String> existingRuns = new HashSet<String>();\n        String[] runIdTimeStamps = new  String[runIds.length];\n        for (int r=0; r< runIds.length ; r++){\n            String runId = runIds[r];\n            runIdTimeStamps[r] = editResultInfo(runId);\n        }\n        for (URL repository : Config.repositoryURLs) {\n            URL repos = new URL(repository, \"/controller/uploader/check_runs\");\n            PostMethod post = new PostMethod(repos.toString());\n            post.addParameter(\"host\",Config.FABAN_HOST);\n            for (String runId : runIds){\n                post.addParameter(\"runId\",runId);\n            }\n            for (String ts : runIdTimeStamps){\n                post.addParameter(\"ts\",ts);\n            }\n            HttpClient client = new HttpClient();\n            client.getHttpConnectionManager().getParams().\n                    setConnectionTimeout(5000);\n            int status = client.executeMethod(post);\n            if (status != HttpStatus.SC_OK)\n                logger.info(\"SC_OK not ok\");\n\n            String response = post.getResponseBodyAsString();\n            StringTokenizer t = new StringTokenizer(response.trim(),\"\\n\");\n            while (t.hasMoreTokens()) {\n                existingRuns.add(t.nextToken().trim());\n            }\n        }\n        return existingRuns;\n    }\n\n    /**\n     * The model object for the EditAnalysis screen view.\n     * This is according to the MVC pattern.\n     */\n    public static class EditAnalysisModel implements Serializable {\n        /** The header, usually the process type. */\n        public String head;\n\n        /** The type string in all lowercase. */\n        public String type;\n\n        /** The string representation of the list of runs to analyze. */\n        public String runList;\n\n        /** The analysis name. */\n        public String name;\n\n        /** The run ids to analyze. */\n        public String[] runIds;\n    }\n\n    String editAnalysis(String process, HttpServletRequest request,\n                              HttpServletResponse response)\n            throws IOException {\n\n        EditAnalysisModel model = new EditAnalysisModel();\n        model.head = process;\n        model.type = process.toLowerCase();\n\n        model.runIds = request.getParameterValues(\"select\");\n        if (model.runIds == null || model.runIds.length < 2) {\n            String msg;\n            msg = \"Select at least 2 runs to \" + model.type + \".\";\n            response.getOutputStream().println(msg);\n            response.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);\n            return null;\n        }\n\n        StringBuilder runList = new StringBuilder();\n\n        for (String runId : model.runIds)\n            runList.append(runId).append(\", \");\n\n        runList.setLength(runList.length() - 2); //Strip off the last comma\n        model.runList = runList.toString();\n\n        model.name = RunAnalyzer.suggestName(RunAnalyzer.Type.COMPARE,\n                model.runIds);\n        request.setAttribute(\"editanalysis.model\", model);\n\n        return \"/edit_analysis.jsp\";\n    }\n\n    /**\n     * This method is responsible for analyzing the runs.\n     * @param request\n     * @param response\n     * @return string\n     * @throws java.io.IOException\n     */\n    public String analyze(HttpServletRequest request,\n                          HttpServletResponse response) throws IOException {\n\n        EditAnalysisModel model = new EditAnalysisModel();\n        model.name = request.getParameter(\"output\");\n        model.type = request.getParameter(\"type\");\n        RunAnalyzer.Type type;\n        if (\"compare\".equals(model.type)) {\n            type = RunAnalyzer.Type.COMPARE;\n        } else if (\"average\".equals(model.type)) {\n            type = RunAnalyzer.Type.AVERAGE;\n        } else {\n            String msg = \"Invalid analysis: \" + model.name;\n            response.getWriter().println(msg);\n            logger.severe(msg);\n            response.sendError(HttpServletResponse.SC_CONFLICT, msg);\n            return null;\n        }\n\n        model.runIds = request.getParameterValues(\"select\");\n        boolean analyze = false;\n        boolean redirect = false;\n        if (RunAnalyzer.exists(model.name)) {\n            String replace = request.getParameter(\"replace\");\n            if (replace == null) {\n                request.setAttribute(\"editanalysis.model\", model);\n                return \"/confirm_analysis.jsp\";\n            } else if (\"Replace\".equals(replace)) {\n                analyze = true;\n                redirect = true;\n            } else {\n                redirect = true;\n            }\n        } else {\n            analyze = true;\n            redirect = true;\n        }\n        if (analyze)\n            try {\n                RunAnalyzer.clear(model.name);\n                UserEnv usrEnv = (UserEnv) request.getSession().\n                                                getAttribute(\"usrEnv\");\n                RunAnalyzer.analyze(type, model.runIds, model.name,\n                                                    usrEnv.getUser());\n            } catch (IOException e) {\n                String msg = e.getMessage();\n                response.getWriter().println(msg);\n                logger.log(Level.SEVERE, msg, e);\n                response.sendError(HttpServletResponse.SC_CONFLICT, msg);\n                return null;\n            }\n\n        if (redirect)\n            response.sendRedirect(\"/analysis/\" + model.name + \"/index.html\");\n\n        return null;\n    }\n\n    /**\n     * This method is responsible for archiving the runs to the repository.\n     * @param request\n     * @param response\n     * @return String\n     * @throws java.io.IOException\n     * @throws java.io.FileNotFoundException\n     * @throws java.text.ParseException\n     * @throws java.lang.ClassNotFoundException\n     */\n    public String archive(HttpServletRequest request,\n                        HttpServletResponse response) throws IOException,\n                        FileNotFoundException, ParseException, ClassNotFoundException {\n        //Reading values from request\n        String[] duplicateIds = request.getParameterValues(\"duplicates\");\n        String[] replaceIds = request.getParameterValues(\"replace\");\n        String[] runIds = request.getParameterValues(\"select\");\n        String submitAction = request.getParameter(\"process\");\n\n        HashSet<String> modelDuplicates = new HashSet<String>();\n        HashSet<String> replaceSet = new HashSet<String>();\n        HashSet<File> uploadSet = new HashSet<File>();\n        HashSet<String> uploadedRuns = new HashSet<String>();\n        HashSet<String> duplicateSet = new HashSet<String>();\n        if(replaceIds != null) {\n            for(String replaceId : replaceIds){\n                replaceSet.add(replaceId);\n            }\n        }\n        \n        EditArchiveModel model = new EditArchiveModel();\n        model.runIds = runIds;\n        if (duplicateIds != null) {\n            for (String duplicateId : duplicateIds){\n                modelDuplicates.add(duplicateId);\n            }\n        }\n        model.duplicates = modelDuplicates;\n        if (Config.repositoryURLs != null &&\n                Config.repositoryURLs.length > 1)\n            model.head = \"Repositories\";\n        else\n            model.head = \"Repository\";\n\n        model.results = new RunResult[runIds.length];\n        for (int i = 0; i < runIds.length; i++) {\n            model.results[i] = RunResult.getInstance(new RunId(runIds[i]));\n        }\n\n        if (submitAction.equals(\"Archive\")) {\n            for (int i = 0; i < model.runIds.length; i++) {\n                String runId = model.runIds[i];\n                if (model.duplicates.contains(runId)) {\n                    if (replaceIds != null) {\n                        if (replaceSet.contains(runId)) {\n                            prepareUpload(request, model.results[i],\n                                    uploadedRuns, uploadSet);\n                        } else { // Description or tags got changed, replace anyway...\n                            if (!model.results[i].description.equals(request.\n                                    getParameter(runId + \"_description\")) ||\n                                !model.results[i].tags.toString().equals(request.\n                                    getParameter(runId + \"_tags\"))) {\n                                replaceSet.add(runId);\n                                prepareUpload(request, model.results[i],\n                                        uploadedRuns, uploadSet);\n                            }\n                        }\n                    } else { // Single run, description changed, replace anyway.\n                        if (!model.results[i].description.equals(\n                                request.getParameter(runId + \"_description\")) ||\n                                !model.results[i].tags.toString().equals(request.\n                                    getParameter(runId + \"_tags\"))) {\n                            replaceSet.add(runId);\n                            prepareUpload(request, model.results[i],\n                                    uploadedRuns, uploadSet);\n                        }\n                    }\n                } else {\n                    prepareUpload(request, model.results[i],\n                            uploadedRuns, uploadSet);\n                }\n            }\n        }\n        duplicateSet = uploadRuns(runIds, uploadSet,replaceSet);\n        request.setAttribute(\"archive.model\", model);\n        request.setAttribute(\"uploadedRuns\", uploadedRuns);\n        request.setAttribute(\"duplicateRuns\", duplicateSet);\n        return \"/archive_results.jsp\";\n    }\n\n    @SuppressWarnings(\"empty-statement\")\n    private void prepareUpload(HttpServletRequest request, RunResult result,\n                    HashSet<String> uploadedRuns, HashSet<File> uploadSet)\n            throws IOException, ClassNotFoundException {\n        String runId = result.runId.toString();\n        StringBuilder formattedTags = new StringBuilder();\n        File runTagFile = new File(Config.OUT_DIR + runId + \"/META-INF/tags\");\n        String tags = request.getParameter(runId + \"_tags\").trim();\n        TagEngine te = TagEngine.getInstance();\n        if (tags != null && !\"\".equals(tags)) {\n            StringTokenizer t = new StringTokenizer(tags,\" \\n,\");\n            ArrayList<String> tagList = new ArrayList<String>(t.countTokens());\n            while (t.hasMoreTokens()) {\n                String nextT = t.nextToken().trim();\n                if( nextT != null && !\"\".equals(nextT) ){\n                    formattedTags.append(nextT + \"\\n\");\n                    tagList.add(nextT);\n                }\n            }          \n            FileHelper.writeContentToFile(formattedTags.toString(), runTagFile);\n            result.tags = tagList.toArray(new String[tagList.size()]);\n            \n            boolean tagsChanged = true;\n            if (result.tags == null && result.tags.length == 0) {\n                if (tags == null || \"\".equals(tags)) {\n                    tagsChanged = false;\n                }\n            }\n\n            if (tagsChanged) {\n                te.add(runId, result.tags);\n                te.save();\n            }\n        } else {\n            runTagFile.delete();\n            result.tags = new String[1];\n            result.tags[0] = \"&nbsp;\";\n            te.add(runId, new String[0]);\n            te.save();\n        }\n        result.description = request.getParameter(runId + \"_description\");\n        editXML(result);\n        uploadedRuns.add(runId);\n        uploadSet.add(jarUpRun(runId));\n    }\n\n    /**\n     * Edit run.xml file.\n     * @param result The run result object to edit\n     */\n    public static void editXML(RunResult result){\n        try {\n            File resultDir = result.runId.getResultDir();\n            String shortName = result.runId.getBenchName();\n            BenchmarkDescription desc = BenchmarkDescription.readDescription(\n                                        shortName, resultDir.getAbsolutePath());\n            String paramFileName = resultDir.getAbsolutePath() + File.separator\n                                                          + desc.configFileName;\n            ParamRepository param = new ParamRepository(paramFileName, false);\n            param.setParameter(\"fa:runConfig/fh:description\",\n                                                            result.description);\n            param.save();\n        } catch (Exception ex) {\n            Logger.getLogger(ResultAction.class.getName()).\n                    log(Level.SEVERE, null, ex);\n        }\n    }\n\n    /**\n     * Jar up the run by runId.\n     * @param runId\n     * @return File\n     * @throws IOException \n     */\n    private File jarUpRun(String runId) throws IOException{\n    \tString[] files = new File(Config.OUT_DIR, runId).list();\n        File jarFile = new File(Config.TMP_DIR, runId + \".jar\");\n        jar(Config.OUT_DIR + runId, files, jarFile.getAbsolutePath());\n        return jarFile;      \n        //return new File(Config.TMP_DIR, \"test.jar\");\n    }   \n\n    /**\n     * This method is responsible for uploading the runs to repository.\n     * @param uploadSet\n     * @param replaceSet\n     * @return HashSet\n     * @throws java.io.IOException\n     */\n    public static HashSet<String> uploadRuns(String[] runIds,\n                                             HashSet<File> uploadSet,\n                                             HashSet<String> replaceSet)\n            throws IOException {\n        // 3. Upload the run\n        HashSet<String> duplicates = new HashSet<String>();\n\n        // Prepare run id set for cross checking.\n        HashSet<String> runIdSet = new HashSet<String>(runIds.length);\n        for (String runId : runIds) {\n            runIdSet.add(runId);\n        }\n\n        // Prepare the parts for the request.\n        ArrayList<Part> params = new ArrayList<Part>();\n        params.add(new StringPart(\"host\", Config.FABAN_HOST));\n        for (String replaceId : replaceSet) {\n            params.add(new StringPart(\"replace\", replaceId));\n        }\n        for (File jarFile : uploadSet) {\n            params.add(new FilePart(\"jarfile\", jarFile));\n        }\n        Part[] parts = new Part[params.size()];\n        parts = params.toArray(parts);\n\n        // Send the request for each reposotory.\n        for (URL repository : Config.repositoryURLs) {\n            URL repos = new URL(repository, \"/controller/uploader/upload_runs\");\n            PostMethod post = new PostMethod(repos.toString());\n            post.setRequestEntity(\n                    new MultipartRequestEntity(parts, post.getParams()));\n\n            HttpClient client = new HttpClient();\n            client.getHttpConnectionManager().getParams().\n                    setConnectionTimeout(5000);\n            int status = client.executeMethod(post);\n\n            if (status == HttpStatus.SC_FORBIDDEN)\n                logger.warning(\"Server denied permission to upload run !\");\n            else if (status == HttpStatus.SC_NOT_ACCEPTABLE)\n                logger.warning(\"Run origin error!\");\n            else if (status != HttpStatus.SC_CREATED)\n                logger.warning(\"Server responded with status code \" +\n                        status + \". Status code 201 (SC_CREATED) expected.\");\n            for (File jarFile : uploadSet) {\n                jarFile.delete();\n            }\n\n            String response = post.getResponseBodyAsString();\n\n            if (status == HttpStatus.SC_CREATED) {\n\n            StringTokenizer t = new StringTokenizer(response.trim(),\"\\n\");\n            while (t.hasMoreTokens()) {\n                String duplicateRun = t.nextToken().trim();\n                if (duplicateRun.length() > 0)\n                    duplicates.add(duplicateRun.trim());\n            }\n\n            for (Iterator<String> iter = duplicates.iterator(); iter.hasNext();) {\n                String runId = iter.next();\n                if (!runIdSet.contains(runId)) {\n                    logger.warning(\"Unexpected archive response from \" +\n                            repos + \": \"  + runId);\n                    iter.remove();\n                }\n            }\n            } else {\n                logger.warning(\"Message from repository: \" + response);\n            }\n        }\n        return duplicates;\n    }\n}\n","lineNo":602}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.common.NameValuePair;\nimport com.sun.faban.harness.util.XMLReader;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * The ParamRepository is the programmatic representation of the\n * configuration file. It allows access to the xml file via xpath.\n * In addition, the ParamRepository also allows updating the configuration\n * file. Such updates should be made during the validation stage.\n */\npublic class ParamRepository {\n\n\n    private XMLReader reader;\n\n    /**\n     * Constructor: Open specified repository.\n     * @param file Name of repository\n     * @param warnDeprecated Log warning when config file is deprecated\n     */\n    public ParamRepository(String file, boolean warnDeprecated) {\n        reader = new XMLReader(file, true, warnDeprecated);\n        reader.processHostPorts(); //Pre-scan the hosts:ports fields\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return value of the parameter of type string\n     */\n    public String getParameter(String xpath) {\n        return reader.getValue(xpath);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath string\n     * @param top element\n     * @return value of the parameter\n     */\n    public String getParameter(String xpath, Element top) {\n        return reader.getValue(xpath, top);\n    }\n\n    /**\n     * Generic method to get NodeList for a given tagName.\n     * @param tagName of type string\n     * @return NodeList for the tagName\n     */\n    public NodeList getNodeListForTagName(String tagName){\n        return reader.getNodeListForTagName(tagName);\n    }\n\n    /**\n     * Generic method to get a list of top level nodes.\n     * @return NodeList\n     */\n    public NodeList getTopLevelElements() {\n        NodeList topLevelElements = reader.getTopLevelElements();\n        return topLevelElements;\n    }\n\n     /**\n     * Generic method to get NodeList for a given xpath.\n     * @param xPath string\n     * @return NodeList for the xpath\n     */\n    public NodeList getNodes(String xPath) {\n        return reader.getNodes(xPath);\n    }\n\n    /**\n     * Generic method to get NodeList for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return NodeList\n     */\n    public NodeList getNodes(String xPath, Element top) {\n        return reader.getNodes(xPath, top);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath.\n     * @param xPath string\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath) {\n        return reader.getNode(xPath);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath, Element top) {\n        return reader.getNode(xPath, top);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String paramName) {\n        return reader.addNode(baseXPath, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(baseXPath, namespace, prefix, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String paramName) {\n        return reader.addNode(parent, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(parent, namespace, prefix, paramName);\n    }\n\n    /**\n     * Sets or replaces the parameter referenced by the XPath.\n     * @param xpath The xpath referencing the parameter\n     * @param newValue The new value to set\n     */\n    public void setParameter(String xpath, String newValue) {\n        reader.setValue(xpath, newValue);\n    }\n\n    /**\n     * Sets the parameter for a newly added DOM element.\n     * @param element The newly added element\n     * @param value The value to assign to the element\n     */\n    public void setParameter(Element element, String value) {\n        reader.setValue(element, value);\n    }\n\n    /**\n     * Saves the parameter repository back to file if it has been modified.\n     *\n     * @throws Exception If there is an exception saving the repository.\n     */\n    public void save() throws Exception {\n        reader.save(null);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return list containing all paramters with the xpath\n     */\n    public List<String> getParameters(String xpath) {\n        return reader.getValues(xpath);\n    }\n\n    /**\n     * Gets the attribute values for the specified attribute of a certain XPath.\n     *\n     * @param elementPath The XPath of the element\n     * @param attributeName The name of the attribute\n     * @return A list of attribute values\n     */\n    public List<String> getAttributeValues(String elementPath, String attributeName) {\n        return reader.getAttributeValues(elementPath, attributeName);\n    }\n\n    /**\n     * Obtains the list of enabled hosts.\n     * @return A list of enabled hosts, grouped by host type.\n     * @throws ConfigurationException\n     */\n    public List<String[]> getEnabledHosts() throws ConfigurationException {\n        ArrayList<String[]> enabledHosts = new ArrayList<String[]>();\n        List<String[]> hosts = getTokenizedParameters(\n                                            \"fa:hostConfig/fa:host\");\n        List<String> enabled = getParameters(\"fa:hostConfig/fh:enabled\");\n        if(hosts.size() != enabled.size()) {\n            throw new ConfigurationException(\"Number of hosts, \" +\n                    hosts.size() + \", does not match enabled, \" +\n                    enabled.size() + \".\");\n        } else {\n            for(int i = 0; i < hosts.size(); i++) {\n                if(Boolean.valueOf((String) enabled.get(i)).booleanValue()) {\n                    enabledHosts.add(hosts.get(i));\n                } else {\n                    enabledHosts.add(new String[0]);\n                }\n            }\n        }\n        return enabledHosts;\n    }\n\n    /**\n     * Obtains the list of enabled hosts.\n     * @param base element\n     * @return A list of enabled hosts, grouped by host type.\n     * @throws ConfigurationException\n     */\n    public String[] getEnabledHosts(Element base) throws ConfigurationException {\n        String[] enabledHosts;\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base))\n            enabledHosts = getTokenizedValue(\"fa:hostConfig/fa:host\", base);\n        else\n            enabledHosts = new String[0];\n       return enabledHosts;\n    }\n\n    /**\n     * Obtains the list of enabled hostports.\n     * @param base element\n     * @return A list of enabled hostports.\n     * @throws ConfigurationException\n     */\n    public List<NameValuePair<Integer>> getEnabledHostPorts(Element base)\n            throws ConfigurationException {\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base))\n            return getHostPorts(base);\n        else\n            return null;\n    }\n\n    /**\n     * This returns tokenized values of parameters in a list.\n     * Mainly used to get host(s)\n     * @param xpath The xpath to the parameters\n     * @return List of tokenized values\n     */\n    public List<String[]> getTokenizedParameters(String xpath) {\n        ArrayList<String[]> params = new ArrayList<String[]>();\n        List<String> entries = reader.getValues(xpath);\n        for (String entry : entries) {\n            StringTokenizer st = new StringTokenizer(entry);\n            String[] values = new String[st.countTokens()];\n            for (int i = 0; st.hasMoreTokens(); i++)\n                values[i] = st.nextToken();\n            params.add(values);\n        }\n        return params;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath) {\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array, from a specific\n     * base node in the document.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @param base The base element.\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath, Element base) {\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath, base));\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains xpath values matching an xpath, broken into tokens.\n     * @param xpath XPath expression to get  ',' and SPACE seperated \n     * values from a single parameter. For Example sutConfig/instances\n     * The values are seperated by ',' and then by SPACE\n     * @return List of arrays of hostnames\n     */\n    public List<String[]> getTokenizedList(String xpath) {\n        // Each value should be passed as , and SPACE seperated strings\n        ArrayList<String[]> list = new ArrayList<String[]>();\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        while (st.hasMoreTokens()) {\n            ArrayList<String> l = new ArrayList<String>();\n            StringTokenizer st2 = new  StringTokenizer(st.nextToken(), \",\");\n            while (st2.hasMoreTokens())\n                l.add(st2.nextToken());\n\n            list.add(l.toArray(new String[1]));\n        }\n        return list;\n    }\n\n    /**\n     * Obtains the host:port name value pair list from the element\n     * matching this XPath.\n     * @param xPathExpr\n     * @return The list of host:port elements, or null if the XPath does\n     * not exist or does not point to a host:port node.\n     */\n    public List<NameValuePair<Integer>> getHostPorts(String xPathExpr) {\n        return reader.getHostPorts(xPathExpr);\n    }\n\n    /**\n     * Obtains the host:port pairs at this element.\n     * @param base The base element\n     * @return The list of host:port pairs\n     */\n    public List<NameValuePair<Integer>> getHostPorts(Element base) {\n        return reader.getHostPorts(base);\n    }\n\n    /**\n     * Obtains the host/role mappings.\n     * @return The host/role mappings\n     * @throws ConfigurationException Invalid host/role mapping\n     */\n    public List<NameValuePair<String>> getHostRoles()\n            throws ConfigurationException {\n\n        ArrayList<NameValuePair<String>> hostTypeList =\n                new ArrayList<NameValuePair<String>>();\n        NodeList topLevelElements = getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n            if (\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            // Get the type of that host. This is the top level element name.\n            String type = ti.getNodeName();\n\n            // Then add the host and type pair to the list.\n            for (String host : hosts) {\n                NameValuePair<String> hostType = new NameValuePair<String>();\n                hostType.name = host;\n                hostType.value = type;\n                hostTypeList.add(hostType);\n            }\n        }\n        return hostTypeList;\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath) {\n        return  Boolean.valueOf(reader.getValue(xpath)).booleanValue();\n    }\n\n    /**\n     * Obtains the boolean value at the given xpath, providing a default\n     * value if it does not exist or is not a boolean.\n     * @param xpath The given xpath\n     * @param defaultValue The default value\n     * @return The boolean at the xpath, or the given default\n     */\n    public boolean getBooleanValue(String xpath, boolean defaultValue) {\n        String s = reader.getValue(xpath);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base) {\n        return  Boolean.valueOf(reader.getValue(xpath, base)).booleanValue();\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @param defaultValue\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base,\n                                   boolean defaultValue) {\n        String s = reader.getValue(xpath, base);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n}\n\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005-2009 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.common.NameValuePair;\nimport com.sun.faban.harness.util.XMLReader;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * The ParamRepository is the programmatic representation of the\n * configuration file. It allows access to the xml file via xpath.\n * In addition, the ParamRepository also allows updating the configuration\n * file. Such updates should be made during the validation stage.\n */\npublic class ParamRepository {\n\n\n    private XMLReader reader;\n\n    /**\n     * Constructor: Open specified repository.\n     * @param file Name of repository\n     * @param warnDeprecated Log warning when config file is deprecated\n     */\n    public ParamRepository(String file, boolean warnDeprecated) {\n        reader = new XMLReader(file, true, warnDeprecated);\n        reader.processHostPorts(); //Pre-scan the hosts:ports fields\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return value of the parameter of type string\n     */\n    public String getParameter(String xpath) {\n        return reader.getValue(xpath);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath string\n     * @param top element\n     * @return value of the parameter\n     */\n    public String getParameter(String xpath, Element top) {\n        return reader.getValue(xpath, top);\n    }\n\n    /**\n     * Generic method to get NodeList for a given tagName.\n     * @param tagName of type string\n     * @return NodeList for the tagName\n     */\n    public NodeList getNodeListForTagName(String tagName){\n        return reader.getNodeListForTagName(tagName);\n    }\n\n    /**\n     * Generic method to get a list of top level nodes.\n     * @return NodeList\n     */\n    public NodeList getTopLevelElements() {\n        NodeList topLevelElements = reader.getTopLevelElements();\n        return topLevelElements;\n    }\n\n     /**\n     * Generic method to get NodeList for a given xpath.\n     * @param xPath string\n     * @return NodeList for the xpath\n     */\n    public NodeList getNodes(String xPath) {\n        return reader.getNodes(xPath);\n    }\n\n    /**\n     * Generic method to get NodeList for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return NodeList\n     */\n    public NodeList getNodes(String xPath, Element top) {\n        return reader.getNodes(xPath, top);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath.\n     * @param xPath string\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath) {\n        return reader.getNode(xPath);\n    }\n\n    /**\n     * Generic method to get a Node for a given xpath\n     * with respect to base node.\n     * @param xPath string\n     * @param top element\n     * @return Node for the xpath\n     */\n    public Node getNode(String xPath, Element top) {\n        return reader.getNode(xPath, top);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String paramName) {\n        return reader.addNode(baseXPath, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository.\n     * @param baseXPath The base XPath to add this node\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(String baseXPath, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(baseXPath, namespace, prefix, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String paramName) {\n        return reader.addNode(parent, null, null, paramName);\n    }\n\n    /**\n     * Adds a new XPath to the param repository,\n     * based on a previously added parameter.\n     * @param parent The parent element to add this node to\n     * @param namespace The namespace for this new element, if any\n     * @param prefix The namespace prefix for this new element, if any\n     * @param paramName The element name\n     * @return The newly added element, or null on failure\n     */\n    public Element addParameter(Element parent, String namespace,\n                                String prefix, String paramName) {\n        return reader.addNode(parent, namespace, prefix, paramName);\n    }\n\n    /**\n     * Sets or replaces the parameter referenced by the XPath.\n     * @param xpath The xpath referencing the parameter\n     * @param newValue The new value to set\n     */\n    public void setParameter(String xpath, String newValue) {\n        reader.setValue(xpath, newValue);\n    }\n\n    /**\n     * Sets the parameter for a newly added DOM element.\n     * @param element The newly added element\n     * @param value The value to assign to the element\n     */\n    public void setParameter(Element element, String value) {\n        reader.setValue(element, value);\n    }\n\n    /**\n     * Saves the parameter repository back to file if it has been modified.\n     *\n     * @throws Exception If there is an exception saving the repository.\n     */\n    public void save() throws Exception {\n        reader.save(null);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return list containing all paramters with the xpath\n     */\n    public List<String> getParameters(String xpath) {\n        return reader.getValues(xpath);\n    }\n\n    /**\n     * Gets the attribute values for the specified attribute of a certain XPath.\n     *\n     * @param elementPath The XPath of the element\n     * @param attributeName The name of the attribute\n     * @return A list of attribute values\n     */\n    public List<String> getAttributeValues(String elementPath, String attributeName) {\n        return reader.getAttributeValues(elementPath, attributeName);\n    }\n\n    /**\n     * Obtains the list of enabled hosts.\n     * @return A list of enabled hosts, grouped by host type.\n     * @throws ConfigurationException\n     */\n    public List<String[]> getEnabledHosts() throws ConfigurationException {\n        ArrayList<String[]> enabledHosts = new ArrayList<String[]>();\n        List<String[]> hosts = getTokenizedParameters(\n                                            \"fa:hostConfig/fa:host\");\n        List<String> enabled = getParameters(\"fa:hostConfig/fh:enabled\");\n        if(hosts.size() != enabled.size()) {\n            throw new ConfigurationException(\"Number of hosts, \" +\n                    hosts.size() + \", does not match enabled, \" +\n                    enabled.size() + \".\");\n        } else {\n            for(int i = 0; i < hosts.size(); i++) {\n                if(Boolean.valueOf((String) enabled.get(i)).booleanValue()) {\n                    enabledHosts.add(hosts.get(i));\n                } else {\n                    enabledHosts.add(new String[0]);\n                }\n            }\n        }\n        return enabledHosts;\n    }\n\n    /**\n     * Obtains the list of enabled hosts.\n     * @param base element\n     * @return A list of enabled hosts, grouped by host type.\n     * @throws ConfigurationException\n     */\n    public String[] getEnabledHosts(Element base) throws ConfigurationException {\n        String[] enabledHosts;\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base))\n            enabledHosts = getTokenizedValue(\"fa:hostConfig/fa:host\", base);\n        else\n            enabledHosts = new String[0];\n       return enabledHosts;\n    }\n\n    /**\n     * Obtains the list of enabled hostports.\n     * @param base element\n     * @return A list of enabled hostports.\n     * @throws ConfigurationException\n     */\n    public List<NameValuePair<Integer>> getEnabledHostPorts(Element base)\n            throws ConfigurationException {\n        if (getBooleanValue(\"fa:hostConfig/fh:enabled\", base))\n            return getHostPorts(base);\n        else\n            return null;\n    }\n\n    /**\n     * This returns tokenized values of parameters in a list.\n     * Mainly used to get host(s)\n     * @param xpath The xpath to the parameters\n     * @return List of tokenized values\n     */\n    public List<String[]> getTokenizedParameters(String xpath) {\n        ArrayList<String[]> params = new ArrayList<String[]>();\n        List<String> entries = reader.getValues(xpath);\n        for (String entry : entries) {\n            StringTokenizer st = new StringTokenizer(entry);\n            String[] values = new String[st.countTokens()];\n            for (int i = 0; st.hasMoreTokens(); i++)\n                values[i] = st.nextToken();\n            params.add(values);\n        }\n        return params;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath) {\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains the value at an XPath, tokenized into an array, from a specific\n     * base node in the document.\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @param base The base element.\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath, Element base) {\n        String value = reader.getValue(xpath, base);\n        if (value == null)\n            return null;\n        value = value.trim();\n        if (value.length() == 0)\n            return null;\n        StringTokenizer st = new StringTokenizer(value);\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     * Obtains xpath values matching an xpath, broken into tokens.\n     * @param xpath XPath expression to get  ',' and SPACE seperated \n     * values from a single parameter. For Example sutConfig/instances\n     * The values are seperated by ',' and then by SPACE\n     * @return List of arrays of hostnames\n     */\n    public List<String[]> getTokenizedList(String xpath) {\n        // Each value should be passed as , and SPACE seperated strings\n        ArrayList<String[]> list = new ArrayList<String[]>();\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        while (st.hasMoreTokens()) {\n            ArrayList<String> l = new ArrayList<String>();\n            StringTokenizer st2 = new  StringTokenizer(st.nextToken(), \",\");\n            while (st2.hasMoreTokens())\n                l.add(st2.nextToken());\n\n            list.add(l.toArray(new String[1]));\n        }\n        return list;\n    }\n\n    /**\n     * Obtains the host:port name value pair list from the element\n     * matching this XPath.\n     * @param xPathExpr\n     * @return The list of host:port elements, or null if the XPath does\n     * not exist or does not point to a host:port node.\n     */\n    public List<NameValuePair<Integer>> getHostPorts(String xPathExpr) {\n        return reader.getHostPorts(xPathExpr);\n    }\n\n    /**\n     * Obtains the host:port pairs at this element.\n     * @param base The base element\n     * @return The list of host:port pairs\n     */\n    public List<NameValuePair<Integer>> getHostPorts(Element base) {\n        return reader.getHostPorts(base);\n    }\n\n    /**\n     * Obtains the host/role mappings.\n     * @return The host/role mappings\n     * @throws ConfigurationException Invalid host/role mapping\n     */\n    public List<NameValuePair<String>> getHostRoles()\n            throws ConfigurationException {\n\n        ArrayList<NameValuePair<String>> hostTypeList =\n                new ArrayList<NameValuePair<String>>();\n        NodeList topLevelElements = getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n            if (\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            // Get the type of that host. This is the top level element name.\n            String type = ti.getNodeName();\n\n            // Then add the host and type pair to the list.\n            for (String host : hosts) {\n                NameValuePair<String> hostType = new NameValuePair<String>();\n                hostType.name = host;\n                hostType.value = type;\n                hostTypeList.add(hostType);\n            }\n        }\n        return hostTypeList;\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath) {\n        return  Boolean.valueOf(reader.getValue(xpath)).booleanValue();\n    }\n\n    /**\n     * Obtains the boolean value at the given xpath, providing a default\n     * value if it does not exist or is not a boolean.\n     * @param xpath The given xpath\n     * @param defaultValue The default value\n     * @return The boolean at the xpath, or the given default\n     */\n    public boolean getBooleanValue(String xpath, boolean defaultValue) {\n        String s = reader.getValue(xpath);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base) {\n        return  Boolean.valueOf(reader.getValue(xpath, base)).booleanValue();\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean.\n     * @param xpath XPath expression to the value which is true or false\n     * @param base element\n     * @param defaultValue\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath, Element base,\n                                   boolean defaultValue) {\n        String s = reader.getValue(xpath, base);\n        if (s == null || s.length() == 0)\n            return defaultValue;\n        else\n            return Boolean.parseBoolean(s);\n\n    }\n}\n\n","lineNo":326}
{}
{}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.services;\n\nimport com.sun.faban.common.NameValuePair;\nimport com.sun.faban.common.ParamReader;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.Run;\nimport com.sun.faban.harness.engine.CmdService;\nimport com.sun.faban.harness.engine.DeployImageClassLoader;\nimport com.sun.faban.harness.tools.MasterToolContext;\nimport com.sun.faban.harness.tools.ToolDescription;\nimport com.sun.faban.harness.util.XMLReader;\nimport java.rmi.RemoteException;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.ArrayList;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class manages all the services.\n *\n * @author Sheetal Patil\n */\npublic class ServiceManager {\n\n    private static Logger logger =\n            Logger.getLogger(ServiceContext.class.getName());\n\n    private static ServiceManager instance = null;\n\n    private List<ServiceWrapper> loadedServicesList = \n            new ArrayList<ServiceWrapper>();\n    private List<ServiceContext> ctxList = new ArrayList<ServiceContext>();\n\n    private LinkedHashMap<String, ServiceDescription> serviceMap =\n            new LinkedHashMap<String, ServiceDescription>();\n\n    private LinkedHashMap<String, ToolDescription> toolMap =\n            new LinkedHashMap<String, ToolDescription>();\n\n    private LinkedHashMap<String, List<String>> toolSetsMap =\n            new LinkedHashMap<String, List<String>>();\n\n    ArrayList<MasterToolContext> toolList = new ArrayList<MasterToolContext>();\n\n    HashSet<String> activeDeployments = new HashSet<String>();\n\n    ArrayList<NameValuePair<String>> hostDeploymentList =\n                                        new ArrayList<NameValuePair<String>>();\n\n\n    private Run run;\n\n    /**\n     * Obtains the set of active services and tools deployments used in the\n     * current run.\n     * @return The set of active deployements or null if there is no current run\n     */\n    public static Set<String> getActiveDeployments() {\n        Set<String> deployments = null;\n        if (instance != null) {\n            deployments = instance.activeDeployments;\n        }\n        return deployments;\n    }\n\n    /**\n     * Constructor.\n     * @param par\n     * @param run\n     * @throws java.lang.Exception\n     */\n    public ServiceManager(ParamRepository par, Run run)\n            throws Exception{\n        String benchmark = run.getBenchmarkName();\n        this.run = run;\n        // Get the service descriptions and tool descriptions\n        parseAvailableServices(benchmark);\n\n        // Obtain the active service list.\n        parseRequestedServices(par);\n        \n        initiateDownload();\n\n        for (ServiceContext ctx : ctxList) {            \n            DeployImageClassLoader loader = DeployImageClassLoader.getInstance(\n                                ctx.desc.locationType, ctx.desc.location,\n                                getClass().getClassLoader());\n            ServiceWrapper wrapper = new ServiceWrapper(\n                                loader.loadClass(ctx.desc.serviceClass), ctx);\n            loadedServicesList.add(wrapper);\n\n        }\n        this.loadedServicesList = Collections.unmodifiableList(\n                                                            loadedServicesList);\n        this.ctxList = Collections.unmodifiableList(ctxList);\n\n        instance = this;\n    }\n  \n    private void parseAvailableServices(String benchmark) {\n        parseServicesAndTools(\"benchmarks\", benchmark);\n        parseToolSets(\"benchmarks\", benchmark);\n        File serviceDir = new File(Config.SERVICE_DIR);\n        File[] serviceBundles;\n        if (serviceDir.isDirectory()) {\n            serviceBundles = serviceDir.listFiles();\n            for (File serviceBundle : serviceBundles) {\n                if (!serviceBundle.isDirectory())\n                    continue;\n                parseServicesAndTools(\"services\", serviceBundle.getName());\n                parseToolSets(\"services\", serviceBundle.getName());\n            }\n            bindServices();\n        }\n    }\n\n    /**\n     * Parses a service/tool bundle.\n     * @param type The location type, services or benchmark\n     * @param dir The deploy jar name, without .jar\n     */\n    public void parseServicesAndTools(String type, String dir) {\n\n        String metaInf = Config.FABAN_HOME + File.separator + type +\n                File.separator + dir + File.separator + \"META-INF\";\n        File metaInfDir = new File(metaInf);\n        if (!metaInfDir.isDirectory()) {\n            return;\n        }\n        File serviceXml = new File(metaInf + File.separator +\n                    \"services-tools.xml\");\n        try {\n            if (serviceXml.exists()) {\n                XMLReader reader = new XMLReader(metaInf + File.separator +\n                        \"services-tools.xml\");\n                Element root = null;\n                if (reader != null) {\n                    root = reader.getRootNode();\n\n                    // First, parse the services.\n                    NodeList serviceNodes = reader.getNodes(\"service\", root);\n                    for (int i = 0; i < serviceNodes.getLength(); i++) {\n\n                        Node serviceNode = serviceNodes.item(i);\n                        if (serviceNode.getNodeType() != Node.ELEMENT_NODE) {\n                            continue;\n                        }\n                        Element se = (Element) serviceNode;\n                        String id = null;\n                        NamedNodeMap attrList = serviceNode.getAttributes();\n                        for (int j = 0; j < attrList.getLength(); j++) {\n                            if (attrList.item(j).getNodeType() ==\n                                    Node.ATTRIBUTE_NODE) {\n                                if (attrList.item(j).getNodeName().equals(\"id\")) {\n                                    id = attrList.item(j).getNodeValue();\n                                }\n                            }\n                        }\n                        NodeList classNodes = serviceNode.getChildNodes();\n                        String loadableClass = null;\n                        for (int k = 0; k < classNodes.getLength(); k++) {\n                            if (classNodes.item(k).getNodeType() ==\n                                    Node.ELEMENT_NODE) {\n                                loadableClass = reader.getValue(\"class\", se);\n\n                            }\n                        }\n                        if (id != null && loadableClass != null) {\n                            if (serviceMap.containsKey(id)) {\n                                logger.log(Level.WARNING,\n                                        \"Ignoring duplicate service \" + id +\n                                        \" in \" + type + File.separator + dir);\n                            } else {\n                                ServiceDescription desc =\n                                        new ServiceDescription(id,\n                                                loadableClass, type, dir);\n                                serviceMap.put(id, desc);\n                            }\n                        }\n                    }\n\n                    // Then parse the tools.\n                    NodeList toolNodes = reader.getNodes(\"tool\", root);\n                    for (int i = 0; i < toolNodes.getLength(); i++) {\n                        String id = null;\n                        String serviceName = null;\n                        String toolClass = null;\n                        Node toolNode = toolNodes.item(i);\n                        if (toolNode.getNodeType() != Node.ELEMENT_NODE) {\n                            continue;\n                        }\n                        Element te = (Element) toolNode;\n                        NamedNodeMap attrList = toolNode.getAttributes();\n                        for (int j = 0; j < attrList.getLength(); j++) {\n                            if (attrList.item(j).getNodeType() ==\n                                    Node.ATTRIBUTE_NODE) {\n                                if (attrList.item(j).getNodeName().equals(\"id\")) {\n                                    id = attrList.item(j).getNodeValue();\n                                }\n                                if (attrList.item(j).getNodeName().\n                                        equals(\"service\")) {\n                                    serviceName = attrList.item(j).getNodeValue();\n                                }\n                            }\n                        }\n                        NodeList classNodes = toolNode.getChildNodes();\n                        for (int k = 0; k < classNodes.getLength(); k++) {\n                            if (classNodes.item(k).getNodeType() ==\n                                    Node.ELEMENT_NODE) {\n                                toolClass = reader.getValue(\"class\", te);\n                            }\n                        }\n\n                        if (id != null) {\n                            String key = id;\n                            if (serviceName != null) {\n                                key += '/' + serviceName;\n                                if (toolMap.containsKey(key)) {\n                                    logger.log(Level.WARNING,\n                                            \"Ignoring duplicate tool\" + id);\n                                } else {\n                                    toolMap.put(key, new ToolDescription(id,\n                                            serviceName, toolClass, type, dir));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch  (Exception e) {\n            logger.log(Level.WARNING, \"Error reading benchmark \" +\n                    \"descriptor for \" + dir, e);\n        }\n    }\n\n    private void bindServices() {\n        Iterator<Map.Entry<String, ToolDescription>> iter =\n                toolMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry<String, ToolDescription> entry = iter.next();\n            ToolDescription toolDesc = entry.getValue();\n            if (!toolDesc.bind(serviceMap))\n                logger.warning(\"Tool \" + toolDesc.getId() + \" at \" +\n                        toolDesc.getLocationType() + File.separator +\n                        toolDesc.getLocation() +\n                        \" references non-existent service \" +\n                        toolDesc.getServiceName());\n        }\n    }\n\n\n    private void parseRequestedServices(ParamRepository par)\n            throws IOException, ConfigurationException {\n        HashSet<NameValuePair<String>> hostDeploymentSet =\n                new HashSet<NameValuePair<String>>();\n\n        NodeList topLevelElements = par.getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        Properties properties = null;\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n            if (ParamReader.FABANURI.equals(ns) && \"fa:runConfig\".\n                    equals(topElement))\n                continue;\n            if(\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = par.getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            // Get the services\n            NodeList serviceNodes = par.getNodes(\"fh:service\", ti);\n            int serviceCount = serviceNodes.getLength();\n            for (int j = 0; j < serviceCount; j++) {\n                Element serviceElement = (Element) serviceNodes.item(j);\n                String serviceName = par.getParameter(\"fh:name\",\n                                                        serviceElement);\n                boolean restart = par.getBooleanValue(\"fh:restart\",\n                                                      serviceElement);\n                Node configNode = par.getNode(\"fh:config\", serviceElement);\n                if(configNode != null) {\n                    properties = new Properties();\n                    NodeList propsList = configNode.getChildNodes();\n                    for (int k = 0; k < propsList.getLength(); k++) {\n                        if (propsList.item(k).getNodeType() ==\n                                Node.ELEMENT_NODE) {\n                            Element propElement = (Element) propsList.item(k);\n                            String key = propsList.item(k).getNodeName();\n                            NodeList props = propElement.getChildNodes();\n                            int propValueLength = props.getLength();\n                            for (int l = 0; l < propValueLength; l++) {\n                                Node valueNode = (Node) props.item(l);\n                                if (valueNode.getNodeType() == Node.TEXT_NODE) {\n                                    String value =\n                                            valueNode.getNodeValue().trim();\n                                    properties.setProperty(key, value);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                ServiceDescription sd = serviceMap.get(serviceName);\n\n                if (sd == null) {\n                    logger.warning(\"Cannot find service: \" + serviceName +\n                                   \". Service may not be deployed.\");\n                    continue;\n                }\n\n                // Benchmarks get loaded automatically and have their checks.\n                // We need to mark a service only in the services directory.\n                if (\"services\".equals(sd.locationType)) {\n                    File runIdFile = new File(Config.SERVICE_DIR +\n                                sd.location + File.separator +\n                                \"META-INF\" + File.separator + \"RunID\");\n                    FileWriter wFile = new FileWriter(runIdFile);\n                    wFile.write(run.getRunId());\n                    wFile.close();\n                }\n\n                ServiceContext ctx =\n                        new ServiceContext(sd, par, ti, properties, restart);\n                ctxList.add(ctx);\n                if (\"services\".equals(sd.locationType)) {\n                    String fullLocation = sd.locationType + '/' + sd.location;\n                    activeDeployments.add(fullLocation);\n\n                    CmdService cmds = CmdService.getHandle();\n                    String[] ctxHosts = ctx.getHosts();\n                    for (String ctxHost : ctxHosts) {\n                        if (hostDeploymentSet.add(new NameValuePair<String>(\n                                cmds.getHostName(ctxHost), fullLocation))) {\n                            hostDeploymentList.add(new NameValuePair<String>(\n                                    ctxHost, fullLocation));\n                        }\n                    }\n                }\n                String toolCmds = par.getParameter(\"fh:tools\", serviceElement);\n                Set<String> tools = new LinkedHashSet<String>();\n                if (toolCmds.toUpperCase().equals(\"NONE\")) {\n                }else if(toolCmds.length() != 0){\n                    StringTokenizer st = new StringTokenizer(toolCmds, \";\");\n                    while (st.hasMoreTokens()) {\n                        tools.add(st.nextToken().trim());\n                    }\n                }else if (\"\".equals(toolCmds) && toolCmds.length() == 0){\n                    String key = \"default\" + '/' + serviceName;\n                    Set<String> toolset_tools = new LinkedHashSet<String>();\n                    if(toolSetsMap.containsKey(key)){\n                            toolset_tools.addAll(toolSetsMap.get(key));\n                            for (String t1 : toolset_tools){\n                                StringTokenizer tt1 = new StringTokenizer(t1);\n                                String toolId1 = tt1.nextToken();\n                                String toolKey1 = toolId1 + '/' + serviceName;\n                                ToolDescription toolDesc = toolMap.get(toolKey1);\n                                MasterToolContext toolCtx = null;\n                                if (toolDesc != null) {\n                                    toolCtx = new MasterToolContext(t1, ctx,\n                                            toolDesc);\n                                } else {\n                                    toolDesc = toolMap.get(toolId1);\n                                    if (toolDesc != null) {\n                                        toolCtx = new MasterToolContext(\n                                                t1, ctx, toolDesc);\n                                        activeDeployments.add(\n                                                toolDesc.getLocationType() +\n                                                File.separator +\n                                                toolDesc.getLocation());\n                                    } else {\n                                        //logger.info(\"No Tool Description for tool: \" + t1);\n                                        logger.fine(\"No Tool Description for tool: \"\n                                                + t1 +\" ,so it's a command line tool\");\n                                        toolCtx = new MasterToolContext(\n                                                t1, ctx, null);\n                                    }\n                                }\n                                if (toolCtx != null) {\n                                    toolList.add(toolCtx);\n                                }\n                            }\n                        }\n\n                }\n                for (String tool : tools) {\n                    StringTokenizer tt = new StringTokenizer(tool);\n                    String toolId = tt.nextToken();\n                    String toolKey = toolId + '/' + serviceName;\n                    Set<String> toolset_tools = new LinkedHashSet<String>();\n                    if (toolSetsMap.containsKey(toolKey)) {\n                        toolset_tools.addAll(toolSetsMap.get(toolKey));\n                        for (String t1 : toolset_tools) {\n                            StringTokenizer tt1 = new StringTokenizer(t1);\n                            String toolId1 = tt1.nextToken();\n                            String toolKey1 = toolId1 + '/' + serviceName;\n                            ToolDescription toolDesc = toolMap.get(toolKey1);\n                            MasterToolContext toolCtx = null;\n                            if (toolDesc != null) {\n                                toolCtx = new MasterToolContext(t1, ctx, toolDesc);\n                            } else {\n                                toolDesc = toolMap.get(toolId1);\n                                if (toolDesc != null) {\n                                    toolCtx = new MasterToolContext(\n                                            t1, ctx, toolDesc);\n                                } else {\n                                    //logger.info(\"No Tool Description for tool: \" + t1);\n                                    logger.fine(\"No Tool Description for tool: \" + t1 + \" ,so it's a command line tool\");\n                                    toolCtx = new MasterToolContext(\n                                            t1, ctx, null);\n                                }\n                            }\n                            if (toolCtx != null) {\n                                toolList.add(toolCtx);\n                            }\n                        }\n                    } else {\n                        ToolDescription toolDesc = toolMap.get(toolKey);\n                        MasterToolContext toolCtx = null;\n                        if (toolDesc != null) {\n                            toolCtx = new MasterToolContext(tool, ctx, toolDesc);\n                        } else {\n                            toolDesc = toolMap.get(toolId);\n                            if (toolDesc != null) {\n                                toolCtx = new MasterToolContext(\n                                        tool, ctx, toolDesc);\n                            } else {\n                                //logger.info(\"No Tool Description for tool: \" + tool);\n                                logger.fine(\"No Tool Description for tool: \" + tool + \" ,so it's a command line tool\");\n                                toolCtx = new MasterToolContext(\n                                        tool, ctx, null);\n                            }\n                        }\n                        if (toolCtx != null) {\n                            toolList.add(toolCtx);\n                        }\n                    }\n                }\n                for (MasterToolContext toolCtx : toolList) {\n                    String locationType =\n                            toolCtx.getToolDescription().getLocationType();\n                    if (\"services\".equals(locationType)) {\n                        String fullLocation = locationType + '/' +\n                                toolCtx.getToolDescription().getLocation();\n                        activeDeployments.add(fullLocation);\n\n                        CmdService cmds = CmdService.getHandle();\n                        String[] ctxHosts =\n                                toolCtx.getToolServiceContext().getHosts();\n                        for (String ctxHost : ctxHosts) {\n                            if (hostDeploymentSet.add(new NameValuePair<String>(\n                                    cmds.getHostName(ctxHost), fullLocation))) {\n                                hostDeploymentList.add(new NameValuePair<String>(\n                                        ctxHost, fullLocation));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Parses and creates the appropriate structures for the tool sets.\n     * @param type The location type, services or benchmark\n     * @param dir The deploy jar name, without .jar\n     */\n    public void parseToolSets(String type, String dir) {\n        String metaInf = Config.FABAN_HOME + File.separator + type +\n                File.separator + dir + File.separator + \"META-INF\";\n        File metaInfDir = new File(metaInf);\n        if (!metaInfDir.isDirectory()) {\n            return;\n        }\n        File toolsetsXml = new File(metaInf + File.separator +\n                    \"toolsets.xml\");\n        try {\n            if(toolsetsXml.exists()){\n                XMLReader reader = new XMLReader(metaInf + File.separator +\n                        \"toolsets.xml\");\n                Element root = null;\n                if (reader != null) {\n                    root = reader.getRootNode();\n\n                    // First, parse the services.\n                    NodeList toolsetsNodes = reader.getNodes(\"toolset\", root);\n                    for (int i = 0; i < toolsetsNodes.getLength(); i++) {\n\n                        Node toolsetsNode = toolsetsNodes.item(i);\n                        if (toolsetsNode.getNodeType() != Node.ELEMENT_NODE) {\n                            continue;\n                        }\n                        Element tse = (Element) toolsetsNode;\n                        ArrayList<String> toolsCmds = new ArrayList<String>();\n                        String service = reader.getValue(\"service\", tse);\n                        String name = reader.getValue(\"name\", tse);\n                        String base = reader.getValue(\"base\", tse);\n                        List<String> toolIncludes = reader.getValues(\"includes\", tse);\n                        List<String> toolExcludes = reader.getValues(\"excludes\", tse);\n                        if(!\"\".equals(base)){\n                            toolsCmds.addAll(toolSetsMap.get(base+\"/\"+service));\n                        }\n                        if(toolIncludes != null){\n                            for (String tool : toolIncludes){\n                                StringTokenizer st = new StringTokenizer(tool, \";\");\n                                while(st.hasMoreTokens())\n                                    toolsCmds.add(st.nextToken().trim());\n                            }\n                        }\n                        if(toolExcludes != null){\n                            ArrayList<String> td = new ArrayList<String>();\n                            for (String tool : toolExcludes){\n                                StringTokenizer st = new StringTokenizer(tool, \";\");\n                                while(st.hasMoreTokens())\n                                    td.add(st.nextToken().trim());\n                            }\n                            toolsCmds.removeAll(td);\n                        }\n\n                        if (!\"\".equals(service) && !\"\".equals(name) &&\n                                (toolIncludes != null || base != null)) {\n                            String key = name+\"/\"+service;\n                            if (toolSetsMap.containsKey(key)) {\n                                logger.log(Level.WARNING,\n                                        \"Ignoring duplicate toolset = \" + key);\n                            } else {\n                                toolSetsMap.put(key, toolsCmds);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch  (Exception e) {\n            logger.log(Level.WARNING, \"Error reading toolsets.xml \" +\n                    \"for \" + dir, e);\n        }        \n    }\n\n    private void initiateDownload() throws RemoteException {\n        HashMap<String, List<String>> downloadMap = new HashMap<String, List<String>>();\n        for (NameValuePair<String> hostPath : hostDeploymentList) {\n            List<String> pathList = downloadMap.get(hostPath.name);\n            if (pathList == null) {\n                pathList = new ArrayList<String>();\n                downloadMap.put(hostPath.name, pathList);\n            }\n            pathList.add(hostPath.value);\n        }\n\n        Set<Map.Entry<String, List<String>>> entrySet = downloadMap.entrySet();\n        CmdService cmds = CmdService.getHandle();\n        for (Map.Entry<String, List<String>> entry : entrySet) {\n            cmds.downloadFiles(entry.getKey(), entry.getValue());\n        }\n    }\n\n    /**\n     * Returns a list of MasterToolContext.\n     * @return List\n     */\n    public List<MasterToolContext> getTools() {\n        return toolList;\n    }\n\n    /**\n     * Configures the service.\n     */\n    public void configure() {\n        for(ServiceWrapper sw : loadedServicesList){\n            try {\n                sw.configure();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to configure service \" +\n                        sw.ctx.desc.id, e);\n            }\n        }\n    }\n\n    /**\n     * Obtains the configuration of a service.\n     */\n    public void getConfig() {\n        for(ServiceWrapper sw : loadedServicesList){\n            try {\n                sw.getConfig();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to obtain service \" +\n                        \"configuration for service \" + sw.ctx.desc.id, e);\n            }\n        }\n    }\n\n    /**\n     * Obtains the logs of a service.\n     */\n    public void getLogs() {\n        for(ServiceWrapper sw : loadedServicesList){\n            try {\n                sw.getLogs();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to obtain service logs \" +\n                        \"for service \" + sw.ctx.desc.id, e);\n             }\n        }\n    }\n\n    /**\n     * Starts a service. If the service is marked for restart,\n     * this will shutdown the service and restart it.\n     */\n    public void startup() {\n        // Use two separate loops to leave some time\n        // between shutdown and startup.\n        for(ServiceWrapper sw : loadedServicesList){\n            if (sw.ctx.restart) {\n                try {\n                    sw.shutdown();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to shutdown service \" +\n                            sw.ctx.desc.id, e);\n                }\n                try {\n                    sw.clearLogs();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to clear service logs \" +\n                            \"for service \" + sw.ctx.desc.id, e);\n                }\n            }\n        }\n\n        for(ServiceWrapper sw : loadedServicesList){\n            if (sw.ctx.restart) {\n                try {\n                    sw.startup();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to startup service \" +\n                            sw.ctx.desc.id, e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Stops a service.\n     */\n    public void shutdown() {\n        for (ServiceContext ctx : ctxList) {\n            if (\"services\".equals(ctx.desc.locationType)) {\n                File runIdFile = new File(Config.SERVICE_DIR +\n                        ctx.desc.location + File.separator +\n                        \"META-INF\" + File.separator + \"RunID\");\n                if (runIdFile.exists())\n                    runIdFile.delete();\n            }\n        }\n        for(ServiceWrapper sw : loadedServicesList){\n            if (sw.ctx.restart)\n                try {\n                    sw.shutdown();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to shutdown service \" +\n                            sw.ctx.desc.id, e);\n                }\n        }\n        instance = null;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.services;\n\nimport com.sun.faban.common.NameValuePair;\nimport com.sun.faban.common.ParamReader;\nimport com.sun.faban.harness.ConfigurationException;\nimport com.sun.faban.harness.ParamRepository;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.Run;\nimport com.sun.faban.harness.engine.CmdService;\nimport com.sun.faban.harness.engine.DeployImageClassLoader;\nimport com.sun.faban.harness.tools.MasterToolContext;\nimport com.sun.faban.harness.tools.ToolDescription;\nimport com.sun.faban.harness.util.XMLReader;\nimport java.rmi.RemoteException;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NamedNodeMap;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.ArrayList;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This class manages all the services.\n *\n * @author Sheetal Patil\n */\npublic class ServiceManager {\n\n    private static Logger logger =\n            Logger.getLogger(ServiceContext.class.getName());\n\n    private static ServiceManager instance = null;\n\n    private List<ServiceWrapper> loadedServicesList = \n            new ArrayList<ServiceWrapper>();\n    private List<ServiceContext> ctxList = new ArrayList<ServiceContext>();\n\n    private LinkedHashMap<String, ServiceDescription> serviceMap =\n            new LinkedHashMap<String, ServiceDescription>();\n\n    private LinkedHashMap<String, ToolDescription> toolMap =\n            new LinkedHashMap<String, ToolDescription>();\n\n    private LinkedHashMap<String, List<String>> toolSetsMap =\n            new LinkedHashMap<String, List<String>>();\n\n    ArrayList<MasterToolContext> toolList = new ArrayList<MasterToolContext>();\n\n    HashSet<String> activeDeployments = new HashSet<String>();\n\n    ArrayList<NameValuePair<String>> hostDeploymentList =\n                                        new ArrayList<NameValuePair<String>>();\n\n\n    private Run run;\n\n    /**\n     * Obtains the set of active services and tools deployments used in the\n     * current run.\n     * @return The set of active deployements or null if there is no current run\n     */\n    public static Set<String> getActiveDeployments() {\n        Set<String> deployments = null;\n        if (instance != null) {\n            deployments = instance.activeDeployments;\n        }\n        return deployments;\n    }\n\n    /**\n     * Constructor.\n     * @param par\n     * @param run\n     * @throws java.lang.Exception\n     */\n    public ServiceManager(ParamRepository par, Run run)\n            throws Exception{\n        String benchmark = run.getBenchmarkName();\n        this.run = run;\n        // Get the service descriptions and tool descriptions\n        parseAvailableServices(benchmark);\n\n        // Obtain the active service list.\n        parseRequestedServices(par);\n        \n        initiateDownload();\n\n        for (ServiceContext ctx : ctxList) {            \n            DeployImageClassLoader loader = DeployImageClassLoader.getInstance(\n                                ctx.desc.locationType, ctx.desc.location,\n                                getClass().getClassLoader());\n            ServiceWrapper wrapper = new ServiceWrapper(\n                                loader.loadClass(ctx.desc.serviceClass), ctx);\n            loadedServicesList.add(wrapper);\n\n        }\n        this.loadedServicesList = Collections.unmodifiableList(\n                                                            loadedServicesList);\n        this.ctxList = Collections.unmodifiableList(ctxList);\n\n        instance = this;\n    }\n  \n    private void parseAvailableServices(String benchmark) {\n        parseServicesAndTools(\"benchmarks\", benchmark);\n        parseToolSets(\"benchmarks\", benchmark);\n        File serviceDir = new File(Config.SERVICE_DIR);\n        File[] serviceBundles;\n        if (serviceDir.isDirectory()) {\n            serviceBundles = serviceDir.listFiles();\n            for (File serviceBundle : serviceBundles) {\n                if (!serviceBundle.isDirectory())\n                    continue;\n                parseServicesAndTools(\"services\", serviceBundle.getName());\n                parseToolSets(\"services\", serviceBundle.getName());\n            }\n            bindServices();\n        }\n    }\n\n    /**\n     * Parses a service/tool bundle.\n     * @param type The location type, services or benchmark\n     * @param dir The deploy jar name, without .jar\n     */\n    public void parseServicesAndTools(String type, String dir) {\n\n        String metaInf = Config.FABAN_HOME + File.separator + type +\n                File.separator + dir + File.separator + \"META-INF\";\n        File metaInfDir = new File(metaInf);\n        if (!metaInfDir.isDirectory()) {\n            return;\n        }\n        File serviceXml = new File(metaInf + File.separator +\n                    \"services-tools.xml\");\n        try {\n            if (serviceXml.exists()) {\n                XMLReader reader = new XMLReader(metaInf + File.separator +\n                        \"services-tools.xml\");\n                Element root = null;\n                if (reader != null) {\n                    root = reader.getRootNode();\n\n                    // First, parse the services.\n                    NodeList serviceNodes = reader.getNodes(\"service\", root);\n                    for (int i = 0; i < serviceNodes.getLength(); i++) {\n\n                        Node serviceNode = serviceNodes.item(i);\n                        if (serviceNode.getNodeType() != Node.ELEMENT_NODE) {\n                            continue;\n                        }\n                        Element se = (Element) serviceNode;\n                        String id = null;\n                        NamedNodeMap attrList = serviceNode.getAttributes();\n                        for (int j = 0; j < attrList.getLength(); j++) {\n                            if (attrList.item(j).getNodeType() ==\n                                    Node.ATTRIBUTE_NODE) {\n                                if (attrList.item(j).getNodeName().equals(\"id\")) {\n                                    id = attrList.item(j).getNodeValue();\n                                }\n                            }\n                        }\n                        NodeList classNodes = serviceNode.getChildNodes();\n                        String loadableClass = null;\n                        for (int k = 0; k < classNodes.getLength(); k++) {\n                            if (classNodes.item(k).getNodeType() ==\n                                    Node.ELEMENT_NODE) {\n                                loadableClass = reader.getValue(\"class\", se);\n\n                            }\n                        }\n                        if (id != null && loadableClass != null) {\n                            if (serviceMap.containsKey(id)) {\n                                logger.log(Level.WARNING,\n                                        \"Ignoring duplicate service \" + id +\n                                        \" in \" + type + File.separator + dir);\n                            } else {\n                                ServiceDescription desc =\n                                        new ServiceDescription(id,\n                                                loadableClass, type, dir);\n                                serviceMap.put(id, desc);\n                            }\n                        }\n                    }\n\n                    // Then parse the tools.\n                    NodeList toolNodes = reader.getNodes(\"tool\", root);\n                    for (int i = 0; i < toolNodes.getLength(); i++) {\n                        String id = null;\n                        String serviceName = null;\n                        String toolClass = null;\n                        Node toolNode = toolNodes.item(i);\n                        if (toolNode.getNodeType() != Node.ELEMENT_NODE) {\n                            continue;\n                        }\n                        Element te = (Element) toolNode;\n                        NamedNodeMap attrList = toolNode.getAttributes();\n                        for (int j = 0; j < attrList.getLength(); j++) {\n                            if (attrList.item(j).getNodeType() ==\n                                    Node.ATTRIBUTE_NODE) {\n                                if (attrList.item(j).getNodeName().equals(\"id\")) {\n                                    id = attrList.item(j).getNodeValue();\n                                }\n                                if (attrList.item(j).getNodeName().\n                                        equals(\"service\")) {\n                                    serviceName = attrList.item(j).getNodeValue();\n                                }\n                            }\n                        }\n                        NodeList classNodes = toolNode.getChildNodes();\n                        for (int k = 0; k < classNodes.getLength(); k++) {\n                            if (classNodes.item(k).getNodeType() ==\n                                    Node.ELEMENT_NODE) {\n                                toolClass = reader.getValue(\"class\", te);\n                            }\n                        }\n\n                        if (id != null) {\n                            String key = id;\n                            if (serviceName != null) {\n                                key += '/' + serviceName;\n                                if (toolMap.containsKey(key)) {\n                                    logger.log(Level.WARNING,\n                                            \"Ignoring duplicate tool\" + id);\n                                } else {\n                                    toolMap.put(key, new ToolDescription(id,\n                                            serviceName, toolClass, type, dir));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch  (Exception e) {\n            logger.log(Level.WARNING, \"Error reading benchmark \" +\n                    \"descriptor for \" + dir, e);\n        }\n    }\n\n    private void bindServices() {\n        Iterator<Map.Entry<String, ToolDescription>> iter =\n                toolMap.entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry<String, ToolDescription> entry = iter.next();\n            ToolDescription toolDesc = entry.getValue();\n            if (!toolDesc.bind(serviceMap))\n                logger.warning(\"Tool \" + toolDesc.getId() + \" at \" +\n                        toolDesc.getLocationType() + File.separator +\n                        toolDesc.getLocation() +\n                        \" references non-existent service \" +\n                        toolDesc.getServiceName());\n        }\n    }\n\n\n    private void parseRequestedServices(ParamRepository par)\n            throws IOException, ConfigurationException {\n        HashSet<NameValuePair<String>> hostDeploymentSet =\n                new HashSet<NameValuePair<String>>();\n\n        NodeList topLevelElements = par.getTopLevelElements();\n        int topLevelSize = topLevelElements.getLength();\n        Properties properties = null;\n        for (int i = 0; i < topLevelSize; i++) {\n            Node node = topLevelElements.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element ti = (Element) node;\n            String ns = ti.getNamespaceURI();\n            String topElement = ti.getNodeName();\n            if (ParamReader.FABANURI.equals(ns) && \"fa:runConfig\".\n                    equals(topElement))\n                continue;\n            if(\"http://faban.sunsource.net/ns/fabanharness\".equals(ns) &&\n                    \"jvmConfig\".equals(topElement))\n                continue;\n\n            // Get the hosts\n            String[] hosts = par.getEnabledHosts(ti);\n            if (hosts == null || hosts.length == 0)\n                continue;\n\n            // Get the services\n            NodeList serviceNodes = par.getNodes(\"fh:service\", ti);\n            int serviceCount = serviceNodes.getLength();\n            for (int j = 0; j < serviceCount; j++) {\n                Element serviceElement = (Element) serviceNodes.item(j);\n                String serviceName = par.getParameter(\"fh:name\",\n                                                        serviceElement);\n                boolean restart = par.getBooleanValue(\"fh:restart\",\n                                                      serviceElement);\n                Node configNode = par.getNode(\"fh:config\", serviceElement);\n                if(configNode != null) {\n                    properties = new Properties();\n                    NodeList propsList = configNode.getChildNodes();\n                    for (int k = 0; k < propsList.getLength(); k++) {\n                        if (propsList.item(k).getNodeType() ==\n                                Node.ELEMENT_NODE) {\n                            Element propElement = (Element) propsList.item(k);\n                            String key = propsList.item(k).getNodeName();\n                            NodeList props = propElement.getChildNodes();\n                            int propValueLength = props.getLength();\n                            for (int l = 0; l < propValueLength; l++) {\n                                Node valueNode = (Node) props.item(l);\n                                if (valueNode.getNodeType() == Node.TEXT_NODE) {\n                                    String value =\n                                            valueNode.getNodeValue().trim();\n                                    properties.setProperty(key, value);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                ServiceDescription sd = serviceMap.get(serviceName);\n\n                if (sd == null) {\n                    logger.warning(\"Cannot find service: \" + serviceName +\n                                   \". Service may not be deployed.\");\n                    continue;\n                }\n\n                // Benchmarks get loaded automatically and have their checks.\n                // We need to mark a service only in the services directory.\n                if (\"services\".equals(sd.locationType)) {\n                    File runIdFile = new File(Config.SERVICE_DIR +\n                                sd.location + File.separator +\n                                \"META-INF\" + File.separator + \"RunID\");\n                    FileWriter wFile = new FileWriter(runIdFile);\n                    wFile.write(run.getRunId());\n                    wFile.close();\n                }\n\n                ServiceContext ctx =\n                        new ServiceContext(sd, par, ti, properties, restart);\n                ctxList.add(ctx);\n                if (\"services\".equals(sd.locationType)) {\n                    String fullLocation = sd.locationType + '/' + sd.location;\n                    activeDeployments.add(fullLocation);\n\n                    CmdService cmds = CmdService.getHandle();\n                    String[] ctxHosts = ctx.getHosts();\n                    for (String ctxHost : ctxHosts) {\n                        if (hostDeploymentSet.add(new NameValuePair<String>(\n                                cmds.getHostName(ctxHost), sd.location))) {\n                            hostDeploymentList.add(new NameValuePair<String>(\n                                    ctxHost, sd.location));\n                        }\n                    }\n                }\n                String toolCmds = par.getParameter(\"fh:tools\", serviceElement);\n                Set<String> tools = new LinkedHashSet<String>();\n                if (toolCmds.toUpperCase().equals(\"NONE\")) {\n                }else if(toolCmds.length() != 0){\n                    StringTokenizer st = new StringTokenizer(toolCmds, \";\");\n                    while (st.hasMoreTokens()) {\n                        tools.add(st.nextToken().trim());\n                    }\n                }else if (\"\".equals(toolCmds) && toolCmds.length() == 0){\n                    String key = \"default\" + '/' + serviceName;\n                    Set<String> toolset_tools = new LinkedHashSet<String>();\n                    if(toolSetsMap.containsKey(key)){\n                            toolset_tools.addAll(toolSetsMap.get(key));\n                            for (String t1 : toolset_tools){\n                                StringTokenizer tt1 = new StringTokenizer(t1);\n                                String toolId1 = tt1.nextToken();\n                                String toolKey1 = toolId1 + '/' + serviceName;\n                                ToolDescription toolDesc = toolMap.get(toolKey1);\n                                MasterToolContext toolCtx = null;\n                                if (toolDesc != null) {\n                                    toolCtx = new MasterToolContext(t1, ctx,\n                                            toolDesc);\n                                } else {\n                                    toolDesc = toolMap.get(toolId1);\n                                    if (toolDesc != null) {\n                                        toolCtx = new MasterToolContext(\n                                                t1, ctx, toolDesc);\n                                        activeDeployments.add(\n                                                toolDesc.getLocationType() +\n                                                File.separator +\n                                                toolDesc.getLocation());\n                                    } else {\n                                        //logger.info(\"No Tool Description for tool: \" + t1);\n                                        logger.fine(\"No Tool Description for tool: \"\n                                                + t1 +\" ,so it's a command line tool\");\n                                        toolCtx = new MasterToolContext(\n                                                t1, ctx, null);\n                                    }\n                                }\n                                if (toolCtx != null) {\n                                    toolList.add(toolCtx);\n                                }\n                            }\n                        }\n\n                }\n                for (String tool : tools) {\n                    StringTokenizer tt = new StringTokenizer(tool);\n                    String toolId = tt.nextToken();\n                    String toolKey = toolId + '/' + serviceName;\n                    Set<String> toolset_tools = new LinkedHashSet<String>();\n                    if (toolSetsMap.containsKey(toolKey)) {\n                        toolset_tools.addAll(toolSetsMap.get(toolKey));\n                        for (String t1 : toolset_tools) {\n                            StringTokenizer tt1 = new StringTokenizer(t1);\n                            String toolId1 = tt1.nextToken();\n                            String toolKey1 = toolId1 + '/' + serviceName;\n                            ToolDescription toolDesc = toolMap.get(toolKey1);\n                            MasterToolContext toolCtx = null;\n                            if (toolDesc != null) {\n                                toolCtx = new MasterToolContext(t1, ctx, toolDesc);\n                            } else {\n                                toolDesc = toolMap.get(toolId1);\n                                if (toolDesc != null) {\n                                    toolCtx = new MasterToolContext(\n                                            t1, ctx, toolDesc);\n                                } else {\n                                    //logger.info(\"No Tool Description for tool: \" + t1);\n                                    logger.fine(\"No Tool Description for tool: \" + t1 + \" ,so it's a command line tool\");\n                                    toolCtx = new MasterToolContext(\n                                            t1, ctx, null);\n                                }\n                            }\n                            if (toolCtx != null) {\n                                toolList.add(toolCtx);\n                            }\n                        }\n                    } else {\n                        ToolDescription toolDesc = toolMap.get(toolKey);\n                        MasterToolContext toolCtx = null;\n                        if (toolDesc != null) {\n                            toolCtx = new MasterToolContext(tool, ctx, toolDesc);\n                        } else {\n                            toolDesc = toolMap.get(toolId);\n                            if (toolDesc != null) {\n                                toolCtx = new MasterToolContext(\n                                        tool, ctx, toolDesc);\n                            } else {\n                                //logger.info(\"No Tool Description for tool: \" + tool);\n                                logger.fine(\"No Tool Description for tool: \" + tool + \" ,so it's a command line tool\");\n                                toolCtx = new MasterToolContext(\n                                        tool, ctx, null);\n                            }\n                        }\n                        if (toolCtx != null) {\n                            toolList.add(toolCtx);\n                        }\n                    }\n                }\n                for (MasterToolContext toolCtx : toolList) {\n                    String locationType =\n                            toolCtx.getToolDescription().getLocationType();\n                    if (\"services\".equals(locationType)) {\n                        String location =\n                                toolCtx.getToolDescription().getLocation();\n                        String fullLocation = locationType + '/' + location;\n                        activeDeployments.add(fullLocation);\n\n                        CmdService cmds = CmdService.getHandle();\n                        String[] ctxHosts =\n                                toolCtx.getToolServiceContext().getHosts();\n                        for (String ctxHost : ctxHosts) {\n                            if (hostDeploymentSet.add(new NameValuePair<String>(\n                                    cmds.getHostName(ctxHost), location))) {\n                                hostDeploymentList.add(new NameValuePair<String>\n                                        (ctxHost, location));\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Parses and creates the appropriate structures for the tool sets.\n     * @param type The location type, services or benchmark\n     * @param dir The deploy jar name, without .jar\n     */\n    public void parseToolSets(String type, String dir) {\n        String metaInf = Config.FABAN_HOME + File.separator + type +\n                File.separator + dir + File.separator + \"META-INF\";\n        File metaInfDir = new File(metaInf);\n        if (!metaInfDir.isDirectory()) {\n            return;\n        }\n        File toolsetsXml = new File(metaInf + File.separator +\n                    \"toolsets.xml\");\n        try {\n            if(toolsetsXml.exists()){\n                XMLReader reader = new XMLReader(metaInf + File.separator +\n                        \"toolsets.xml\");\n                Element root = null;\n                if (reader != null) {\n                    root = reader.getRootNode();\n\n                    // First, parse the services.\n                    NodeList toolsetsNodes = reader.getNodes(\"toolset\", root);\n                    for (int i = 0; i < toolsetsNodes.getLength(); i++) {\n\n                        Node toolsetsNode = toolsetsNodes.item(i);\n                        if (toolsetsNode.getNodeType() != Node.ELEMENT_NODE) {\n                            continue;\n                        }\n                        Element tse = (Element) toolsetsNode;\n                        ArrayList<String> toolsCmds = new ArrayList<String>();\n                        String service = reader.getValue(\"service\", tse);\n                        String name = reader.getValue(\"name\", tse);\n                        String base = reader.getValue(\"base\", tse);\n                        List<String> toolIncludes = reader.getValues(\"includes\", tse);\n                        List<String> toolExcludes = reader.getValues(\"excludes\", tse);\n                        if(!\"\".equals(base)){\n                            toolsCmds.addAll(toolSetsMap.get(base+\"/\"+service));\n                        }\n                        if(toolIncludes != null){\n                            for (String tool : toolIncludes){\n                                StringTokenizer st = new StringTokenizer(tool, \";\");\n                                while(st.hasMoreTokens())\n                                    toolsCmds.add(st.nextToken().trim());\n                            }\n                        }\n                        if(toolExcludes != null){\n                            ArrayList<String> td = new ArrayList<String>();\n                            for (String tool : toolExcludes){\n                                StringTokenizer st = new StringTokenizer(tool, \";\");\n                                while(st.hasMoreTokens())\n                                    td.add(st.nextToken().trim());\n                            }\n                            toolsCmds.removeAll(td);\n                        }\n\n                        if (!\"\".equals(service) && !\"\".equals(name) &&\n                                (toolIncludes != null || base != null)) {\n                            String key = name+\"/\"+service;\n                            if (toolSetsMap.containsKey(key)) {\n                                logger.log(Level.WARNING,\n                                        \"Ignoring duplicate toolset = \" + key);\n                            } else {\n                                toolSetsMap.put(key, toolsCmds);\n                            }\n                        }\n                    }\n                }\n            }\n        } catch  (Exception e) {\n            logger.log(Level.WARNING, \"Error reading toolsets.xml \" +\n                    \"for \" + dir, e);\n        }        \n    }\n\n    private void initiateDownload() throws RemoteException {\n        HashMap<String, List<String>> downloadMap = new HashMap<String, List<String>>();\n        for (NameValuePair<String> hostPath : hostDeploymentList) {\n            List<String> pathList = downloadMap.get(hostPath.name);\n            if (pathList == null) {\n                pathList = new ArrayList<String>();\n                downloadMap.put(hostPath.name, pathList);\n            }\n            pathList.add(hostPath.value);\n        }\n\n        Set<Map.Entry<String, List<String>>> entrySet = downloadMap.entrySet();\n        CmdService cmds = CmdService.getHandle();\n        for (Map.Entry<String, List<String>> entry : entrySet) {\n            cmds.downloadServices(entry.getKey(), entry.getValue());\n        }\n\n        // Also update the paths on the local command agent.\n        ArrayList<String> activeServiceList = new ArrayList<String>();\n        for (String deployment : activeDeployments) {\n            if (deployment.startsWith(\"service/\"))\n                activeServiceList.add(deployment.substring(8));\n        }\n        cmds.updatePaths(activeServiceList);\n    }\n\n    /**\n     * Returns a list of MasterToolContext.\n     * @return List\n     */\n    public List<MasterToolContext> getTools() {\n        return toolList;\n    }\n\n    /**\n     * Configures the service.\n     */\n    public void configure() {\n        for(ServiceWrapper sw : loadedServicesList){\n            try {\n                sw.configure();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to configure service \" +\n                        sw.ctx.desc.id, e);\n            }\n        }\n    }\n\n    /**\n     * Obtains the configuration of a service.\n     */\n    public void getConfig() {\n        for(ServiceWrapper sw : loadedServicesList){\n            try {\n                sw.getConfig();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to obtain service \" +\n                        \"configuration for service \" + sw.ctx.desc.id, e);\n            }\n        }\n    }\n\n    /**\n     * Obtains the logs of a service.\n     */\n    public void getLogs() {\n        for(ServiceWrapper sw : loadedServicesList){\n            try {\n                sw.getLogs();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Failed to obtain service logs \" +\n                        \"for service \" + sw.ctx.desc.id, e);\n             }\n        }\n    }\n\n    /**\n     * Starts a service. If the service is marked for restart,\n     * this will shutdown the service and restart it.\n     */\n    public void startup() {\n        // Use two separate loops to leave some time\n        // between shutdown and startup.\n        for(ServiceWrapper sw : loadedServicesList){\n            if (sw.ctx.restart) {\n                try {\n                    sw.shutdown();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to shutdown service \" +\n                            sw.ctx.desc.id, e);\n                }\n                try {\n                    sw.clearLogs();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to clear service logs \" +\n                            \"for service \" + sw.ctx.desc.id, e);\n                }\n            }\n        }\n\n        for(ServiceWrapper sw : loadedServicesList){\n            if (sw.ctx.restart) {\n                try {\n                    sw.startup();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to startup service \" +\n                            sw.ctx.desc.id, e);\n                }\n            }\n        }\n    }\n\n    /**\n     * Stops a service.\n     */\n    public void shutdown() {\n        for (ServiceContext ctx : ctxList) {\n            if (\"services\".equals(ctx.desc.locationType)) {\n                File runIdFile = new File(Config.SERVICE_DIR +\n                        ctx.desc.location + File.separator +\n                        \"META-INF\" + File.separator + \"RunID\");\n                if (runIdFile.exists())\n                    runIdFile.delete();\n            }\n        }\n        for(ServiceWrapper sw : loadedServicesList){\n            if (sw.ctx.restart)\n                try {\n                    sw.shutdown();\n                } catch (Exception e) {\n                    logger.log(Level.WARNING, \"Failed to shutdown service \" +\n                            sw.ctx.desc.id, e);\n                }\n        }\n        instance = null;\n    }\n}\n","lineNo":482}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.transport.hc3;\n\nimport com.sun.faban.driver.transport.util.TimedSocketWrapper;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * The BelowTimedSSLSocketFactory is used for the Apache Commons\n * HttpClient 3.1 SSL connections to let the transport be timed.\n *\n * @author Akara Sucharitakul\n */\npublic class AboveTimedSSLSocketFactory implements SecureProtocolSocketFactory {\n\n    private static SSLSocketFactory secureFactory =\n            (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort) throws IOException {\n        return new TimedSocketWrapper(secureFactory.createSocket(\n                host, port, localAddress, localPort));\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort, HttpConnectionParams params)\n            throws IOException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        if (timeout == 0) {\n            return createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n            socket.connect(new InetSocketAddress(host, port), timeout);\n            return new TimedSocketWrapper(\n                    secureFactory.createSocket(socket, host, port, true));\n        }\n    }\n\n    public Socket createSocket(String host, int port) throws IOException {\n        return new TimedSocketWrapper(secureFactory.createSocket(host, port));\n    }\n\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean close)\n            throws IOException, UnknownHostException {\n        return new TimedSocketWrapper(\n                secureFactory.createSocket(socket, host, port, close));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory are the same.\n     * @param obj The other object to compare to\n     * @return true if obj is a ProtocolTimedSocketFactory, false otherwise\n     */\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(getClass()));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory have the same hash code.\n     * @return The hash code of the class, thus all instances are the same\n     */\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.transport.hc3;\n\nimport com.sun.faban.driver.transport.util.TimedSocketWrapper;\nimport com.sun.faban.driver.engine.DriverContext;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * The BelowTimedSSLSocketFactory is used for the Apache Commons\n * HttpClient 3.1 SSL connections to let the transport be timed.\n *\n * @author Akara Sucharitakul\n */\npublic class AboveTimedSSLSocketFactory implements SecureProtocolSocketFactory {\n\n    private static SSLSocketFactory secureFactory =\n            (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort) throws IOException {\n\n        Socket socket = secureFactory.createSocket();\n        InetSocketAddress endpoint = new InetSocketAddress(host, port);\n        socket.bind(new InetSocketAddress(localAddress, localPort));\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n        socket.connect(endpoint, 30000);\n        socket.setSoTimeout(30000); // 30 second socket read timeout.\n        return new TimedSocketWrapper(socket);\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort, HttpConnectionParams params)\n            throws IOException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        if (timeout == 0) {\n            return createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = secureFactory.createSocket();\n            InetSocketAddress endpoint = new InetSocketAddress(host, port);\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n\n            DriverContext ctx = DriverContext.getContext();\n            if (ctx != null)\n                ctx.recordStartTime();\n            if (timeout < 0)\n                timeout = 30000; // 30 second connect timeout.\n            socket.connect(endpoint, timeout);\n            socket.setSoTimeout(30000); // 30 second socket read timeout.\n            return new TimedSocketWrapper(socket);\n        }\n    }\n\n    public Socket createSocket(String host, int port) throws IOException {\n        Socket socket = secureFactory.createSocket();\n        InetSocketAddress endpoint = new InetSocketAddress(host, port);\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n        socket.connect(endpoint, 30000);\n        socket.setSoTimeout(30000); // 30 second socket read timeout.\n        return new TimedSocketWrapper(socket);\n    }\n\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean close)\n            throws IOException, UnknownHostException {\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n\n        // This is the most accurate we can do with an existing socket.\n        return new TimedSocketWrapper(\n                secureFactory.createSocket(socket, host, port, close));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory are the same.\n     * @param obj The other object to compare to\n     * @return true if obj is a ProtocolTimedSocketFactory, false otherwise\n     */\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(getClass()));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory have the same hash code.\n     * @return The hash code of the class, thus all instances are the same\n     */\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n}\n","lineNo":52}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.transport.hc3;\n\nimport com.sun.faban.driver.transport.util.TimedSocketWrapper;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * The BelowTimedSSLSocketFactory is used for the Apache Commons\n * HttpClient 3.1 SSL connections to let the transport be timed.\n *\n * @author Akara Sucharitakul\n */\npublic class AboveTimedSSLSocketFactory implements SecureProtocolSocketFactory {\n\n    private static SSLSocketFactory secureFactory =\n            (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort) throws IOException {\n        return new TimedSocketWrapper(secureFactory.createSocket(\n                host, port, localAddress, localPort));\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort, HttpConnectionParams params)\n            throws IOException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        if (timeout == 0) {\n            return createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n            socket.connect(new InetSocketAddress(host, port), timeout);\n            return new TimedSocketWrapper(\n                    secureFactory.createSocket(socket, host, port, true));\n        }\n    }\n\n    public Socket createSocket(String host, int port) throws IOException {\n        return new TimedSocketWrapper(secureFactory.createSocket(host, port));\n    }\n\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean close)\n            throws IOException, UnknownHostException {\n        return new TimedSocketWrapper(\n                secureFactory.createSocket(socket, host, port, close));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory are the same.\n     * @param obj The other object to compare to\n     * @return true if obj is a ProtocolTimedSocketFactory, false otherwise\n     */\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(getClass()));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory have the same hash code.\n     * @return The hash code of the class, thus all instances are the same\n     */\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.transport.hc3;\n\nimport com.sun.faban.driver.transport.util.TimedSocketWrapper;\nimport com.sun.faban.driver.engine.DriverContext;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * The BelowTimedSSLSocketFactory is used for the Apache Commons\n * HttpClient 3.1 SSL connections to let the transport be timed.\n *\n * @author Akara Sucharitakul\n */\npublic class AboveTimedSSLSocketFactory implements SecureProtocolSocketFactory {\n\n    private static SSLSocketFactory secureFactory =\n            (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort) throws IOException {\n\n        Socket socket = secureFactory.createSocket();\n        InetSocketAddress endpoint = new InetSocketAddress(host, port);\n        socket.bind(new InetSocketAddress(localAddress, localPort));\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n        socket.connect(endpoint, 30000);\n        socket.setSoTimeout(30000); // 30 second socket read timeout.\n        return new TimedSocketWrapper(socket);\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort, HttpConnectionParams params)\n            throws IOException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        if (timeout == 0) {\n            return createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = secureFactory.createSocket();\n            InetSocketAddress endpoint = new InetSocketAddress(host, port);\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n\n            DriverContext ctx = DriverContext.getContext();\n            if (ctx != null)\n                ctx.recordStartTime();\n            if (timeout < 0)\n                timeout = 30000; // 30 second connect timeout.\n            socket.connect(endpoint, timeout);\n            socket.setSoTimeout(30000); // 30 second socket read timeout.\n            return new TimedSocketWrapper(socket);\n        }\n    }\n\n    public Socket createSocket(String host, int port) throws IOException {\n        Socket socket = secureFactory.createSocket();\n        InetSocketAddress endpoint = new InetSocketAddress(host, port);\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n        socket.connect(endpoint, 30000);\n        socket.setSoTimeout(30000); // 30 second socket read timeout.\n        return new TimedSocketWrapper(socket);\n    }\n\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean close)\n            throws IOException, UnknownHostException {\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n\n        // This is the most accurate we can do with an existing socket.\n        return new TimedSocketWrapper(\n                secureFactory.createSocket(socket, host, port, close));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory are the same.\n     * @param obj The other object to compare to\n     * @return true if obj is a ProtocolTimedSocketFactory, false otherwise\n     */\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(getClass()));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory have the same hash code.\n     * @return The hash code of the class, thus all instances are the same\n     */\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n}\n","lineNo":75}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.transport.hc3;\n\nimport com.sun.faban.driver.transport.util.TimedSocketWrapper;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * The BelowTimedSSLSocketFactory is used for the Apache Commons\n * HttpClient 3.1 SSL connections to let the transport be timed.\n *\n * @author Akara Sucharitakul\n */\npublic class AboveTimedSSLSocketFactory implements SecureProtocolSocketFactory {\n\n    private static SSLSocketFactory secureFactory =\n            (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort) throws IOException {\n        return new TimedSocketWrapper(secureFactory.createSocket(\n                host, port, localAddress, localPort));\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort, HttpConnectionParams params)\n            throws IOException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        if (timeout == 0) {\n            return createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = new Socket();\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n            socket.connect(new InetSocketAddress(host, port), timeout);\n            return new TimedSocketWrapper(\n                    secureFactory.createSocket(socket, host, port, true));\n        }\n    }\n\n    public Socket createSocket(String host, int port) throws IOException {\n        return new TimedSocketWrapper(secureFactory.createSocket(host, port));\n    }\n\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean close)\n            throws IOException, UnknownHostException {\n        return new TimedSocketWrapper(\n                secureFactory.createSocket(socket, host, port, close));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory are the same.\n     * @param obj The other object to compare to\n     * @return true if obj is a ProtocolTimedSocketFactory, false otherwise\n     */\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(getClass()));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory have the same hash code.\n     * @return The hash code of the class, thus all instances are the same\n     */\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.transport.hc3;\n\nimport com.sun.faban.driver.transport.util.TimedSocketWrapper;\nimport com.sun.faban.driver.engine.DriverContext;\nimport org.apache.commons.httpclient.params.HttpConnectionParams;\nimport org.apache.commons.httpclient.protocol.SecureProtocolSocketFactory;\n\nimport javax.net.ssl.SSLSocketFactory;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\n\n/**\n * The BelowTimedSSLSocketFactory is used for the Apache Commons\n * HttpClient 3.1 SSL connections to let the transport be timed.\n *\n * @author Akara Sucharitakul\n */\npublic class AboveTimedSSLSocketFactory implements SecureProtocolSocketFactory {\n\n    private static SSLSocketFactory secureFactory =\n            (SSLSocketFactory) SSLSocketFactory.getDefault();\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort) throws IOException {\n\n        Socket socket = secureFactory.createSocket();\n        InetSocketAddress endpoint = new InetSocketAddress(host, port);\n        socket.bind(new InetSocketAddress(localAddress, localPort));\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n        socket.connect(endpoint, 30000);\n        socket.setSoTimeout(30000); // 30 second socket read timeout.\n        return new TimedSocketWrapper(socket);\n    }\n\n    public Socket createSocket(String host, int port, InetAddress localAddress,\n                               int localPort, HttpConnectionParams params)\n            throws IOException {\n        if (params == null) {\n            throw new IllegalArgumentException(\"Parameters may not be null\");\n        }\n        int timeout = params.getConnectionTimeout();\n        if (timeout == 0) {\n            return createSocket(host, port, localAddress, localPort);\n        } else {\n            Socket socket = secureFactory.createSocket();\n            InetSocketAddress endpoint = new InetSocketAddress(host, port);\n            socket.bind(new InetSocketAddress(localAddress, localPort));\n\n            DriverContext ctx = DriverContext.getContext();\n            if (ctx != null)\n                ctx.recordStartTime();\n            if (timeout < 0)\n                timeout = 30000; // 30 second connect timeout.\n            socket.connect(endpoint, timeout);\n            socket.setSoTimeout(30000); // 30 second socket read timeout.\n            return new TimedSocketWrapper(socket);\n        }\n    }\n\n    public Socket createSocket(String host, int port) throws IOException {\n        Socket socket = secureFactory.createSocket();\n        InetSocketAddress endpoint = new InetSocketAddress(host, port);\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n        socket.connect(endpoint, 30000);\n        socket.setSoTimeout(30000); // 30 second socket read timeout.\n        return new TimedSocketWrapper(socket);\n    }\n\n    public Socket createSocket(Socket socket, String host, int port,\n                               boolean close)\n            throws IOException, UnknownHostException {\n\n        DriverContext ctx = DriverContext.getContext();\n        if (ctx != null)\n            ctx.recordStartTime();\n\n        // This is the most accurate we can do with an existing socket.\n        return new TimedSocketWrapper(\n                secureFactory.createSocket(socket, host, port, close));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory are the same.\n     * @param obj The other object to compare to\n     * @return true if obj is a ProtocolTimedSocketFactory, false otherwise\n     */\n    public boolean equals(Object obj) {\n        return ((obj != null) && obj.getClass().equals(getClass()));\n    }\n\n    /**\n     * All instances of ProtocolTimedSocketFactory have the same hash code.\n     * @return The hash code of the class, thus all instances are the same\n     */\n    public int hashCode() {\n        return getClass().hashCode();\n    }\n\n}\n","lineNo":90}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: TimeThread.java,v 1.3 2009/07/21 21:21:09 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.driver.FatalException;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.logging.Level;\n\n\n/**\n * A driver thread that controls the run by ramp up, steady state,\n * and ramp down times.\n *\n * @author Akara Sucharitakul\n */\npublic class TimeThread extends AgentThread {\n\n    /**\n     * Allocates and initializes the timing structures which is specific\n     * to the pseudo-thread dimensions.\n     */\n\tvoid initTimes() {\n        delayTime = new long[1];\n        startTime = new long[1];\n        endTime = new long[1];\n        previousOperation = new int[1];\n\n        // This is the start and end time of the previous operation used to\n        // calculate the start of the next operation. We set it to the current\n        // time for the first operation to have a reference point. In fact,\n        // any reference point is OK.\n        startTime[0] = System.nanoTime();\n        endTime[0] = startTime[0];\n        previousOperation[0] = -1;\n    }\n\n    /**\n     * Each thread executes in the doRun method until the benchmark time is up\n     * The main loop chooses a tx. type according to the mix specified in\n     * the parameter file and calls the appropriate transaction\n     * method to do the job.\n   \t * The stats for the entire run are stored in a Metrics object\n   \t * which is returned to the Agent via the getResult() method.\n     * @see Metrics\n     */\n\tvoid doRun() {\n\n        boolean active = true;\n        driverContext = new DriverContext(this, timer);\n\n        try {\n            driver = driverClass.newInstance();\n        } catch (Throwable t) {\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n                cause = t.getCause();\n            }\n            logger.log(Level.SEVERE, name +\n                    \": Error initializing driver object.\", t);\n            agent.abortRun();\n            return; // Terminate this thread immediately\n        }\n\n        // Call the preRun.\n        preRun();\n\n        // Notify the agent that we have started successfully.\n        agent.threadStartLatch.countDown();\n\n        selector = new Mix.Selector[1];\n        selector[0] = driverConfig.mix[0].selector(random);\n\n        if (runInfo.simultaneousStart) {\n            waitStartTime();\n\n            // Calculate time periods\n            // Note that the time periods are in secs, need to convert\n            endRampUp = agent.startTime + runInfo.rampUp * 1000000000l;\n            endStdyState = endRampUp + runInfo.stdyState * 1000000000l;\n            endRampDown = endStdyState + runInfo.rampDown * 1000000000l;\n        }\n\n        logger.fine(name + \": Start of run.\");\n\n        // Loop until time or cycles are up\n        driverLoop:\n        while (!stopped) {\n\n            if (runInfo.variableLoad) {\n                if (id >= agent.runningThreads) {\n                    try {\n                        logger.log(Level.FINE, \"Current load level: (\" + \n                                agent.runningThreads + \") Thread \" + id + \n                                \" sleeping.\");\n                        sleep(agent.timeToRunFor * 1000);\n                        active = false;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.FINE, e.getMessage(), e);\n                    }\n                } else {\n                    active = true;\n                }\n            }\n\n            if (active) {\n\n                if (!runInfo.simultaneousStart && !startTimeSet &&\n                        agent.timeSetLatch.getCount() == 0) {\n                    startTimeSet = true;\n\n                    // Calculate time periods\n                    // Note that the time periods are in secs, need to convert\n                    endRampUp = agent.startTime + runInfo.rampUp * 1000000000l;\n                    endStdyState = endRampUp + runInfo.stdyState * 1000000000l;\n                    endRampDown = endStdyState + runInfo.rampDown * 1000000000l;\n                }\n\n                // Save the previous operation\n                previousOperation[mixId] = currentOperation;\n                BenchmarkDefinition.Operation previousOp = null;\n                if (previousOperation[mixId] >= 0) {\n                    previousOp = driverConfig.operations[currentOperation];\n                }\n\n                // Select the operation\n                currentOperation = selector[0].select();\n                BenchmarkDefinition.Operation op =\n                        driverConfig.operations[currentOperation];\n\n                // The invoke time is based on the delay after the previous op.\n                // so we need to use previous op for calculating and recording.\n                long invokeTime = getInvokeTime(previousOp, mixId);\n\n                // endRampDown is only valid if start time is set.\n                // If the start time of next tx is beyond the end\n                // of the ramp down, just stop right here.\n                if (startTimeSet && invokeTime >= endRampDown) {\n                    break driverLoop;\n                }\n\n                logger.finest(name + \": Invoking \" + op.name + \" at time \" +\n                        invokeTime + \". Ramp down ends at time \" +\n                        endRampDown + '.');\n\n                driverContext.setInvokeTime(invokeTime);\n\n                // Invoke the operation\n                try {\n                    if (id == 0)\n                        logger.finest(\"Invoking \" + op.name + \" at \" + System.nanoTime());\n                    op.m.invoke(driver);\n                    if (id == 0)\n                        logger.finest(\"Returned from \" + op.name + \" (OK) at \" + System.nanoTime());\n                    validateTimeCompletion(op);\n                    if (id == 0) {\n                        DriverContext.TimingInfo t = driverContext.timingInfo;\n                        logger.finest(\"Invoke: \" + t.invokeTime + \", Respond: \" + t.respondTime + \", Pause: \" + t.pauseTime);\n                    }\n                    checkRamp();\n                    metrics.recordTx();\n                    metrics.recordDelayTime();\n                } catch (InvocationTargetException e) {\n                    if (id == 0)\n                        logger.finest(\"Returned from \" + op.name + \" (Err) at \" + System.nanoTime());\n                    // An invocation target exception is caused by another\n                    // exception thrown by the operation directly.\n                    Throwable cause = e.getCause();\n                    checkFatal(cause, op);\n\n                    // We have to fix up the invoke/respond times to have valid\n                    // values and not TIME_NOT_SET.\n\n                    // In case of exception, invokeTime or even respondTime may\n                    // still be TIME_NOT_SET.\n                    DriverContext.TimingInfo timingInfo =\n                            driverContext.timingInfo;\n                    // If it never waited, we'll see whether we can just use the\n                    // previous start and end times.\n                    if (timingInfo.invokeTime == TIME_NOT_SET) {\n                        long currentTime = System.nanoTime();\n                        if (currentTime < timingInfo.intendedInvokeTime) {\n                            // No time change, no need to checkRamp\n                            metrics.recordError();\n                            logError(cause, op);\n                            continue driverLoop;\n                        }\n                        // Too late, we'll need to use the real time\n                        // for both invoke and respond time.\n                        timingInfo.invokeTime = System.nanoTime();\n                        timingInfo.respondTime = timingInfo.invokeTime;\n                        checkRamp();\n                        metrics.recordError();\n                        logError(cause, op);\n                    // The delay time is invalid,\n                    // we cannot record in this case.\n                    } else if (timingInfo.respondTime == TIME_NOT_SET) {\n                        timingInfo.respondTime = System.nanoTime();\n                        checkRamp();\n                        metrics.recordError();\n                        logError(cause, op);\n                        metrics.recordDelayTime();\n                    } else { // All times are there\n                        checkRamp();\n                        metrics.recordError();\n                        logError(cause, op);\n                        metrics.recordDelayTime();\n                    }\n                } catch (IllegalAccessException e) {\n                    logger.log(Level.SEVERE, name + \".\" + op.m.getName() +\n                            \": \" + e.getMessage(), e);\n                    agent.abortRun();\n                    return;\n                }\n\n                startTime[mixId] = driverContext.timingInfo.invokeTime;\n                endTime[mixId] = driverContext.timingInfo.respondTime;\n\n                if (startTimeSet && endTime[mixId] >= endRampDown) {\n                    break driverLoop;\n                }\n            }\n        }\n        logger.fine(name + \": End of run.\");\n    }\n\n    /**\n     * Checks whether the last operation is in the ramp-up or ramp-down or\n     * not. Updates the inRamp parameter accordingly.\n     */\n\tvoid checkRamp() {\n        inRamp = !isSteadyState(driverContext.timingInfo.invokeTime,\n                                driverContext.timingInfo.respondTime);\n    }\n\n    /**\n     * Tests whether the last operation is in steady state or not. This is\n     * called by the driver from within the operation so we need to be careful\n     * not to change run control parameters. This method only reads the stats.\n     * @return True if the last operation is in steady state, false otherwise.\n     */\n\tboolean isSteadyState() {\n        if (driverContext.timingInfo.respondTime == TIME_NOT_SET) {\n\t\t\tthrow new FatalException(\"isTxSteadyState called before response \" +\n                    \"time capture. Cannot determine tx in steady state or \" +\n                    \"not. This is a bug in the driver code.\");\n\t\t}\n\n        return isSteadyState(driverContext.timingInfo.invokeTime,\n                                driverContext.timingInfo.respondTime);\n    }\n\n    /**\n     * Tests whether the time between start and end is in steady state or not.\n     * For non time-based steady state, this will depend on the current cycle\n     * count. Otherwise time is used.\n     *\n     * @param start The start of a time span\n     * @param end   The end of a time span\n     * @return true if this time span is in steady state, false otherwise.\n     */\n\tboolean isSteadyState(long start, long end) {\n        return startTimeSet && start >= endRampUp && end < endStdyState;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id$\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.driver.FatalException;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.logging.Level;\n\n\n/**\n * A driver thread that controls the run by ramp up, steady state,\n * and ramp down times.\n *\n * @author Akara Sucharitakul\n */\npublic class TimeThread extends AgentThread {\n\n    /**\n     * Allocates and initializes the timing structures which is specific\n     * to the pseudo-thread dimensions.\n     */\n\tvoid initTimes() {\n        delayTime = new long[1];\n        startTime = new long[1];\n        endTime = new long[1];\n        previousOperation = new int[1];\n\n        // This is the start and end time of the previous operation used to\n        // calculate the start of the next operation. We set it to the current\n        // time for the first operation to have a reference point. In fact,\n        // any reference point is OK.\n        startTime[0] = System.nanoTime();\n        endTime[0] = startTime[0];\n        previousOperation[0] = -1;\n    }\n\n    /**\n     * Each thread executes in the doRun method until the benchmark time is up\n     * The main loop chooses a tx. type according to the mix specified in\n     * the parameter file and calls the appropriate transaction\n     * method to do the job.\n   \t * The stats for the entire run are stored in a Metrics object\n   \t * which is returned to the Agent via the getResult() method.\n     * @see Metrics\n     */\n\tvoid doRun() {\n\n        boolean active = true;\n        driverContext = new DriverContext(this, timer);\n\n        try {\n            driver = driverClass.newInstance();\n        } catch (Throwable t) {\n            Throwable cause = t.getCause();\n            while (cause != null) {\n                t = cause;\n                cause = t.getCause();\n            }\n            logger.log(Level.SEVERE, name +\n                    \": Error initializing driver object.\", t);\n            agent.abortRun();\n            return; // Terminate this thread immediately\n        }\n\n        // Call the preRun.\n        preRun();\n\n        // Notify the agent that we have started successfully.\n        agent.threadStartLatch.countDown();\n\n        selector = new Mix.Selector[1];\n        selector[0] = driverConfig.mix[0].selector(random);\n\n        if (runInfo.simultaneousStart) {\n            waitStartTime();\n\n            // Calculate time periods\n            // Note that the time periods are in secs, need to convert\n            endRampUp = agent.startTime + runInfo.rampUp * 1000000000l;\n            endStdyState = endRampUp + runInfo.stdyState * 1000000000l;\n            endRampDown = endStdyState + runInfo.rampDown * 1000000000l;\n        }\n\n        logger.fine(name + \": Start of run.\");\n\n        // Loop until time or cycles are up\n        driverLoop:\n        while (!stopped) {\n\n            if (runInfo.variableLoad) {\n                if (id >= agent.runningThreads) {\n                    try {\n                        logger.log(Level.FINE, \"Current load level: (\" + \n                                agent.runningThreads + \") Thread \" + id + \n                                \" sleeping.\");\n                        sleep(agent.timeToRunFor * 1000);\n                        active = false;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.FINE, e.getMessage(), e);\n                    }\n                } else {\n                    active = true;\n                }\n            }\n\n            if (active) {\n\n                if (!runInfo.simultaneousStart && !startTimeSet &&\n                        agent.timeSetLatch.getCount() == 0) {\n                    startTimeSet = true;\n\n                    // Calculate time periods\n                    // Note that the time periods are in secs, need to convert\n                    endRampUp = agent.startTime + runInfo.rampUp * 1000000000l;\n                    endStdyState = endRampUp + runInfo.stdyState * 1000000000l;\n                    endRampDown = endStdyState + runInfo.rampDown * 1000000000l;\n                }\n\n                // Save the previous operation\n                previousOperation[mixId] = currentOperation;\n                BenchmarkDefinition.Operation previousOp = null;\n                if (previousOperation[mixId] >= 0) {\n                    previousOp = driverConfig.operations[currentOperation];\n                }\n\n                // Select the operation\n                currentOperation = selector[0].select();\n                BenchmarkDefinition.Operation op =\n                        driverConfig.operations[currentOperation];\n\n                // The invoke time is based on the delay after the previous op.\n                // so we need to use previous op for calculating and recording.\n                long invokeTime = getInvokeTime(previousOp, mixId);\n\n                // endRampDown is only valid if start time is set.\n                // If the start time of next tx is beyond the end\n                // of the ramp down, just stop right here.\n                if (startTimeSet && invokeTime >= endRampDown) {\n                    break driverLoop;\n                }\n\n                logger.finest(name + \": Invoking \" + op.name + \" at time \" +\n                        invokeTime + \". Ramp down ends at time \" +\n                        endRampDown + '.');\n\n                driverContext.setInvokeTime(invokeTime);\n\n                // Invoke the operation\n                try {\n                    if (id == 0)\n                        logger.finest(\"Invoking \" + op.name + \" at \" + System.nanoTime());\n                    op.m.invoke(driver);\n                    if (id == 0)\n                        logger.finest(\"Returned from \" + op.name + \" (OK) at \" + System.nanoTime());\n                    validateTimeCompletion(op);\n                    if (id == 0) {\n                        DriverContext.TimingInfo t = driverContext.timingInfo;\n                        logger.finest(\"Invoke: \" + t.invokeTime + \", Respond: \" + t.respondTime + \", Pause: \" + t.pauseTime);\n                    }\n                    checkRamp();\n                    metrics.recordTx();\n                    metrics.recordDelayTime();\n                } catch (InvocationTargetException e) {\n                    if (id == 0)\n                        logger.finest(\"Returned from \" + op.name + \" (Err) at \" + System.nanoTime());\n                    // An invocation target exception is caused by another\n                    // exception thrown by the operation directly.\n                    Throwable cause = e.getCause();\n                    checkFatal(cause, op);\n\n                    // We have to fix up the invoke/respond times to have valid\n                    // values and not TIME_NOT_SET.\n\n                    // In case of exception, invokeTime or even respondTime may\n                    // still be TIME_NOT_SET.\n                    DriverContext.TimingInfo timingInfo =\n                            driverContext.timingInfo;\n\n                    // The lastRespondTime may be set, though. if so, propagate\n                    // it back to respondTime.\n                    if (timingInfo.respondTime == TIME_NOT_SET &&\n                        timingInfo.lastRespondTime != TIME_NOT_SET) {\n                        logger.fine(\"Potential open request in operation \" +\n                                op.m.getName() + \".\");\n                        timingInfo.respondTime = timingInfo.lastRespondTime;\n                    }\n\n                    // If it never waited, we'll see whether we can just use the\n                    // previous start and end times.\n                    if (timingInfo.invokeTime == TIME_NOT_SET) {\n                        long currentTime = System.nanoTime();\n                        if (currentTime < timingInfo.intendedInvokeTime) {\n                            // No time change, no need to checkRamp\n                            metrics.recordError();\n                            logError(cause, op);\n                            continue driverLoop;\n                        }\n                        // Too late, we'll need to use the real time\n                        // for both invoke and respond time.\n                        timingInfo.invokeTime = System.nanoTime();\n                        timingInfo.respondTime = timingInfo.invokeTime;\n                        checkRamp();\n                        metrics.recordError();\n                        logError(cause, op);\n                    // The delay time is invalid,\n                    // we cannot record in this case.\n                    } else if (timingInfo.respondTime == TIME_NOT_SET) {\n                        timingInfo.respondTime = System.nanoTime();\n                        checkRamp();\n                        metrics.recordError();\n                        logError(cause, op);\n                        metrics.recordDelayTime();\n                    } else { // All times are there\n                        checkRamp();\n                        metrics.recordError();\n                        logError(cause, op);\n                        metrics.recordDelayTime();\n                    }\n                } catch (IllegalAccessException e) {\n                    logger.log(Level.SEVERE, name + \".\" + op.m.getName() +\n                            \": \" + e.getMessage(), e);\n                    agent.abortRun();\n                    return;\n                }\n\n                startTime[mixId] = driverContext.timingInfo.invokeTime;\n                endTime[mixId] = driverContext.timingInfo.respondTime;\n\n                if (startTimeSet && endTime[mixId] >= endRampDown) {\n                    break driverLoop;\n                }\n            }\n        }\n        logger.fine(name + \": End of run.\");\n    }\n\n    /**\n     * Checks whether the last operation is in the ramp-up or ramp-down or\n     * not. Updates the inRamp parameter accordingly.\n     */\n\tvoid checkRamp() {\n        inRamp = !isSteadyState(driverContext.timingInfo.invokeTime,\n                                driverContext.timingInfo.respondTime);\n    }\n\n    /**\n     * Tests whether the last operation is in steady state or not. This is\n     * called by the driver from within the operation so we need to be careful\n     * not to change run control parameters. This method only reads the stats.\n     * @return True if the last operation is in steady state, false otherwise.\n     */\n\tboolean isSteadyState() {\n        // The lastRespondTime may be set, though. if so, propagate\n        // it back to respondTime.\n        long respondTime = driverContext.timingInfo.respondTime;\n        if (respondTime == TIME_NOT_SET) {\n            if (driverContext.timingInfo.lastRespondTime != TIME_NOT_SET) {\n                logger.fine(\"Potential pending open request.\");\n                respondTime = driverContext.timingInfo.lastRespondTime;\n            } else {\n\t\t\t    throw new FatalException(\"isTxSteadyState called before \" +\n                      \"response time capture. Cannot determine tx in steady\" +\n                      \" state or not. This is a bug in the driver code.\");\n            }\n\t\t}\n\n        return isSteadyState(driverContext.timingInfo.invokeTime, respondTime);\n    }\n\n    /**\n     * Tests whether the time between start and end is in steady state or not.\n     * For non time-based steady state, this will depend on the current cycle\n     * count. Otherwise time is used.\n     *\n     * @param start The start of a time span\n     * @param end   The end of a time span\n     * @return true if this time span is in steady state, false otherwise.\n     */\n\tboolean isSteadyState(long start, long end) {\n        return startTimeSet && start >= endRampUp && end < endStdyState;\n    }\n}\n","lineNo":277}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CLI.java,v 1.3 2008/01/15 08:02:52 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpMethodBase;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.MultipartPostMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\n\nimport java.io.*;\nimport java.util.ArrayList;\n\n/**\n * Command line interface for submitting runs, etc.<br/>\n * <br/>\n * CLI [-M master] [-U user [-P password]] action args<br/>\n * <br/>\n * Action and arguments:<ul>\n * <li>pending<br/>&nbsp;Lists pending runs.<\/li>\n * <li>status runId<br/>&nbsp;Provides the status for the given run id.<\/li>\n * <li>submit benchmark profile configfile.xml [configfile2.xml...]<br/>\n * &nbsp;Submits benchmark runs.<\/li>\n * <\/ul><br/>\n * The master is provided as a URL to the master's root context and defaults\n * to http://localhost:9980/.\n *\n * @author Akara Sucharitakul\n */\npublic class CLI {\n\n    /**\n     * The first argument to the CLI is the action. It can be:<ul>\n     * <li>pending<\/li>\n     * <li>status runId<\/li>\n     * <li>submit benchmark profile configfile.xml<\/ul>\n     * <\/ul>\n     *\n     * @param args The command line arguments.\n     */\n    public static void main(String[] args) {\n\n        if (args.length == 0) {\n            printUsage();\n            System.exit(1);\n        }\n\n        ArrayList<String> argList = new ArrayList<String>();\n        // Do the getopt thing.\n        char opt = (char) -1;\n        String master = null;\n        String user = null;\n        String password = null;\n\n        for (String arg : args) {\n            if (arg.startsWith(\"-M\")) {\n                String optArg = arg.substring(2);\n                if (optArg.length() == 0) {\n                    opt = 'M';\n                    continue;\n                }\n                master = optArg;\n            } else if (arg.startsWith(\"-U\")) {\n                String optArg = arg.substring(2);\n                if (optArg.length() == 0) {\n                    opt = 'U';\n                    continue;\n                }\n                user = optArg;\n            } else if (arg.startsWith(\"-P\")) {\n                String optArg = arg.substring(2);\n                if (optArg.length() == 0) {\n                    opt = 'P';\n                    continue;\n                }\n                password = optArg;\n            } else if (opt != (char) -1) {\n                switch (opt) {\n                    case 'M': master   = arg; opt = (char) -1; break;\n                    case 'U': user     = arg; opt = (char) -1; break;\n                    case 'P': password = arg; opt = (char) -1; break;\n                }\n            } else {\n                argList.add(arg);\n                opt = (char) -1;\n            }\n        }\n\n        if (master == null)\n            master = \"http://localhost:9980/\";\n        else if (!master.endsWith(\"/\"))\n            master += '/';\n\n        CLI cli = new CLI();\n        String action = argList.get(0);\n\n        try {\n            if (\"pending\".equals(action)) {\n                cli.doGet(master + \"pending\");\n            } else if (\"status\".equals(action)) {\n                if (argList.size() > 1)\n                    cli.doGet(master + \"status/\" + argList.get(1));\n                else\n                    printUsage();\n            } else if (\"submit\".equals(action)) {\n                if (argList.size() > 3) {\n                    cli.doPostSubmit(master, user, password, argList);\n                } else {\n                    printUsage();\n                    System.exit(1);\n                }\n            } else if (\"kill\".equals(action)) {\n                if (argList.size() > 1) {\n                    cli.doPostKill(master, user, password, argList);\n                } else {\n                    printUsage();\n                    System.exit(1);\n                }\n            } else if (\"wait\".equals(action)) {\n                if (argList.size() > 1) {\n                    cli.pollStatus(master + \"status/\" + argList.get(1));\n                } else {\n                    printUsage();\n                    System.exit(1);\n                }\n            } else if (\"showlogs\".equals(action)) {\n                StringBuilder url = new StringBuilder();\n                if (argList.size() > 1) {\n                    url.append(master).append(\"logs/\");\n                    url.append(argList.get(1));\n                } else {\n                    printUsage();\n                }\n                for (int i = 2; i < argList.size(); i++) {\n                    if (\"-t\".equals(argList.get(i)))\n                        url.append(\"/tail\");\n                    if (\"-f\".equals(argList.get(i)))\n                        url.append(\"/follow\");\n                    if (\"-ft\".equals(argList.get(i)))\n                        url.append(\"/tail/follow\");\n                    if (\"-tf\".equals(argList.get(i)))\n                        url.append(\"/tail/follow\");\n                }\n                cli.doGet(url.toString());\n            } else {\n                printUsage();\n            }\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n            System.exit(1);\n        }\n    }\n\n    private static void printUsage() {\n        String cmd = System.getProperty(\"faban.cli.command\");\n        if (cmd == null)\n            cmd = CLI.class.getName();\n        cmd += \" [-M masterURL] [-U user [-P password]] \";\n        System.err.println(cmd + \"pending\");\n        System.err.println(cmd + \"status runId\");\n        System.err.println(cmd + \"submit benchmark profile configfile\");\n        System.err.println(cmd + \"kill runId\");\n        System.err.println(cmd + \"wait runId\");\n        System.err.println(cmd + \"showlogs runId [-ft]\");\n        System.exit(1);\n    }\n\n    private void doGet(String url) throws IOException {\n        GetMethod get = new GetMethod(url);\n        makeRequest(get);\n\n    }\n\n    private void pollStatus(String url) throws IOException {\n        GetMethod get = new GetMethod(url);\n        for (;;) {\n            String status = makeStringRequest(get);\n            if ( \"COMPLETED\".equals(status) ||\n                    \"FAILED\".equals(status) ||\n                    \"KILLED\".equals(status) ) {\n                System.out.println(status);\n            } else {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void doPostSubmit(String master, String user, String password,\n                       ArrayList<String> argList) throws IOException {\n        String url = master + argList.get(0) + '/' + argList.get(1) + '/' +\n                     argList.get(2);\n        MultipartPostMethod post = new MultipartPostMethod(url);\n        if (user != null)\n            post.addParameter(\"sun\", user);\n        if (password != null)\n            post.addParameter(\"sp\", password);\n        int submitCount = 0;\n        for (int i = 3; i < argList.size(); i++) {\n            try {\n                post.addParameter(\"configfile\", new File(argList.get(i)));\n                ++submitCount;\n            } catch (FileNotFoundException e) {\n                System.err.println(\"File \" + argList.get(i) + \" not found.\");\n            }\n        }\n        if (submitCount == 0) {\n            throw new IOException(\"No run submitted!\");\n        }\n        makeRequest(post);\n    }\n\n    private void doPostKill(String master, String user, String password,\n                            ArrayList<String> argList) throws IOException {\n        String url = master + argList.get(0) + '/' + argList.get(1);\n        PostMethod post = new PostMethod(url);\n        if (user == null)\n            user = \"\";\n        if (password == null)\n            password = \"\";\n        post.addParameter(\"sun\", user);\n        post.addParameter(\"sp\", password);\n        makeRequest(post);\n    }\n\n    private void makeRequest(HttpMethodBase method) throws IOException {\n        HttpClient client = new HttpClient();\n        client.setConnectionTimeout(5000);\n        int status = client.executeMethod(method);\n        String enc = method.getResponseCharSet();\n\n        InputStream response = method.getResponseBodyAsStream();\n\n        if (status == HttpStatus.SC_NOT_FOUND) {\n            System.err.println(\"Not found!\");\n            return;\n        } else if (status == HttpStatus.SC_NO_CONTENT) {\n            System.err.println(\"Empty!\");\n            return;\n        } else if (response != null) {\n            BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(response, enc));\n            String line = null;\n            while ((line = reader.readLine()) != null)\n                System.out.println(line);\n        } else if (status != HttpStatus.SC_OK)\n            throw new IOException(HttpStatus.getStatusText(status));\n    }\n\n    private String makeStringRequest(HttpMethodBase method) throws IOException {\n        HttpClient client = new HttpClient();\n        client.setConnectionTimeout(5000);\n        int status = client.executeMethod(method);\n        String enc = method.getResponseCharSet();\n\n        InputStream response = method.getResponseBodyAsStream();\n        StringBuilder buffer = new StringBuilder();\n        if (status == HttpStatus.SC_NOT_FOUND) {\n            System.err.println(\"Not found!\");\n            return buffer.toString();\n        } else if (status == HttpStatus.SC_NO_CONTENT) {\n            System.err.println(\"Empty!\");\n            return buffer.toString();\n        } else if (response != null) {\n            BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(response, enc));\n            String line = null;\n            while ((line = reader.readLine()) != null)\n                buffer.append(line).append('\\n');\n        }\n        else if (status != HttpStatus.SC_OK)\n            throw new IOException(HttpStatus.getStatusText(status));\n        return buffer.toString();\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CLI.java,v 1.4 2009/08/05 23:50:12 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport org.apache.commons.httpclient.HttpClient;\nimport org.apache.commons.httpclient.HttpMethodBase;\nimport org.apache.commons.httpclient.HttpStatus;\nimport org.apache.commons.httpclient.methods.GetMethod;\nimport org.apache.commons.httpclient.methods.PostMethod;\nimport org.apache.commons.httpclient.methods.multipart.FilePart;\nimport org.apache.commons.httpclient.methods.multipart.MultipartRequestEntity;\nimport org.apache.commons.httpclient.methods.multipart.Part;\nimport org.apache.commons.httpclient.methods.multipart.StringPart;\n\nimport java.io.*;\nimport java.util.ArrayList;\n\n/**\n * Command line interface for submitting runs, etc.<br/>\n * <br/>\n * CLI [-M master] [-U user [-P password]] action args<br/>\n * <br/>\n * Action and arguments:<ul>\n * <li>pending<br/>&nbsp;Lists pending runs.<\/li>\n * <li>status runId<br/>&nbsp;Provides the status for the given run id.<\/li>\n * <li>submit benchmark profile configfile.xml [configfile2.xml...]<br/>\n * &nbsp;Submits benchmark runs.<\/li>\n * <\/ul><br/>\n * The master is provided as a URL to the master's root context and defaults\n * to http://localhost:9980/.\n *\n * @author Akara Sucharitakul\n */\npublic class CLI {\n\n    /**\n     * The first argument to the CLI is the action. It can be:<ul>\n     * <li>pending<\/li>\n     * <li>status runId<\/li>\n     * <li>submit benchmark profile configfile.xml<\/ul>\n     * <\/ul>\n     *\n     * @param args The command line arguments.\n     */\n    public static void main(String[] args) {\n\n        if (args.length == 0) {\n            printUsage();\n            System.exit(1);\n        }\n\n        ArrayList<String> argList = new ArrayList<String>();\n        // Do the getopt thing.\n        char opt = (char) -1;\n        String master = null;\n        String user = null;\n        String password = null;\n\n        for (String arg : args) {\n            if (arg.startsWith(\"-M\")) {\n                String optArg = arg.substring(2);\n                if (optArg.length() == 0) {\n                    opt = 'M';\n                    continue;\n                }\n                master = optArg;\n            } else if (arg.startsWith(\"-U\")) {\n                String optArg = arg.substring(2);\n                if (optArg.length() == 0) {\n                    opt = 'U';\n                    continue;\n                }\n                user = optArg;\n            } else if (arg.startsWith(\"-P\")) {\n                String optArg = arg.substring(2);\n                if (optArg.length() == 0) {\n                    opt = 'P';\n                    continue;\n                }\n                password = optArg;\n            } else if (opt != (char) -1) {\n                switch (opt) {\n                    case 'M': master   = arg; opt = (char) -1; break;\n                    case 'U': user     = arg; opt = (char) -1; break;\n                    case 'P': password = arg; opt = (char) -1; break;\n                }\n            } else {\n                argList.add(arg);\n                opt = (char) -1;\n            }\n        }\n\n        if (master == null)\n            master = \"http://localhost:9980/\";\n        else if (!master.endsWith(\"/\"))\n            master += '/';\n\n        CLI cli = new CLI();\n        String action = argList.get(0);\n\n        try {\n            if (\"pending\".equals(action)) {\n                cli.doGet(master + \"pending\");\n            } else if (\"status\".equals(action)) {\n                if (argList.size() > 1)\n                    cli.doGet(master + \"status/\" + argList.get(1));\n                else\n                    printUsage();\n            } else if (\"submit\".equals(action)) {\n                if (argList.size() > 3) {\n                    cli.doPostSubmit(master, user, password, argList);\n                } else {\n                    printUsage();\n                    System.exit(1);\n                }\n            } else if (\"kill\".equals(action)) {\n                if (argList.size() > 1) {\n                    cli.doPostKill(master, user, password, argList);\n                } else {\n                    printUsage();\n                    System.exit(1);\n                }\n            } else if (\"wait\".equals(action)) {\n                if (argList.size() > 1) {\n                    cli.pollStatus(master + \"status/\" + argList.get(1));\n                } else {\n                    printUsage();\n                    System.exit(1);\n                }\n            } else if (\"showlogs\".equals(action)) {\n                StringBuilder url = new StringBuilder();\n                if (argList.size() > 1) {\n                    url.append(master).append(\"logs/\");\n                    url.append(argList.get(1));\n                } else {\n                    printUsage();\n                }\n                for (int i = 2; i < argList.size(); i++) {\n                    if (\"-t\".equals(argList.get(i)))\n                        url.append(\"/tail\");\n                    if (\"-f\".equals(argList.get(i)))\n                        url.append(\"/follow\");\n                    if (\"-ft\".equals(argList.get(i)))\n                        url.append(\"/tail/follow\");\n                    if (\"-tf\".equals(argList.get(i)))\n                        url.append(\"/tail/follow\");\n                }\n                cli.doGet(url.toString());\n            } else {\n                printUsage();\n            }\n        } catch (IOException e) {\n            System.err.println(e.getMessage());\n            System.exit(1);\n        }\n    }\n\n    private static void printUsage() {\n        String cmd = System.getProperty(\"faban.cli.command\");\n        if (cmd == null)\n            cmd = CLI.class.getName();\n        cmd += \" [-M masterURL] [-U user [-P password]] \";\n        System.err.println(cmd + \"pending\");\n        System.err.println(cmd + \"status runId\");\n        System.err.println(cmd + \"submit benchmark profile configfile\");\n        System.err.println(cmd + \"kill runId\");\n        System.err.println(cmd + \"wait runId\");\n        System.err.println(cmd + \"showlogs runId [-ft]\");\n        System.exit(1);\n    }\n\n    private void doGet(String url) throws IOException {\n        GetMethod get = new GetMethod(url);\n        makeRequest(get);\n\n    }\n\n    private void pollStatus(String url) throws IOException {\n        GetMethod get = new GetMethod(url);\n        for (;;) {\n            String status = makeStringRequest(get);\n            if ( \"COMPLETED\".equals(status) ||\n                    \"FAILED\".equals(status) ||\n                    \"KILLED\".equals(status) ) {\n                System.out.println(status);\n            } else {\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private void doPostSubmit(String master, String user, String password,\n                       ArrayList<String> argList) throws IOException {\n        String url = master + argList.get(0) + '/' + argList.get(1) + '/' +\n                     argList.get(2);\n        ArrayList<Part> params = new ArrayList<Part>();\n        if (user != null)\n            params.add(new StringPart(\"sun\", user));\n        if (password != null)\n            params.add(new StringPart(\"sp\", password));\n        int submitCount = 0;\n        for (int i = 3; i < argList.size(); i++) {\n            File configFile = new File(argList.get(i));\n            if (configFile.isFile()) {\n                params.add(new FilePart(\"configfile\", configFile));\n                ++submitCount;\n            } else {\n                System.err.println(\"File \" + argList.get(i) + \" not found.\");\n            }\n        }\n        if (submitCount == 0) {\n            throw new IOException(\"No run submitted!\");\n        }\n        Part[] parts = new Part[params.size()];\n        parts = params.toArray(parts);\n        PostMethod post = new PostMethod(url);\n        post.setRequestEntity(\n                new MultipartRequestEntity(parts, post.getParams()));        \n        makeRequest(post);\n    }\n\n    private void doPostKill(String master, String user, String password,\n                            ArrayList<String> argList) throws IOException {\n        String url = master + argList.get(0) + '/' + argList.get(1);\n        PostMethod post = new PostMethod(url);\n        if (user == null)\n            user = \"\";\n        if (password == null)\n            password = \"\";\n        post.addParameter(\"sun\", user);\n        post.addParameter(\"sp\", password);\n        makeRequest(post);\n    }\n\n    private void makeRequest(HttpMethodBase method) throws IOException {\n        HttpClient client = new HttpClient();\n        client.getHttpConnectionManager().getParams().\n                setConnectionTimeout(5000);\n        int status = client.executeMethod(method);\n        String enc = method.getResponseCharSet();\n\n        InputStream response = method.getResponseBodyAsStream();\n\n        if (status == HttpStatus.SC_NOT_FOUND) {\n            System.err.println(\"Not found!\");\n            return;\n        } else if (status == HttpStatus.SC_NO_CONTENT) {\n            System.err.println(\"Empty!\");\n            return;\n        } else if (response != null) {\n            BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(response, enc));\n            String line = null;\n            while ((line = reader.readLine()) != null)\n                System.out.println(line);\n        } else if (status != HttpStatus.SC_OK)\n            throw new IOException(HttpStatus.getStatusText(status));\n    }\n\n    private String makeStringRequest(HttpMethodBase method) throws IOException {\n        HttpClient client = new HttpClient();\n        client.getHttpConnectionManager().getParams().\n                setConnectionTimeout(5000);\n        int status = client.executeMethod(method);\n        String enc = method.getResponseCharSet();\n\n        InputStream response = method.getResponseBodyAsStream();\n        StringBuilder buffer = new StringBuilder();\n        if (status == HttpStatus.SC_NOT_FOUND) {\n            System.err.println(\"Not found!\");\n            return buffer.toString();\n        } else if (status == HttpStatus.SC_NO_CONTENT) {\n            System.err.println(\"Empty!\");\n            return buffer.toString();\n        } else if (response != null) {\n            BufferedReader reader = new BufferedReader(\n                    new InputStreamReader(response, enc));\n            String line = null;\n            while ((line = reader.readLine()) != null)\n                buffer.append(line).append('\\n');\n        }\n        else if (status != HttpStatus.SC_OK)\n            throw new IOException(HttpStatus.getStatusText(status));\n        return buffer.toString();\n    }\n}\n","lineNo":228}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: RunAnalyzer.java,v 1.8 2008/09/03 05:16:29 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\nimport com.sun.faban.harness.security.Acl;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.common.Command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\nimport java.util.HashSet;\nimport java.util.ArrayList;\n\n/**\n * Run Analyzer that handles all the backend tasks to analyze the runs.\n *\n * @author Akara Sucharitakul\n */\npublic class RunAnalyzer {\n\n    /** Analyze types. */\n    public enum Type {\n\n        /** Comparison */\n        COMPARE,\n\n        /** Averaging */\n        AVERAGE;\n\n        /**\n         * Returns the string representation of the analysis type.\n         * @return The string representation of the enum elements in lower case\n         */\n        public String toString() {\n            return name().toLowerCase();\n        }\n    };\n\n    private static Logger logger =\n            Logger.getLogger(RunAnalyzer.class.getName());\n\n    /**\n     * Provides a suggested analysis name for the analysis based on the\n     * analysis type and and run ids that are used.\n     * The run id can come in the form of bench.seq or\n     * host.bench.seq. We try to keep the suggested name\n     * as short as possible. We have three formats:\n     * <ol>\n     * <li>Generic format: type_runId1_runId2...<\/li>\n     * <li>Same benchmark: type-bench_<host.>seq1_<host>.seq2...<\/li>\n     * <li>Same host, same benchmark: type-bench-host_seq1_seq2...<\/li>\n     * <\/ol>\n     * @return The suggested analysis name\n     */\n    public static String suggestName(Type type, String[] runIdStrings) {\n        StringBuilder suggestion = new StringBuilder();\n        HashSet<String> benchNameSet = new HashSet<String>();\n        HashSet<String> hostNameSet = new HashSet<String>();\n        suggestion.append(type);\n\n        RunId[] runIds = new RunId[runIdStrings.length];\n        String benchName = null;\n        String hostName = null;\n        for (int i = 0; i < runIdStrings.length; i++) {\n            RunId runId = new RunId(runIdStrings[i]);\n            benchName = runId.getBenchName();\n            hostName = runId.getHostName();\n            benchNameSet.add(benchName);\n            hostNameSet.add(hostName);\n            runIds[i] = runId;\n        }\n\n        if (benchNameSet.size() == 1) {\n            suggestion.append('-').append(benchName);\n            if (hostNameSet.size() == 1) {\n                if (hostName.length() > 0)\n                    suggestion.append('-').append(hostName);\n                for (RunId runId : runIds)\n                    suggestion.append('_').append(runId.getRunSeq());\n            } else {\n                for (RunId runId : runIds) {\n                    suggestion.append('_');\n                    hostName = runId.getHostName();\n                    if (hostName.length() > 0)\n                        suggestion.append(hostName).append('.');\n                    suggestion.append(runId.getRunSeq());\n                }\n            }\n        } else {\n            for (RunId runId : runIds)\n                suggestion.append('_').append(runId);\n        }\n        return suggestion.toString();\n\n    }\n\n    /**\n     * Checks whether the analysis with the given name exists.\n     * @param name The analysis name\n     * @return true if the analysis exists, false otherwise\n     */\n    public static boolean exists(String name) {\n        File analysisDir = new File(Config.ANALYSIS_DIR + name);\n        File resultFile = new File(analysisDir, \"index.html\");\n        if (resultFile.exists()) {\n            return true;\n        } else if (analysisDir.isDirectory()) {\n            FileHelper.recursiveDelete(analysisDir);\n            return false;\n        } else {\n            return false;\n        }\n    }\n\n    public static void clear(String name) {\n        File analysisDir = new File(Config.ANALYSIS_DIR + name);\n        if (analysisDir.isDirectory()) {\n            FileHelper.recursiveDelete(analysisDir);\n        }\n    }\n\n    /**\n     * Executes the run analysis.\n     * @param type The type of the analysis\n     * @param runIdStrings The run ids to analyze, in form of String array\n     * @param output The name of the analysis results\n     * @param user The user name requesting this analysis\n     * @throws IOException The analysis failed and results are not generated\n     */\n    public static void analyze(Type type, String[] runIdStrings,\n                               String output, String user)\n            throws IOException {\n        File analysisDir = new File(Config.ANALYSIS_DIR + output);\n        if (!analysisDir.mkdirs()) {\n            throw new IOException(\"Failed creating directory \" +\n                                    analysisDir +'!');\n        }\n        ArrayList<String> cmd = new ArrayList<String>();\n        cmd.add(Config.BIN_DIR.trim() + \"fenxi\");\n        cmd.add(type.toString());\n        for (String runId : runIdStrings)\n            cmd.add(Config.OUT_DIR + runId);\n\n        cmd.add(Config.ANALYSIS_DIR + output);\n\n        // Before we put anything in, we deal with security.\n        File metaDir = new File(analysisDir, \"META-INF\");\n        metaDir.mkdir();\n\n        // Merge the ACLs from all the source\n        Acl.merge(runIdStrings, output);\n\n        if (user != null)\n            FileHelper.writeStringToFile(user, new File(metaDir, \"submitter\"));\n\n        Command c = new Command(cmd);\n        try {\n            c.execute();\n        } catch (InterruptedException e) {\n            String msg = \"Analysis interrupted\";\n            logger.log(Level.SEVERE, msg, e);\n            throw new IOException(msg);\n        }\n        File outIdx = new File(analysisDir, \"index.html\");\n        if (!outIdx.exists()) {\n            FileHelper.recursiveDelete(analysisDir);\n            throw new IOException(\"Failed creating analysis.\");\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: RunAnalyzer.java,v 1.9 2009/07/24 22:48:25 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\nimport com.sun.faban.harness.security.Acl;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.common.Command;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\nimport java.util.HashSet;\nimport java.util.ArrayList;\n\n/**\n * Run Analyzer that handles all the backend tasks to analyze the runs.\n *\n * @author Akara Sucharitakul\n */\npublic class RunAnalyzer {\n\n    /** Analyze types. */\n    public enum Type {\n\n        /** Comparison */\n        COMPARE,\n\n        /** Averaging */\n        AVERAGE;\n\n        /**\n         * Returns the string representation of the analysis type.\n         * @return The string representation of the enum elements in lower case\n         */\n        public String toString() {\n            return name().toLowerCase();\n        }\n    };\n\n    private static Logger logger =\n            Logger.getLogger(RunAnalyzer.class.getName());\n\n    /**\n     * Provides a suggested analysis name for the analysis based on the\n     * analysis type and and run ids that are used.\n     * The run id can come in the form of bench.seq or\n     * host.bench.seq. We try to keep the suggested name\n     * as short as possible. We have three formats:\n     * <ol>\n     * <li>Generic format: type_runId1_runId2...<\/li>\n     * <li>Same benchmark: type-bench_<host.>seq1_<host>.seq2...<\/li>\n     * <li>Same host, same benchmark: type-bench-host_seq1_seq2...<\/li>\n     * <\/ol>\n     * @return The suggested analysis name\n     */\n    public static String suggestName(Type type, String[] runIdStrings) {\n        StringBuilder suggestion = new StringBuilder();\n        HashSet<String> benchNameSet = new HashSet<String>();\n        HashSet<String> hostNameSet = new HashSet<String>();\n        suggestion.append(type);\n\n        RunId[] runIds = new RunId[runIdStrings.length];\n        String benchName = null;\n        String hostName = null;\n        for (int i = 0; i < runIdStrings.length; i++) {\n            RunId runId = new RunId(runIdStrings[i]);\n            benchName = runId.getBenchName();\n            hostName = runId.getHostName();\n            benchNameSet.add(benchName);\n            hostNameSet.add(hostName);\n            runIds[i] = runId;\n        }\n\n        if (benchNameSet.size() == 1) {\n            suggestion.append('-').append(benchName);\n            if (hostNameSet.size() == 1) {\n                if (hostName.length() > 0)\n                    suggestion.append('-').append(hostName);\n                for (RunId runId : runIds)\n                    suggestion.append('_').append(runId.getRunSeq());\n            } else {\n                for (RunId runId : runIds) {\n                    suggestion.append('_');\n                    hostName = runId.getHostName();\n                    if (hostName.length() > 0)\n                        suggestion.append(hostName).append('.');\n                    suggestion.append(runId.getRunSeq());\n                }\n            }\n        } else {\n            for (RunId runId : runIds)\n                suggestion.append('_').append(runId);\n        }\n        return suggestion.toString();\n\n    }\n\n    /**\n     * Checks whether the analysis with the given name exists.\n     * @param name The analysis name\n     * @return true if the analysis exists, false otherwise\n     */\n    public static boolean exists(String name) {\n        File analysisDir = new File(Config.ANALYSIS_DIR + name);\n        File resultFile = new File(analysisDir, \"index.html\");\n        if (resultFile.exists()) {\n            return true;\n        } else if (analysisDir.isDirectory()) {\n            FileHelper.recursiveDelete(analysisDir);\n            return false;\n        } else {\n            return false;\n        }\n    }\n\n    public static void clear(String name) {\n        File analysisDir = new File(Config.ANALYSIS_DIR + name);\n        if (analysisDir.isDirectory()) {\n            FileHelper.recursiveDelete(analysisDir);\n        }\n    }\n\n    /**\n     * Executes the run analysis.\n     * @param type The type of the analysis\n     * @param runIdStrings The run ids to analyze, in form of String array\n     * @param output The name of the analysis results\n     * @param user The user name requesting this analysis\n     * @throws IOException The analysis failed and results are not generated\n     */\n    public static void analyze(Type type, String[] runIdStrings,\n                               String output, String user)\n            throws IOException {\n        File analysisDir = new File(Config.ANALYSIS_DIR + output);\n        if (!analysisDir.mkdirs()) {\n            throw new IOException(\"Failed creating directory \" +\n                                    analysisDir +'!');\n        }\n        ArrayList<String> cmd = new ArrayList<String>();\n        cmd.add(Config.BIN_DIR.trim() + \"fenxi\");\n        cmd.add(type.toString());\n        for (String runId : runIdStrings) {\n            String inputDir = Config.OUT_DIR + runId;\n            if (new File(inputDir, \"xanaDB\").isDirectory()) {\n                cmd.add(inputDir);\n                continue;\n            }\n            inputDir += File.separator + Config.POST_DIR;\n            if (new File(inputDir, \"xanaDB\").isDirectory()) {\n                cmd.add(inputDir);\n                continue;\n            }\n            // If we're here, no xanaDB is found.\n            throw new IOException(\"RunId \" + runId +\n                    \" has not been post-processed and cannot be analyzed. \" +\n                    \"Please run fenxi process on the run result first.\");\n        }\n\n        cmd.add(Config.ANALYSIS_DIR + output);\n\n        // Before we put anything in, we deal with security.\n        File metaDir = new File(analysisDir, \"META-INF\");\n        metaDir.mkdir();\n\n        // Merge the ACLs from all the source\n        Acl.merge(runIdStrings, output);\n\n        if (user != null)\n            FileHelper.writeStringToFile(user, new File(metaDir, \"submitter\"));\n\n        Command c = new Command(cmd);\n        try {\n            c.execute();\n        } catch (InterruptedException e) {\n            String msg = \"Analysis interrupted\";\n            logger.log(Level.SEVERE, msg, e);\n            throw new IOException(msg);\n        }\n        File outIdx = new File(analysisDir, \"index.html\");\n        if (!outIdx.exists()) {\n            FileHelper.recursiveDelete(analysisDir);\n            throw new IOException(\"Failed creating analysis.\");\n        }\n    }\n}\n","lineNo":167}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: TableHandler.java,v 1.10 2009/05/26 21:06:54 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n/**\n * Handler for parsing the log and displaying a log record in a\n * table format showing the essential fields of each log record.\n *\n * @author Akara Sucharitakul\n */\nclass TableHandler extends LogParseHandler {\n    boolean displayEnd = false;\n    boolean headerWritten = false;\n    String requestBase;\n    LogBuffer logBuffer;\n\n    public TableHandler(long start, HttpServletRequest request,\n                                ServletOutputStream out, String runId) {        \n        super(request, out, runId);\n        requestBase = request.getRequestURI() + \"?runId=\" + runId;\n        if (Config.LOG_VIEW_BUFFER_SIZE > 0){\n            logBuffer = new LogBuffer(Config.LOG_VIEW_BUFFER_SIZE);\n        }\n        if (start == -1) {\n            displayEnd = true;\n        } else if (logBuffer == null){\n            begin = start;\n            end = Long.MAX_VALUE;\n        } else {\n            begin = start;\n            end = start + logBuffer.capacity();\n        }\n    }\n\n    @Override\n    public void processRecord() throws IOException {\n        if (logBuffer != null) {\n            LogRecord oldLog = logBuffer.add(logRecord);\n\n            // Recycle the old records.\n            if (oldLog == null)\n                logRecord = new LogRecord();\n            else {\n                logRecord = oldLog;\n                logRecord.clear();\n            }\n        }else{\n            if (headerWritten == false) {\n                printHeader(null);\n                headerWritten = true;\n            }\n            printRow(begin + recordCount++, logRecord, requestBase);\n            logRecord.clear();\n        }\n    }\n\n    public void processDetail(String qName) {\n        if (\"exception\".equals(qName))\n            logRecord.exceptionFlag = true;\n    }\n\n    public void printHtml()\n            throws IOException {\n        \n        String naviBar = null;\n        \n        if (logBuffer != null) {\n\n            // Recalculate the real begin based on the parser.\n            begin = recordCount - logBuffer.size();\n            if (begin < 0l) {\n                begin = 0l;\n            }\n\n            // Prepare the navigation links\n            StringBuilder naviBuffer = new StringBuilder(256);\n            if (begin > 0l) {\n                naviBuffer.append(\"<a href=\\\"\" + requestBase + \"\\\">Top<\/a>\\n\");\n                long prevPage = begin - logBuffer.capacity() / 2l;\n                if (prevPage < 0l) {\n                    prevPage = 0l;\n                }\n                naviBuffer.append(\"<a href=\\\"\" + requestBase + \"&startId=\" +\n                        prevPage + \"\\\">PgUp<\/a>\\n\");\n            } else {\n                naviBuffer.append(\"Top PgUp \");\n            }\n\n            long nextPage = begin + logBuffer.size() / 2l;\n            naviBuffer.append(\"<a href=\\\"\" + requestBase + \"&startId=\" +\n                    nextPage + \"\\\">PgDn<\/a>\\n\");\n\n            naviBuffer.append(\"<a href=\\\"\" + requestBase +\n                    \"&startId=end#end\\\">Bottom<\/a>\");\n            naviBar = naviBuffer.toString();\n\n            printHeader(naviBar);\n\n            // Write the records.\n            int size = logBuffer.size();\n            for (int i = 0; i < size; i++) {\n                printRow(begin + i, logBuffer.get(i), requestBase);\n            }\n        }\n        printTrailer(naviBar);\n    }\n    \n    private void printHeader(String naviBar) throws IOException {\n        // Write the header.\n        out.println(\"<html>\");\n        out.print(\"<head><title>Logs: RunID \" + runId);\n        out.println(\"<\/title>\");\n        out.println(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \" +\n                    \"href=\\\"/css/style.css\\\" />\");\n        out.println(\"<link rel=\\\"icon\\\" type=\\\"image/gif\\\" href=\\\"\" +\n                    request.getContextPath() + \"/img/faban.gif\\\">\");        \n        if (displayEnd && !xmlComplete)\n            out.print(\"<meta http-equiv=\\\"refresh\\\" content=\\\"10\\\">\");\n        out.println(\"<\/head><body>\");\n        if (naviBar != null)\n            out.println(naviBar);\n        out.println(\"<hr style=\\\"border: 1px solid #cccccc;\\\">\" +\n                    \"<table border=\\\"0\\\" cellpadding=\\\"4\\\" \" +\n                    \"cellspacing=\\\"3\\\" style=\\\"padding: 2px; border: \" +\n                    \"2px solid #cccccc;\\\">\");\n        out.println(\"<tbody>\");\n        out.println(\"<tr>\");\n        out.println(\"<th class=\\\"header\\\">Time<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Host<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Level<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Message<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Thread<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Source<\/th>\");\n        out.println(\"<\/tr>\");        \n    }\n    \n    private void printTrailer(String naviBar) throws IOException {\n        // Write the trailer.\n        out.println(\"<\/tbody><\/table><a name=\\\"end\\\">\" +\n                \"<hr style=\\\"border: 1px solid #cccccc;\\\"><\/a>\");\n        if (naviBar != null)\n            out.println(naviBar);\n        out.println(\"<\/body><\/html>\");        \n    }\n\n    private void printRow(long sequence, LogRecord record, String requestBase)\n            throws IOException {\n        out.print(\"<tr class=\\\"\" + ROWCLASS[(int) (sequence % 2l)] + \"\\\">\");\n        out.println(\"<td class=\\\"tablecell\\\">\" + record.date + \"<\/td>\");\n        if (record.host == null) {\n            out.println(\"<td class=\\\"tablecell\\\">&nbsp;<\/td>\");\n        } else {\n            int endHostName = record.host.indexOf('.');\n            if (endHostName > 0)\n                record.host = record.host.substring(0, endHostName);\n            out.println(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center;\\\">\" + record.host +\n                    \"<\/td>\");\n        }\n        if (\"SEVERE\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold; color: rgb(255, 0, 0);\\\">\");\n        } else if (\"WARNING\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold; color: rgb(255, 102, 51);\\\">\");\n        } else if (\"INFO\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold; color: rgb(0, 192, 0);\\\">\");\n        } else if (\"CONFIG\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold;\\\">\");\n        } else {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center;\\\">\");\n        }\n        out.print(record.level);\n        if (record.exceptionFlag)\n            out.println(\"<font size=\\\"-1\\\"><i><br><a href=\\\"\" +\n                    requestBase + \"&exception=\" + record.id +\n                    \"\\\">exception<\/a><\/i><\/font><\/td>\");\n        else\n            out.println(\"<\/td>\");\n        out.println(\"<td class=\\\"tablecell\\\">\" + record.message + \"<\/td>\");\n        out.println(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center;\\\">\" + record.thread +\n                \"<\/td>\");\n        out.println(\"<td class=\\\"tablecell\\\">\" + record.clazz + '.' + record.method + \"<\/td>\");\n        out.println(\"<\/tr>\");\n    }\n\n    static class LogBuffer {\n        LogRecord[] buffer = null;\n        int bufPtr = 0;\n        boolean wrapped = false;\n\n        public LogBuffer(int size) {\n            buffer = new LogRecord[size];\n        }\n\n        public LogRecord add(LogRecord record) {\n            LogRecord oldRecord = buffer[bufPtr];\n            buffer[bufPtr++] = record;\n            if (bufPtr >= buffer.length) {\n                bufPtr = 0;\n                wrapped = true;\n            }\n            return oldRecord;\n        }\n\n        public LogRecord get(int id) {\n            if (wrapped)\n                id += bufPtr;\n            if (id >= buffer.length)\n                id -= buffer.length;\n            return buffer[id];\n        }\n\n        public int size() {\n            if (!wrapped)\n                return bufPtr;\n            return buffer.length;\n        }\n\n        public int capacity() {\n            return buffer.length;\n        }\n\n        public boolean filled() {\n            return wrapped;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: TableHandler.java,v 1.11 2009/06/23 18:34:08 sheetalpatil Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\n\nimport javax.servlet.ServletOutputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n/**\n * Handler for parsing the log and displaying a log record in a\n * table format showing the essential fields of each log record.\n *\n * @author Akara Sucharitakul\n */\nclass TableHandler extends LogParseHandler {\n    boolean displayEnd = false;\n    boolean headerWritten = false;\n    String requestBase;\n    LogBuffer logBuffer;\n\n    public TableHandler(long start, HttpServletRequest request,\n                                ServletOutputStream out, String runId) {        \n        super(request, out, runId);\n        requestBase = request.getRequestURI() + \"?runId=\" + runId;\n        if (Config.LOG_VIEW_BUFFER_SIZE > 0){\n            logBuffer = new LogBuffer(Config.LOG_VIEW_BUFFER_SIZE);\n        }\n        if (start == -1) {\n            displayEnd = true;\n        } else if (logBuffer == null){\n            begin = start;\n            end = Long.MAX_VALUE;\n        } else {\n            begin = start;\n            end = start + logBuffer.capacity();\n        }\n    }\n\n    @Override\n    public void processRecord() throws IOException {\n        if (logBuffer != null) {\n            LogRecord oldLog = logBuffer.add(logRecord);\n\n            // Recycle the old records.\n            if (oldLog == null)\n                logRecord = new LogRecord();\n            else {\n                logRecord = oldLog;\n                logRecord.clear();\n            }\n        }else{\n            if (headerWritten == false) {\n                printHeader(null);\n                headerWritten = true;\n            }\n            printRow(begin + recordCount++, logRecord, requestBase);\n            logRecord.clear();\n        }\n    }\n\n    public void processDetail(String qName) {\n        if (\"exception\".equals(qName))\n            logRecord.exceptionFlag = true;\n    }\n\n    public void printHtml()\n            throws IOException {\n        \n        String naviBar = null;\n        \n        if (logBuffer != null) {\n\n            // Recalculate the real begin based on the parser.\n            begin = recordCount - logBuffer.size();\n            if (begin < 0l) {\n                begin = 0l;\n            }\n\n            // Prepare the navigation links\n            StringBuilder naviBuffer = new StringBuilder(256);\n            if (begin > 0l) {\n                naviBuffer.append(\"<a href=\\\"\" + requestBase + \"\\\">Top<\/a>\\n\");\n                long prevPage = begin - logBuffer.capacity() / 2l;\n                if (prevPage < 0l) {\n                    prevPage = 0l;\n                }\n                naviBuffer.append(\"<a href=\\\"\" + requestBase + \"&startId=\" +\n                        prevPage + \"\\\">PgUp<\/a>\\n\");\n            } else {\n                naviBuffer.append(\"Top PgUp \");\n            }\n\n            long nextPage = begin + logBuffer.size() / 2l;\n            naviBuffer.append(\"<a href=\\\"\" + requestBase + \"&startId=\" +\n                    nextPage + \"\\\">PgDn<\/a>\\n\");\n\n            naviBuffer.append(\"<a href=\\\"\" + requestBase +\n                    \"&startId=end#end\\\">Bottom<\/a>\");\n            naviBar = naviBuffer.toString();\n\n            printHeader(naviBar);\n\n            // Write the records.\n            int size = logBuffer.size();\n            for (int i = 0; i < size; i++) {\n                printRow(begin + i, logBuffer.get(i), requestBase);\n            }\n        }\n        printTrailer(naviBar);\n    }\n    \n    private void printHeader(String naviBar) throws IOException {\n        // Write the header.\n        out.println(\"<html>\");\n        out.print(\"<head><title>Logs: RunID \" + runId);\n        out.println(\"<\/title>\");\n        out.println(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \" +\n                    \"href=\\\"/css/style.css\\\" />\");\n        out.println(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" \" +\n                    \"href=\\\"/css/balloontip2.css\\\" />\");\n        out.println(\"<script type=\\\"text/javascript\\\" \" +\n                    \"src=\\\"/scripts/balloontip2.js\\\"><\/script>\");\n        out.println(\"<link rel=\\\"icon\\\" type=\\\"image/gif\\\" href=\\\"\" +\n                    request.getContextPath() + \"/img/faban.gif\\\">\");        \n        if (displayEnd && !xmlComplete)\n            out.print(\"<meta http-equiv=\\\"refresh\\\" content=\\\"10\\\">\");\n        out.println(\"<\/head><body>\");\n        if (naviBar != null)\n            out.println(naviBar);\n        out.println(\"<hr style=\\\"border: 1px solid #cccccc;\\\">\" +\n                    \"<table border=\\\"0\\\" cellpadding=\\\"4\\\" \" +\n                    \"cellspacing=\\\"3\\\" style=\\\"padding: 2px; border: \" +\n                    \"2px solid #cccccc;\\\">\");\n        out.println(\"<tbody>\");\n        out.println(\"<tr>\");\n        out.println(\"<th class=\\\"header\\\">Time<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Host<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Level<\/th>\");\n        out.println(\"<th class=\\\"header\\\">Message<\/th>\");\n        //out.println(\"<th class=\\\"header\\\">Thread<\/th>\");\n        //out.println(\"<th class=\\\"header\\\">Source<\/th>\");\n        out.println(\"<\/tr>\");        \n    }\n    \n    private void printTrailer(String naviBar) throws IOException {\n        // Write the trailer.\n        out.println(\"<\/tbody><\/table><a name=\\\"end\\\">\" +\n                \"<hr style=\\\"border: 1px solid #cccccc;\\\"><\/a>\");\n        if (naviBar != null)\n            out.println(naviBar);\n        out.println(\"<\/body><\/html>\");        \n    }\n\n    private void printRow(long sequence, LogRecord record, String requestBase)\n            throws IOException {\n        String dt = record.date.toString();\n        dt = dt.substring(dt.lastIndexOf(\"T\")+1, dt.length());\n        String thread = \"Thread: \" + record.thread;\n        String source = \"Source: \" + record.clazz + '.' + record.method;       \n        String content = thread + \"<br/>\" + source;\n        String msgmouseover = \"onmouseover=\\\"showtip('\"+ content +\"', '\"+ content.length() * 6 +\"')\\\" onmouseout=\\\"hideddrivetip()\\\"\";\n        String datemouseover = \"onmouseover=\\\"showtip('\"+ record.date +\"')\\\" onmouseout=\\\"hideddrivetip()\\\"\";\n        out.print(\"<tr class=\\\"\" + ROWCLASS[(int) (sequence % 2l)] + \"\\\">\");\n        out.println(\"<td \" + datemouseover + \"  class=\\\"tablecell\\\">\" + dt + \"<\/td>\");\n        if (record.host == null) {\n            out.println(\"<td class=\\\"tablecell\\\">&nbsp;<\/td>\");\n        } else {\n            int endHostName = record.host.indexOf('.');\n            if (endHostName > 0)\n                record.host = record.host.substring(0, endHostName);\n            out.println(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center;\\\">\" + record.host +\n                    \"<\/td>\");\n        }\n        if (\"SEVERE\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold; color: rgb(255, 0, 0);\\\">\");\n        } else if (\"WARNING\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold; color: rgb(255, 102, 51);\\\">\");\n        } else if (\"INFO\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold; color: rgb(0, 192, 0);\\\">\");\n        } else if (\"CONFIG\".equals(record.level)) {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center; font-weight: \" +\n                    \"bold;\\\">\");\n        } else {\n            out.print(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center;\\\">\");\n        }\n        out.print(record.level);\n        if (record.exceptionFlag)\n            out.println(\"<font size=\\\"-1\\\"><i><br><a href=\\\"\" +\n                    requestBase + \"&exception=\" + record.id +\n                    \"\\\">exception<\/a><\/i><\/font><\/td>\");\n        else\n            out.println(\"<\/td>\");\n        out.println(\"<td \" + msgmouseover + \" class=\\\"tablecell\\\">\" + record.message + \"<\/td>\");\n        //out.println(\"<td class=\\\"tablecell\\\" style=\\\"text-align: center;\\\">\" + record.thread +\n        //        \"<\/td>\");\n        //out.println(\"<td class=\\\"tablecell\\\">\" + record.clazz + '.' + record.method + \"<\/td>\");\n        out.println(\"<\/tr>\");\n    }\n\n    static class LogBuffer {\n        LogRecord[] buffer = null;\n        int bufPtr = 0;\n        boolean wrapped = false;\n\n        public LogBuffer(int size) {\n            buffer = new LogRecord[size];\n        }\n\n        public LogRecord add(LogRecord record) {\n            LogRecord oldRecord = buffer[bufPtr];\n            buffer[bufPtr++] = record;\n            if (bufPtr >= buffer.length) {\n                bufPtr = 0;\n                wrapped = true;\n            }\n            return oldRecord;\n        }\n\n        public LogRecord get(int id) {\n            if (wrapped)\n                id += bufPtr;\n            if (id >= buffer.length)\n                id -= buffer.length;\n            return buffer[id];\n        }\n\n        public int size() {\n            if (!wrapped)\n                return bufPtr;\n            return buffer.length;\n        }\n\n        public int capacity() {\n            return buffer.length;\n        }\n\n        public boolean filled() {\n            return wrapped;\n        }\n    }\n}\n","lineNo":179}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: NegativeExponential.java,v 1.1 2008/09/10 18:25:54 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.driver.util.Random;\nimport com.sun.faban.driver.DefinitionException;\nimport com.sun.faban.driver.CycleType;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * Implements the negative exponential distribution/selection.\n *\n * @author Akara Sucharitakul\n */\npublic class NegativeExponential extends Cycle {\n\n    /**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\tlong cycleMean;\n    long cycleMax;\n\n    /**\n     * Initializes this cycle according to the annotation.\n     * @param a The annotation\n     * @throws DefinitionException If there is an error in the annotation\n     */\n\tpublic void init(Annotation a) throws DefinitionException {\n        com.sun.faban.driver.NegativeExponential cycleDef =\n                (com.sun.faban.driver.NegativeExponential) a;\n        cycleType = cycleDef.cycleType();\n        cycleDeviation = cycleDef.cycleDeviation();\n        cycleMean = cycleDef.cycleMean();\n        cycleMax = cycleDef.cycleMax();\n        if (cycleMax == -1) {\n\t\t\tcycleMax = 5 * cycleMean;\n\t\t}\n\n        // Now check parameters for validity.\n        if (cycleMean < 0) {\n\t\t\tthrow new DefinitionException(\"@NegativeExponential cycleMean < 0\");\n\t\t}\n        if (cycleMax < 0) {\n\t\t\tthrow new DefinitionException(\"@NegativeExponential cycleMax < 0\");\n\t\t}\n        if (cycleMean > cycleMax) {\n\t\t\tthrow new DefinitionException(\n                    \"@NegativeExponential cycleMean > cycleMax\");\n\t\t}\n        if (cycleMax == 0 && cycleType == CycleType.CYCLETIME) {\n\t\t\tthrow new DefinitionException(\n                    \"@NegativeExponential CYCLETIME cycleMax cannot be 0\");\n\t\t}\n        // Adjust time to nanosec.\n        cycleMean *= 1000000l;\n        cycleMax *= 1000000l;\n    }\n\n    /**\n     * Randoms/calculates the delay time for a thread based on its\n     * supplied random number generator and the actual conditions in the\n     * distribution.\n     *\n     * @param random The random number generator used\n     * @return The delay time\n     */\n\tpublic long getDelay(Random random) {\n        long delay = 0;\n        if (cycleMean > 0) {\n            double x = random.drandom(0.0, 1.0);\n            if (x == 0) {\n\t\t\t\tx = 0.05;\n\t\t\t}\n            delay = (long)(cycleMean * -Math.log(x));\n            if (delay > cycleMax) {\n\t\t\t\tdelay = cycleMax;\n\t\t\t}\n        }\n        return delay;\n    }\n\n    /**\n     * Provides the maximum value to be represented inside a histogram.\n     *\n     * @return The max reasonable delay to be presented in the output histogram.\n     */\n\tpublic double getHistogramMax() {\n        if (cycleMax > 0) {\n\t\t\treturn cycleMax;\n\t\t}\n\n        // We know it takes very little time to prepare the data to submit.\n        // This case can only happen for think time. Giving a histogram\n        // max of 2 seconds for data prep should be enough.\n        return 2d;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: NegativeExponential.java,v 1.2 2009/06/10 23:40:10 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.driver.util.Random;\nimport com.sun.faban.driver.DefinitionException;\nimport com.sun.faban.driver.CycleType;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * Implements the negative exponential distribution/selection.\n *\n * @author Akara Sucharitakul\n */\npublic class NegativeExponential extends Cycle {\n\n    /**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n    long cycleMin;\n\tlong cycleMean;\n    long cycleMax;\n    boolean truncate;\n\n    /**\n     * Initializes this cycle according to the annotation.\n     * @param a The annotation\n     * @throws DefinitionException If there is an error in the annotation\n     */\n\tpublic void init(Annotation a) throws DefinitionException {\n        com.sun.faban.driver.NegativeExponential cycleDef =\n                (com.sun.faban.driver.NegativeExponential) a;\n        cycleType = cycleDef.cycleType();\n        cycleDeviation = cycleDef.cycleDeviation();\n        cycleMin = cycleDef.cycleMin();\n        cycleMean = cycleDef.cycleMean();\n        cycleMax = cycleDef.cycleMax();\n        truncate = cycleDef.truncateAtMin();\n        if (cycleMax == -1) {\n\t\t\tcycleMax = 5 * cycleMean;\n\t\t}\n\n        // Now check parameters for validity.\n        if (cycleMin < 0) {\n\t\t\tthrow new DefinitionException(\"@NegativeExponential cycleMin < 0\");\n\t\t}\n        if (cycleMean < 0) {\n\t\t\tthrow new DefinitionException(\"@NegativeExponential cycleMean < 0\");\n\t\t}\n        if (cycleMax < 0) {\n\t\t\tthrow new DefinitionException(\"@NegativeExponential cycleMax < 0\");\n\t\t}\n        if (cycleMin > cycleMean) {\n\t\t\tthrow new DefinitionException(\n                    \"@NegativeExponential cycleMin > cycleMean\");\n\t\t}\n        if (cycleMean > cycleMax) {\n\t\t\tthrow new DefinitionException(\n                    \"@NegativeExponential cycleMean > cycleMax\");\n\t\t}\n        if (cycleMax == 0 && cycleType == CycleType.CYCLETIME) {\n\t\t\tthrow new DefinitionException(\n                    \"@NegativeExponential CYCLETIME cycleMax cannot be 0\");\n\t\t}\n        // Adjust time to nanosec.\n        cycleMin  *= 1000000l;\n        cycleMean *= 1000000l;\n        cycleMax  *= 1000000l;\n    }\n\n    /**\n     * Randoms/calculates the delay time for a thread based on its\n     * supplied random number generator and the actual conditions in the\n     * distribution.\n     *\n     * @param random The random number generator used\n     * @return The delay time\n     */\n\tpublic long getDelay(Random random) {\n        long delay = 0;\n        long mean = cycleMean;\n        long shift = 0;\n        \n        if (!truncate) {\n            shift = cycleMin;\n            mean = cycleMean - shift;\n        }\n\n        if (cycleMean > 0) {\n            double x = random.drandom(0.0, 1.0);\n            if (x == 0) {\n\t\t\t\tx = 1e-20d;\n\t\t\t}\n            delay = shift + (long)(mean * -Math.log(x));\n            if (delay < cycleMin) {\n                delay = cycleMin;\n            } else if (delay > cycleMax) {\n\t\t\t\tdelay = cycleMax;\n\t\t\t}\n        }\n        return delay;\n    }\n\n    /**\n     * Provides the maximum value to be represented inside a histogram.\n     *\n     * @return The max reasonable delay to be presented in the output histogram.\n     */\n\tpublic double getHistogramMax() {\n        if (cycleMax > 0) {\n\t\t\treturn cycleMax;\n\t\t}\n\n        // We know it takes very little time to prepare the data to submit.\n        // This case can only happen for think time. Giving a histogram\n        // max of 2 seconds for data prep should be enough.\n        return 2d;\n    }\n}\n","lineNo":104}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: AgentBootstrap.java,v 1.19 2009/05/30 04:43:47 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.rmi.RMISecurityManager;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.RMISocketFactory;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.*;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * Bootstrap class for the CmdAgent and FileAgent\n */\npublic class AgentBootstrap {\n\n    private static int daemonPort = 9981;\n\n    private static Logger logger =\n                            Logger.getLogger(AgentBootstrap.class.getName());\n    static AgentSocketFactory socketFactory;\n    static String progName;\n    static boolean daemon = false;\n    static boolean agentsAreUp = false;\n    static String host;\n    static String ident;\n    static String master;\n    static Registry registry;\n    static String javaHome;\n    static String downloadURL;\n    // Initialize it to make sure it doesn't end up a 'null'\n    static ArrayList<String> jvmOptions = new ArrayList<String>();\n    static ArrayList<String> extClassPath = new ArrayList<String>();\n    static CmdAgentImpl cmd;\n    static FileAgentImpl file;\n    static final Set<String> registeredNames =\n                    Collections.synchronizedSet(new HashSet<String>());\n\n    public static void main(String[] args) {\n        System.setSecurityManager (new RMISecurityManager());\n\n        progName = System.getProperty(\"faban.cli.command\");\n        String usage = \"Usage: \" + progName + \" [port]\";\n\n        if (args.length < 2) {\n            if (args.length == 1) {\n                if (\"-h\".equals(args[0]) || \"--help\".equals(args[0]) ||\n                                            \"-?\".equals(args[0])) {\n                    System.err.println(usage);\n                    System.exit(0);\n                } else {\n                    daemonPort = Integer.parseInt(args[0]);\n                }\n            }\n            startDaemon();\n        } else if (args.length > 3) {\n            try {\n                startAgents(args);\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        } else {\n            // We do not expose the start params for agent mode as that\n            // is not supposed to be called by the user. The daemon mode\n            // has only one optional param - port.\n            System.err.println(usage);\n            System.exit(-1);\n        }\n    }\n\n    private static void startDaemon() {\n        daemon = true;\n        /* Note that the daemon is not designed to accept any concurrency at\n         * all and hence the accept/dispatch is not threaded. This is not a\n         * bug. It should only receive one and only one connection request per\n         * run. Requests to start an agent while one is running will return\n         * with an error. We don't care if a concurrent request has to wait.\n         * Simplicity is the goal here.\n         */\n        try {\n            ServerSocket serverSocket = new ServerSocket(daemonPort);\n            byte[] buffer = new byte[8192];\n            for (;;) {\n                Socket socket = serverSocket.accept();\n                InputStream in = socket.getInputStream();\n                OutputStream out = socket.getOutputStream();\n                int length = in.read(buffer);\n                if (length > 0) {\n                    String argLine = new String(buffer, 0, length);\n                    System.out.println(\"Agent(Daemon) starting agent with options: \" +\n                                                                    argLine);\n                    String[] args = argLine.split(\" \");\n                    if (args.length < 4) {\n                       out.write(\"400 ERROR: Inadequate params.\".getBytes());\n                    }\n                    try {\n                        startAgents(args);\n                        out.write(\"200 OK\".getBytes());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        out.write((\"500 ERROR: \" + e.getMessage()).getBytes());\n                    }\n                }\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n                try {\n                    out.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();  // We don't use logger here 'cause we don't\n            // know the harness at this time.\n            // The logger may not be configured properly.\n            System.exit(1);\n        }\n\n    }\n\n    private static synchronized void startAgents(String[] args)\n            throws Exception {\n\n        String hostname = args[0];\n        master = args[1];\n        String masterLocal = args[2];\n        javaHome = args[3];\n\n        String benchName = null;\n\n        // Setup the basic jvmOptions for this environment which may not\n        // be the same as passed down from the master.\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                                                        fs + \"faban.policy\");\n        host = InetAddress.getLocalHost().getHostName();\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                                        \"config\" + fs + \"logging.\" + host +\n                                        \".properties\");\n\n        ArrayList<String> libPath = new ArrayList<String>();\n        String libPrefix = \"-Djava.library.path=\";\n\n        // There may be optional JVM args\n        boolean isClassPath = false;\n        if(args.length > 4) {\n            for(int i = 4; i < args.length; i++)\n                if(args[i].startsWith(\"faban.download\")) {\n                    downloadURL = args[i].substring(\n                            args[i].indexOf('=') + 1);\n                }else if (args[i].startsWith(\"faban.benchmarkName\")) {\n                    benchName = args[i].substring(args[i].indexOf('=') + 1);\n                } else if (args[i].indexOf(\"faban.logging.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.LOGGING_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].indexOf(\"faban.registry.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.RMI_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].startsWith(\"-Dfaban.command.buffer=\")) {\n                    String[] prop = args[i].substring(2).split(\"=\");\n                    System.setProperty(prop[0], prop[1]);\n                    // Pass it along, too.\n                    jvmOptions.add(args[i]);\n                } else if (\"-server\".equals(args[i]) ||\n                        \"-client\".equals(args[i])) { // prepend these options\n                    jvmOptions.add(0, args[i]);\n                } else if (args[i].startsWith(\"-Dfaban.home=\") ||\n                        args[i].startsWith(\"-Djava.security.policy=\") ||\n                        args[i].startsWith(\"-Djava.util.logging.config.file=\")){\n                    // These are sometimes passed down from the master.\n                    // Ignore these. Use our local settings instead.\n                    // NOOP\n                } else if (\"-cp\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (\"-classpath\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (isClassPath) {\n                    String[] cp = pathSplit(args[i]);\n                    for (String cpElement : cp)\n                        extClassPath.add(cpElement);\n                    isClassPath = false;\n                } else if (args[i].startsWith(libPrefix)) {\n                    String[] lp = pathSplit(\n                            args[i].substring(libPrefix.length()));\n                    for (String lpElement : lp)\n                        libPath.add(lpElement);\n                } else {\n                    jvmOptions.add(args[i]);\n                }\n        }\n\n        setLogger();\n\n        // Ensure proper JAVA_HOME by searching for the java executable.\n        File java = null;\n        File javaBin = new File(javaHome, \"bin\");\n        if (javaBin.isDirectory()) {\n            String[] pathExts = CmdMap.getPathExt();\n            if (pathExts != null) {\n                for (String ext : pathExts) {\n                    ext = ext.trim();\n                    if (ext == null || ext.length() == 0)\n                        continue;\n                    File javaPath = new File(javaBin, \"java\" + ext);\n                    if (javaPath.exists()) {\n                        java = javaPath;\n                        break;\n                    }\n                }\n            }\n            if (java == null) {\n                java = new File(javaBin, \"java\");\n                if (!java.exists()) {\n                    java = null;\n                }\n            }\n        }\n\n        // If not found, just use the process' JAVA_HOME instead.\n        if (java == null) {\n            String newJavaHome = Utilities.getJavaHome();\n            if (!newJavaHome.equals(javaHome)) {\n                logger.warning(\"JAVA_HOME \" + javaHome +\n                        \" does not exist. Using \" + newJavaHome + \" instead.\");\n                javaHome = newJavaHome;\n            }\n        }\n\n        logger.finer(\"JVM options for child processes:\" + jvmOptions);\n\n        // We cannot set the socket factory twice. So we need to reconfigure it.\n        if (socketFactory == null) {\n            socketFactory = new AgentSocketFactory(master, masterLocal);\n            RMISocketFactory.setSocketFactory(socketFactory);\n        } else {\n            socketFactory.setMaster(master, masterLocal);\n        }\n\n        // Get hold of the registry\n        registry = RegistryLocator.getRegistry(master, Config.RMI_PORT);\n        logger.fine(\"Succeeded obtaining registry.\");\n\n        // Sometimes we get the host name with the whole domain baggage.\n        // The host name is widely used in result files, tools, etc. We\n        // do not want that baggage. So we make sure to crop it off.\n        // i.e. brazilian.sfbay.Sun.COM should just show as brazilian.\n        int dotIdx = host.indexOf('.');\n        if (dotIdx > 0)\n            host = host.substring(0, dotIdx);\n\n        //ident will be unique\n        ident = Config.CMD_AGENT + \"@\" + host;\n\n        // Make sure there is only one agent running in a machine\n        CmdAgent agent = (CmdAgent) registry.getService(ident);\n\n        if (agent == null) { // If not found, reregister new agent.\n            boolean agentCreated = false;\n            if (cmd == null) {\n                cmd = new CmdAgentImpl();\n                agentCreated = true;\n                logger.fine(hostname + \"(Realname: \" + host +\n                                                \") created CmdAgentImpl\");\n            }\n\n            if (register(ident, cmd)) { // Double check for race condition\n                agent = cmd;\n\n                // setBenchName scans all resources.\n                // Benchmark needs to be loaded first.\n                new Download().loadBenchmark(benchName, downloadURL);\n                cmd.setBenchName(benchName, libPath);\n\n                if(host.equals(master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                } else if (sameHost(host, master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                }\n\n                // Create and reregister FileAgent\n                if (file == null)\n                    file = new FileAgentImpl();\n                reregister(Config.FILE_AGENT + \"@\" + host, file);\n\n                // Register a blank Config.FILE_AGENT for the master's\n                // file agent.\n                if (sameHost(host, master))\n                    reregister(Config.FILE_AGENT, file);\n            } else { // If we run into that, we just grab the agent again.\n                if (agentCreated) {\n                    UnicastRemoteObject.unexportObject(cmd, true);\n                    agentCreated = false;\n                    logger.fine(hostname + \"(Realname: \" + host +\n                                                \") unexported CmdAgentImpl\");\n                }\n                agent = (CmdAgent) registry.getService(ident);\n            }\n        }\n\n        // Only if the 'hostname' is an interface name and not equal\n        // the actual host name, we re-reregister the agents with the 'hostname'\n        if (!host.equals(hostname)) {\n            reregister(Config.CMD_AGENT + \"@\" + hostname, agent);\n\n            // The FileAgent registration may have a significant lag time\n            // from the CmdAgent registration due to downloads, etc.\n            // We just need to wait.\n            FileAgent f = (FileAgent) registry.getService(\n                                            Config.FILE_AGENT + \"@\" + host);\n            int retry = 0;\n            while (f == null) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                }\n                f = (FileAgent) registry.getService(\n                        Config.FILE_AGENT + \"@\" + host);\n                if (++retry > 100)\n                    break;\n            }\n            if (f != null)\n                reregister(Config.FILE_AGENT + \"@\" + hostname, f);\n            else\n                logger.severe(\"Giving up re-registering file agent at \" + host +\n                        \" as \" + hostname +\" after \" + retry + \" retries.\");\n        }\n    }\n\n    private static boolean register(String name, Remote service)\n            throws RemoteException {\n        boolean success = false;\n        if (registeredNames.add(name)) {\n            success = registry.register(name, service);\n            if (success) {\n                logger.fine(\"Succeeded registering \" + name);\n            } else {\n                logger.fine(\"Failed registering \" + name +\n                                        \". Entry already exists.\");\n            }\n        }\n        return success;\n    }\n\n    private static void reregister(String name, Remote service)\n            throws RemoteException {\n        if (registeredNames.add(name)) {\n            registry.reregister(name, service);\n            logger.fine(\"Succeeded re-registering \" + name);\n        }\n    }\n\n    static void deregisterAgents() throws RemoteException {\n        synchronized(registeredNames) {\n            for (String name : registeredNames)\n                registry.unregister(name);\n\n            registeredNames.clear();\n        }\n    }\n\n    static void terminateAgents() {\n        if (!daemon) {\n            System.exit(0);\n        }\n    }\n\n    /**\n     * This method is for splitting both Unix and Windows paths into their\n     * pathElements. It detects the path separator whether it is Unix or\n     * Windows style and takes care of the separators accordingly.\n     * @param path The path to split\n     * @return The splitted path\n     */\n    private static String[] pathSplit(String path) {\n        String pathSeparator = \":\";  // Unix style by default.\n\n        // Check for '\\' used in Windows paths.\n        if (path.indexOf('\\\\') >= 0) {\n            pathSeparator=\";\";\n        }\n\n        return path.split(pathSeparator);\n    }\n\n    private static boolean sameHost(String host1, String host2) {\n        InetAddress[] host1Ip = new InetAddress[0];\n        try {\n            host1Ip = InetAddress.getAllByName(host1);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host1 + \" not found.\");\n            return false;\n        }\n        InetAddress[] host2Ip = new InetAddress[0];\n        try {\n            host2Ip = InetAddress.getAllByName(host2);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host2 + \" not found.\");\n            return false;\n        }\n        for (int i = 0; i < host1Ip.length; i++) {\n            for (int j = 0; j < host2Ip.length; j++) {\n                if (host1Ip[i].equals(host2Ip[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private static void setLogger() {\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            logger.fine(\"Updating \" + Config.CONFIG_DIR + \"logging.\" +\n                    host + \".properties\");\n            log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n            log.setProperty(\"java.util.logging.SocketHandler.port\",\n                    String.valueOf(Config.LOGGING_PORT));\n            FileOutputStream out = new FileOutputStream(\n                    new File(Config.CONFIG_DIR + \"logging.\" + host +\n                    \".properties\"));\n            log.store(out, \"Faban logging properties\");\n            out.close();\n\n            LogManager.getLogManager().readConfiguration(new FileInputStream(\n                    Config.CONFIG_DIR + \"logging.\" + host + \".properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: AgentBootstrap.java,v 1.20 2009/05/30 23:46:59 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.net.UnknownHostException;\nimport java.rmi.RMISecurityManager;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.RMISocketFactory;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.*;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * Bootstrap class for the CmdAgent and FileAgent\n */\npublic class AgentBootstrap {\n\n    private static int daemonPort = 9981;\n\n    private static Logger logger =\n                            Logger.getLogger(AgentBootstrap.class.getName());\n    static AgentSocketFactory socketFactory;\n    static String progName;\n    static boolean daemon = false;\n    static boolean agentsAreUp = false;\n    static String host;\n    static String ident;\n    static String master;\n    static Registry registry;\n    static String javaHome;\n    static String downloadURL;\n    // Initialize it to make sure it doesn't end up a 'null'\n    static ArrayList<String> jvmOptions = new ArrayList<String>();\n    static ArrayList<String> extClassPath = new ArrayList<String>();\n    static CmdAgentImpl cmd;\n    static FileAgentImpl file;\n    static final Set<String> registeredNames =\n                    Collections.synchronizedSet(new HashSet<String>());\n\n    public static void main(String[] args) {\n        System.setSecurityManager (new RMISecurityManager());\n\n        progName = System.getProperty(\"faban.cli.command\");\n        String usage = \"Usage: \" + progName + \" [port]\";\n\n        if (args.length < 2) {\n            if (args.length == 1) {\n                if (\"-h\".equals(args[0]) || \"--help\".equals(args[0]) ||\n                                            \"-?\".equals(args[0])) {\n                    System.err.println(usage);\n                    System.exit(0);\n                } else {\n                    daemonPort = Integer.parseInt(args[0]);\n                }\n            }\n            startDaemon();\n        } else if (args.length > 3) {\n            try {\n                startAgents(args);\n            } catch (Exception e) {\n                e.printStackTrace();\n                System.exit(-1);\n            }\n        } else {\n            // We do not expose the start params for agent mode as that\n            // is not supposed to be called by the user. The daemon mode\n            // has only one optional param - port.\n            System.err.println(usage);\n            System.exit(-1);\n        }\n    }\n\n    private static void startDaemon() {\n        daemon = true;\n        /* Note that the daemon is not designed to accept any concurrency at\n         * all and hence the accept/dispatch is not threaded. This is not a\n         * bug. It should only receive one and only one connection request per\n         * run. Requests to start an agent while one is running will return\n         * with an error. We don't care if a concurrent request has to wait.\n         * Simplicity is the goal here.\n         */\n        try {\n            ServerSocket serverSocket = new ServerSocket(daemonPort);\n            byte[] buffer = new byte[8192];\n            for (;;) {\n                Socket socket = serverSocket.accept();\n                InputStream in = socket.getInputStream();\n                OutputStream out = socket.getOutputStream();\n                int length = in.read(buffer);\n                if (length > 0) {\n                    String argLine = new String(buffer, 0, length);\n                    System.out.println(\"Agent(Daemon) starting agent with options: \" +\n                                                                    argLine);\n                    String[] args = argLine.split(\" \");\n                    if (args.length < 4) {\n                       out.write(\"400 ERROR: Inadequate params.\".getBytes());\n                    }\n                    try {\n                        startAgents(args);\n                        out.write(\"200 OK\".getBytes());\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                        out.write((\"500 ERROR: \" + e.getMessage()).getBytes());\n                    }\n                }\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n                try {\n                    out.close();\n                } catch (IOException e) {\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();  // We don't use logger here 'cause we don't\n            // know the harness at this time.\n            // The logger may not be configured properly.\n            System.exit(1);\n        }\n\n    }\n\n    private static synchronized void startAgents(String[] args)\n            throws Exception {\n\n        String hostname = args[0];\n        master = args[1];\n        String masterLocal = args[2];\n        javaHome = args[3];\n\n        String benchName = null;\n\n        // Setup the basic jvmOptions for this environment which may not\n        // be the same as passed down from the master.\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n        jvmOptions.add(\"-Dfaban.home=\" + escapedHome);\n        jvmOptions.add(\"-Djava.security.policy=\" + escapedHome + \"config\" +\n                                                        fs + \"faban.policy\");\n        host = InetAddress.getLocalHost().getHostName();\n        jvmOptions.add(\"-Djava.util.logging.config.file=\" + escapedHome +\n                                        \"config\" + fs + \"logging.\" + host +\n                                        \".properties\");\n\n        ArrayList<String> libPath = new ArrayList<String>();\n        String libPrefix = \"-Djava.library.path=\";\n\n        // There may be optional JVM args\n        boolean isClassPath = false;\n        if(args.length > 4) {\n            for(int i = 4; i < args.length; i++)\n                if(args[i].startsWith(\"faban.download\")) {\n                    downloadURL = args[i].substring(\n                            args[i].indexOf('=') + 1);\n                }else if (args[i].startsWith(\"faban.benchmarkName\")) {\n                    benchName = args[i].substring(args[i].indexOf('=') + 1);\n                } else if (args[i].indexOf(\"faban.logging.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.LOGGING_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].indexOf(\"faban.registry.port\") != -1) {\n                    jvmOptions.add(args[i]);\n                    Config.RMI_PORT = Integer.parseInt(\n                            args[i].substring(args[i].indexOf(\"=\") + 1));\n                } else if (args[i].startsWith(\"-Dfaban.command.buffer=\")) {\n                    String[] prop = args[i].substring(2).split(\"=\");\n                    System.setProperty(prop[0], prop[1]);\n                    // Pass it along, too.\n                    jvmOptions.add(args[i]);\n                } else if (\"-server\".equals(args[i]) ||\n                        \"-client\".equals(args[i])) { // prepend these options\n                    jvmOptions.add(0, args[i]);\n                } else if (args[i].startsWith(\"-Dfaban.home=\") ||\n                        args[i].startsWith(\"-Djava.security.policy=\") ||\n                        args[i].startsWith(\"-Djava.util.logging.config.file=\")){\n                    // These are sometimes passed down from the master.\n                    // Ignore these. Use our local settings instead.\n                    // NOOP\n                } else if (\"-cp\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (\"-classpath\".equals(args[i])) {\n                    isClassPath = true;\n                } else if (isClassPath) {\n                    String[] cp = pathSplit(args[i]);\n                    for (String cpElement : cp)\n                        extClassPath.add(cpElement);\n                    isClassPath = false;\n                } else if (args[i].startsWith(libPrefix)) {\n                    String[] lp = pathSplit(\n                            args[i].substring(libPrefix.length()));\n                    for (String lpElement : lp)\n                        libPath.add(lpElement);\n                } else {\n                    jvmOptions.add(args[i]);\n                }\n        }\n\n        setLogger();\n\n        // Ensure proper JAVA_HOME by searching for the java executable.\n        File java = null;\n        File javaBin = new File(javaHome, \"bin\");\n        if (javaBin.isDirectory()) {\n            String[] pathExts = CmdMap.getPathExt();\n            if (pathExts != null) {\n                for (String ext : pathExts) {\n                    ext = ext.trim();\n                    if (ext == null || ext.length() == 0)\n                        continue;\n                    File javaPath = new File(javaBin, \"java\" + ext);\n                    if (javaPath.exists()) {\n                        java = javaPath;\n                        break;\n                    }\n                }\n            }\n            if (java == null) {\n                java = new File(javaBin, \"java\");\n                if (!java.exists()) {\n                    java = null;\n                }\n            }\n        }\n\n        // If not found, just use the process' JAVA_HOME instead.\n        if (java == null) {\n            String newJavaHome = Utilities.getJavaHome();\n            if (!newJavaHome.equals(javaHome)) {\n                logger.warning(\"JAVA_HOME \" + javaHome +\n                        \" does not exist. Using \" + newJavaHome + \" instead.\");\n                javaHome = newJavaHome;\n            }\n        }\n\n        logger.finer(\"JVM options for child processes:\" + jvmOptions);\n\n        // We cannot set the socket factory twice. So we need to reconfigure it.\n        if (socketFactory == null) {\n            socketFactory = new AgentSocketFactory(master, masterLocal);\n            RMISocketFactory.setSocketFactory(socketFactory);\n        } else {\n            socketFactory.setMaster(master, masterLocal);\n        }\n\n        // Get hold of the registry\n        registry = RegistryLocator.getRegistry(master, Config.RMI_PORT);\n        logger.fine(\"Succeeded obtaining registry.\");\n\n        // Sometimes we get the host name with the whole domain baggage.\n        // The host name is widely used in result files, tools, etc. We\n        // do not want that baggage. So we make sure to crop it off.\n        // i.e. brazilian.sfbay.Sun.COM should just show as brazilian.\n        int dotIdx = host.indexOf('.');\n        if (dotIdx > 0)\n            host = host.substring(0, dotIdx);\n\n        //ident will be unique\n        ident = Config.CMD_AGENT + \"@\" + host;\n\n        // Make sure there is only one agent running in a machine\n        CmdAgent agent = (CmdAgent) registry.getService(ident);\n\n        if (agent == null) { // If not found, reregister new agent.\n            boolean agentCreated = false;\n            if (cmd == null) {\n                cmd = new CmdAgentImpl();\n                agentCreated = true;\n                logger.fine(hostname + \"(Realname: \" + host +\n                                                \") created CmdAgentImpl\");\n            }\n\n            if (register(ident, cmd)) { // Double check for race condition\n                agent = cmd;\n\n                // setBenchName scans all resources.\n                // Benchmark needs to be loaded first.\n                new Download().loadBenchmark(benchName, downloadURL);\n                cmd.setBenchName(benchName, libPath);\n\n                if(host.equals(master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                } else if (sameHost(host, master)) {\n                    ident = Config.CMD_AGENT;\n                    reregister(ident, cmd);\n                }\n\n                // Create and reregister FileAgent\n                if (file == null)\n                    file = new FileAgentImpl();\n                reregister(Config.FILE_AGENT + \"@\" + host, file);\n\n                // Register a blank Config.FILE_AGENT for the master's\n                // file agent.\n                if (sameHost(host, master))\n                    reregister(Config.FILE_AGENT, file);\n            } else { // If we run into that, we just grab the agent again.\n                if (agentCreated) {\n                    UnicastRemoteObject.unexportObject(cmd, true);\n                    agentCreated = false;\n                    logger.fine(hostname + \"(Realname: \" + host +\n                                                \") unexported CmdAgentImpl\");\n                }\n                agent = (CmdAgent) registry.getService(ident);\n            }\n        }\n\n        // Only if the 'hostname' is an interface name and not equal\n        // the actual host name, we re-reregister the agents with the 'hostname'\n        if (!host.equals(hostname)) {\n            reregister(Config.CMD_AGENT + \"@\" + hostname, agent);\n\n            // The FileAgent registration may have a significant lag time\n            // from the CmdAgent registration due to downloads, etc.\n            // We just need to wait.\n            FileAgent f = (FileAgent) registry.getService(\n                                            Config.FILE_AGENT + \"@\" + host);\n            int retry = 0;\n            while (f == null) {\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                }\n                f = (FileAgent) registry.getService(\n                        Config.FILE_AGENT + \"@\" + host);\n                if (++retry > 100)\n                    break;\n            }\n            if (f != null)\n                reregister(Config.FILE_AGENT + \"@\" + hostname, f);\n            else\n                logger.severe(\"Giving up re-registering file agent at \" + host +\n                        \" as \" + hostname +\" after \" + retry + \" retries.\");\n        }\n    }\n\n    private static boolean register(String name, Remote service)\n            throws RemoteException {\n        boolean success = false;\n        if (registeredNames.add(name)) {\n            success = registry.register(name, service);\n            if (success) {\n                logger.fine(\"Succeeded registering \" + name);\n            } else {\n                logger.fine(\"Failed registering \" + name +\n                                        \". Entry already exists.\");\n            }\n        }\n        return success;\n    }\n\n    private static void reregister(String name, Remote service)\n            throws RemoteException {\n        if (registeredNames.add(name)) {\n            registry.reregister(name, service);\n            logger.fine(\"Succeeded re-registering \" + name);\n        }\n    }\n\n    static void deregisterAgents() throws RemoteException {\n        synchronized(registeredNames) {\n            for (String name : registeredNames)\n                registry.unregister(name);\n\n            registeredNames.clear();\n        }\n    }\n\n    static void terminateAgents() {\n        if (!daemon) {\n            System.exit(0);\n        }\n    }\n\n    /**\n     * This method is for splitting both Unix and Windows paths into their\n     * pathElements. It detects the path separator whether it is Unix or\n     * Windows style and takes care of the separators accordingly.\n     * @param path The path to split\n     * @return The splitted path\n     */\n    private static String[] pathSplit(String path) {\n        char pathSeparator = ':';  // Unix style by default.\n\n        // Check for '\\' used in Windows paths.\n        if (path.indexOf('\\\\') >= 0) {\n            pathSeparator=';';\n        }\n\n        // Check for \"c:/foo/bar\" sometimes used in Windows paths\n        if (pathSeparator == ':' ) {\n            Pattern p = Pattern.compile(\"\\\\A[a-zA-Z]:/\");\n            Matcher m = p.matcher(path);\n            if (m.find())\n                pathSeparator = ';';\n        }\n\n        // Check for ...;c:/foo/bar at any place in the path\n        if (pathSeparator == ':' ) {\n            Pattern p = Pattern.compile(\";[a-zA-Z]:/\");\n            Matcher m = p.matcher(path);\n            if (m.find())\n                pathSeparator = ';';\n        }\n\n        String delimiter = \"\" + pathSeparator;\n\n        return path.split(delimiter);\n    }\n\n    private static boolean sameHost(String host1, String host2) {\n        InetAddress[] host1Ip = new InetAddress[0];\n        try {\n            host1Ip = InetAddress.getAllByName(host1);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host1 + \" not found.\");\n            return false;\n        }\n        InetAddress[] host2Ip = new InetAddress[0];\n        try {\n            host2Ip = InetAddress.getAllByName(host2);\n        } catch (UnknownHostException e) {\n            logger.severe(\"Host \" + host2 + \" not found.\");\n            return false;\n        }\n        for (int i = 0; i < host1Ip.length; i++) {\n            for (int j = 0; j < host2Ip.length; j++) {\n                if (host1Ip[i].equals(host2Ip[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private static void setLogger() {\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            logger.fine(\"Updating \" + Config.CONFIG_DIR + \"logging.\" +\n                    host + \".properties\");\n            log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n            log.setProperty(\"java.util.logging.SocketHandler.port\",\n                    String.valueOf(Config.LOGGING_PORT));\n            FileOutputStream out = new FileOutputStream(\n                    new File(Config.CONFIG_DIR + \"logging.\" + host +\n                    \".properties\"));\n            log.store(out, \"Faban logging properties\");\n            out.close();\n\n            LogManager.getLogManager().readConfiguration(new FileInputStream(\n                    Config.CONFIG_DIR + \"logging.\" + host + \".properties\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n","lineNo":443}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: DefaultFabanBenchmark.java,v 1.15 2009/03/15 07:22:19 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The default benchmark class for use with benchmarks implemented with the\n * Faban Driver Framework. This class is designed to be extended if additional\n * features are desired. Do not use the DefaultFabanBenchmark if the actual\n * driver is not implemented using the Faban Driver Framework. Implement the\n * Benchmark interface directly in such cases.\n *\n * @author Akara Sucharitakul\n */\npublic class DefaultFabanBenchmark implements Benchmark {\n\n    private Logger logger = Logger.getLogger(getClass().getName());;\n    protected ParamRepository params;\n    protected List<String> agents;\n    protected String[] agentHosts;\n    protected Map<String, List<String>> hostAgents;\n    protected Map<String, List<String>> agentEnv;\n    protected CommandHandle masterHandle;\n\n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n            \n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Empty agents field, throw exception.\n                    String msg = \"Number of agents for \" + agentName +\n                                            \" driver must not be empty.\";\n                    ConfigurationException ce = new ConfigurationException(msg);\n                    logger.log(Level.SEVERE, msg, ce);\n                    throw ce;\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost == previousHost)\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n            // Update the output directory to the one assigned by the harness.\n            params.setParameter(\"fa:runConfig/fd:outputDir\", getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void configure() throws Exception {\n        // No configuration needed.\n    }\n\n    /**\n     * This method is responsible for starting the benchmark run\n     */\n    public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        getMasterIP());\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: DefaultFabanBenchmark.java,v 1.16 2009/05/21 20:54:04 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The default benchmark class for use with benchmarks implemented with the\n * Faban Driver Framework. This class is designed to be extended if additional\n * features are desired. Do not use the DefaultFabanBenchmark if the actual\n * driver is not implemented using the Faban Driver Framework. Implement the\n * Benchmark interface directly in such cases.\n *\n * @author Akara Sucharitakul\n */\npublic class DefaultFabanBenchmark implements Benchmark {\n\n    private Logger logger = Logger.getLogger(getClass().getName());;\n    protected ParamRepository params;\n    protected List<String> agents;\n    protected String[] agentHosts;\n    protected Map<String, List<String>> hostAgents;\n    protected Map<String, List<String>> agentEnv;\n    protected CommandHandle masterHandle;\n\n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n            \n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Empty agents field, throw exception.\n                    String msg = \"Number of agents for \" + agentName +\n                                            \" driver must not be empty.\";\n                    ConfigurationException ce = new ConfigurationException(msg);\n                    logger.log(Level.SEVERE, msg, ce);\n                    throw ce;\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost == previousHost)\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n            // Update the output directory to the one assigned by the harness.\n            params.setParameter(\"fa:runConfig/fd:outputDir\", getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void configure() throws Exception {\n        // No configuration needed.\n    }\n\n    /**\n     * This method is responsible for starting the benchmark run\n     */\n    public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n                \n                String masterIP = getMasterIP(hostName);\n                if (masterIP == null) {\n                    masterIP = getMasterIP();\n                }\n\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        masterIP);\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed\n     *\n     * @throws Exception if any error occurred.\n     */\n    public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    }\n}\n","lineNo":297}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: DefaultFabanBenchmark2.java,v 1.2 2009/03/15 07:22:19 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The default benchmark class for use with benchmarks implemented with the\n * Faban Driver Framework. This class is designed to be extended if additional\n * features are desired. Do not use the DefaultFabanBenchmark if the actual\n * driver is not implemented using the Faban Driver Framework. Implement the\n * Benchmark interface directly in such cases.\n *\n * @author Akara Sucharitakul\n */\npublic class DefaultFabanBenchmark2 {\n\n    private Logger logger = Logger.getLogger(getClass().getName());;\n    protected ParamRepository params;\n    protected List<String> agents;\n    protected String[] agentHosts;\n    protected Map<String, List<String>> hostAgents;\n    protected Map<String, List<String>> agentEnv;\n    protected CommandHandle masterHandle;\n\n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    @Validate public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n\n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Empty agents field, throw exception.\n                    String msg = \"Number of agents for \" + agentName +\n                                            \" driver must not be empty.\";\n                    ConfigurationException ce = new ConfigurationException(msg);\n                    logger.log(Level.SEVERE, msg, ce);\n                    throw ce;\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost == previousHost)\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n            // Update the output directory to the one assigned by the harness.\n            params.setParameter(\"fa:runConfig/fd:outputDir\", getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void configure() throws Exception {\n        // No configuration needed.\n    //}\n\n    /**\n     * This method is responsible for starting the benchmark run\n     */\n    @StartRun public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        getMasterIP());\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    @EndRun public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    //}\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: DefaultFabanBenchmark2.java,v 1.3 2009/05/21 20:54:04 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport static com.sun.faban.harness.RunContext.*;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\n\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The default benchmark class for use with benchmarks implemented with the\n * Faban Driver Framework. This class is designed to be extended if additional\n * features are desired. Do not use the DefaultFabanBenchmark if the actual\n * driver is not implemented using the Faban Driver Framework. Implement the\n * Benchmark interface directly in such cases.\n *\n * @author Akara Sucharitakul\n */\npublic class DefaultFabanBenchmark2 {\n\n    private Logger logger = Logger.getLogger(getClass().getName());;\n    protected ParamRepository params;\n    protected List<String> agents;\n    protected String[] agentHosts;\n    protected Map<String, List<String>> hostAgents;\n    protected Map<String, List<String>> agentEnv;\n    protected CommandHandle masterHandle;\n\n    /**\n     * Allows benchmark to validate the configuration file. Note that no\n     * execution facility is available during validation.\n     *\n     * @throws Exception if any error occurred.\n     * @see RunContext#exec(com.sun.faban.common.Command)\n     */\n    @Validate public void validate() throws Exception {\n        params = getParamRepository();\n\n        // Check and match the hosts and agents\n        // First, list the drivers in the config file.\n        agents = params.getAttributeValues(\n                                    \"fa:runConfig/fd:driverConfig\", \"name\");\n\n        // Second, obtain the systems to run the drivers.\n        agentHosts = params.getTokenizedValue(\n                                        \"fa:runConfig/fa:hostConfig/fa:host\");\n\n        hostAgents = new HashMap<String, List<String>>(agentHosts.length + 5);\n\n        agentEnv = new HashMap<String, List<String>>();\n\n        HashMap<String, Integer> anyHostAgents = new HashMap<String, Integer>();\n        for (String agentName : agents) {\n\n            String qb = \"fa:runConfig/fd:driverConfig[@name=\\\"\" + agentName +\n                         \"\\\"]/\";\n\n            // Obtain the environment needed for the agent type...\n            List<String> env = params.getParameters(qb + \"fd:environment\");\n            if (env != null && env.size() > 0) {\n                agentEnv.put(agentName, env);\n                if (logger.isLoggable(Level.FINER)) {\n                    StringBuilder b = new StringBuilder();\n                    b.append(\"Env for \").append(agentName).append(\"Agents: \");\n                    for (String envEntry : env) {\n                        b.append('[').append(envEntry).append(']');\n                    }\n                    logger.finer(b.toString());\n                }\n            }\n\n            // Prepare the agent distribution...\n            String[] agentSpecs = params.getTokenizedValue(qb + \"fd:agents\");\n\n            switch (agentSpecs.length) {\n                case 0: // Empty agents field, throw exception.\n                    String msg = \"Number of agents for \" + agentName +\n                                            \" driver must not be empty.\";\n                    ConfigurationException ce = new ConfigurationException(msg);\n                    logger.log(Level.SEVERE, msg, ce);\n                    throw ce;\n                case 1: // Single value field, could be just count or host:count\n                    if (agentSpecs[0].indexOf(':') < 0) { //Just count\n                        int agentCnt = 0;\n                        try {\n                            agentCnt = Integer.parseInt(agentSpecs[0]);\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpecs[0];\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Record the count for this agent.\n                        anyHostAgents.put(agentName, agentCnt);\n                        break;\n                    }\n                default: // One or more host:count\n                    for (String agentSpec : agentSpecs) {\n                        int colIdx = agentSpec.indexOf(':');\n\n                        // Check the spec for anything odd.\n                        if (colIdx < 1) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        String hostName = agentSpec.substring(0, colIdx);\n                        int agentCnt;\n                        try {\n                            agentCnt = Integer.parseInt(\n                                            agentSpec.substring(colIdx + 1));\n                        } catch (NumberFormatException e) {\n                            msg = \"Invalid agents spec \" + agentSpec;\n                            ce = new ConfigurationException(msg);\n                            logger.log(Level.SEVERE, msg, ce);\n                            throw ce;\n                        }\n                        // Add one entry to the list for each agent.\n                        List<String> agentList = null;\n                        for (int i = 0; i < agentCnt; i++) {\n                            if (agentList == null)\n                                agentList = hostAgents.get(hostName);\n                            if (agentList == null) {\n                                agentList = new ArrayList<String>();\n                                hostAgents.put(hostName, agentList);\n                            }\n                            agentList.add(agentName);\n                        }\n                    }\n\n            }\n        }\n\n        // After we got the host specifics done, we'll need to take care of\n        // distributing the anyhost agents fairly.\n        if (anyHostAgents.size() > 0) {\n\n            // Ensure all hosts are in hostAgents.\n            for (String hostName : agentHosts)\n                if (hostAgents.get(hostName) == null)\n                    hostAgents.put(hostName, new ArrayList<String>());\n\n            String previousHost = null;\n            for (Map.Entry<String, Integer> anyHostEntry :\n                                                    anyHostAgents.entrySet()) {\n                String agentName = anyHostEntry.getKey();\n                int cnt = anyHostEntry.getValue();\n                Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                        hostAgents.entrySet();\n\n                // Find the host with minimum agent for each anyHostAgent\n                for (int i = 0; i < cnt; i++) {\n                    String leastBusyHost = null;\n                    int minAgents = Integer.MAX_VALUE;\n                    // Scan the hostAgents to find the least busy.\n                    for (Map.Entry<String, List<String>> hostAgentsEntry :\n                                                               hostAgentsSet) {\n                        int agents = hostAgentsEntry.getValue().size();\n                        if (agents < minAgents) {\n                            leastBusyHost = hostAgentsEntry.getKey();\n                            minAgents = agents;\n                        } else if (agents == minAgents) {\n                            // If there is more than one least busy, pick\n                            // the first one that was not previously assigned.\n                            if (leastBusyHost == previousHost)\n                                leastBusyHost = hostAgentsEntry.getKey();\n                        }\n                    }\n                    hostAgents.get(leastBusyHost).add(agentName);\n                    previousHost = leastBusyHost;\n                }\n            }\n        }\n\n        // In any case, there is a chance that some hosts are not used.\n        // we just remove those hosts from hostAgents.\n        Set<Map.Entry<String, List<String>>> hostAgentsSet =\n                                                hostAgents.entrySet();\n        for (Map.Entry<String, List<String>> hostAgentsEntry : hostAgentsSet)\n            if (hostAgentsEntry.getValue().size() == 0)\n                hostAgents.remove(hostAgentsEntry);\n\n        // Then we need to make sure our agentHosts strings are accurate.\n\n        // We want to keep the order the hosts were entered. So we use\n        // a LinkedHashSet and insert every host in here.\n        LinkedHashSet<String> agentHostSet = new LinkedHashSet<String>();\n        for (String agentHost : agentHosts)\n            agentHostSet.add(agentHost);\n\n        Set<String> hostAgentsKeySet = hostAgents.keySet();\n\n        // Now we remove all the hosts that are not used...\n        agentHostSet.retainAll(hostAgentsKeySet);\n\n        // and add what is used and not listed, if any.\n        agentHostSet.addAll(hostAgentsKeySet);\n\n        // Put it back into the array for later use.\n        agentHosts = agentHostSet.toArray(new String[agentHostSet.size()]);\n\n        // Recreate the string from the array.\n        StringBuilder agentHostsBldr = new StringBuilder();\n        for (int i = 0; i < agentHosts.length; i++) {\n            if (i > 0)\n                agentHostsBldr.append(' ');\n            agentHostsBldr.append(agentHosts[i]);\n        }\n\n        try {\n            // Save the new host back the list.\n            params.setParameter(\"fa:runConfig/fa:hostConfig/fa:host\",\n                                                agentHostsBldr.toString());\n            // Update the output directory to the one assigned by the harness.\n            params.setParameter(\"fa:runConfig/fd:outputDir\", getOutDir());\n            params.save();\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Exception updating \" + getParamFile(), e);\n            throw e;\n        }\n    }\n\n    /**\n     * This method is called to configure the specific benchmark run\n     * Tasks done in this method include reading user parameters,\n     * logging them and initializing various local variables.\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void configure() throws Exception {\n        // No configuration needed.\n    //}\n\n    /**\n     * This method is responsible for starting the benchmark run\n     */\n    @StartRun public void start() throws Exception {\n\n        // Spread the drivers to the systems.\n        // Start Agents. Other JVM Options like security policy and logging\n        // properties are added by CmdAgent when starting the java command.\n        Command c = null;\n\n        HashMap<String, Integer> agentIds =\n                                new HashMap<String, Integer>(agents.size());\n\n        // Iterate through all the hosts before coming back for the next set\n        // of agents for the first host. Once we're though all agent sets\n        // for all hosts, the agentStarted flag will be false and we'll exit\n        // the loop.\n        boolean agentStarted = true;\n        for (int i = 0; agentStarted; i++) {\n            agentStarted = false;\n            for (String hostName : agentHosts) {\n                List<String> agentList = hostAgents.get(hostName);\n                if (i >= agentList.size())\n                    continue;\n                String agentType = agentList.get(i);\n                Integer oldAgentId = agentIds.get(agentType);\n                int agentId;\n                if (oldAgentId == null) {\n                    agentIds.put(agentType, 0);\n                    agentId = 0;\n                } else {\n                    agentId = oldAgentId.intValue() + 1;\n                    agentIds.put(agentType, agentId);\n                }\n                logger.info(\"Starting \" + agentType + \"Agent[\" + agentId +\n                        \"] on host \" + hostName + '.');\n\n                String masterIP = getMasterIP(hostName);\n                if (masterIP == null) {\n                    masterIP = getMasterIP();\n                }\n\n                Command agent = new Command(\"com.sun.faban.driver.engine.\" +\n                        \"AgentImpl\", agentType, String.valueOf(agentId),\n                        masterIP);\n\n                List<String> env = agentEnv.get(agentType);\n                if (env != null) {\n                    String[] e = new String[env.size()];\n                    e = env.toArray(e);\n                    agent.setEnvironment(e);\n                }\n\n                agent.setSynchronous(false);\n                java(hostName, agent);\n                agentStarted = true;\n                //Wait for the Agents to register\n                try {\n                    Thread.sleep(500);\n                } catch(InterruptedException e) {\n                    logger.severe(\"Exception Sleeping : \" + e);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }\n\n        //Wait for all the Agents to register\n        try {\n            Thread.sleep(5000);\n        } catch(InterruptedException e) {\n            logger.severe(\"Exception Sleeping : \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        // Start the master\n        c = new Command(\"-Dbenchmark.config=\" + getParamFile(),\n                \"-Dfaban.outputdir.unique=true\",\n                \"com.sun.faban.driver.engine.MasterImpl\");\n        c.setSynchronous(false);\n\n        masterHandle = java(c);\n\n        // Wait until the master gets to rampup before we give back control.\n        // This will ensure the tools start at correct times.\n        java(new Command(\"com.sun.faban.driver.engine.PingMaster\", \"RAMPUP\"));\n        logger.info(\"Ramp up started\");\n    }\n\n    /**\n     * This method is responsible for waiting for all commands started and\n     * run all postprocessing needed.\n     *\n     * @throws Exception if any error occurred.\n     */\n    @EndRun public void end() throws Exception {\n\n        // Wait for the master to complete the run.\n        masterHandle.waitFor();\n        int exitValue = masterHandle.exitValue();\n        if (exitValue != 0) {\n            logger.severe(\"Master terminated with exit value \" + exitValue);\n            throw new Exception(\"Driver failed to complete benchmark run\");\n        }\n    }\n\n    /**\n     * This method aborts the current benchmark run and is\n     * called when a user asks for a run to be killed\n     *\n     * @throws Exception if any error occurred.\n     */\n    //public void kill() throws Exception {\n        // We don't need to kill off anything here. All processes managed\n        // by the run context are automatically terminated.\n    //}\n}\n","lineNo":297}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: ToolService.java,v 1.7 2008/05/23 05:57:41 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.harness.agent.ToolAgent;\nimport com.sun.faban.harness.agent.ToolAgentImpl;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.ParamRepository;\n\nimport java.rmi.RemoteException;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Tool service API.\n * The Tool Service object is created by the Engine at the start of a\n * run. The Tool Service will interpret the Tools specific parameters in\n * the ParamRepository and start up the ToolAgents on all the\n * machines on which the user requested that tools be run. It then\n * connects to the ToolAgents via RMI. In the API implementation,\n * it identifies the particular ToolAgent and passes the call along.\n * IMPORTANT: There should be a single ToolService object in the\n * entire framework or else multiple copies of the ToolAgent\n * application will be spawned on the target machines.\n * For this reason, this class is a Singleton.\n *\n * @author Ramesh Ramachandran\n */\nfinal public class ToolService {\n    private ToolAgent[] toolAgents;\n    private String[] hostNames;\n    private Logger logger;\n    private CmdService cmds;\n    private boolean runTools;\n\n    private static ToolService toolService;\n\n    private ToolService() {\n        runTools = false;\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton ToolService\n     * @return reference to the single ToolService\n     */\n    public static ToolService getHandle() {\n        if(toolService == null)\n            toolService = new ToolService();\n        return toolService;\n    }\n\n    public void init() {\n        logger = Logger.getLogger(this.getClass().getName());\n    }\n\n    /**\n     * This method initializes the ToolAgent RMI server processes\n     * on the specified set of machines\n     * @param par The parameter repository\n     * @param outDir The run output directory, relative to Config.OUT_DIR\n     * @return true if setup successful, else false\n     *\n     */\n    public boolean setup(ParamRepository par, String outDir) {\n\n        cmds = CmdService.getHandle();\n\n        /* Get tool related parameters */\n\n        List hostClasses = par.getTokenizedParameters(\"fa:hostConfig/fa:host\");\n        List allTools =  par.getParameters(\"fa:hostConfig/fh:tools\");\n        List enabled = par.getParameters(\"fa:hostConfig/fh:enabled\");\n\n        if(hostClasses.size() != enabled.size()) {\n            logger.warning(\"Number of hosts does not match \" +\n                    \"Number of enabled node\");\n            return false;\n        }\n\n        // HashMap containing exclusive list of tools to start on each machine.\n        HashMap<String, HashSet<String>> hostMap =\n                new HashMap<String, HashSet<String>>();\n\n        // Temporary tool list for host class being processed.\n        ArrayList<String> newTools = new ArrayList<String>();\n\n        // First we flatten out the classes into host names and tools sets\n        for (int i = 0; i < hostClasses.size(); i++) {\n            // Ignore if the host class is not enabled.\n            if (!Boolean.parseBoolean((String)enabled.get(i)))\n                continue;\n\n            String toolCmds = ((String) allTools.get(i)).trim();\n\n            // Ignore class if no tools to start.\n            if (toolCmds.length() == 0 || toolCmds.toUpperCase().equals(\"NONE\"))\n                continue;\n\n            // Get the hosts list in the class.\n            String[] hosts = (String[]) hostClasses.get(i);\n\n            // Get the tools list for this host list.\n\n            StringTokenizer st = new StringTokenizer(toolCmds, \";\");\n            while(st.hasMoreTokens()) {\n                String tool = st.nextToken().trim();\n                if (tool.length() > 0)\n                    newTools.add(tool);\n            }\n\n            for (int j = 0; j < hosts.length; j++) {\n                String host = hosts[j];\n                // Now get the tools list for this host,\n                // or allocate if non-existent\n                HashSet<String> toolsSet = hostMap.get(host);\n                if (toolsSet == null) {\n                    toolsSet = new HashSet<String>(newTools);\n                    hostMap.put(host, toolsSet);\n                } else {\n                    toolsSet.addAll(newTools);\n                }\n            }\n            // Clear the set for the next host class.\n            newTools.clear();\n        }\n\n        if (hostMap.size() == 0) {\n            logger.fine(\"No Tool to start !!\");\n            return true;\n        }\n\n        // Put the host names into an array.\n        Set<String> hostSet = hostMap.keySet();\n        hostNames = new String[hostSet.size()];\n        hostNames = hostSet.toArray(hostNames);\n\n        // Start the tools.\n        try {\n            for (int i = 0; i < hostNames.length; i++) {\n                logger.info(\"Setting up tools on machine \" + hostNames[i]);\n                cmds.startAgent(hostNames[i], ToolAgentImpl.class,\n                        Config.TOOL_AGENT);\n\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to setup tools.\", e);\n            return(false);\n        }\n\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException ie) {\n            kill();\n            return(false);\n        }\n\n        toolAgents = new ToolAgent[hostNames.length];\n        try {\n            for (int i = 0; i < hostNames.length; i++) {\n                String serviceName = Config.TOOL_AGENT + \"@\" + hostNames[i];\n                logger.fine(\"Connecting to \" + serviceName);\n                toolAgents[i] = (ToolAgent) CmdService.getHandle().\n                        getRegistry().getService(serviceName);\n                if (toolAgents[i] == null) {\n                    logger.warning(\"Could not connect to \" + serviceName);\n                    continue;\n                }\n                // Send toolslist\n                logger.fine(\"Configuring ToolAgent at \" + serviceName);\n\n                HashSet<String> toolsSet = hostMap.get(hostNames[i]);\n                String[] toolsArray = new String[toolsSet.size()];\n                toolsArray = toolsSet.toArray(toolsArray);\n                toolAgents[i].configure(toolsArray, outDir);\n            }\n\n        } catch (RemoteException re) {\n            logger.log(Level.WARNING, \"RemoteException in ToolAgent.\", re);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception starting tools.\", e);\n            return(false);\n        }\n\n        runTools = true;\n        return(true);\n    }\n\n\n    /**\n     * Start all tools on all machines\n     * @param delay after which tools should start\n     */\n    public void start(int delay) {\n\n        if (runTools == false || toolAgents == null || toolAgents.length  == 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].start(delay);\n            } catch (RemoteException r) {\n                logger.log(Level.WARNING, \"Error in Starting tools on \" +\n                        \"machine \" + hostNames[i] + \".\", r);\n            }\n        }\n    }\n\n    /**\n     * Start all tools on all machines\n     * @param delay after which tools should start\n     * @param duration after which tools must be stopped\n     */\n    public void start(int delay, int duration) {\n\n        if (runTools == false || toolAgents == null || toolAgents.length == 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].start(delay, duration);\n            } catch (RemoteException r) {\n                logger.log(Level.WARNING, \"Error in Starting tools on \" +\n                        \"machine \" + hostNames[i] + \".\", r);\n            }\n        }\n    }\n\n    /**\n     * Stop all tools on all machines\n     *\n     */\n    public void stop() {\n        if (runTools == false || toolAgents == null || toolAgents.length <= 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].stop();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error in Stopping tools on \" +\n                        \"machine \" + hostNames[i] + \".\", e);\n            }\n        }\n    }\n\n    /**\n     * Kill all tools and ToolAgents\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        if (runTools == false || toolAgents == null || toolAgents.length <= 0)\n            return;\n        for (int i = 0; i < toolAgents.length; i++) {\n            if (toolAgents[i] != null)\n                try {\n                    toolAgents[i].kill();\n                } catch (Exception r) { // Ignore Errors\n                }\n        }\n        for (int i = 0; i < toolAgents.length; i++) {\n            if (toolAgents[i] != null)\n                try {\n                    // wait will clear tmp files\n                    cmds.wait(hostNames[i], \"ToolAgent\" + i);\n                } catch (Exception e) {\n                }\n        }\n        toolAgents = null;\n        hostNames = null;\n    }\n\n    /**\n     * Wait for all tools.\n=     */\n    public void waitFor() {\n        if (runTools == false || toolAgents == null || toolAgents.length <= 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].waitFor();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error in Stopping tools on \" +\n                        \"machine \" + hostNames[i] + \".\", e);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: ToolService.java,v 1.8 2009/05/21 10:13:24 sheetalpatil Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.harness.agent.ToolAgent;\nimport com.sun.faban.harness.agent.ToolAgentImpl;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.ParamRepository;\n\nimport com.sun.faban.harness.services.ServiceManager;\nimport com.sun.faban.harness.tools.MasterToolContext;\nimport java.io.IOException;\nimport java.rmi.RemoteException;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.xml.parsers.ParserConfigurationException;\nimport org.xml.sax.SAXException;\n\n/**\n * This file contains the class that implements the Tool service API.\n * The Tool Service object is created by the Engine at the start of a\n * run. The Tool Service will interpret the Tools specific parameters in\n * the ParamRepository and start up the ToolAgents on all the\n * machines on which the user requested that tools be run. It then\n * connects to the ToolAgents via RMI. In the API implementation,\n * it identifies the particular ToolAgent and passes the call along.\n * IMPORTANT: There should be a single ToolService object in the\n * entire framework or else multiple copies of the ToolAgent\n * application will be spawned on the target machines.\n * For this reason, this class is a Singleton.\n *\n * @author Ramesh Ramachandran\n */\nfinal public class ToolService {\n    private ToolAgent[] toolAgents;\n    private String[] hostNames;\n    private Logger logger;\n    private CmdService cmds;\n    private boolean runTools;\n\n    private static ToolService toolService;\n\n    private ToolService() {\n        runTools = false;\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton ToolService\n     * @return reference to the single ToolService\n     */\n    public static ToolService getHandle() {\n        if(toolService == null)\n            toolService = new ToolService();\n        return toolService;\n    }\n\n    public void init() {\n        logger = Logger.getLogger(this.getClass().getName());\n    }\n\n    /**\n     * This method initializes the ToolAgent RMI server processes\n     * on the specified set of machines\n     * @param par The parameter repository\n     * @param outDir The run output directory, relative to Config.OUT_DIR\n     * @return true if setup successful, else false\n     *\n     */\n    public boolean setup(ParamRepository par, String outDir, ServiceManager serviceMgr) \n            throws ParserConfigurationException, SAXException, IOException, Exception {\n\n        cmds = CmdService.getHandle();\n\n        /* Get tool related parameters */\n\n        List hostClasses = par.getTokenizedParameters(\"fa:hostConfig/fa:host\");\n        List allTools =  par.getParameters(\"fa:hostConfig/fh:tools\");\n        List enabled = par.getParameters(\"fa:hostConfig/fh:enabled\");\n\n        if(hostClasses.size() != enabled.size()) {\n            logger.warning(\"Number of hosts does not match \" +\n                    \"Number of enabled node\");\n            return false;\n        }\n\n        // HashMap containing exclusive list of tools to start on each machine.\n        HashMap<String, List<MasterToolContext>> hostMap =\n                new HashMap<String, List<MasterToolContext>>();\n\n        List<MasterToolContext> tools = serviceMgr.getTools();\n        List<MasterToolContext> hostToolList = null;\n        for (MasterToolContext tool : tools) {\n            String[] hosts = tool.getToolServiceContext().getHosts();\n            for (String host : hosts) {\n                hostToolList = hostMap.get(host);\n                if (hostToolList == null) {\n                    hostToolList = new ArrayList<MasterToolContext>();\n                    hostMap.put(host, hostToolList);\n                }\n                hostToolList.add(tool);\n            }\n        }\n\n        // Temporary tool list for host class being processed.\n        ArrayList<MasterToolContext> newTools = new ArrayList<MasterToolContext>();\n\n        // First we flatten out the classes into host names and tools sets\n        for (int i = 0; i < hostClasses.size(); i++) {\n            // Ignore if the host class is not enabled.\n            if (!Boolean.parseBoolean((String)enabled.get(i)))\n                continue;\n\n            String toolCmds = ((String) allTools.get(i)).trim();\n\n            // Ignore class if no tools to start.\n            if (toolCmds.length() == 0 || toolCmds.toUpperCase().equals(\"NONE\"))\n                continue;\n\n            // Get the hosts list in the class.\n            String[] hosts = (String[]) hostClasses.get(i);\n\n            // Get the tools list for this host list.\n\n            StringTokenizer st = new StringTokenizer(toolCmds, \";\");\n            while(st.hasMoreTokens()) {\n                String tool = st.nextToken().trim();\n                if (tool.length() > 0){\n                    MasterToolContext tCtx = new MasterToolContext(tool, null, null);\n                    newTools.add(tCtx);\n                }\n            }\n\n            for (int j = 0; j < hosts.length; j++) {\n                String host = hosts[j];\n                // Now get the tools list for this host,\n                // or allocate if non-existent\n                hostToolList = hostMap.get(host);\n                if (hostToolList == null) {\n                    hostToolList = new ArrayList<MasterToolContext>();\n                    hostMap.put(host, hostToolList);\n                }\n                hostToolList.addAll(newTools);\n                \n            }\n            // Clear the set for the next host class.\n            newTools.clear();\n        }\n\n        if (hostMap.size() == 0) {\n            logger.fine(\"No Tool to start !!\");\n            return true;\n        }\n\n        // Put the host names into an array.\n        Set<String> hostSet = hostMap.keySet();\n        hostNames = new String[hostSet.size()];\n        hostNames = hostSet.toArray(hostNames);\n\n        // Start the tools.\n        try {\n            for (int i = 0; i < hostNames.length; i++) {\n                logger.info(\"Setting up tools on machine \" + hostNames[i]);\n                cmds.startAgent(hostNames[i], ToolAgentImpl.class,\n                        Config.TOOL_AGENT);\n\n            }\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to setup tools.\", e);\n            return(false);\n        }\n\n        try {\n            Thread.sleep(5000);\n        } catch (InterruptedException ie) {\n            kill();\n            return(false);\n        }\n\n        toolAgents = new ToolAgent[hostNames.length];\n        try {\n            for (int i = 0; i < hostNames.length; i++) {\n                String serviceName = Config.TOOL_AGENT + \"@\" + hostNames[i];\n                logger.fine(\"Connecting to \" + serviceName);\n                toolAgents[i] = (ToolAgent) CmdService.getHandle().\n                        getRegistry().getService(serviceName);\n                if (toolAgents[i] == null) {\n                    logger.warning(\"Could not connect to \" + serviceName);\n                    continue;\n                }\n                // Send toolslist\n                logger.fine(\"Configuring ToolAgent at \" + serviceName);\n\n                List<MasterToolContext> toolList = hostMap.get(hostNames[i]);\n                if(toolList != null)\n                    toolAgents[i].configure(toolList, outDir);\n            }\n\n        } catch (RemoteException re) {\n            logger.log(Level.WARNING, \"RemoteException in ToolAgent.\", re);\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Exception starting tools.\", e);\n            return(false);\n        }\n\n        runTools = true;\n        return(true);\n    }\n\n\n    /**\n     * Start all tools on all machines\n     * @param delay after which tools should start\n     */\n    public void start(int delay) {\n\n        if (runTools == false || toolAgents == null || toolAgents.length  == 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].start(delay);\n            } catch (RemoteException r) {\n                logger.log(Level.WARNING, \"Error in Starting tools on \" +\n                        \"machine \" + hostNames[i] + \".\", r);\n            }\n        }\n    }\n\n    /**\n     * Start all tools on all machines\n     * @param delay after which tools should start\n     * @param duration after which tools must be stopped\n     */\n    public void start(int delay, int duration) {\n\n        if (runTools == false || toolAgents == null || toolAgents.length == 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].start(delay, duration);\n            } catch (RemoteException r) {\n                logger.log(Level.WARNING, \"Error in Starting tools on \" +\n                        \"machine \" + hostNames[i] + \".\", r);\n            }\n        }\n    }\n\n    /**\n     * Stop all tools on all machines\n     *\n     */\n    public void stop() {\n        if (runTools == false || toolAgents == null || toolAgents.length <= 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].stop();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error in Stopping tools on \" +\n                        \"machine \" + hostNames[i] + \".\", e);\n            }\n        }\n    }\n\n    /**\n     * Kill all tools and ToolAgents\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        if (runTools == false || toolAgents == null || toolAgents.length <= 0)\n            return;\n        for (int i = 0; i < toolAgents.length; i++) {\n            if (toolAgents[i] != null)\n                try {\n                    toolAgents[i].kill();\n                } catch (Exception r) { // Ignore Errors\n                }\n        }\n        for (int i = 0; i < toolAgents.length; i++) {\n            if (toolAgents[i] != null)\n                try {\n                    // wait will clear tmp files\n                    cmds.wait(hostNames[i], \"ToolAgent\" + i);\n                } catch (Exception e) {\n                }\n        }\n        toolAgents = null;\n        hostNames = null;\n    }\n\n    /**\n     * Wait for all tools.\n=     */\n    public void waitFor() {\n        if (runTools == false || toolAgents == null || toolAgents.length <= 0)\n            return;\n\n        for (int i = 0; i < toolAgents.length; i++) {\n            try {\n                if (toolAgents[i] != null)\n                    toolAgents[i].waitFor();\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error in Stopping tools on \" +\n                        \"machine \" + hostNames[i] + \".\", e);\n            }\n        }\n    }\n}\n","lineNo":151}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.5 2009/04/01 19:11:10 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 32009l;\n\n    /*\n    Response Histogram\n    ~~~~~~~~~~~~~~~~~~\n    Use fine and coarse bucket sizes for response time.\n    Use fine buckets for up to 1.5 * Max90th\n    Use coarse bucket sizes for 1.5 * Max90th to 5 * Max90th\n    We do not care much about accuracy when we're far beyond the Max90th.\n    We use 200 buckets up to Max90th. This means 300 buckets for up to\n    1.5 * Max90th. Beyond that, we reduce the accuracy by 10x so only 70\n    coarse buckets are needed. Altogether, we use 370 buckets, which is\n    63% savings when compared to 1000 buckets. The logic will be slightly\n    more complicated but by not much.\n    */\n    public static final int RESPBUCKET_SIZE_RATIO = 10;\n    public static final int COARSE_RESPBUCKETS = 70; // Percentage coarse.\n    public static final int FINE_RESPBUCKETS = (100 - COARSE_RESPBUCKETS) *\n                                                    RESPBUCKET_SIZE_RATIO;\n    public static final int RESPBUCKETS = FINE_RESPBUCKETS + COARSE_RESPBUCKETS;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    // We use double here to prevent cumulative errors\n    protected long fineRespBucketSize;  // Size of the fine and coarse\n    protected long coarseRespBucketSize; // response time buckets, in ns.\n    protected long fineRespHistMax; // Max fine response time\n    protected long coarseRespHistMax; // Max coarse response time\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sum of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected String host;\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        host = agent.agent.host;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n\n        txTypes = driverConfig.operations.length;\n\n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        // Calculate the response time histograms.\n        double precision = driverConfig.responseTimeUnit.toNanos(1l);\n        long max90nanos = Math.round(max90th * precision);\n        fineRespBucketSize = max90nanos / 200l;  // 20% of scale of 1000\n        fineRespHistMax = fineRespBucketSize * FINE_RESPBUCKETS;\n        coarseRespBucketSize = fineRespBucketSize * RESPBUCKET_SIZE_RATIO;\n        coarseRespHistMax = coarseRespBucketSize * COARSE_RESPBUCKETS +\n                                                    fineRespHistMax;\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            int bucket;\n            if (responseTime < fineRespHistMax) {\n                bucket = (int) (responseTime / fineRespBucketSize);\n            } else if (responseTime < coarseRespHistMax) {\n                bucket = (int) (((responseTime - fineRespHistMax) /\n                        coarseRespBucketSize) + FINE_RESPBUCKETS);\n            } else {\n                bucket = RESPBUCKETS - 1;\n            }\n            respHist[txType][bucket]++;\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        if (thread.driverContext.timingInfo.respondTime !=\n                AgentThread.TIME_NOT_SET)\n            endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        long bucket = actualDelayTime / delayBucketSize;\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][(int) bucket]++;\n\t\t}\n        bucket = thread.delayTime[thread.mixId] / delayBucketSize;\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][(int) bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Check whether the host is the same. If not, set host to null\n        if (host != s.host) {\n            if (host != null && !host.equals(s.host))\n                host = null;\n            if (s.host != null && !s.host.equals(host))\n                host = null;\n        }\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg;\n        long resp90, resp99;\n        int sumtx, cnt90, cnt99;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            long max90nanos = Math.round(max90 * precision);\n\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90d);\n                int j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp90 = j * fineRespBucketSize;\n                else if (j < RESPBUCKETS)\n                    resp90 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else\n                    resp90 = coarseRespHistMax;\n\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90 / precision);\n                if (resp90 > max90nanos) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n\n                // 99th% hack for Berkeley.\n                sumtx = 0;\n                cnt99 = (int)(txCntStdy[i] * .99d);\n                j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt99)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp99 = j * fineRespBucketSize;\n                else if (j < RESPBUCKETS)\n                    resp99 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else\n                    resp99 = coarseRespHistMax;\n\n                space(16, buffer);\n                formatter.format(\"<p99th>%5.3f<\/p99th>\\n\", resp99 / precision);\n                // end hack.\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n                // 99th% hack for Berkeley.\n                space(16, buffer).append(\"<p99th/>\\n\");\n                // End 99th% hack.\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Logger logger = Logger.getLogger(\n                                        this.getClass().getName());\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = null;\n            try {\n                elements = attachment.getResults();\n            } catch (Exception e) { // Ensure the getResults\n                                    // doesn't break report generation.\n                logger.log(Level.WARNING, \"Exceptione reporting CustomMetrics\",\n                                                                            e);\n                elements = null;\n            }\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        while (maxBucketId >= 0) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n            --maxBucketId;\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * The respHist, or response histogram has a special structure:\n     * The lower buckets are fine-grained buckets. The higher buckets\n     * are coarse-grained bucket covering 10x as much time. It is done this\n     * way to save memory (from 1000 entries per thread per operation, down to\n     * 370 entries). For low response times, we care a lot about the exact\n     * response time and therefore we use fine-grained buckets. For large\n     * response times we just want to know the ballpark, but not the exact\n     * number. So it does not make sense to keep the same bucket size\n     * throughout. We use fine granularity below 1.5x largest set 90th% and\n     * coarse granularity for anything beyond that.\n     *\n     * Now, we need to flatten the response time histogram into a flat one\n     * before plotting. We do this, here. We'll end up with more entries, but\n     * we really don't care since this is one copy, once per run at report time.\n     */\n    private void flattenRespHist() {\n        int limit = getBucketLimit(respHist);\n\n        // If all buckets are used, the last one does not get extrapolated\n        // as it has the data of that bucket and beyond.\n        boolean spareLastBucket = false;\n        if (limit == respHist[0].length)\n            spareLastBucket = true;\n\n        if (limit > FINE_RESPBUCKETS) {\n            int size;\n            if (spareLastBucket) {\n                --limit;\n                size = (COARSE_RESPBUCKETS - 1) * RESPBUCKET_SIZE_RATIO +\n                                                        FINE_RESPBUCKETS + 1;\n            } else {\n                size = (limit - FINE_RESPBUCKETS) * RESPBUCKET_SIZE_RATIO +\n                                                        FINE_RESPBUCKETS;\n            }\n            int[][] respHist = new int[txTypes][size];\n            for (int i = 0; i < txTypes; i++) {\n\n                // Copy the fine buckets unchanged.\n                for (int j = 0; j < FINE_RESPBUCKETS; j++)\n                    respHist[i][j] = this.respHist[i][j];\n\n                for (int j = FINE_RESPBUCKETS; j < limit; j++) {\n                    int count = this.respHist[i][j];\n                    // Spread the count among all 10 flat buckets.\n                    int base = count / RESPBUCKET_SIZE_RATIO;\n                    int remainder = count % RESPBUCKET_SIZE_RATIO;\n                    int baseIdx = (j - FINE_RESPBUCKETS) *\n                                    RESPBUCKET_SIZE_RATIO + FINE_RESPBUCKETS;\n                    int k = 9;\n                    // The higher buckets get the base\n                    for (; k >= remainder; k--)\n                        respHist[i][baseIdx + k] = base;\n                    // The lower remaining buckets get the base + 1\n                    ++base;\n                    for (; k >= 0; k--)\n                        respHist[i][baseIdx + k] = base;\n                }\n                if (spareLastBucket)\n                    // Just copy the last bucket.\n                    respHist[i][size - 1] = this.respHist[i][limit];\n            }\n            this.respHist = respHist;\n        }\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        flattenRespHist();\n\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times (\" +\n                responseTimeUnit + \")\", fineRespBucketSize / precision, \"%.5f\",\n                respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times \" +\n                \"(seconds)\", delayBucketSize / 1e9d, \"%.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times (seconds)\", delayBucketSize / 1e9d, \"%.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.6 2009/05/04 19:19:16 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport com.sun.faban.driver.util.PairwiseAggregator;\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable,\n        PairwiseAggregator.Aggregable<Metrics> {\n\n\tprivate static final long serialVersionUID = 32009l;\n\n    /*\n    Response Histogram\n    ~~~~~~~~~~~~~~~~~~\n    Use fine and coarse bucket sizes for response time.\n    Use fine buckets for up to 1.5 * Max90th\n    Use coarse bucket sizes for 1.5 * Max90th to 5 * Max90th\n    We do not care much about accuracy when we're far beyond the Max90th.\n    We use 200 buckets up to Max90th. This means 300 buckets for up to\n    1.5 * Max90th. Beyond that, we reduce the accuracy by 10x so only 70\n    coarse buckets are needed. Altogether, we use 370 buckets, which is\n    63% savings when compared to 1000 buckets. The logic will be slightly\n    more complicated but by not much.\n    */\n    public static final int RESPBUCKET_SIZE_RATIO = 10;\n    public static final int COARSE_RESPBUCKETS = 70; // Percentage coarse.\n    public static final int FINE_RESPBUCKETS = (100 - COARSE_RESPBUCKETS) *\n                                                    RESPBUCKET_SIZE_RATIO;\n    public static final int RESPBUCKETS = FINE_RESPBUCKETS + COARSE_RESPBUCKETS;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    // We use double here to prevent cumulative errors\n    protected long fineRespBucketSize;  // Size of the fine and coarse\n    protected long coarseRespBucketSize; // response time buckets, in ns.\n    protected long fineRespHistMax; // Max fine response time\n    protected long coarseRespHistMax; // Max coarse response time\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and runtime reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sum of response times total.\n     * This is used for runtime reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /**\n     * Sum of high response times that fall into the overflow\n     * bucket. This is used for calculating the representative value\n     * for the overflow bucket to establish a reasonable standard deviation.\n     */\n    protected double[] hiRespSumStdy;\n\n    protected double[] sumSquaresStdy;\n\n    protected double[] sumSquaresTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected String host;\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        host = agent.agent.host;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n\n        txTypes = driverConfig.operations.length;\n\n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        hiRespSumStdy = new double[txTypes];\n        sumSquaresStdy = new double[txTypes];\n        sumSquaresTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        // Calculate the response time histograms.\n        double precision = driverConfig.responseTimeUnit.toNanos(1l);\n        long max90nanos = Math.round(max90th * precision);\n        fineRespBucketSize = max90nanos / 200l;  // 20% of scale of 1000\n        fineRespHistMax = fineRespBucketSize * FINE_RESPBUCKETS;\n        coarseRespBucketSize = fineRespBucketSize * RESPBUCKET_SIZE_RATIO;\n\n        // The last coarse response bucket is used for overflow.\n        coarseRespHistMax = coarseRespBucketSize * (COARSE_RESPBUCKETS - 1) +\n                                                    fineRespHistMax;\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n        sumSquaresTotal[txType] = addSumSquare(sumSquaresTotal[txType], \n                txCntTotal[txType], respSumTotal[txType], responseTime);\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n            sumSquaresStdy[txType] = addSumSquare(sumSquaresStdy[txType],\n                txCntStdy[txType], respSumStdy[txType], responseTime);\n\n            // post in histogram of response times\n            int bucket;\n            if (responseTime < fineRespHistMax) {\n                bucket = (int) (responseTime / fineRespBucketSize);\n            } else if (responseTime < coarseRespHistMax) {\n                bucket = (int) (((responseTime - fineRespHistMax) /\n                        coarseRespBucketSize) + FINE_RESPBUCKETS);\n            } else {\n                bucket = RESPBUCKETS - 1;\n                hiRespSumStdy[txType] += responseTime;\n            }\n            respHist[txType][bucket]++;\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        if (thread.driverContext.timingInfo.respondTime !=\n                AgentThread.TIME_NOT_SET)\n            endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        long bucket = actualDelayTime / delayBucketSize;\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][(int) bucket]++;\n\t\t}\n        bucket = thread.delayTime[thread.mixId] / delayBucketSize;\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][(int) bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Check whether the host is the same. If not, set host to null\n        if (host != s.host) {\n            if (host != null && !host.equals(s.host))\n                host = null;\n            if (s.host != null && !s.host.equals(host))\n                host = null;\n        }\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n            // Add the sum squares before adding the count and response sum.\n            // The values of count and sum have to be unchanged at this point.\n            sumSquaresStdy[i] = addSumSquare(\n                    sumSquaresStdy[i], txCntStdy[i], respSumStdy[i],\n                    s.sumSquaresStdy[i], s.txCntStdy[i], s.respSumStdy[i]);\n            sumSquaresTotal[i] = addSumSquare(\n                    sumSquaresTotal[i], txCntTotal[i], respSumTotal[i],\n                    s.sumSquaresTotal[i], s.txCntTotal[i], s.respSumTotal[i]);\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n            hiRespSumStdy[i] += s.hiRespSumStdy[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * Calculate the sum of squares based on <b><i>Youngs, E.A., and Cramer,\n     * E.M. Some results relevant to choice of sum and sum-of-product\n     * algorithms. Technometrics 13(Aug. 1975), 458.<\/i><\/b>\n     * @param s The previous sum of squares\n     * @param n The current transaction count\n     * @param t The current total response time\n     * @param x The current response time\n     * @return The new sum of squares\n     */\n    static double addSumSquare(double s, int n, double t, double x) {\n        if (n > 1) {\n            double y = n * x - t;\n            s = s + y * y / (n * (n - 1));\n        }\n        return s;\n    }\n\n    /**\n     * Aggregates 2 sum of squares S1 and S2, each of these\n     * variances come from a sample set with N1 and N2 samples and sum\n     * of T1 and T2 respectively. This aggregation uses Chan's algorithm\n     * published in <a href=\n     * \"ftp://reports.stanford.edu/pub/cstr/reports/cs/tr/79/773/CS-TR-79-773.pdf\"\n     * >Updating Formulae and a Pairwise Algorithm for Computing Sample\n     * Variances<\/a> referenced by the Wikipedia article <a href=\n     * \"http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance\"\n     * >Algorithms for calculating variance<\/a>.\n     * @param s1 The sum of squares of the first sample set\n     * @param n1 The sample set size of the first sample set\n     * @param t1 The sum (total) of the first sample set\n     * @param s2 The sum of squares of the second sample set\n     * @param n2 The sample set size of the second sample set\n     * @param t2 The sum (total) of the second sample set\n     * @return The aggregated sum square of the sample sets\n     */\n    static double addSumSquare(double s1, int n1, double t1,\n                               double s2, int n2, double t2) {\n        \n        // We have to account for adding zero and one occurence, too.\n        double s;\n        if (n2 == 0) {\n            s = s1;\n        } else if (n1 == 0) {\n            s = s2;\n        } else if (n2 == 1) {\n            s = addSumSquare(s1, n1, t1, t2);\n        } else if (n1 == 1) {\n            s = addSumSquare(s2, n2, t2, t1);\n        } else {\n            s = (n2 / (double) n1) * t1 - t2;\n            s = s1 + s2 + (n1 / (double) (n2 * (n1 + n2))) * s * s;\n        }\n        if (Double.isNaN(s)) {\n            Logger.getLogger(Metrics.class.getName()).\n                    warning(\"addSumSquare(\" + s1 + \", \" + n1 + \", \" + t1 +\n                    \", \" + s2 + \", \" + n2 + \", \" + t2 + \") returns NaN\");\n        }\n        return s;\n    }\n\n    /**\n     * Subtracts 2 sum of squares S and S1 to obtain S2. This will allow\n     * us to find the variance or standard deviation for response times\n     * for a time slot. This method is used for calculating the current\n     * standard deviation in the runtime stats. The results are estimates and\n     * may not be totally accurate. In most cases it is pretty accurate, though.\n     * We do our best to make it as good as it gets.\n     *\n     * @param s The sum square of the full sample\n     * @param n The sample set size of the full sample\n     * @param t The sum (total) of the full sample\n     * @param s1 The sum square of the subtractor\n     * @param n1 The set size of the subtractor\n     * @param t1 The sum (total) of the full sample\n     * @return The difference of the sum sum square\n     */\n    static double subtractSumSquare(double s, int n, double t,\n            double s1, int n1, double t1) {\n        Logger logger = Logger.getLogger(Metrics.class.getName());\n        double s2;\n        int n2 = n - n1;\n        if (n1 == 0) { // Base n was 0, s does not change.\n            s2 = s;\n        } else if (n2 == 0) { // No samples (ops), so no s\n            s2 = Double.NaN;\n        } else if (n2 == 1) { // 1 sample, s is 0\n            s2 = 0d;\n        } else if (s < s1) { // Shrinking s, unusual but can happen.\n            // Remember, we steal the data without syncing from the owning\n            // thread. So it is not always accurate. In this case we assume\n            // very little or no addition to s and therefore s2 can safely be 0.\n            // Remember this data is only an approximation anyway.\n            logger.finer(\"subtractSumSquare(\" + s + \", \" + n + \", \" + t +\n                    \", \" + s1 + \", \" + n1 + \", \" + t1 + \") s < s1\");\n            s2 = 0d;\n        } else {\n            double t2 = t - t1;\n            s2 = (n2 / (double) n1) * t1 - t2;\n            s2 = s - s1 - (n1 / (double) (n2 * (n1 + n2))) * s2 * s2;\n            if (Double.isNaN(s2)) {  // This case should not happen.\n                logger.warning(\"subtractSumSquare(\" + s + \", \" + n + \", \" + t +\n                        \", \" + s1 + \", \" + n1 + \", \" + t1 + \") returns NaN\");\n            } else if (s2 < 0d) { // This does happen. Again, the data we have\n                // may not be accurate. The diff between s and s1 are too small.\n                // When applying the adjustment factor the result turns out\n                // negative. In this case we can savely assume s2 is very small\n                // and set it to 0.\n                logger.finer(\"subtractSumSquare(\" + s + \", \" + n + \", \" + t +\n                        \", \" + s1 + \", \" + n1 + \", \" + t1 +\n                        \") returns negative\");\n                s2 = 0d;\n            }\n        }\n        return s2;\n    }\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.sumSquaresStdy = sumSquaresStdy.clone();\n            clone.sumSquaresTotal = sumSquaresTotal.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.hiRespSumStdy = hiRespSumStdy.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg;\n        long resp90, resp99;\n        int sumtx, cnt90, cnt99;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n        double[] ckSD = null;\n\n        Logger logger = Logger.getLogger(Metrics.class.getName());\n        Level crosscheck = Level.FINE;\n        if (logger.isLoggable(crosscheck)) {\n            ckSD = new double[txTypes];\n        }\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            long max90nanos = Math.round(max90 * precision);\n\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                avg = (respSumStdy[i]/txCntStdy[i]) / precision;\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                space(16, buffer);\n                formatter.format(\"<sd>%5.3f<\/sd>\\n\",\n                        Math.sqrt(sumSquaresStdy[i]/txCntStdy[i]) / precision);\n\n                if (logger.isLoggable(crosscheck)) {\n                    ckSD[i] = estimateStdev(i, avg, precision);\n                }\n\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90d);\n                int j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp90 = j * fineRespBucketSize;\n                else if (j < RESPBUCKETS)\n                    resp90 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else // Report the overflow bucket.\n                     // Ensure no mistakes due to floating point errors.\n                    resp90 = 2 * coarseRespBucketSize + coarseRespHistMax;\n\n                space(16, buffer);\n                if (resp90 > coarseRespHistMax + coarseRespBucketSize)\n                    formatter.format(\"<p90th>&gt; %5.3f<\/p90th>\\n\",\n                                     coarseRespHistMax / precision);\n                else\n                    formatter.format(\"<p90th>%5.3f<\/p90th>\\n\",\n                                     resp90 / precision);\n                if (resp90 > max90nanos) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n\n                // 99th% hack for Berkeley.\n                sumtx = 0;\n                cnt99 = (int)(txCntStdy[i] * .99d);\n                j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt99)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp99 = j * fineRespBucketSize;\n                else if (j < RESPBUCKETS)\n                    resp99 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else // Report the overflow bucket\n                     // Ensure no mistakes due to floating point errors.\n                    resp99 = 2 * coarseRespBucketSize + coarseRespHistMax;\n\n                space(16, buffer);\n                if (resp99 > coarseRespHistMax + coarseRespBucketSize)\n                    formatter.format(\"<p99th>&gt; %5.3f<\/p99th>\\n\",\n                                     coarseRespHistMax / precision);\n                else\n                    formatter.format(\"<p99th>%5.3f<\/p99th>\\n\",\n                                     resp99 / precision);\n                // end hack.\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<sd/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n                // 99th% hack for Berkeley.\n                space(16, buffer).append(\"<p99th/>\\n\");\n                // End 99th% hack.\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        if (logger.isLoggable(crosscheck) && !Double.isNaN(ckSD[0])) {\n            StringBuilder b = new StringBuilder();\n            Formatter f = new Formatter(b);\n            b.append(\"Crosscheck estimated SD from histogram: \");\n            f.format(\"%.03f\", ckSD[0]);\n            for (int j = 1; j < ckSD.length; j++) {\n                f.format(\"/%.03f\", ckSD[j]);\n            }\n            logger.log(crosscheck, b.toString());\n        }\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = null;\n            try {\n                elements = attachment.getResults();\n            } catch (Exception e) { // Ensure the getResults\n                                    // doesn't break report generation.\n                logger.log(Level.WARNING, \"Exceptione reporting CustomMetrics\",\n                                                                            e);\n                elements = null;\n            }\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n    \n    private double estimateStdev(int type, double avg, double precision) {\n                        // Overall standard deviation, for checking only.\n        double sumDev2 = 0d;\n        for (int j = 0; j < respHist[type].length; j++) {\n            if (respHist[type][j] == 0) {\n                continue;\n            }\n            long bucketRep = getBucketRepValue(j);\n            double dev;\n            if (bucketRep == Long.MIN_VALUE) {\n                dev = hiRespSumStdy[type] / respHist[type][j];\n            } else {\n                dev = bucketRep;\n            }\n            dev = dev / precision - avg;\n            sumDev2 += dev * dev * respHist[type][j];\n        }\n        return Math.sqrt(sumDev2 / txCntStdy[type]);\n    }\n\n    private long getBucketRepValue(int bucketId) {\n        long resp;\n        if (bucketId < Metrics.FINE_RESPBUCKETS) {\n            resp = bucketId * fineRespBucketSize + (fineRespBucketSize/2);\n        } else if (bucketId < Metrics.RESPBUCKETS) {\n            resp = (bucketId - Metrics.FINE_RESPBUCKETS) *\n                    coarseRespBucketSize + fineRespHistMax +\n                    (coarseRespBucketSize/2);\n        } else {\n            resp = Long.MIN_VALUE;\n        }\n        return resp;\n    }\n\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        while (maxBucketId >= 0) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n            --maxBucketId;\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * The respHist, or response histogram has a special structure:\n     * The lower buckets are fine-grained buckets. The higher buckets\n     * are coarse-grained bucket covering 10x as much time. It is done this\n     * way to save memory (from 1000 entries per thread per operation, down to\n     * 370 entries). For low response times, we care a lot about the exact\n     * response time and therefore we use fine-grained buckets. For large\n     * response times we just want to know the ballpark, but not the exact\n     * number. So it does not make sense to keep the same bucket size\n     * throughout. We use fine granularity below 1.5x largest set 90th% and\n     * coarse granularity for anything beyond that.\n     *\n     * Now, we need to flatten the response time histogram into a flat one\n     * before plotting. We do this, here. We'll end up with more entries, but\n     * we really don't care since this is one copy, once per run at report time.\n     */\n    private void flattenRespHist() {\n        int limit = getBucketLimit(respHist);\n\n        // If all buckets are used, the last one does not get extrapolated\n        // as it has the data of that bucket and beyond.\n        boolean spareLastBucket = false;\n        if (limit == respHist[0].length)\n            spareLastBucket = true;\n\n        if (limit > FINE_RESPBUCKETS) {\n            int size;\n            if (spareLastBucket) {\n                --limit;\n                size = (COARSE_RESPBUCKETS - 1) * RESPBUCKET_SIZE_RATIO +\n                                                        FINE_RESPBUCKETS + 1;\n            } else {\n                size = (limit - FINE_RESPBUCKETS) * RESPBUCKET_SIZE_RATIO +\n                                                        FINE_RESPBUCKETS;\n            }\n            int[][] respHist = new int[txTypes][size];\n            for (int i = 0; i < txTypes; i++) {\n\n                // Copy the fine buckets unchanged.\n                for (int j = 0; j < FINE_RESPBUCKETS; j++)\n                    respHist[i][j] = this.respHist[i][j];\n\n                for (int j = FINE_RESPBUCKETS; j < limit; j++) {\n                    int count = this.respHist[i][j];\n                    // Spread the count among all 10 flat buckets.\n                    int base = count / RESPBUCKET_SIZE_RATIO;\n                    int remainder = count % RESPBUCKET_SIZE_RATIO;\n                    int baseIdx = (j - FINE_RESPBUCKETS) *\n                                    RESPBUCKET_SIZE_RATIO + FINE_RESPBUCKETS;\n                    int k = 9;\n                    // The higher buckets get the base\n                    for (; k >= remainder; k--)\n                        respHist[i][baseIdx + k] = base;\n                    // The lower remaining buckets get the base + 1\n                    ++base;\n                    for (; k >= 0; k--)\n                        respHist[i][baseIdx + k] = base;\n                }\n                if (spareLastBucket)\n                    // Just copy the last bucket.\n                    respHist[i][size - 1] = this.respHist[i][limit];\n            }\n            this.respHist = respHist;\n        }\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        flattenRespHist();\n\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times (\" +\n                responseTimeUnit + \")\", fineRespBucketSize / precision, \"%.5f\",\n                respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times \" +\n                \"(seconds)\", delayBucketSize / 1e9d, \"%.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times (seconds)\", delayBucketSize / 1e9d, \"%.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","lineNo":816}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Timer.java,v 1.7 2008/07/29 23:26:41 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.util;\n\nimport com.sun.faban.driver.FatalException;\n\nimport java.io.Serializable;\nimport java.util.Random;\nimport java.util.logging.Logger;\n\n/**\n * This class has the functions to get timestamps\n */\npublic class Timer implements Serializable {\n    /** The millisec epoch time of this benchmark */\n\tlong epochMillis;\n\n    /** The nanosec epoch time of this benchmark */\n    transient long epochNanos; // This has no meaning on a different system.\n\n    transient long diffms; // The epoch difference, millisec part\n    transient int diffns; // The epoch difference, nanosec part\n\n    private transient Logger logger;\n    private long compensation = 5000000l;  // Some pretty good starting numbers\n    private double deviation = 5000000d; // for both fields.\n    private Boolean debug = null;\n\n    /**\n     * Default Constructor which saves the current time\n     * as epochMillis and epochNanos (the start of the benchmark).\n     * The resolution is unknown. Note that this is only constructed on the\n     * master so the initial values before adjustments pertain to the master\n     * alone.\n     */\n\tpublic Timer() {\n\n        // This is just a fake setting of the epochNanos. The call\n        // into System.nanoTime() ensures initialization of the nano timer\n        // and prevents underflow from calibration.\n        epochNanos = System.nanoTime();\n\n        // Set the benchmark epoch 10ms ahead of the actual current time\n        // also prevents underflow in case the nano timer is just initialized.\n        // The value of the nano timer may be very close to Long.MIN_VALUE.\n        epochMillis = System.currentTimeMillis() + 10l;\n        epochNanos = calibrateNanos(epochMillis);\n\n        getLogger().fine(\"Timer: baseTime ms: \" + epochMillis +\n                         \", ns: \" + epochNanos);\n\t}\n\n    /**\n     * Calibrates the difference of the nanosec timer from the millisec\n     * timer using 100 iterations. This is probably the most accurate\n     * way to establish the relationship.\n     * @param baseMillis the base millisec to find the base nanosec for\n     * @return The base nanosec corresponding to the base millisec.\n     */\n    private long calibrateNanos(long baseMillis) {\n\n        if (isDebug())\n            return estimateNanos(baseMillis);\n\n        int iterations = 100;\n        int limit = 1000;  // Limit the number of total loops...\n        long[] diffms = new long[iterations];\n        int[] diffns = new int[iterations];\n        Logger logger = getLogger();\n        System.gc(); // We don't want gc during calibration. So we try to gc\n                     // now, on best effort.\n\n        // Run the calibration loop and collect data.\n        for (int i = 0, tooLong = 0; i < iterations;) {\n            if (tooLong > limit) // prevent infinite loops.\n                throw new FatalException(\"Cannot establish clock offset \" +\n                                         \"(ms->ns), retries \" + i + \",\" +\n                                         tooLong);\n\n            long nanos;\n            long millis;\n            long millisBefore = System.currentTimeMillis();\n            do {\n               nanos = System.nanoTime();\n               millis = System.currentTimeMillis();\n            } while (millis == millisBefore);\n\n            if (++millisBefore == millis) { // Only use the edges.\n                diffms[i] = millis - nanos / 1000000l;\n                diffns[i] = (int) (nanos % 1000000l);\n                logger.finer(\"iter: \" + i + \", millis: \" + millis +\n                        \", nanos: \" + nanos + \", diffms: \" + diffms[i] +\n                        \", diffns: \" + diffns[i]);\n                tooLong = 0; // Reset retry counters on success.\n                ++i;\n            } else {\n                ++tooLong;\n            }\n        }\n\n        // Find the granularity of the nanosec results.\n        int granularity = 6;\n        for (int i = 0; i < diffns.length; i++) {\n            int ns = diffns[i];\n            int mod = 10;\n            int g = 0;\n            for (; g < 6; g++) {\n                if (ns % mod != 0)\n                    break;\n                mod *= 10;\n            }\n            if (g < granularity)\n                granularity = g;\n            if (granularity == 0)\n                break;\n        }\n        logger.fine(\"Nanosec timer granularity: \" + granularity);\n\n        // Find the max ms difference.\n        long maxDiffMs = Long.MIN_VALUE;\n        for (int i = 0; i < diffms.length; i++) {\n            if (diffms[i] > maxDiffMs)\n                maxDiffMs = diffms[i];\n        }\n\n        // Adjust the ms difference to be the same, the rest goes into ns.\n        for (int i = 0; i < diffms.length; i++) {\n            if (diffms[i] < maxDiffMs) {\n                diffns[i] += (maxDiffMs - diffms[i]) * 1000000l;\n                diffms[i] = maxDiffMs;\n            }\n        }\n\n        // Find the avg diffns\n        double avgDiffNs = 0d;\n        for (int i = 0; i < diffns.length; i++)\n            avgDiffNs += diffns[i];\n        avgDiffNs /= diffns.length;\n\n        // Find the standard deviation\n        double sdevDiffNs = 0d;\n        for (int i = 0; i < diffns.length; i++) {\n            double dev = diffns[i] - avgDiffNs;\n            dev *= dev;\n            sdevDiffNs += dev;\n        }\n        sdevDiffNs = Math.sqrt(sdevDiffNs / diffns.length);\n        logger.fine(\"Sdev nsec: \" + sdevDiffNs);\n\n        // Now, eliminate the outliers beyond 2x sdev.\n        // Based on the empirical rule, about 95% of the values are within\n        // 2 standard deviations (assuming a normal distribution of\n        // timing discrepancy). So what's beyond 2x sdev can really\n        // be counted as outliers.\n        int count = 0;\n        double avgDiffNs2 = 0;\n        for (int i = 0; i < diffns.length; i++) {\n            double dev = Math.abs(diffns[i] - avgDiffNs);\n            if (dev <= sdevDiffNs * 2d) { // Outliers are beyond 2x sdev.\n                ++count;\n                avgDiffNs2 += diffns[i];\n            } else {\n                logger.fine(\"Excluded: \" + i);\n            }\n        }\n        avgDiffNs2 /= count;\n\n        // Warn if we have a lot of outliers, allow 10% on each side.\n        if (count < (int) 0.8d * iterations)\n            logger.warning(\"Too many outliers in calibration. \" +\n                    (iterations - count) + \" of \" + iterations);\n\n        // Round the average to the granularity\n        int grainSize = 1;\n        for (int i = 0; i < granularity; i++) {\n            grainSize *= 10;\n        }\n        int avgDiffNsI = (int) Math.round(avgDiffNs2 / grainSize);\n        avgDiffNsI *= grainSize;\n\n        // Re-adjust the ms so the ns does not exceed 1,000,000.\n        maxDiffMs -= avgDiffNsI / 1000000;\n        avgDiffNsI %= 1000000;\n\n        // Then assign the diffs.\n        this.diffms = maxDiffMs;\n        this.diffns = avgDiffNsI;\n\n        // Based on our local differences between the nanos and millis clock\n        // clock, we calculate the base nanose based on the given base millis.\n        return (baseMillis - this.diffms) * 1000000l + this.diffns;\n    }\n\n    /**\n     * Estimates the difference of the nanosec timer from the millisec\n     * timer. This method is not as timing sensitive as calibrateNanos\n     * and is routed from calibrateNanos in debug mode when the driver\n     * is run in an IDE or debugger. It is by far not as accurate as\n     * calibrateNanos.\n     * @param baseMillis the base millisec to find the base nanosec for\n     * @return The base nanosec corresponding to the base millisec.\n     */\n    private long estimateNanos(long baseMillis) {\n        long ns1 = System.nanoTime();\n        long ms = System.currentTimeMillis();\n        long ns2 = System.nanoTime();\n        long avgNs = (ns2 - ns1) / 2 + ns1;\n        this.diffms = ms - avgNs / 1000000;\n        this.diffns = (int) (avgNs % 1000000);\n        return (baseMillis - this.diffms) * 1000000l + this.diffns;\n    }\n\n    private Logger getLogger() {\n        if (logger == null)\n            logger = Logger.getLogger(getClass().getName());\n        return logger;\n    }\n\n    /**\n     * Converts the millisec relative time to absolute nanosecs.\n     * @param relTimeMillis The millisec relative time\n     * @return The corresponding nanosec time\n     */\n    public long toAbsNanos(int relTimeMillis) {\n        return (relTimeMillis + epochMillis - diffms) * 1000000l + diffns;\n    }\n\n    /**\n     * Converts the nanosecond time relative to the run's epoch to absolute\n     * millisec comparable to System.currentTimeMillis().\n     * @param relTimeNanos The relative time in nanosecs\n     * @return The absolute time in millisecs\n     */\n    public long toAbsMillis(long relTimeNanos) {\n        return (relTimeNanos + epochNanos) / 1000000l + diffms;\n    }\n\n    /**\n     * Converts the millisec time relative to the run's epoch to absolute\n     * millisec comparable to System.currentTimeMillis().\n     * @param relTimeMillis The relative time in nanosecs\n     * @return the absolute time in millisecs\n     */\n    public long toAbsMillis(int relTimeMillis) {\n        return relTimeMillis + epochMillis;\n    }\n\n    /**\n     * Obtains the current time relative to the base time, in\n     * milliseconds. This is mainly used to determine the current state of\n     * of the run. The base time is synchronized between the Faban\n     * master and all driver agents.\n     * @return The nanoseconds from the base time.\n     */\n    public int getTime() {\n        long c = System.currentTimeMillis();\n        return (int) (c - epochMillis);\n    }\n\n    /**\n     * Obtains the time relative to the base time, given a nanoTime\n     * with an unknown datum. The base time is synchronized between the Faban\n     * master and all driver agents.\n     * @param nanoTime The nanotime obtained from System.nanoTime()\n     * @return The nanosecond time relative to our base time.\n     */\n    public long toRelTime(long nanoTime) {\n        return nanoTime - epochNanos;\n    }\n\n    /**\n     * Obtains the nano time comparable to System.nanoTime() from a given\n     * nanotime relative to the base time.\n     * @param relNanos The relative nanosecond time\n     * @return The nanoseconds comparable to System.nanoTime.\n     */\n    public long toAbsTime(long relNanos) {\n        return relNanos + epochNanos;\n    }\n\n    /**\n     * Sets the actual measured sleep time deviation. This is called from\n     * the calibrator. Since the deviation is rarely read and certainly not\n     * read concurrently we do not need to protect it. The compensation\n     * will automatically be set as a round-up of deviation.\n     * @param deviation The deviation, in nanosecs.\n     */\n    private void setDeviation(double deviation) {\n        this.deviation = deviation;\n        int compensation = (int) (deviation / 1000000); // A low cost way to\n        ++compensation;                                 // round up.\n        // Note: There's a 1:10^6 chance we round up a full millis.\n        // But that's better than not rounding up at all.\n\n        // Make a single atomic int assignment in order to avoid race conditions\n        this.compensation = compensation * 1000000l;\n    }\n\n    /**\n     * Reads the compensation value.\n     * @return The compensation\n     */\n    public long getCompensation() {\n        return compensation;\n    }\n\n    /**\n     * Reads the deviation value.\n     * @return The deviation\n     */\n    public double getDeviation() {\n        return deviation;\n    }\n\n    /**\n     * Causes this thread to sleep until the wakeup time as referenced\n     * by this timer. Timer.sleep is not a minimum sleep time as in\n     * Thread.sleep, but rather a calibrated and compensated sleep\n     * time which gives the best statistical opportunity to wake up\n     * at the required time. The actual wakeup can be slightly before\n     * or slightly after the wakeup time but the average discrepancy\n     * should be close to zero.\n     * @param wakeupTime The time this thread is supposed to wakeup.\n     */\n    public void wakeupAt(long wakeupTime) {\n        long currentTime;\n        if ((currentTime = System.nanoTime()) < wakeupTime - compensation)\n            try {\n                long sleepTime = wakeupTime - currentTime - compensation;\n                Thread.sleep(sleepTime / 1000000l, (int) (sleepTime % 1000000l));\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\n                        \"Sleep interrupted. Run terminating.\");\n                // If we get an interrupt, the run is killed/terminated.\n                // Just stop sleeping.\n            }\n    }\n\n    /**\n     * Runs a timer sleep time calibration for a certain amount of time.\n     * @param id The agent identifier - used for logging purposes.\n     * @param endTime The time to end the calibration, referencing this JVMs\n     *        nanosec timer.\n     */\n    public void calibrate(String id, long endTime) {\n        // Convert relative time to abs time.\n        endTime = toAbsTime(endTime);\n        // Only calibrate if we have at least 5 secs to do so.\n        // Otherwise it does not make sense at all.\n        if (endTime - System.nanoTime() > 5000000000l) {\n            Calibrator calibrator = new Calibrator(id, endTime);\n            calibrator.start();\n        }\n    }\n\n    /**\n     * Adjusts the base time based on the clock differences of this JVM to\n     * the master's JVM. This is done at the millisecond accuracy. Since\n     * remote calls are usually not much faster than a millisec, it does\n     * not make much sense to be too ideological about accuracy here.\n     * @param offset The millisec offset between systems\n     */\n    public void adjustBaseTime(int offset) {\n\n        // This is just a fake setting of the epochNanos. The call\n        // into System.nanoTime() ensures initialization of the nano timer\n        // and prevents underflow from calibration. This is just in case\n        // the first call of System.nanoTime gives a value very close to\n        // Long.MIN_VALUE.\n        epochNanos = System.nanoTime();\n\n        // We use the provided offset to calculate the millis\n        // reprsenting the same timestamp on a remote system.\n        epochMillis += offset;\n\n        // And then calibrate the nanos based on the new millis.\n        epochNanos = calibrateNanos(epochMillis);\n    }\n\n    /**\n     * Check whether we're in debug mode. Debug mode will make\n     * the Faban driver less timing sensitive. Debug mode is set\n     * by passing a system property -Dfaban.debug=true to the JVM\n     * at startup.\n     * @return true if debug is turned on.\n     */\n    boolean isDebug() {\n        if (debug == null) {\n            String debugSwitch = System.getProperty(\"faban.debug\");\n            if (debugSwitch != null)\n                debug = new Boolean(debugSwitch);\n            else\n                debug = Boolean.FALSE;\n        }\n        return debug.booleanValue();\n    }\n\n    /**\n     * The Calibrator thread is used to calibrate the deviation of the sleep\n     * time for compensation purposes. We already know the semantics of sleep\n     * points to the minimum sleep time. The actual time calculated from<ul>\n     *      <li>System.currentTimeMillis()\n     *      <li>Thread.sleep(sleepTime)\n     *      <li>System.currentTimeMillis()\n     *\n     * <\/ul>is always higher than sleepTime. The difference varies largely\n     * between systems and could dramatically skew the driver cycles. It is\n     * however expected to be in the 10s of milliseconds or less than 10\n     * milliseconds range.<p>\n     *\n     * The Calibrator must be run by each agent during the rampup time.\n     * Assuming the rampup is adequately long, it should capture a pretty good\n     * average deviation which will include the effects of several garbage\n     * collections and use this difference to compensate the sleep time.\n     *\n     * @author Akara Sucharitakul\n     */\n    class Calibrator extends Thread {\n\n        private String id;\n        private long endTime;\n\n        /**\n         * Constructs the calibrator.\n         * @param endTime The time to end the calibration, based on this timer\n         */\n        Calibrator(String id, long endTime) {\n            this.id = id;\n            this.endTime = endTime;\n            setName(\"Calibrator\");\n        }\n\n        /**\n         * Runs the calibrator thread.\n         */\n        public void run() {\n            long timeAfter = Long.MIN_VALUE;\n            int maxSleep = -1; // Initial value\n            Random random = new Random();\n\n            int count = 0;\n            long devSum = 0l;\n            for (;;) {\n                // We random the intended sleep between 10 and 30 ms\n                // thus assuming the systems running the driver will\n                // have a timer resolution of 10ms or better.\n                // The avg sleep time is 20ms as a result.\n                int intendedSleep = random.nextInt(21) + 10;\n                if (maxSleep == -1) // Set maxSleep for first check.\n                    maxSleep = intendedSleep;\n                if (timeAfter + maxSleep >= endTime) {\n                    setDeviation((double) devSum/count); // Final one.\n                    break;\n                }\n                long timeBefore = Long.MAX_VALUE;\n                try {\n                    timeBefore = System.nanoTime();\n                    Thread.sleep(intendedSleep, 0);\n                    timeAfter = System.nanoTime();\n                } catch (InterruptedException e) {\n                }\n                if (timeAfter > timeBefore) { // If not interrupted.\n                    long actualSleep = timeAfter - timeBefore;\n                    long deviation = actualSleep - intendedSleep * 1000000l;\n                    devSum += deviation;\n                    ++count;\n                    if (actualSleep > maxSleep)\n                        maxSleep = (int) (actualSleep / 1000000l);\n                    // Keep converging the deviation to the final value\n                    // until this thread exits, just before steady state.\n                    if (count % 50 == 0) // Sets every 50 experiments, ~1 sec.\n                        setDeviation((double) devSum/count);\n                }\n            }\n\n            // Test for qualifying final compensation...\n            if (!isDebug() && compensation > 100000000l) {\n                getLogger().severe(id + \": System needed time compensation \" +\n                        \"of \" + compensation / 1000000l + \".\\nValues over \" +\n                        \"100ms are unacceptable for a driver. \\nPlease use a \" +\n                        \"faster system or tune the driver JVM/GC.\\nExiting...\");\n                System.exit(1);\n            }\n            getLogger().fine(id + \": Calibration succeeded. Sleep time \" +\n                    \"deviation: \" + getDeviation() + \" ns, compensation: \" +\n                    compensation + \" ns.\");\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Timer.java,v 1.8 2009/03/15 07:26:13 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.util;\n\nimport com.sun.faban.driver.FatalException;\n\nimport java.io.Serializable;\nimport java.util.Random;\nimport java.util.logging.Logger;\n\n/**\n * This class has the functions to get timestamps\n */\npublic class Timer implements Serializable {\n    /** The millisec epoch time of this benchmark */\n\tlong epochMillis;\n\n    /** The nanosec epoch time of this benchmark */\n    transient long epochNanos; // This has no meaning on a different system.\n\n    transient long diffms; // The epoch difference, millisec part\n    transient int diffns; // The epoch difference, nanosec part\n\n    private transient Logger logger;\n    private long compensation = 5000000l;  // Some pretty good starting numbers\n    private double deviation = 5000000d; // for both fields.\n    private Boolean debug = null;\n\n    /**\n     * Default Constructor which saves the current time\n     * as epochMillis and epochNanos (the start of the benchmark).\n     * The resolution is unknown. Note that this is only constructed on the\n     * master so the initial values before adjustments pertain to the master\n     * alone.\n     */\n\tpublic Timer() {\n\n        // This is just a fake setting of the epochNanos. The call\n        // into System.nanoTime() ensures initialization of the nano timer\n        // and prevents underflow from calibration.\n        epochNanos = System.nanoTime();\n\n        // Set the benchmark epoch 10ms ahead of the actual current time\n        // also prevents underflow in case the nano timer is just initialized.\n        // The value of the nano timer may be very close to Long.MIN_VALUE.\n        epochMillis = System.currentTimeMillis() + 10l;\n        epochNanos = calibrateNanos(epochMillis);\n\n        getLogger().fine(\"Timer: baseTime ms: \" + epochMillis +\n                         \", ns: \" + epochNanos);\n\t}\n\n    /**\n     * Calibrates the difference of the nanosec timer from the millisec\n     * timer using 100 iterations. This is probably the most accurate\n     * way to establish the relationship.\n     * @param baseMillis the base millisec to find the base nanosec for\n     * @return The base nanosec corresponding to the base millisec.\n     */\n    private long calibrateNanos(long baseMillis) {\n\n        if (isDebug())\n            return estimateNanos(baseMillis);\n\n        int iterations = 100;\n        int limit = 1000;  // Limit the number of total loops...\n        long[] diffms = new long[iterations];\n        int[] diffns = new int[iterations];\n        int[] clockStep = new int[iterations];\n        int msStep = Integer.MAX_VALUE;\n        Logger logger = getLogger();\n        System.gc(); // We don't want gc during calibration. So we try to gc\n                     // now, on best effort.\n\n        // Run the calibration loop and collect data.\n        for (int i = 0, tooLong = 0; i < iterations;) {\n            if (tooLong > limit) // prevent infinite loops.\n                throw new FatalException(\"Cannot establish clock offset \" +\n                                         \"(ms->ns), retries \" + i + \",\" +\n                                         tooLong);\n\n            long nanos;\n            long millis;\n            long millisBefore = System.currentTimeMillis();\n            do {\n               nanos = System.nanoTime();\n               millis = System.currentTimeMillis();\n            } while (millis == millisBefore);\n\n            // Now we're on the edge of a new ms value\n            // Find the ms clock step for this system\n            // by iterating down the min step value.\n            clockStep[i] = (int) (millis - millisBefore);\n            if (clockStep[i] < msStep)\n                msStep = clockStep[i];\n\n            // If we discover any step bigger than the best recorded step,\n            // ignore the iteration.\n            if (msStep != Integer.MAX_VALUE && clockStep[i] > msStep) {\n                ++tooLong;\n                continue;\n            }\n\n            diffms[i] = millis - nanos / 1000000l;\n            diffns[i] = (int) (nanos % 1000000l);\n            logger.finer(\"iter: \" + i + \", millis: \" + millis +\n                    \", nanos: \" + nanos + \", diffms: \" + diffms[i] +\n                    \", diffns: \" + diffns[i] + \", stepms: \" + clockStep[i]);\n            tooLong = 0; // Reset retry counters on success.\n            ++i;\n        }\n        logger.fine(\"System.currentTimeMillis() granularity is \" + msStep +\n                    \"ms\");\n\n        // There might still be some records left at the beginning before\n        // that have the step > minstep. This happens before the minstep\n        // is established. We must not use these records. Count them and\n        // report. If more than 25% are bad, don't continue.\n        int badRecords = 0;\n        for (int i = 0; i < clockStep.length; i++) {\n            if (clockStep[i] > msStep) {\n                logger.finer(\"Rejected bad record \" + i + \n                             \"Edge mis-detection. Clock step of \" +\n                             clockStep[i] + \"ms higher than granularity.\");\n                ++badRecords;\n            }\n        }\n        if (badRecords > iterations / 4) {\n            throw new FatalException(\"Cannot establish clock offset \" +\n                    \"(ms->ns), edge mis-detections beyond threshold - \" +\n                    badRecords + \" out of \" + iterations +\n                    \". Perhaps system is too busy.\");\n        } else {\n            logger.fine(\"Rejected \" + badRecords + \" bad records.\");\n        }\n        int goodRecords = iterations - badRecords;\n\n        // Find the granularity of the nanosec results.\n        int granularity = 6;\n        for (int i = 0; i < diffns.length; i++) {\n            int ns = diffns[i];\n            int mod = 10;\n            int g = 0;\n            for (; g < 6; g++) {\n                if (ns % mod != 0)\n                    break;\n                mod *= 10;\n            }\n            if (g < granularity)\n                granularity = g;\n            if (granularity == 0)\n                break;\n        }\n        logger.fine(\"Nanosec timer granularity: 1e\" + granularity);\n\n        // Find the max ms difference.\n        long maxDiffMs = Long.MIN_VALUE;\n        for (int i = 0; i < diffms.length; i++) {\n            if (clockStep[i] > msStep) // ignore bad records\n                continue;\n            if (diffms[i] > maxDiffMs)\n                maxDiffMs = diffms[i];\n        }\n\n        // Adjust the ms difference to be the same, the rest goes into ns.\n        for (int i = 0; i < diffms.length; i++) {\n            if (clockStep[i] > msStep) // again, ignore bad records\n                continue;\n            if (diffms[i] < maxDiffMs) {\n                diffns[i] += (maxDiffMs - diffms[i]) * 1000000l;\n                diffms[i] = maxDiffMs;\n            }\n        }\n\n        // Find the avg diffns\n        double avgDiffNs = 0d;\n        for (int i = 0; i < diffns.length; i++) {\n            if (clockStep[i] == msStep) // again, ignore bad records\n                avgDiffNs += diffns[i];\n        }\n        avgDiffNs /= goodRecords;\n\n        // Find the standard deviation\n        double sdevDiffNs = 0d;\n        for (int i = 0; i < diffns.length; i++) {\n            if (clockStep[i] == msStep) { // again, use only good records\n                double dev = diffns[i] - avgDiffNs;\n                dev *= dev;\n                sdevDiffNs += dev;\n            }\n        }\n        sdevDiffNs = Math.sqrt(sdevDiffNs / goodRecords);\n        logger.fine(\"Sdev nsec: \" + sdevDiffNs);\n\n        // Now, eliminate the outliers beyond 2x sdev.\n        // Based on the empirical rule, about 95% of the values are within\n        // 2 standard deviations (assuming a normal distribution of\n        // timing discrepancy). So what's beyond 2x sdev can really\n        // be counted as outliers.\n        int count = 0;\n        double avgDiffNs2 = 0;\n        for (int i = 0; i < diffns.length; i++) {\n            if (clockStep[i] > msStep) // again, ignore bad records\n                continue;\n            double dev = Math.abs(diffns[i] - avgDiffNs);\n            if (dev <= sdevDiffNs * 2d) { // Outliers are beyond 2x sdev.\n                ++count;\n                avgDiffNs2 += diffns[i];\n            } else {\n                logger.fine(\"Excluded outlier record \" + i + \". \" +\n                            \"Nanosec diff beyond 2*sdev or about 95th% \" +\n                            \"according to empirical rule\");\n            }\n        }\n        avgDiffNs2 /= count;\n\n        // Warn if we have a lot of outliers, allow 10% on each side.\n        if (count < (int) 0.8d * goodRecords)\n            logger.warning(\"Too many outliers in calibration. \" +\n                    (goodRecords - count) + \" of \" + goodRecords);\n\n        // Round the average to the granularity\n        int grainSize = 1;\n        for (int i = 0; i < granularity; i++) {\n            grainSize *= 10;\n        }\n        int avgDiffNsI = (int) Math.round(avgDiffNs2 / grainSize);\n        avgDiffNsI *= grainSize;\n\n        // Re-adjust the ms so the ns does not exceed 1,000,000.\n        maxDiffMs -= avgDiffNsI / 1000000;\n        avgDiffNsI %= 1000000;\n\n        // Then assign the diffs.\n        this.diffms = maxDiffMs;\n        this.diffns = avgDiffNsI;\n\n        // Based on our local differences between the nanos and millis clock\n        // clock, we calculate the base nanose based on the given base millis.\n        return (baseMillis - this.diffms) * 1000000l + this.diffns;\n    }\n\n    /**\n     * Estimates the difference of the nanosec timer from the millisec\n     * timer. This method is not as timing sensitive as calibrateNanos\n     * and is routed from calibrateNanos in debug mode when the driver\n     * is run in an IDE or debugger. It is by far not as accurate as\n     * calibrateNanos.\n     * @param baseMillis the base millisec to find the base nanosec for\n     * @return The base nanosec corresponding to the base millisec.\n     */\n    private long estimateNanos(long baseMillis) {\n        long ns1 = System.nanoTime();\n        long ms = System.currentTimeMillis();\n        long ns2 = System.nanoTime();\n        long avgNs = (ns2 - ns1) / 2 + ns1;\n        this.diffms = ms - avgNs / 1000000;\n        this.diffns = (int) (avgNs % 1000000);\n        return (baseMillis - this.diffms) * 1000000l + this.diffns;\n    }\n\n    private Logger getLogger() {\n        if (logger == null)\n            logger = Logger.getLogger(getClass().getName());\n        return logger;\n    }\n\n    /**\n     * Converts the millisec relative time to absolute nanosecs.\n     * @param relTimeMillis The millisec relative time\n     * @return The corresponding nanosec time\n     */\n    public long toAbsNanos(int relTimeMillis) {\n        return (relTimeMillis + epochMillis - diffms) * 1000000l + diffns;\n    }\n\n    /**\n     * Converts the nanosecond time relative to the run's epoch to absolute\n     * millisec comparable to System.currentTimeMillis().\n     * @param relTimeNanos The relative time in nanosecs\n     * @return The absolute time in millisecs\n     */\n    public long toAbsMillis(long relTimeNanos) {\n        return (relTimeNanos + epochNanos) / 1000000l + diffms;\n    }\n\n    /**\n     * Converts the millisec time relative to the run's epoch to absolute\n     * millisec comparable to System.currentTimeMillis().\n     * @param relTimeMillis The relative time in nanosecs\n     * @return the absolute time in millisecs\n     */\n    public long toAbsMillis(int relTimeMillis) {\n        return relTimeMillis + epochMillis;\n    }\n\n    /**\n     * Obtains the current time relative to the base time, in\n     * milliseconds. This is mainly used to determine the current state of\n     * of the run. The base time is synchronized between the Faban\n     * master and all driver agents.\n     * @return The nanoseconds from the base time.\n     */\n    public int getTime() {\n        long c = System.currentTimeMillis();\n        return (int) (c - epochMillis);\n    }\n\n    /**\n     * Obtains the time relative to the base time, given a nanoTime\n     * with an unknown datum. The base time is synchronized between the Faban\n     * master and all driver agents.\n     * @param nanoTime The nanotime obtained from System.nanoTime()\n     * @return The nanosecond time relative to our base time.\n     */\n    public long toRelTime(long nanoTime) {\n        return nanoTime - epochNanos;\n    }\n\n    /**\n     * Obtains the nano time comparable to System.nanoTime() from a given\n     * nanotime relative to the base time.\n     * @param relNanos The relative nanosecond time\n     * @return The nanoseconds comparable to System.nanoTime.\n     */\n    public long toAbsTime(long relNanos) {\n        return relNanos + epochNanos;\n    }\n\n    /**\n     * Sets the actual measured sleep time deviation. This is called from\n     * the calibrator. Since the deviation is rarely read and certainly not\n     * read concurrently we do not need to protect it. The compensation\n     * will automatically be set as a round-up of deviation.\n     * @param deviation The deviation, in nanosecs.\n     */\n    private void setDeviation(double deviation) {\n        this.deviation = deviation;\n        int compensation = (int) (deviation / 1000000); // A low cost way to\n        ++compensation;                                 // round up.\n        // Note: There's a 1:10^6 chance we round up a full millis.\n        // But that's better than not rounding up at all.\n\n        // Make a single atomic int assignment in order to avoid race conditions\n        this.compensation = compensation * 1000000l;\n    }\n\n    /**\n     * Reads the compensation value.\n     * @return The compensation\n     */\n    public long getCompensation() {\n        return compensation;\n    }\n\n    /**\n     * Reads the deviation value.\n     * @return The deviation\n     */\n    public double getDeviation() {\n        return deviation;\n    }\n\n    /**\n     * Causes this thread to sleep until the wakeup time as referenced\n     * by this timer. Timer.sleep is not a minimum sleep time as in\n     * Thread.sleep, but rather a calibrated and compensated sleep\n     * time which gives the best statistical opportunity to wake up\n     * at the required time. The actual wakeup can be slightly before\n     * or slightly after the wakeup time but the average discrepancy\n     * should be close to zero.\n     * @param wakeupTime The time this thread is supposed to wakeup.\n     */\n    public void wakeupAt(long wakeupTime) {\n        long currentTime;\n        if ((currentTime = System.nanoTime()) < wakeupTime - compensation)\n            try {\n                long sleepTime = wakeupTime - currentTime - compensation;\n                Thread.sleep(sleepTime / 1000000l, (int) (sleepTime % 1000000l));\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\n                        \"Sleep interrupted. Run terminating.\");\n                // If we get an interrupt, the run is killed/terminated.\n                // Just stop sleeping.\n            }\n    }\n\n    /**\n     * Runs a timer sleep time calibration for a certain amount of time.\n     * @param id The agent identifier - used for logging purposes.\n     * @param endTime The time to end the calibration, referencing this JVMs\n     *        nanosec timer.\n     */\n    public void calibrate(String id, long endTime) {\n        // Convert relative time to abs time.\n        endTime = toAbsTime(endTime);\n        // Only calibrate if we have at least 5 secs to do so.\n        // Otherwise it does not make sense at all.\n        if (endTime - System.nanoTime() > 5000000000l) {\n            Calibrator calibrator = new Calibrator(id, endTime);\n            calibrator.start();\n        }\n    }\n\n    /**\n     * Adjusts the base time based on the clock differences of this JVM to\n     * the master's JVM. This is done at the millisecond accuracy. Since\n     * remote calls are usually not much faster than a millisec, it does\n     * not make much sense to be too ideological about accuracy here.\n     * @param offset The millisec offset between systems\n     */\n    public void adjustBaseTime(int offset) {\n\n        // This is just a fake setting of the epochNanos. The call\n        // into System.nanoTime() ensures initialization of the nano timer\n        // and prevents underflow from calibration. This is just in case\n        // the first call of System.nanoTime gives a value very close to\n        // Long.MIN_VALUE.\n        epochNanos = System.nanoTime();\n\n        // We use the provided offset to calculate the millis\n        // reprsenting the same timestamp on a remote system.\n        epochMillis += offset;\n\n        // And then calibrate the nanos based on the new millis.\n        epochNanos = calibrateNanos(epochMillis);\n    }\n\n    /**\n     * Check whether we're in debug mode. Debug mode will make\n     * the Faban driver less timing sensitive. Debug mode is set\n     * by passing a system property -Dfaban.debug=true to the JVM\n     * at startup.\n     * @return true if debug is turned on.\n     */\n    boolean isDebug() {\n        if (debug == null) {\n            String debugSwitch = System.getProperty(\"faban.debug\");\n            if (debugSwitch != null)\n                debug = new Boolean(debugSwitch);\n            else\n                debug = Boolean.FALSE;\n        }\n        return debug.booleanValue();\n    }\n\n    /**\n     * The Calibrator thread is used to calibrate the deviation of the sleep\n     * time for compensation purposes. We already know the semantics of sleep\n     * points to the minimum sleep time. The actual time calculated from<ul>\n     *      <li>System.currentTimeMillis()\n     *      <li>Thread.sleep(sleepTime)\n     *      <li>System.currentTimeMillis()\n     *\n     * <\/ul>is always higher than sleepTime. The difference varies largely\n     * between systems and could dramatically skew the driver cycles. It is\n     * however expected to be in the 10s of milliseconds or less than 10\n     * milliseconds range.<p>\n     *\n     * The Calibrator must be run by each agent during the rampup time.\n     * Assuming the rampup is adequately long, it should capture a pretty good\n     * average deviation which will include the effects of several garbage\n     * collections and use this difference to compensate the sleep time.\n     *\n     * @author Akara Sucharitakul\n     */\n    class Calibrator extends Thread {\n\n        private String id;\n        private long endTime;\n\n        /**\n         * Constructs the calibrator.\n         * @param endTime The time to end the calibration, based on this timer\n         */\n        Calibrator(String id, long endTime) {\n            this.id = id;\n            this.endTime = endTime;\n            setName(\"Calibrator\");\n        }\n\n        /**\n         * Runs the calibrator thread.\n         */\n        public void run() {\n            long timeAfter = Long.MIN_VALUE;\n            int maxSleep = -1; // Initial value\n            Random random = new Random();\n\n            int count = 0;\n            long devSum = 0l;\n            for (;;) {\n                // We random the intended sleep between 10 and 30 ms\n                // thus assuming the systems running the driver will\n                // have a timer resolution of 10ms or better.\n                // The avg sleep time is 20ms as a result.\n                int intendedSleep = random.nextInt(21) + 10;\n                if (maxSleep == -1) // Set maxSleep for first check.\n                    maxSleep = intendedSleep;\n                if (timeAfter + maxSleep >= endTime) {\n                    setDeviation((double) devSum/count); // Final one.\n                    break;\n                }\n                long timeBefore = Long.MAX_VALUE;\n                try {\n                    timeBefore = System.nanoTime();\n                    Thread.sleep(intendedSleep, 0);\n                    timeAfter = System.nanoTime();\n                } catch (InterruptedException e) {\n                }\n                if (timeAfter > timeBefore) { // If not interrupted.\n                    long actualSleep = timeAfter - timeBefore;\n                    long deviation = actualSleep - intendedSleep * 1000000l;\n                    devSum += deviation;\n                    ++count;\n                    if (actualSleep > maxSleep)\n                        maxSleep = (int) (actualSleep / 1000000l);\n                    // Keep converging the deviation to the final value\n                    // until this thread exits, just before steady state.\n                    if (count % 50 == 0) // Sets every 50 experiments, ~1 sec.\n                        setDeviation((double) devSum/count);\n                }\n            }\n\n            // Test for qualifying final compensation...\n            if (!isDebug() && compensation > 100000000l) {\n                getLogger().severe(id + \": System needed time compensation \" +\n                        \"of \" + compensation / 1000000l + \".\\nValues over \" +\n                        \"100ms are unacceptable for a driver. \\nPlease use a \" +\n                        \"faster system or tune the driver JVM/GC.\\nExiting...\");\n                System.exit(1);\n            }\n            getLogger().fine(id + \": Calibration succeeded. Sleep time \" +\n                    \"deviation: \" + getDeviation() + \" ns, compensation: \" +\n                    compensation + \" ns.\");\n        }\n    }\n}\n","lineNo":157}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: MasterImpl.java,v 1.1 2008/09/10 18:25:54 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.driver.ConfigurationException;\nimport com.sun.faban.driver.FatalException;\nimport com.sun.faban.driver.RunControl;\nimport com.sun.faban.driver.util.PlotServer;\nimport com.sun.faban.driver.util.Timer;\n\nimport java.io.*;\nimport java.rmi.ConnectException;\nimport java.rmi.NotBoundException;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.TimerTask;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\n/**\n * This is the main Master class for running a Faban driver.\n * The Master is instantiated on the <b>master machine<\/b> by the\n * user wishing to run a benchmark. It is responsible for co-ordinating\n * the work of all the Agents, setting up the benchmark test,\n * collecting the results etc.\n * NOTE: The registry and agents must have been brought up before\n * starting the driver. The driver will fail otherwise.\n *\n * @see        com.sun.faban.driver.engine.Agent\n * @see        com.sun.faban.common.Registry\n *\n */\npublic class MasterImpl extends UnicastRemoteObject implements Master {\n\n    /**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\n\t// This field is a legal requirement and serves no other purpose.\n    static final String COPYRIGHT =\n            \"Copyright \\251 2006 Sun Microsystems, Inc., 4150 Network Circle, \" +\n            \"Santa Clara, California 95054, U.S.A. All rights reserved.\\n\" +\n            \"U.S. Government Rights - Commercial software.  Government users \" +\n            \"are subject to the Sun Microsystems, Inc. standard license \" +\n            \"agreement and applicable provisions of the FAR and its \" +\n            \"supplements.\\n\" +\n            \"Use is subject to license terms.\\n\" +\n            \"This distribution may include materials developed by third \" +\n            \"parties.\\n\" +\n            \"Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks \" +\n            \"or registered trademarks of Sun Microsystems, Inc. in the U.S. \" +\n            \"and other countries.\\n\" +\n            \"Apache is a trademark of The Apache Software Foundation, and is \" +\n            \"used with permission.\\n\" +\n            \"This product is covered and controlled by U.S. Export Control \" +\n            \"laws and may be subject to the export or import laws in other \" +\n            \"countries.  Nuclear, missile, chemical biological weapons or \" +\n            \"nuclear maritime end uses or end users, whether direct or \" +\n            \"indirect, are strictly prohibited.  Export or reexport to \" +\n            \"countries subject to U.S. embargo or to entities identified on \" +\n            \"U.S. export exclusion lists, including, but not limited to, the \" +\n            \"denied persons and specially designated nationals lists is \" +\n            \"strictly prohibited.\\n\" +\n            \"\\n\" +\n            \"Copyright \\251 2006 Sun Microsystems, Inc., 4150 Network Circle, \" +\n            \"Santa Clara, California 95054, Etats-Unis. Tous droits \" +\n            \"r\\351serv\\351s.\\n\" +\n            \"L'utilisation est soumise aux termes de la Licence.\\n\" +\n            \"Cette distribution peut comprendre des composants \" +\n            \"d\\351velopp\\351s par des tierces parties.\\n\" +\n            \"Sun,  Sun Microsystems,  le logo Sun et  Java sont des marques \" +\n            \"de fabrique ou des marques d\\351pos\\351es de \" +\n            \"Sun Microsystems, Inc. aux Etats-Unis et dans d'autres pays.\\n\" +\n            \"Apache est une marque d\\264Apache Software Foundation, utilis\\351e \" +\n            \"avec leur permission.\\n\" +\n            \"Ce produit est soumis \\340 la l\\351gislation am\\351ricaine \" +\n            \"en mati\\350re de contr\\364le des exportations et peut \\352tre \" +\n            \"soumis \\340 la r\\350glementation en vigueur dans d'autres pays \" +\n            \"dans le domaine des exportations et importations. Les \" +\n            \"utilisations, ou utilisateurs finaux, pour des armes \" +\n            \"nucl\\351aires, des missiles, des armes biologiques et chimiques \" +\n            \"ou du nucl\\351aire maritime, directement ou indirectement, sont \" +\n            \"strictement interdites. Les exportations ou r\\351exportations \" +\n            \"vers les pays sous embargo am\\351ricain, ou vers des entit\\351s \" +\n            \"figurant sur les listes d'exclusion d'exportation \" +\n            \"am\\351ricaines, y compris, mais de mani\\350re non exhaustive, \" +\n            \"la liste de personnes qui font objet d'un ordre de ne pas \" +\n            \"participer, d'une fa\\347on directe ou indirecte, aux \" +\n            \"exportations des produits ou des services qui sont r\\351gis par \" +\n            \"la l\\351gislation am\\351ricaine en mati\\350re de contr\\364le \" +\n            \"des exportations et la liste de ressortissants sp\\351cifiquement \" +\n            \"d\\351sign\\351s, sont rigoureusement interdites.\\n\";\n\n    private String className = getClass().getName();\n    protected Logger logger = Logger.getLogger(className);\n\n    BenchmarkDefinition benchDef;\n\n    /** Remote references for each agentImpl of each driver type. */\n    protected Agent[][] agentRefs;\n    // Note: first dimension is the driver type\n\n    /** Threads required per agentImpl for each driver. */\n    protected int[] agentThreads;\n\n    /** Remaining threads to be distributed to the first agents. */\n    protected int[] remainderThreads;\n\n    /** The RunInfo structure */\n    protected RunInfo runInfo;\n\n    protected Timer timer; // The time recorder.\n\n    protected static String fs = System.getProperty(\"file.separator\");\n\n    private boolean runAborted = false;\n\n    protected Object stateLock = new Object();\n    protected MasterState state = MasterState.CONFIGURING;\n\n    protected java.util.Timer scheduler;\n\n    /**\n     * Creates and exports a new Master\n     *\n     * @throws java.rmi.RemoteException if failed to export object\n     */\n    protected MasterImpl() throws RemoteException {\n        super();\n\n        try {\n            RegistryLocator.getRegistry().reregister(\"Master\", this);\n        } catch (ConnectException e) {\n            // A ConnectException should be interpreted as no registry.\n        } catch (NotBoundException e) {\n            // Here too, do nothing. If we run in single process mode,\n            // the registry is just not there.\n        }\n    }\n\n    /**\n     * Runs the benchmark from begin to end.\n     * @throws Exception Any error that had occurred during the run.\n     */\n    public void runBenchmark() throws Exception {\n\n        // Read the benchmark definition from the defining class\n        benchDef = BenchmarkDefinition.read(RunInfo.getDefiningClassName());\n\n        // Get the runInfo\n        runInfo = RunInfo.read(benchDef);\n\n        // When run form the harness, the outputdir may be the runId.\n        // In that case the faban.outputdir.unique property must be set to true.\n        boolean uniqueDir = false;\n        String uniqueDirString = System.getProperty(\"faban.outputdir.unique\");\n        if (uniqueDirString != null) {\n\t\t\tuniqueDir = RunInfo.ConfigurationReader.\n                    relaxedParseBoolean(uniqueDirString);\n\t\t}\n\n        if (uniqueDir) {\n            // Ensure separator is not at end.\n            if (runInfo.resultsDir.endsWith(fs)) {\n\t\t\t\trunInfo.resultsDir = runInfo.resultsDir.substring(0,\n                        runInfo.resultsDir.length() - fs.length());\n\t\t\t}\n\n            // Then take the innermost directory name.\n            int idx = runInfo.resultsDir.lastIndexOf(fs);\n            ++idx;\n            runInfo.runId = runInfo.resultsDir.substring(idx);\n        } else {\n            // Gets the ID for this run from the sequence file.\n            try {\n                runInfo.runId = getRunID(true);\n            } catch (Exception e) {\n                logger.severe(\"Cannot read the run id\");\n                logger.throwing(className, \"<init>\", e);\n                throw e;\n            }\n        }\n        logger.info(\"RunID for this run is : \" + runInfo.runId);\n\n        String runOutputDir = runInfo.resultsDir;\n        if (!uniqueDir) {\n\t\t\trunOutputDir = runInfo.resultsDir + fs + runInfo.runId;\n\t\t}\n\n        // make a new directory for the run.\n        File runDirFile = null;\n        runDirFile = new File(runOutputDir);\n        if ( !runDirFile.exists()) {\n\t\t\tif ( !runDirFile.mkdirs()) {\n\t\t\t\tthrow new IOException(\"Could not create the new \" +\n                        \"Run Directory: \" + runOutputDir);\n\t\t\t}\n\t\t}\n\n        logger.info(\"Output directory for this run is : \" + runOutputDir);\n        runInfo.resultsDir = runOutputDir;\n\n        configureLogger (runOutputDir);\n\n        timer = new Timer();\n\n        agentRefs = new Agent[benchDef.drivers.length][];\n        agentThreads = new int[benchDef.drivers.length];\n        remainderThreads = new int[benchDef.drivers.length];\n\n        scheduler = new java.util.Timer(\"Scheduler\", false);\n        try {\n            int agentCnt = configure();\n            if (agentCnt > 0) {\n                for (int i = 0; i < benchDef.drivers.length && !runAborted; i++) {\n\t\t\t\t\tconfigureAgents(i);\n\t\t\t\t}\n                logger.config(\"Detected \" + agentCnt + \" Remote Agents.\");\n            } else {\n                configureLocal();\n            }\n        } catch (ConnectException e) {\n            configureLocal();\n        } catch (NotBoundException e) {\n            configureLocal();\n        } catch (RemoteException e) {\n            Throwable t = e.getCause();\n            Throwable tt;\n            while ((tt = t.getCause()) != null) {\n\t\t\t\tt = tt;\n\t\t\t}\n            logger.log(Level.WARNING,\n                    \"Error acccessing registry or agent!\", t);\n            configureLocal();\n        }\n        changeState(MasterState.STARTING);\n        executeRun();\n    }\n\n    /**\n     * This method retrieves the ID for the current run, by looking\n     * in the specappplatform.seq file in the user's home directory.\n     * If the increment flag is set to true, the runId is incremented.\n     * Also the file will be created if it does not exist. This shall\n     * be done only maximum once in a run. Non-incrementing getRunID\n     * may be called more than once from many processes.\n     *\n     * @param increment Whether the file shall be incremented or not\n     * @return runId\n     * @throws IOException \n     */\n    public String getRunID(boolean increment) throws IOException{\n        int runID = -1;\n\n        String seqDir = System.getProperty(\"faban.sequence.path\");\n        if (seqDir == null) {\n\t\t\tseqDir = System.getProperty(\"user.home\");\n\t\t}\n\n        String seqFileName = System.getProperty(\"faban.sequence.file\");\n        if (seqFileName == null)\n            seqFileName = benchDef.name.toLowerCase() + \".seq\";\n        seqFileName = seqDir + fs + seqFileName;\n        File seqFile = new File(seqFileName);\n        if (seqFile.exists()) {\n            FileReader bufIn = null;\n            char[] buffer = new char[64];\n            int length = 0;\n            try {\n                bufIn = new FileReader(seqFile);\n            }\n            catch (FileNotFoundException e) {\n                logger.log(Level.SEVERE, \"The sequence file '\" + seqFile +\n                        \"' does not exist.\", e);\n                throw e;\n            }\n            try {\n                length = bufIn.read(buffer);\n                bufIn.close();\n            }\n            catch (IOException e) {\n                logger.log(Level.SEVERE, \"Could not read/close the sequence \" +\n                        \"file \" + seqFileName + '.', e);\n                throw e;\n            }\n            if (length > 0) {\n                // Strip off the newlines\n                if (buffer[length - 1] == '\\n') {\n\t\t\t\t\t--length;\n\t\t\t\t}\n                if (buffer[length - 1] == '\\r') {\n\t\t\t\t\t--length;\n\t\t\t\t}\n                runID = Integer.parseInt(new String(buffer, 0, length));\n            }\n        }\n        if (runID == -1) {\n            if (increment) {\n\t\t\t\ttry {\n                    seqFile.createNewFile();\n                }\n                catch (IOException e) {\n                    logger.log(Level.SEVERE, \"Could not create the sequence \" +\n                            \"file \" + seqFileName + '.', e);\n                    throw e;\n                }\n\t\t\t}\n            runID = 1;\n        }\n        // Update the runid in the sequence file\n        if (increment) {\n\t\t\ttry {\n                FileWriter fileOut = new FileWriter(seqFileName);\n                fileOut.write(Integer.toString(runID + 1));\n                fileOut.close();\n            }\n            catch (IOException e) {\n                logger.log(Level.SEVERE, \"Could not write to the sequence file \"\n                        + seqFileName + '.', e);\n                throw e;\n            }\n\t\t}\n        return Integer.toString(runID);\n    }\n\n    private void configureLogger(String dir) {\n\n        logger = Logger.getLogger(\"com.sun.faban.driver\");\n        FileHandler handler = null;\n        try {\n            handler = new FileHandler(dir + fs + \"driver.log\", true);\n        } catch (IOException e) {\n            logger.severe(e.getMessage());\n            System.exit(1);\n        }\n\n        handler.setFormatter(new SimpleFormatter());\n        handler.setLevel(Level.FINEST);\n        logger.addHandler(handler);\n        runInfo.logHandler = handler;\n    }\n\n    /**\n     * Contacts the registry and gets references for all agents.\n     * Then calculates the load distribution to each agentImpl.\n     * @return The total number of agents configured\n     */\n    protected int configure() throws Exception {\n\n        Registry registry = RegistryLocator.getRegistry();\n\n        int totalAgentCnt = 0;\n\n        // Get all agents for all drivers\n        for (int i = 0; i < benchDef.drivers.length && !runAborted; i++) {\n            // Only for drivers to run...\n            if (runInfo.driverConfigs[i].numAgents != 0) {\n\n                // Get all the agentImpl refs\n                String agentName = benchDef.drivers[i].name + \"Agent\";\n                Remote[] refs = registry.getServices(agentName);\n                int agentCnt = 0;\n\n                // Usually, the agents should have been started\n                // according to the given number. But just in case\n                // some of them did not get started or there might\n                // be some others sneaking in...\n                if (refs == null || (agentCnt = refs.length) == 0) {\n                    // Hmmm, for some reason the agents didn't get started\n                    if (runInfo.driverConfigs[i].numAgents > 0) {\n                        logger.warning(\"Cannot find \" + agentName + \"s. Not \" +\n                                \"starting \" + benchDef.drivers[i].name + '.');\n\t\t\t\t\t}\n                    runInfo.driverConfigs[i].numAgents = 0;\n                    continue;\n                }\n\n                if (agentCnt != runInfo.driverConfigs[i].numAgents) {\n                    if (runInfo.driverConfigs[i].numAgents > 0) {\n                        logger.warning(\"Configured \" + runInfo.driverConfigs[i].\n                                numAgents + ' ' + benchDef.drivers[i].name +\n                                \"Agents but found \" + agentCnt + '.');\n                        if (agentCnt > runInfo.driverConfigs[i].numAgents) {\n\t\t\t\t\t\t\tlogger.warning(\"Some unkown agents managed to \" +\n                                    \"sneak in! We'll use'em!\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warning(\"Some agents surely didn't get \" +\n                                   \"started. We'll just use the ones we have.\");\n\t\t\t\t\t\t}\n                    }\n\n                    // Now we need to adjust the runInfo according to realty\n                    runInfo.driverConfigs[i].numAgents = agentCnt;\n                }\n\n                // Now assign the agent refs to the global agent array.\n                agentRefs[i] = new Agent[agentCnt];\n                for (int j = 0; j < agentCnt; j++) {\n\t\t\t\t\tagentRefs[i][j] = (Agent) refs[j];\n\t\t\t\t}\n\n                // We need to calculate the thread counts\n                if (runInfo.driverConfigs[i].numThreads == -1) {\n\t\t\t\t\trunInfo.driverConfigs[i].numThreads = runInfo.scale *\n                            benchDef.drivers[i].threadPerScale;\n\t\t\t\t}\n                agentThreads[i] = runInfo.driverConfigs[i].numThreads /\n                        runInfo.driverConfigs[i].numAgents;\n                remainderThreads[i] = runInfo.driverConfigs[i].numThreads -\n                        agentThreads[i] * runInfo.driverConfigs[i].numAgents;\n\n                totalAgentCnt += agentCnt;\n            }\n        }\n        return totalAgentCnt;\n    }\n\n    protected void configureLocal() throws Exception {\n        int driverToRun = -1;\n        if (runInfo.driverConfigs.length > 1) {\n            for (int i = 0; i < runInfo.driverConfigs.length; i++) {\n\t\t\t\tif (runInfo.driverConfigs[i].numAgents == 1) {\n                    if (driverToRun == -1) {\n                        driverToRun = i;\n                    } else {\n                        String msg = \"Can only configure 1 agentImpl for \" +\n                                \"local runs.\\nDetected \" + benchDef.\n                                drivers[driverToRun].name + \" and \" +\n                                benchDef.drivers[i].name + \" set to run.\";\n                        throw new ConfigurationException(msg);\n                    }\n                } else if (runInfo.driverConfigs[i].numAgents > 1) {\n                    String msg = \"Can only configure 1 agentImpl for local \" +\n                            \"runs.\\n\" + benchDef.drivers[i].name + \" is set to \" +\n                            runInfo.driverConfigs[i].numAgents + \" agents.\";\n                    throw new ConfigurationException(msg);\n                }\n\t\t\t}\n        } else {\n            driverToRun = 0;\n            runInfo.driverConfigs[0].numAgents = 1;\n        }\n\n        if (driverToRun < 0) {\n\t\t\tthrow new ConfigurationException(\"No driver configured to run.\");\n\t\t}\n\n        logger.config(\"Starting single, in-process \" +\n                      benchDef.drivers[driverToRun].name + \"Agent.\");\n\n        // We need to calculate the thread counts\n        if (runInfo.driverConfigs[driverToRun].numThreads == -1) {\n\t\t\trunInfo.driverConfigs[driverToRun].numThreads = runInfo.\n                    scale * benchDef.drivers[driverToRun].threadPerScale;\n\t\t}\n        agentThreads[driverToRun] =\n                runInfo.driverConfigs[driverToRun].numThreads;\n\n        RunInfo.AgentInfo agentInfo = new RunInfo.AgentInfo();\n        runInfo.agentInfo = agentInfo;\n\n        runInfo.driverConfig = runInfo.driverConfigs[driverToRun];\n        agentRefs[driverToRun] = new Agent[1];\n        agentRefs[driverToRun][0] =\n                new AgentImpl(runInfo.driverConfig.name, \"0\");\n\n        runInfo.agentInfo.agentNumber = 0;\n\n        agentInfo.threads = this.agentThreads[driverToRun];\n        agentInfo.agentScale = runInfo.scale;\n        agentRefs[driverToRun][0].configure(this, runInfo,\n                driverToRun, timer);\n    }\n\n    /**\n     * configureAgents()\n     * Get a list of all the registered agents and parseProperties them\n     */\n    private void configureAgents(int driverType) throws Exception {\n\n        int agentCnt = runInfo.driverConfigs[driverType].numAgents;\n        if (agentCnt > 0) {\n            RunInfo.AgentInfo agentInfo = new RunInfo.AgentInfo();\n            runInfo.agentInfo = agentInfo;\n            logger.config(\"num\" + benchDef.drivers[driverType].name +\n                        \"Agents = \" + agentCnt);\n\n            agentInfo.threads = agentThreads[driverType];\n            agentInfo.agentScale = (double) runInfo.scale/agentCnt;\n            Remote[] refs = agentRefs[driverType];\n            logger.info(\"Configuring \" + refs.length + ' ' +\n                        benchDef.drivers[driverType].name + \"Agents...\");\n\n            runInfo.driverConfig = runInfo.driverConfigs[driverType];\n            int agentId = 0;\n\n            // If there are remaining threads left, distribute each to\n            // the first agents. Ditto for scale\n            if (remainderThreads[driverType] > 0) {\n                agentInfo.threads = agentThreads[driverType] + 1;\n                agentInfo.agentScale = (double) runInfo.scale *\n                        runInfo.driverConfigs[driverType].numThreads /\n                        agentInfo.threads;\n\n                for (; agentId < remainderThreads[driverType]; agentId++) {\n                    runInfo.agentInfo.agentNumber = agentId;\n                    ((Agent)refs[agentId]).configure(this, runInfo,\n                                                     driverType, timer);\n                    runInfo.agentInfo.startThreadNumber += agentInfo.threads;\n                }\n            }\n\n            // Now deal with the non-remainders...\n            agentInfo.threads = agentThreads[driverType];\n            agentInfo.agentScale = (double) runInfo.scale *\n                    runInfo.driverConfigs[driverType].numThreads /\n                    agentInfo.threads;\n\n            for (; agentId < refs.length && !runAborted; agentId++) {\n                runInfo.agentInfo.agentNumber = agentId;\n                ((Agent)refs[agentId]).configure(this, runInfo, driverType, timer);\n                runInfo.agentInfo.startThreadNumber += agentInfo.threads;\n            }\n        }\n        runInfo.driverConfig = null;\n        runInfo.agentInfo = null; // reset it so we don't use it anywhere else\n    }\n\n    /**\n     * Tell the agents to start the run execution\n     * Note that the Agent's run method call is non-blocking\n     * i.e the Master does not wait for an Agent. Instead, we\n     * wait for the total length of the run, after we signal\n     * all the agents to start.\n     */\n    private void executeRun() throws Exception {\n        StatsWriter sw = null;\n\n        // Now wait for all threads to start if it is parallel.\n        if (runInfo.parallelAgentThreadStart) {\n\t\t\twaitForThreadStart();\n\t\t}\n\n        // Leave plenty of time to notify all agents of the start time.\n        setStartTime(estimateCommsTime() + timer.getTime());\n\n        int sleepTime = runInfo.benchStartTime - timer.getTime();\n        if (sleepTime <= 0) {\n            String msg = \"Threads are not done initializing by start time.\\n\" +\n                    \"Possibly too high latency between agents.\";\n            logger.severe(msg);\n            throw new ConfigurationException(msg);\n        }\n\n        if (runAborted) { // If aborted during thread start, we discontinue.\n            try {\n                Thread.sleep(10000); // But wait for some cleanup before we do\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n            throw new FatalException(\"Run Aborted.\");\n        }\n\n        logger.info(\"Started all threads; run commences in \" + sleepTime +\n                \" ms\");\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n        \tlogger.log(Level.FINE, ie.getMessage(), ie);\n        }\n        // At this time each agent will start the run automatically.\n\n        // Start thread to dump stats for charting\n        sw = new StatsWriter();\n\n        TimerTask killAtEnd = null;\n        final AtomicBoolean joining = new AtomicBoolean(false);\n\n        // In case of time control, we can wait and log more stats. We also\n        // know when the run should terminate and can force a kill. But in\n        // case of cycle control, we can only wait.\n        if (benchDef.runControl == RunControl.TIME) {\n            changeState(MasterState.RAMPUP);\n            try {\n                Thread.sleep(runInfo.rampUp * 1000);\n            } catch (InterruptedException ie) {\n            \tlogger.log(Level.FINE, ie.getMessage(), ie);\n            }\n            changeState(MasterState.STEADYSTATE);\n            logger.info(\"Ramp up completed\");\n            try {\n                Thread.sleep(runInfo.stdyState * 1000);\n            } catch (InterruptedException ie) {\n            \tlogger.log(Level.FINE, ie.getMessage(), ie);\n            }\n            changeState(MasterState.RAMPDOWN);\n            logger.info(\"Steady state completed\");\n            try {\n                Thread.sleep(runInfo.rampDown * 1000);\n            } catch (InterruptedException ie) {\n            \tlogger.log(Level.FINE, ie.getMessage(), ie);\n            }\n            logger.info(\"Ramp down completed\");\n\n            // Schedule a forced termination 2 minutes from here where we start\n            // the wait.\n            killAtEnd = new TimerTask() {\n\n                        Thread mainThread = Thread.currentThread();\n\n\t\t\t\t\t\tpublic void run() {\n                            for (int i = 0; i < agentRefs.length; i++) {\n\t\t\t\t\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\t\t\t\t\t// Ensure we terminate the first agent last\n                                    for (int j = agentRefs[i].length - 1;\n                                         j >= 0; j--) {\n\t\t\t\t\t\t\t\t\t\ttry {\n                                            agentRefs[i][j].terminate();\n                                        } catch (RemoteException e) {\n                                            logger.log(Level.SEVERE,\n                                                    \"Error checking thread \" +\n                                                    \"starts.\", e);\n                                        }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n                            if (joining.get()) {\n\t\t\t\t\t\t\t\tmainThread.interrupt();\n\t\t\t\t\t\t\t}\n                        }\n                    };\n            scheduler.schedule(killAtEnd, 120000);\n        } else { // For cycle mode, we never know the end of rampup, steady.\n            changeState(MasterState.STEADYSTATE);\n        }\n\n        // Now wait for all threads under all agents to terminate.\n        joining.set(true);\n\n        joinLoop:\n        for (int driverType = 0; driverType < runInfo.driverConfigs.length;\n             driverType++) {\n            if (runInfo.driverConfigs[driverType].numAgents > 0) {\n                Remote refs[] = agentRefs[driverType];\n                // Make sure we join the first agent last\n                for (int i = refs.length - 1; i >= 0; i--) {\n\t\t\t\t\ttry {\n                        ((Agent) refs[i]).join();\n                    } catch (RemoteException e) {\n                        logger.warning(\"Master: RemoteException got \" + e);\n                        logger.throwing(className, \"executeRun\", e);\n\n                        // If the RemoteException is caused by an interrupt,\n                        // we break the loop. This is because killAtEnd is in\n                        // effect.\n                        if (Thread.interrupted()) {\n\t\t\t\t\t\t\tbreak joinLoop;\n\t\t\t\t\t\t}\n                    }\n\t\t\t\t}\n            }\n        }\n        joining.set(false);\n\n        // It would be good if we do not have to execute killAtEnd. By now\n        // if it's still there in the scheduler it means all the joins work\n        // flawlessly.\n        if (killAtEnd != null) {\n\t\t\tkillAtEnd.cancel();\n\t\t}\n\n        /* Gather stats and print report */\n        changeState(MasterState.RESULTS);\n        Metrics[] results = new Metrics[runInfo.driverConfigs.length];\n        for (int driverType = 0; driverType < results.length; driverType++) {\n\t\t\tresults[driverType] = getDriverMetrics(driverType);\n\t\t}\n\n        generateReports(results);\n\n        // Tell StatsWriter to quit\n        sw.quit();\n    }\n\n    private Metrics getDriverMetrics(int driverType) {\n        Remote refs[];\n        Metrics result = null;\n        try {\n            if (runInfo.driverConfigs[driverType].numAgents > 0) {\n                Metrics[] results = new Metrics[\n                        runInfo.driverConfigs[driverType].numAgents];\n                refs = agentRefs[driverType];\n                logger.info(\"Gathering \" +\n                        benchDef.drivers[driverType].name + \"Stats ...\");\n                for (int i = 0; i < refs.length; i++) {\n\t\t\t\t\tresults[i] = (Metrics) (((Agent) refs[i]).getResults());\n\t\t\t\t}\n\n                for (int i = 0; i < results.length; i++) {\n\t\t\t\t\tif (results[i] != null) {\n\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\tresult = results[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.add(results[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n                // Once we have the metrics, we have to set it's start time\n                // Since this is set after all threads have started, it will\n                // be 0 in all the metrices we receive.\n                if (result != null) {\n\t\t\t\t\tresult.startTime =  runInfo.start;\n\t\t\t\t}\n            }\n        } catch (RemoteException re) {\n            logger.log(Level.WARNING, \"Master: RemoteException got \" + re, re);\n        }\n        return result;\n    }\n\n    /**\n     * Generates the summary and detail report.\n     * @param results Array of Metrics objects, one per driver type\n     * @throws IOException \n     */\n    public void generateReports(Metrics[] results) throws IOException {\n        String runOutputDir = runInfo.resultsDir + fs;\n        FileWriter summary = new FileWriter(runOutputDir + \"summary.xml\");\n        FileWriter detail = new FileWriter(runOutputDir + \"detail.xan\");\n\n        // As all stats from each agentImpl are of the same type, we can\n        // create a new instance from any instance.\n        logger.info(\"Printing Summary report...\");\n        summary.append(createSummaryReport(results));\n        summary.close();\n\n        logger.info(\"Summary finished. Now printing detail ...\");\n        detail.append(createDetailReport(results));\n        detail.close();\n\n        logger.info(\"Detail finished. Results written to \" +\n                runInfo.resultsDir + '.');\n    }\n\n    /**\n     * Aggregates results of incompatible stats and prints the benchmark\n     * summary report header.\n     * @param results The per-driver metrics\n     * @return The report as a char sequence\n     */\n    @SuppressWarnings(\"boxing\")\n\tprivate CharSequence createSummaryReport(Metrics[] results) {\n        long startTime = Long.MAX_VALUE;\n        long endTime = 0l;\n        double metric = 0d;\n        boolean passed = true;\n\n        StringBuilder buffer = new StringBuilder(8192);\n        StringBuilder hdrBuffer = new StringBuilder(1024);\n\n        for (int i = 0; i < results.length; i++) {\n            if (results[i] == null) {\n                logger.warning(\"Unable to obtain \" + benchDef.drivers[i].name +\n                        \" results, ignoring...\");\n                continue;\n            }\n            if (results[i].startTime < startTime) {\n\t\t\t\tstartTime = results[i].startTime;\n\t\t\t}\n            long end;\n            if ((end = results[i].startTime + results[i].endTime) > endTime) {\n\t\t\t\tendTime = end;\n\t\t\t}\n            if (!results[i].printSummary(buffer, benchDef)) {\n\t\t\t\tpassed = false;\n\t\t\t}\n            metric += results[i].metric;\n        }\n        String xslPath = System.getProperty(\"faban.xsl.path\", \"../../xslt/\");\n        if (!xslPath.endsWith(\"/\")) {\n\t\t\txslPath += '/';\n\t\t}\n        hdrBuffer.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n        hdrBuffer.append(\"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\").\n                append(xslPath).append(\"summary_report.xsl\\\"?>\\n\");\n        hdrBuffer.append(\"<benchResults>\\n\");\n        hdrBuffer.append(\"    <benchSummary name=\\\"\").append(benchDef.name).\n                append(\"\\\" version=\\\"\").append(benchDef.version).\n                append(\"\\\">\\n\");\n        hdrBuffer.append(\"        <runId>\").append(runInfo.runId).\n                append(\"<\/runId>\\n\");\n        hdrBuffer.append(\"        <startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        hdrBuffer.append(\"        <endTime>\").append(new Date(endTime)).\n                append(\"<\/endTime>\\n\");\n        Formatter formatter = new Formatter(hdrBuffer);\n        formatter.format(\"        <metric unit=\\\"%s\\\">%.03f<\/metric>\\n\",\n                benchDef.metric, metric);\n        hdrBuffer.append(\"        <passed>\").append(passed).\n                append(\"<\/passed>\\n\");\n        hdrBuffer.append(\"    <\/benchSummary>\\n\");\n\n        buffer.insert(0, hdrBuffer);\n        buffer.append(\"<\/benchResults>\\n\");\n        return buffer;\n    }\n\n    /**\n     * Aggregates detail results into a single buffer.\n     * @param results The per-driver metrics\n     * @return The report as a char sequence\n     */\n    private CharSequence createDetailReport(Metrics[] results) {\n        StringBuilder buffer = new StringBuilder(8192);\n        buffer.append(\"Title: \").append(benchDef.name).\n                append(\" Detailed Results\\n\\n\\n\");\n        buffer.append(\"Section: Benchmark Information\\n\");\n        buffer.append(\"Name   Value\\n\");\n        buffer.append(\"-----  -------------\\n\");\n        buffer.append(\"RunId  \").append(runInfo.runId).append(\"\\n\\n\\n\");\n        for (Metrics result : results)\n            if (result != null)\n                result.printDetail(buffer);\n\n        return buffer;\n    }\n\n    private class StatsWriter extends Thread {\n\n        private int driverTypes = benchDef.drivers.length;\n\n        PlotServer[] plotServers = new PlotServer[driverTypes];\n        Metrics[][] currentResults = new Metrics[driverTypes][];\n        \n        Remote[] refs;\n        boolean started = false;\n        boolean endFlag = false;\n        long dumpInterval;\n        int dumpSecs;\n\n\n        private int prevTxCnt[] = new int[driverTypes];\n        private double avgTps[] = new double[driverTypes];\n        private int elapsed = 0;\n\n\n\n        /**\n         * Construct a {@link StatsWriter}.\n         */\n        public StatsWriter() {\n            if (!runInfo.runtimeStatsEnabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n            for (int driverId = 0; driverId < driverTypes; driverId ++) {\n                if (runInfo.driverConfigs[driverId].numAgents <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                String dumpResource =\n                        runInfo.driverConfigs[driverId].runtimeStatsTarget;\n                if (dumpResource == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                if (!started) {\n                    logger.info(\"Starting StatsWriter ...\");\n                    started = true;\n                }\n\n                try {\n                    plotServers[driverId] = new PlotServer(2, dumpResource);\n                } catch (IOException e) {\n                    logger.severe(e.getMessage());\n                    logger.throwing(className, \"StatsWriter.<init>\", e);\n                }\n            }\n\n            dumpInterval = runInfo.runtimeStatsInterval * 1000;\n            // Make millis so we do not\n            // have to re-calculate.\n\n            start();\n        }\n\n        /**\n         * @see java.lang.Thread#run()\n         */\n        @Override\n\t\tpublic void run() {\n\n            long baseTime = System.currentTimeMillis();\n\n            // Loop, sleeping for dumpInterval and then dump stats\n            while (! endFlag) {\n                baseTime += dumpInterval;\n                for (;;) {\n\t\t\t\t\ttry {\n                        // Adjust for time spent in other ops.\n                        long sleepTime = baseTime -\n                                System.currentTimeMillis();\n\n                        // Only sleep the remaining time.\n                        if (sleepTime > 0) {\n\t\t\t\t\t\t\tThread.sleep(sleepTime);\n\t\t\t\t\t\t}\n\n                        // Break loop when sleep complete\n                        // or no time left to sleep.\n                        break;\n                    } catch (InterruptedException ie) {\n                        // If interrupted, just loop\n                        // back and sleep the remaining time.\n                    }\n\t\t\t\t}\n\n                try {\n                    // The time range for the next output is between\n                    // elapsed and newElapsed.\n                    int newElapsed = elapsed + dumpSecs;\n                    for (int driverId = 0; driverId < driverTypes; driverId++) {\n\n                        // runtimeStatsTarget for that driver will be null if\n                        // a. The numAgents for the driver is 0 or less\n                        // b. The runtimeStatsTarget property for the driver is null\n                        if (plotServers[driverId] == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n                        currentResults[driverId] = new Metrics[\n                                runInfo.driverConfigs[driverId].numAgents];\n                        for (int i = 0; i < agentRefs[driverId].length; i++) {\n\t\t\t\t\t\t\tcurrentResults[driverId][i] = (Metrics)\n                                    (agentRefs[driverId][i].\n                                    getResults());\n\t\t\t\t\t\t}\n                        dumpStats(driverId, currentResults[driverId]);\n                    }\n                    elapsed = newElapsed;\n                } catch (RemoteException re) {\n                    logger.warning(\"Master: RemoteException got \" + re);\n                    logger.throwing(className, \"run\", re);\n                }\n            }\n        }\n\n        void quit() {\n            if (started) {\n                logger.info(\"Quitting StatsWriter...\");\n                endFlag = true;\n            }\n        }\n\n        /**\n         * This method is called by the Master every time it wants to dump\n         * the thruput data out to files\n         * @param driverId The driver id to dump the stats\n         * @param agentStats The stats to dump\n         */\n        void dumpStats(int driverId, Metrics[] agentStats) {\n            double[] plotData = new double[2];\n            // plotData[0] is the ops/sec\n            // plotData[1] is the avg ops/sec\n\n            int txCnt = 0;\n            int rampUp = runInfo.rampUp; // The rampup in secs\n\n            // Get the aggregate tx\n            for (int i = 0; i < agentStats.length; i++) {\n\t\t\t\tfor (int j = 0; j < agentStats[i].txCntStdy.length; j++) {\n\t\t\t\t\ttxCnt += agentStats[i].txCntStdy[j];\n\t\t\t\t}\n\t\t\t}\n\n            // The immediate tps;\n            plotData[0] = (double) (txCnt - prevTxCnt[driverId]) / dumpSecs;\n\n            // Calculate the new average tps\n            if (elapsed > rampUp) {\n\t\t\t\tplotData[1] = (double)txCnt / (elapsed - rampUp);\n\t\t\t}\n\n            try {\n                plotServers[driverId].plot(plotData);\n            } catch (IOException e) {\n                logger.throwing(className, \"dumpStats\", e);\n                // The plot server implicitly manages connections and\n                // removes dropped connections. We don't have to worry here.\n                // Just log what happened is enough.\n            }\n\n            // Adjust the values to reflect new values.\n            prevTxCnt[driverId] = txCnt;\n            avgTps[driverId] = plotData[1];\n        }\n    }\n\n    /**\n     * Obtain the master's time for time adjustment.\n     *\n     * @return The current time on the master\n     */\n    public long currentTimeMillis() {\n        return System.currentTimeMillis();\n    }\n\n    protected void changeState(MasterState newState) {\n        synchronized (stateLock) {\n            state = newState;\n            stateLock.notifyAll();\n        }\n    }\n\n\n    /**\n     * Obtains the current state of the master.\n     * @return The current state of the master.\n     */\n    public MasterState getCurrentState() {\n        /*\n         * State is an int and changed by int assignment which is atomic.\n         * So we will get one or the other state, but not something in between.\n         * synchronization is not necessary.\n         */\n        return state;\n    }\n\n    /**\n     * Wait for a certain state on the master.\n     * @param state\n     */\n    public void waitForState(MasterState state) {\n        synchronized (stateLock) {\n            while (state.compareTo(this.state) > 0) {\n\t\t\t\ttry {\n                    stateLock.wait();\n                } catch (InterruptedException e) {\n                    logger.log(Level.FINE, \"Interrupted waiting for state!\",\n                               e);\n                }\n\t\t\t}\n        }\n    }\n\n    /**\n     * Over-estimate the time it takes to ping all agents.\n     * @return A time in ms more than enough to ping all agents\n     */\n    int estimateCommsTime() {\n        int agentCount = 0;\n        for (Agent[] agentRef : agentRefs) {\n\t\t\tif (agentRef != null) {\n\t\t\t\tagentCount += agentRef.length;\n\t\t\t}\n\t\t}\n\n        // Given 100ms per agent (more than enough), Calculate the total time.\n        int time = 100 * agentCount;\n\n        // Minimum of 2 secs.\n        if (time < 2000) {\n\t\t\ttime = 2000;\n\t\t}\n\n        return time;\n    }\n\n    /**\n     * Waits for all threads in all agents to start.\n     */\n    public void waitForThreadStart() {\n        if (agentRefs != null) {\n\t\t\tfor (int i = 0; i < agentRefs.length && !runAborted; i++) {\n\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\ttry {\n                            agentRefs[i][j].waitForThreadStart();\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE,\n                                    \"Error checking thread starts.\", e);\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    /**\n     * Sets the benchmark start time after all threads are started.\n     * @param relTime The ms time from the run epoch\n     */\n    public void setStartTime(int relTime) {\n        runInfo.benchStartTime = relTime;\n        runInfo.start = timer.toAbsMillis(relTime);\n        if (agentRefs != null) {\n\t\t\tfor (int i = 0; i < agentRefs.length && !runAborted; i++) {\n\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\ttry {\n                            agentRefs[i][j].setStartTime(relTime);\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE,\n                                    \"Error checking thread starts.\", e);\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    /**\n     * Notifies the master to terminate the run immediately.\n     * This usually happens if there is a fatal error in the run.\n     */\n    public synchronized void abortRun() {\n\n        if (runAborted) { // We only need to schedule the killAll once.\n\t\t\treturn;\n\t\t}\n\n        runAborted = true;\n        changeState(MasterState.ABORTED);\n\n        // Note: This is a remote call. We cannot terminate the\n        // run right here. We need to schedule the termintation\n        // asynchronously.\n        TimerTask killAll = new TimerTask() {\n\n\t\t\tpublic void run() {\n                if (agentRefs != null) {\n                    for (int i = 0; i < agentRefs.length; i++) {\n\t\t\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\t\t\ttry {\n                                    agentRefs[i][j].kill();\n                                } catch (RemoteException e) {\n                                    logger.log(Level.SEVERE,\n                                            \"Error calling kill on agent.\", e);\n                                }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                    for (int i = 0; i < agentRefs.length; i++) {\n\t\t\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\t\t\ttry {\n                                    agentRefs[i][j].join();\n                                } catch (RemoteException e) {\n                                    logger.log(Level.SEVERE,\n                                            \"Error calling join on agent.\", e);\n                                }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n                logger.severe(\"Run aborted. Master terminating!\");\n                System.exit(1);\n            }\n        };\n        scheduler.schedule(killAll, 1000);\n    }\n\n\n    /**\n     * The main method to start the master. No arguments\n     * are required. The -noexit argument will cause the master\n     * to wait. The only actual expectation is the benchmark.properties\n     * property pointing to the properties file.\n     * @param args The command line arguments are ignored.\n     */\n    public static void main(String[] args) {\n\n        // Check whether -noexit is set.\n        boolean normalExit = true;\n        for (String arg : args) {\n            if (\"-noexit\".equals(arg)) {\n                normalExit = false;\n                break;\n            }\n        }\n        MasterImpl m = null;\n        try {\n            m = new MasterImpl();\n        } catch  (RemoteException e) {\n            // We have no master so we have no logger, create a new one\n            // for logging this message.\n            Logger logger = Logger.getLogger(Master.class.getName());\n            logger.log(Level.SEVERE, \"Cannot initialize remote object, \" +\n                    \"stubs may not be generated properly.\", e);\n            System.exit(1);\n        }\n        try {\n            m.runBenchmark();\n            if (normalExit) {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n        } catch (Throwable t) {\n            m.logger.log(Level.SEVERE, \"Master terminated with errors.\", t);\n            System.exit(1);\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: MasterImpl.java,v 1.2 2009/02/25 19:41:29 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.engine;\n\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.driver.ConfigurationException;\nimport com.sun.faban.driver.FatalException;\nimport com.sun.faban.driver.RunControl;\nimport com.sun.faban.driver.util.PlotServer;\nimport com.sun.faban.driver.util.Timer;\n\nimport java.io.*;\nimport java.rmi.ConnectException;\nimport java.rmi.NotBoundException;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.TimerTask;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.logging.FileHandler;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.logging.SimpleFormatter;\n\n/**\n * This is the main Master class for running a Faban driver.\n * The Master is instantiated on the <b>master machine<\/b> by the\n * user wishing to run a benchmark. It is responsible for co-ordinating\n * the work of all the Agents, setting up the benchmark test,\n * collecting the results etc.\n * NOTE: The registry and agents must have been brought up before\n * starting the driver. The driver will fail otherwise.\n *\n * @see        com.sun.faban.driver.engine.Agent\n * @see        com.sun.faban.common.Registry\n *\n */\npublic class MasterImpl extends UnicastRemoteObject implements Master {\n\n    /**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\n\t// This field is a legal requirement and serves no other purpose.\n    static final String COPYRIGHT =\n            \"Copyright \\251 2006 Sun Microsystems, Inc., 4150 Network Circle, \" +\n            \"Santa Clara, California 95054, U.S.A. All rights reserved.\\n\" +\n            \"U.S. Government Rights - Commercial software.  Government users \" +\n            \"are subject to the Sun Microsystems, Inc. standard license \" +\n            \"agreement and applicable provisions of the FAR and its \" +\n            \"supplements.\\n\" +\n            \"Use is subject to license terms.\\n\" +\n            \"This distribution may include materials developed by third \" +\n            \"parties.\\n\" +\n            \"Sun,  Sun Microsystems,  the Sun logo and  Java are trademarks \" +\n            \"or registered trademarks of Sun Microsystems, Inc. in the U.S. \" +\n            \"and other countries.\\n\" +\n            \"Apache is a trademark of The Apache Software Foundation, and is \" +\n            \"used with permission.\\n\" +\n            \"This product is covered and controlled by U.S. Export Control \" +\n            \"laws and may be subject to the export or import laws in other \" +\n            \"countries.  Nuclear, missile, chemical biological weapons or \" +\n            \"nuclear maritime end uses or end users, whether direct or \" +\n            \"indirect, are strictly prohibited.  Export or reexport to \" +\n            \"countries subject to U.S. embargo or to entities identified on \" +\n            \"U.S. export exclusion lists, including, but not limited to, the \" +\n            \"denied persons and specially designated nationals lists is \" +\n            \"strictly prohibited.\\n\" +\n            \"\\n\" +\n            \"Copyright \\251 2006 Sun Microsystems, Inc., 4150 Network Circle, \" +\n            \"Santa Clara, California 95054, Etats-Unis. Tous droits \" +\n            \"r\\351serv\\351s.\\n\" +\n            \"L'utilisation est soumise aux termes de la Licence.\\n\" +\n            \"Cette distribution peut comprendre des composants \" +\n            \"d\\351velopp\\351s par des tierces parties.\\n\" +\n            \"Sun,  Sun Microsystems,  le logo Sun et  Java sont des marques \" +\n            \"de fabrique ou des marques d\\351pos\\351es de \" +\n            \"Sun Microsystems, Inc. aux Etats-Unis et dans d'autres pays.\\n\" +\n            \"Apache est une marque d\\264Apache Software Foundation, utilis\\351e \" +\n            \"avec leur permission.\\n\" +\n            \"Ce produit est soumis \\340 la l\\351gislation am\\351ricaine \" +\n            \"en mati\\350re de contr\\364le des exportations et peut \\352tre \" +\n            \"soumis \\340 la r\\350glementation en vigueur dans d'autres pays \" +\n            \"dans le domaine des exportations et importations. Les \" +\n            \"utilisations, ou utilisateurs finaux, pour des armes \" +\n            \"nucl\\351aires, des missiles, des armes biologiques et chimiques \" +\n            \"ou du nucl\\351aire maritime, directement ou indirectement, sont \" +\n            \"strictement interdites. Les exportations ou r\\351exportations \" +\n            \"vers les pays sous embargo am\\351ricain, ou vers des entit\\351s \" +\n            \"figurant sur les listes d'exclusion d'exportation \" +\n            \"am\\351ricaines, y compris, mais de mani\\350re non exhaustive, \" +\n            \"la liste de personnes qui font objet d'un ordre de ne pas \" +\n            \"participer, d'une fa\\347on directe ou indirecte, aux \" +\n            \"exportations des produits ou des services qui sont r\\351gis par \" +\n            \"la l\\351gislation am\\351ricaine en mati\\350re de contr\\364le \" +\n            \"des exportations et la liste de ressortissants sp\\351cifiquement \" +\n            \"d\\351sign\\351s, sont rigoureusement interdites.\\n\";\n\n    private String className = getClass().getName();\n    protected Logger logger = Logger.getLogger(className);\n\n    BenchmarkDefinition benchDef;\n\n    /** Remote references for each agentImpl of each driver type. */\n    protected Agent[][] agentRefs;\n    // Note: first dimension is the driver type\n\n    /** Threads required per agentImpl for each driver. */\n    protected int[] agentThreads;\n\n    /** Remaining threads to be distributed to the first agents. */\n    protected int[] remainderThreads;\n\n    /** The RunInfo structure */\n    protected RunInfo runInfo;\n\n    protected Timer timer; // The time recorder.\n\n    protected static String fs = System.getProperty(\"file.separator\");\n\n    private boolean runAborted = false;\n\n    protected Object stateLock = new Object();\n    protected MasterState state = MasterState.CONFIGURING;\n\n    protected java.util.Timer scheduler;\n\n    /**\n     * Creates and exports a new Master\n     *\n     * @throws java.rmi.RemoteException if failed to export object\n     */\n    protected MasterImpl() throws RemoteException {\n        super();\n\n        try {\n            RegistryLocator.getRegistry().reregister(\"Master\", this);\n        } catch (ConnectException e) {\n            // A ConnectException should be interpreted as no registry.\n        } catch (NotBoundException e) {\n            // Here too, do nothing. If we run in single process mode,\n            // the registry is just not there.\n        }\n    }\n\n    /**\n     * Runs the benchmark from begin to end.\n     * @throws Exception Any error that had occurred during the run.\n     */\n    public void runBenchmark() throws Exception {\n\n        // Read the benchmark definition from the defining class\n        benchDef = BenchmarkDefinition.read(RunInfo.getDefiningClassName());\n\n        // Get the runInfo\n        runInfo = RunInfo.read(benchDef);\n\n        // When run form the harness, the outputdir may be the runId.\n        // In that case the faban.outputdir.unique property must be set to true.\n        boolean uniqueDir = false;\n        String uniqueDirString = System.getProperty(\"faban.outputdir.unique\");\n        if (uniqueDirString != null) {\n\t\t\tuniqueDir = RunInfo.ConfigurationReader.\n                    relaxedParseBoolean(uniqueDirString);\n\t\t}\n\n        if (uniqueDir) {\n            // Ensure separator is not at end.\n            if (runInfo.resultsDir.endsWith(fs)) {\n\t\t\t\trunInfo.resultsDir = runInfo.resultsDir.substring(0,\n                        runInfo.resultsDir.length() - fs.length());\n\t\t\t}\n\n            // Then take the innermost directory name.\n            int idx = runInfo.resultsDir.lastIndexOf(fs);\n            ++idx;\n            runInfo.runId = runInfo.resultsDir.substring(idx);\n        } else {\n            // Gets the ID for this run from the sequence file.\n            try {\n                runInfo.runId = getRunID(true);\n            } catch (Exception e) {\n                logger.severe(\"Cannot read the run id\");\n                logger.throwing(className, \"<init>\", e);\n                throw e;\n            }\n        }\n        logger.info(\"RunID for this run is : \" + runInfo.runId);\n\n        String runOutputDir = runInfo.resultsDir;\n        if (!uniqueDir) {\n\t\t\trunOutputDir = runInfo.resultsDir + fs + runInfo.runId;\n\t\t}\n\n        // make a new directory for the run.\n        File runDirFile = null;\n        runDirFile = new File(runOutputDir);\n        if ( !runDirFile.exists()) {\n\t\t\tif ( !runDirFile.mkdirs()) {\n\t\t\t\tthrow new IOException(\"Could not create the new \" +\n                        \"Run Directory: \" + runOutputDir);\n\t\t\t}\n\t\t}\n\n        logger.info(\"Output directory for this run is : \" + runOutputDir);\n        runInfo.resultsDir = runOutputDir;\n\n        configureLogger (runOutputDir);\n\n        timer = new Timer();\n\n        agentRefs = new Agent[benchDef.drivers.length][];\n        agentThreads = new int[benchDef.drivers.length];\n        remainderThreads = new int[benchDef.drivers.length];\n\n        scheduler = new java.util.Timer(\"Scheduler\", false);\n        try {\n            int agentCnt = configure();\n            if (agentCnt > 0) {\n                for (int i = 0; i < benchDef.drivers.length && !runAborted; i++) {\n\t\t\t\t\tconfigureAgents(i);\n\t\t\t\t}\n                logger.config(\"Detected \" + agentCnt + \" Remote Agents.\");\n            } else {\n                configureLocal();\n            }\n        } catch (ConnectException e) {\n            configureLocal();\n        } catch (NotBoundException e) {\n            configureLocal();\n        } catch (RemoteException e) {\n            Throwable t = e.getCause();\n            Throwable tt;\n            while ((tt = t.getCause()) != null) {\n\t\t\t\tt = tt;\n\t\t\t}\n            logger.log(Level.WARNING,\n                    \"Error acccessing registry or agent!\", t);\n            configureLocal();\n        }\n        changeState(MasterState.STARTING);\n        executeRun();\n    }\n\n    /**\n     * This method retrieves the ID for the current run, by looking\n     * in the specappplatform.seq file in the user's home directory.\n     * If the increment flag is set to true, the runId is incremented.\n     * Also the file will be created if it does not exist. This shall\n     * be done only maximum once in a run. Non-incrementing getRunID\n     * may be called more than once from many processes.\n     *\n     * @param increment Whether the file shall be incremented or not\n     * @return runId\n     * @throws IOException \n     */\n    public String getRunID(boolean increment) throws IOException{\n        int runID = -1;\n\n        String seqDir = System.getProperty(\"faban.sequence.path\");\n        if (seqDir == null) {\n\t\t\tseqDir = System.getProperty(\"user.home\");\n\t\t}\n\n        String seqFileName = System.getProperty(\"faban.sequence.file\");\n        if (seqFileName == null)\n            seqFileName = benchDef.name.toLowerCase() + \".seq\";\n        seqFileName = seqDir + fs + seqFileName;\n        File seqFile = new File(seqFileName);\n        if (seqFile.exists()) {\n            FileReader bufIn = null;\n            char[] buffer = new char[64];\n            int length = 0;\n            try {\n                bufIn = new FileReader(seqFile);\n            }\n            catch (FileNotFoundException e) {\n                logger.log(Level.SEVERE, \"The sequence file '\" + seqFile +\n                        \"' does not exist.\", e);\n                throw e;\n            }\n            try {\n                length = bufIn.read(buffer);\n                bufIn.close();\n            }\n            catch (IOException e) {\n                logger.log(Level.SEVERE, \"Could not read/close the sequence \" +\n                        \"file \" + seqFileName + '.', e);\n                throw e;\n            }\n            if (length > 0) {\n                // Strip off the newlines\n                if (buffer[length - 1] == '\\n') {\n\t\t\t\t\t--length;\n\t\t\t\t}\n                if (buffer[length - 1] == '\\r') {\n\t\t\t\t\t--length;\n\t\t\t\t}\n                runID = Integer.parseInt(new String(buffer, 0, length));\n            }\n        }\n        if (runID == -1) {\n            if (increment) {\n\t\t\t\ttry {\n                    seqFile.createNewFile();\n                }\n                catch (IOException e) {\n                    logger.log(Level.SEVERE, \"Could not create the sequence \" +\n                            \"file \" + seqFileName + '.', e);\n                    throw e;\n                }\n\t\t\t}\n            runID = 1;\n        }\n        // Update the runid in the sequence file\n        if (increment) {\n\t\t\ttry {\n                FileWriter fileOut = new FileWriter(seqFileName);\n                fileOut.write(Integer.toString(runID + 1));\n                fileOut.close();\n            }\n            catch (IOException e) {\n                logger.log(Level.SEVERE, \"Could not write to the sequence file \"\n                        + seqFileName + '.', e);\n                throw e;\n            }\n\t\t}\n        return Integer.toString(runID);\n    }\n\n    private void configureLogger(String dir) {\n\n        logger = Logger.getLogger(\"com.sun.faban.driver\");\n        FileHandler handler = null;\n        try {\n            handler = new FileHandler(dir + fs + \"driver.log\", true);\n        } catch (IOException e) {\n            logger.severe(e.getMessage());\n            System.exit(1);\n        }\n\n        handler.setFormatter(new SimpleFormatter());\n        handler.setLevel(Level.FINEST);\n        logger.addHandler(handler);\n        runInfo.logHandler = handler;\n    }\n\n    /**\n     * Contacts the registry and gets references for all agents.\n     * Then calculates the load distribution to each agentImpl.\n     * @return The total number of agents configured\n     */\n    protected int configure() throws Exception {\n\n        Registry registry = RegistryLocator.getRegistry();\n\n        int totalAgentCnt = 0;\n\n        // Get all agents for all drivers\n        for (int i = 0; i < benchDef.drivers.length && !runAborted; i++) {\n            // Only for drivers to run...\n            if (runInfo.driverConfigs[i].numAgents != 0) {\n\n                // Get all the agentImpl refs\n                String agentName = benchDef.drivers[i].name + \"Agent\";\n                Remote[] refs = registry.getServices(agentName);\n                int agentCnt = 0;\n\n                // Usually, the agents should have been started\n                // according to the given number. But just in case\n                // some of them did not get started or there might\n                // be some others sneaking in...\n                if (refs == null || (agentCnt = refs.length) == 0) {\n                    // Hmmm, for some reason the agents didn't get started\n                    if (runInfo.driverConfigs[i].numAgents > 0) {\n                        logger.warning(\"Cannot find \" + agentName + \"s. Not \" +\n                                \"starting \" + benchDef.drivers[i].name + '.');\n\t\t\t\t\t}\n                    runInfo.driverConfigs[i].numAgents = 0;\n                    continue;\n                }\n\n                if (agentCnt != runInfo.driverConfigs[i].numAgents) {\n                    if (runInfo.driverConfigs[i].numAgents > 0) {\n                        logger.warning(\"Configured \" + runInfo.driverConfigs[i].\n                                numAgents + ' ' + benchDef.drivers[i].name +\n                                \"Agents but found \" + agentCnt + '.');\n                        if (agentCnt > runInfo.driverConfigs[i].numAgents) {\n\t\t\t\t\t\t\tlogger.warning(\"Some unkown agents managed to \" +\n                                    \"sneak in! We'll use'em!\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlogger.warning(\"Some agents surely didn't get \" +\n                                   \"started. We'll just use the ones we have.\");\n\t\t\t\t\t\t}\n                    }\n\n                    // Now we need to adjust the runInfo according to realty\n                    runInfo.driverConfigs[i].numAgents = agentCnt;\n                }\n\n                // Now assign the agent refs to the global agent array.\n                agentRefs[i] = new Agent[agentCnt];\n                for (int j = 0; j < agentCnt; j++) {\n\t\t\t\t\tagentRefs[i][j] = (Agent) refs[j];\n\t\t\t\t}\n\n                // We need to calculate the thread counts\n                if (runInfo.driverConfigs[i].numThreads == -1) {\n\t\t\t\t\trunInfo.driverConfigs[i].numThreads = runInfo.scale *\n                            benchDef.drivers[i].threadPerScale;\n\t\t\t\t}\n                agentThreads[i] = runInfo.driverConfigs[i].numThreads /\n                        runInfo.driverConfigs[i].numAgents;\n                remainderThreads[i] = runInfo.driverConfigs[i].numThreads -\n                        agentThreads[i] * runInfo.driverConfigs[i].numAgents;\n\n                totalAgentCnt += agentCnt;\n            }\n        }\n        return totalAgentCnt;\n    }\n\n    protected void configureLocal() throws Exception {\n        int driverToRun = -1;\n        if (runInfo.driverConfigs.length > 1) {\n            for (int i = 0; i < runInfo.driverConfigs.length; i++) {\n\t\t\t\tif (runInfo.driverConfigs[i].numAgents == 1) {\n                    if (driverToRun == -1) {\n                        driverToRun = i;\n                    } else {\n                        String msg = \"Can only configure 1 agentImpl for \" +\n                                \"local runs.\\nDetected \" + benchDef.\n                                drivers[driverToRun].name + \" and \" +\n                                benchDef.drivers[i].name + \" set to run.\";\n                        throw new ConfigurationException(msg);\n                    }\n                } else if (runInfo.driverConfigs[i].numAgents > 1) {\n                    String msg = \"Can only configure 1 agentImpl for local \" +\n                            \"runs.\\n\" + benchDef.drivers[i].name + \" is set to \" +\n                            runInfo.driverConfigs[i].numAgents + \" agents.\";\n                    throw new ConfigurationException(msg);\n                }\n\t\t\t}\n        } else {\n            driverToRun = 0;\n            runInfo.driverConfigs[0].numAgents = 1;\n        }\n\n        if (driverToRun < 0) {\n\t\t\tthrow new ConfigurationException(\"No driver configured to run.\");\n\t\t}\n\n        logger.config(\"Starting single, in-process \" +\n                      benchDef.drivers[driverToRun].name + \"Agent.\");\n\n        // We need to calculate the thread counts\n        if (runInfo.driverConfigs[driverToRun].numThreads == -1) {\n\t\t\trunInfo.driverConfigs[driverToRun].numThreads = runInfo.\n                    scale * benchDef.drivers[driverToRun].threadPerScale;\n\t\t}\n        agentThreads[driverToRun] =\n                runInfo.driverConfigs[driverToRun].numThreads;\n\n        RunInfo.AgentInfo agentInfo = new RunInfo.AgentInfo();\n        runInfo.agentInfo = agentInfo;\n\n        runInfo.driverConfig = runInfo.driverConfigs[driverToRun];\n        agentRefs[driverToRun] = new Agent[1];\n        agentRefs[driverToRun][0] =\n                new AgentImpl(runInfo.driverConfig.name, \"0\");\n\n        runInfo.agentInfo.agentNumber = 0;\n\n        agentInfo.threads = this.agentThreads[driverToRun];\n        agentInfo.agentScale = runInfo.scale;\n        agentRefs[driverToRun][0].configure(this, runInfo,\n                driverToRun, timer);\n    }\n\n    /**\n     * configureAgents()\n     * Get a list of all the registered agents and parseProperties them\n     */\n    private void configureAgents(int driverType) throws Exception {\n\n        int agentCnt = runInfo.driverConfigs[driverType].numAgents;\n        if (agentCnt > 0) {\n            RunInfo.AgentInfo agentInfo = new RunInfo.AgentInfo();\n            runInfo.agentInfo = agentInfo;\n            logger.config(\"num\" + benchDef.drivers[driverType].name +\n                        \"Agents = \" + agentCnt);\n\n            agentInfo.threads = agentThreads[driverType];\n            agentInfo.agentScale = (double) runInfo.scale/agentCnt;\n            Remote[] refs = agentRefs[driverType];\n            logger.info(\"Configuring \" + refs.length + ' ' +\n                        benchDef.drivers[driverType].name + \"Agents...\");\n\n            runInfo.driverConfig = runInfo.driverConfigs[driverType];\n            int agentId = 0;\n\n            // If there are remaining threads left, distribute each to\n            // the first agents. Ditto for scale\n            if (remainderThreads[driverType] > 0) {\n                agentInfo.threads = agentThreads[driverType] + 1;\n                agentInfo.agentScale = (double) runInfo.scale *\n                        runInfo.driverConfigs[driverType].numThreads /\n                        agentInfo.threads;\n\n                for (; agentId < remainderThreads[driverType]; agentId++) {\n                    runInfo.agentInfo.agentNumber = agentId;\n                    ((Agent)refs[agentId]).configure(this, runInfo,\n                                                     driverType, timer);\n                    runInfo.agentInfo.startThreadNumber += agentInfo.threads;\n                }\n            }\n\n            // Now deal with the non-remainders...\n            agentInfo.threads = agentThreads[driverType];\n            agentInfo.agentScale = (double) runInfo.scale *\n                    runInfo.driverConfigs[driverType].numThreads /\n                    agentInfo.threads;\n\n            for (; agentId < refs.length && !runAborted; agentId++) {\n                runInfo.agentInfo.agentNumber = agentId;\n                ((Agent)refs[agentId]).configure(this, runInfo, driverType, timer);\n                runInfo.agentInfo.startThreadNumber += agentInfo.threads;\n            }\n        }\n        runInfo.driverConfig = null;\n        runInfo.agentInfo = null; // reset it so we don't use it anywhere else\n    }\n\n    /**\n     * Tell the agents to start the run execution\n     * Note that the Agent's run method call is non-blocking\n     * i.e the Master does not wait for an Agent. Instead, we\n     * wait for the total length of the run, after we signal\n     * all the agents to start.\n     */\n    private void executeRun() throws Exception {\n        StatsWriter sw = null;\n\n        // Now wait for all threads to start if it is parallel.\n        if (runInfo.parallelAgentThreadStart) {\n\t\t\twaitForThreadStart();\n\t\t}\n\n        // Leave plenty of time to notify all agents of the start time.\n        setStartTime(estimateCommsTime() + timer.getTime());\n\n        int sleepTime = runInfo.benchStartTime - timer.getTime();\n        if (sleepTime <= 0) {\n            String msg = \"Threads are not done initializing by start time.\\n\" +\n                    \"Possibly too high latency between agents.\";\n            logger.severe(msg);\n            throw new ConfigurationException(msg);\n        }\n\n        if (runAborted) { // If aborted during thread start, we discontinue.\n            try {\n                Thread.sleep(10000); // But wait for some cleanup before we do\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n            throw new FatalException(\"Run Aborted.\");\n        }\n\n        logger.info(\"Started all threads; run commences in \" + sleepTime +\n                \" ms\");\n        try {\n            Thread.sleep(sleepTime);\n        } catch (InterruptedException ie) {\n        \tlogger.log(Level.FINE, ie.getMessage(), ie);\n        }\n        // At this time each agent will start the run automatically.\n\n        // Start thread to dump stats for charting\n        sw = new StatsWriter();\n\n        TimerTask killAtEnd = null;\n        final AtomicBoolean joining = new AtomicBoolean(false);\n\n        // In case of time control, we can wait and log more stats. We also\n        // know when the run should terminate and can force a kill. But in\n        // case of cycle control, we can only wait.\n        if (benchDef.runControl == RunControl.TIME) {\n            changeState(MasterState.RAMPUP);\n            try {\n                Thread.sleep(runInfo.rampUp * 1000);\n            } catch (InterruptedException ie) {\n            \tlogger.log(Level.FINE, ie.getMessage(), ie);\n            }\n            changeState(MasterState.STEADYSTATE);\n            logger.info(\"Ramp up completed\");\n            try {\n                Thread.sleep(runInfo.stdyState * 1000);\n            } catch (InterruptedException ie) {\n            \tlogger.log(Level.FINE, ie.getMessage(), ie);\n            }\n            changeState(MasterState.RAMPDOWN);\n            logger.info(\"Steady state completed\");\n            try {\n                Thread.sleep(runInfo.rampDown * 1000);\n            } catch (InterruptedException ie) {\n            \tlogger.log(Level.FINE, ie.getMessage(), ie);\n            }\n            logger.info(\"Ramp down completed\");\n\n            // Schedule a forced termination 2 minutes from here where we start\n            // the wait.\n            killAtEnd = new TimerTask() {\n\n                        Thread mainThread = Thread.currentThread();\n\n\t\t\t\t\t\tpublic void run() {\n                            for (int i = 0; i < agentRefs.length; i++) {\n\t\t\t\t\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\t\t\t\t\t// Ensure we terminate the first agent last\n                                    for (int j = agentRefs[i].length - 1;\n                                         j >= 0; j--) {\n\t\t\t\t\t\t\t\t\t\ttry {\n                                            agentRefs[i][j].terminate();\n                                        } catch (RemoteException e) {\n                                            logger.log(Level.SEVERE,\n                                                    \"Error checking thread \" +\n                                                    \"starts.\", e);\n                                        }\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n                            if (joining.get()) {\n\t\t\t\t\t\t\t\tmainThread.interrupt();\n\t\t\t\t\t\t\t}\n                        }\n                    };\n            scheduler.schedule(killAtEnd, 120000);\n        } else { // For cycle mode, we never know the end of rampup, steady.\n            changeState(MasterState.STEADYSTATE);\n        }\n\n        // Now wait for all threads under all agents to terminate.\n        joining.set(true);\n\n        joinLoop:\n        for (int driverType = 0; driverType < runInfo.driverConfigs.length;\n             driverType++) {\n            if (runInfo.driverConfigs[driverType].numAgents > 0) {\n                Remote refs[] = agentRefs[driverType];\n                // Make sure we join the first agent last\n                for (int i = refs.length - 1; i >= 0; i--) {\n\t\t\t\t\ttry {\n                        ((Agent) refs[i]).join();\n                    } catch (RemoteException e) {\n                        logger.warning(\"Master: RemoteException got \" + e);\n                        logger.throwing(className, \"executeRun\", e);\n\n                        // If the RemoteException is caused by an interrupt,\n                        // we break the loop. This is because killAtEnd is in\n                        // effect.\n                        if (Thread.interrupted()) {\n\t\t\t\t\t\t\tbreak joinLoop;\n\t\t\t\t\t\t}\n                    }\n\t\t\t\t}\n            }\n        }\n        joining.set(false);\n\n        // It would be good if we do not have to execute killAtEnd. By now\n        // if it's still there in the scheduler it means all the joins work\n        // flawlessly.\n        if (killAtEnd != null) {\n\t\t\tkillAtEnd.cancel();\n\t\t}\n\n        /* Gather stats and print report */\n        changeState(MasterState.RESULTS);\n        Metrics[] results = new Metrics[runInfo.driverConfigs.length];\n        for (int driverType = 0; driverType < results.length; driverType++) {\n\t\t\tresults[driverType] = getDriverMetrics(driverType);\n\t\t}\n\n        generateReports(results);\n\n        // Tell StatsWriter to quit\n        sw.quit();\n    }\n\n    private Metrics getDriverMetrics(int driverType) {\n        Remote refs[];\n        Metrics result = null;\n        try {\n            if (runInfo.driverConfigs[driverType].numAgents > 0) {\n                Metrics[] results = new Metrics[\n                        runInfo.driverConfigs[driverType].numAgents];\n                refs = agentRefs[driverType];\n                logger.info(\"Gathering \" +\n                        benchDef.drivers[driverType].name + \"Stats ...\");\n                for (int i = 0; i < refs.length; i++) {\n\t\t\t\t\tresults[i] = (Metrics) (((Agent) refs[i]).getResults());\n\t\t\t\t}\n\n                for (int i = 0; i < results.length; i++) {\n\t\t\t\t\tif (results[i] != null) {\n\t\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\t\tresult = results[i];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.add(results[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n                // Once we have the metrics, we have to set it's start time\n                // Since this is set after all threads have started, it will\n                // be 0 in all the metrices we receive.\n                if (result != null) {\n\t\t\t\t\tresult.startTime =  runInfo.start;\n\t\t\t\t}\n            }\n        } catch (RemoteException re) {\n            logger.log(Level.WARNING, \"Master: RemoteException got \" + re, re);\n        }\n        return result;\n    }\n\n    /**\n     * Generates the summary and detail report.\n     * @param results Array of Metrics objects, one per driver type\n     * @throws IOException \n     */\n    public void generateReports(Metrics[] results) throws IOException {\n\n        CharSequence summaryContent = createSummaryReport(results);\n        if (summaryContent != null) {\n            String runOutputDir = runInfo.resultsDir + fs;\n            FileWriter summary = new FileWriter(runOutputDir + \"summary.xml\");\n            FileWriter detail = new FileWriter(runOutputDir + \"detail.xan\");\n\n            // As all stats from each agentImpl are of the same type, we can\n            // create a new instance from any instance.\n            logger.info(\"Printing Summary report...\");\n            summary.append(summaryContent);\n            summary.close();\n\n            logger.info(\"Summary finished. Now printing detail ...\");\n            detail.append(createDetailReport(results));\n            detail.close();\n\n            logger.info(\"Detail finished. Results written to \" +\n                    runInfo.resultsDir + '.');\n        }\n    }\n\n    /**\n     * Aggregates results of incompatible stats and prints the benchmark\n     * summary report header.\n     * @param results The per-driver metrics\n     * @return The report as a char sequence\n     */\n    @SuppressWarnings(\"boxing\")\n\tprivate CharSequence createSummaryReport(Metrics[] results) {\n        long startTime = Long.MAX_VALUE;\n        long endTime = 0l;\n        double metric = 0d;\n        boolean passed = true;\n\n        StringBuilder buffer = new StringBuilder(8192);\n\n        for (int i = 0; i < results.length; i++) {\n            if (results[i] == null) {\n                logger.warning(\"Unable to obtain \" + benchDef.drivers[i].name +\n                        \" results, ignoring...\");\n                continue;\n            }\n            if (results[i].startTime < startTime) {\n\t\t\t\tstartTime = results[i].startTime;\n\t\t\t}\n            long end;\n            if ((end = results[i].startTime + results[i].endTime) > endTime) {\n\t\t\t\tendTime = end;\n\t\t\t}\n            if (!results[i].printSummary(buffer, benchDef)) {\n\t\t\t\tpassed = false;\n\t\t\t}\n            metric += results[i].metric;\n        }\n\n        // If we did not get any results for any reason, there's no need to\n        // proceed. In that case startTime will still be Long.MAX_VALUE and\n        // end time will still be 0.\n        if (startTime == Long.MAX_VALUE || endTime == 0l) {\n            logger.severe(\"Unable to obtain any results\");\n            buffer = null;\n        } else {\n            StringBuilder hdrBuffer = new StringBuilder(1024);\n            String xslPath =\n                    System.getProperty(\"faban.xsl.path\", \"../../xslt/\");\n            if (!xslPath.endsWith(\"/\")) {\n                xslPath += '/';\n            }\n            hdrBuffer.append(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\");\n            hdrBuffer.append(\"<?xml-stylesheet type=\\\"text/xsl\\\" href=\\\"\").\n                    append(xslPath).append(\"summary_report.xsl\\\"?>\\n\");\n            hdrBuffer.append(\"<benchResults>\\n\");\n            hdrBuffer.append(\"    <benchSummary name=\\\"\").append(benchDef.name).\n                    append(\"\\\" version=\\\"\").append(benchDef.version).\n                    append(\"\\\">\\n\");\n            hdrBuffer.append(\"        <runId>\").append(runInfo.runId).\n                    append(\"<\/runId>\\n\");\n            hdrBuffer.append(\"        <startTime>\").append(new Date(startTime)).\n                    append(\"<\/startTime>\\n\");\n            hdrBuffer.append(\"        <endTime>\").append(new Date(endTime)).\n                    append(\"<\/endTime>\\n\");\n            Formatter formatter = new Formatter(hdrBuffer);\n            formatter.format(\"        <metric unit=\\\"%s\\\">%.03f<\/metric>\\n\",\n                    benchDef.metric, metric);\n            hdrBuffer.append(\"        <passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            hdrBuffer.append(\"    <\/benchSummary>\\n\");\n\n            buffer.insert(0, hdrBuffer);\n            buffer.append(\"<\/benchResults>\\n\");\n        }\n        return buffer;\n    }\n\n    /**\n     * Aggregates detail results into a single buffer.\n     * @param results The per-driver metrics\n     * @return The report as a char sequence\n     */\n    private CharSequence createDetailReport(Metrics[] results) {\n        StringBuilder buffer = new StringBuilder(8192);\n        buffer.append(\"Title: \").append(benchDef.name).\n                append(\" Detailed Results\\n\\n\\n\");\n        buffer.append(\"Section: Benchmark Information\\n\");\n        buffer.append(\"Name   Value\\n\");\n        buffer.append(\"-----  -------------\\n\");\n        buffer.append(\"RunId  \").append(runInfo.runId).append(\"\\n\\n\\n\");\n        for (Metrics result : results)\n            if (result != null)\n                result.printDetail(buffer);\n\n        return buffer;\n    }\n\n    private class StatsWriter extends Thread {\n\n        private int driverTypes = benchDef.drivers.length;\n\n        PlotServer[] plotServers = new PlotServer[driverTypes];\n        Metrics[][] currentResults = new Metrics[driverTypes][];\n        \n        Remote[] refs;\n        boolean started = false;\n        boolean endFlag = false;\n        long dumpInterval;\n        int dumpSecs;\n\n\n        private int prevTxCnt[] = new int[driverTypes];\n        private double avgTps[] = new double[driverTypes];\n        private int elapsed = 0;\n\n\n\n        /**\n         * Construct a {@link StatsWriter}.\n         */\n        public StatsWriter() {\n            if (!runInfo.runtimeStatsEnabled) {\n\t\t\t\treturn;\n\t\t\t}\n\n            for (int driverId = 0; driverId < driverTypes; driverId ++) {\n                if (runInfo.driverConfigs[driverId].numAgents <= 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                String dumpResource =\n                        runInfo.driverConfigs[driverId].runtimeStatsTarget;\n                if (dumpResource == null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                if (!started) {\n                    logger.info(\"Starting StatsWriter ...\");\n                    started = true;\n                }\n\n                try {\n                    plotServers[driverId] = new PlotServer(2, dumpResource);\n                } catch (IOException e) {\n                    logger.severe(e.getMessage());\n                    logger.throwing(className, \"StatsWriter.<init>\", e);\n                }\n            }\n\n            dumpInterval = runInfo.runtimeStatsInterval * 1000;\n            // Make millis so we do not\n            // have to re-calculate.\n\n            start();\n        }\n\n        /**\n         * @see java.lang.Thread#run()\n         */\n        @Override\n\t\tpublic void run() {\n\n            long baseTime = System.currentTimeMillis();\n\n            // Loop, sleeping for dumpInterval and then dump stats\n            while (! endFlag) {\n                baseTime += dumpInterval;\n                for (;;) {\n\t\t\t\t\ttry {\n                        // Adjust for time spent in other ops.\n                        long sleepTime = baseTime -\n                                System.currentTimeMillis();\n\n                        // Only sleep the remaining time.\n                        if (sleepTime > 0) {\n\t\t\t\t\t\t\tThread.sleep(sleepTime);\n\t\t\t\t\t\t}\n\n                        // Break loop when sleep complete\n                        // or no time left to sleep.\n                        break;\n                    } catch (InterruptedException ie) {\n                        // If interrupted, just loop\n                        // back and sleep the remaining time.\n                    }\n\t\t\t\t}\n\n                try {\n                    // The time range for the next output is between\n                    // elapsed and newElapsed.\n                    int newElapsed = elapsed + dumpSecs;\n                    for (int driverId = 0; driverId < driverTypes; driverId++) {\n\n                        // runtimeStatsTarget for that driver will be null if\n                        // a. The numAgents for the driver is 0 or less\n                        // b. The runtimeStatsTarget property for the driver is null\n                        if (plotServers[driverId] == null) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n                        currentResults[driverId] = new Metrics[\n                                runInfo.driverConfigs[driverId].numAgents];\n                        for (int i = 0; i < agentRefs[driverId].length; i++) {\n\t\t\t\t\t\t\tcurrentResults[driverId][i] = (Metrics)\n                                    (agentRefs[driverId][i].\n                                    getResults());\n\t\t\t\t\t\t}\n                        dumpStats(driverId, currentResults[driverId]);\n                    }\n                    elapsed = newElapsed;\n                } catch (RemoteException re) {\n                    logger.warning(\"Master: RemoteException got \" + re);\n                    logger.throwing(className, \"run\", re);\n                }\n            }\n        }\n\n        void quit() {\n            if (started) {\n                logger.info(\"Quitting StatsWriter...\");\n                endFlag = true;\n            }\n        }\n\n        /**\n         * This method is called by the Master every time it wants to dump\n         * the thruput data out to files\n         * @param driverId The driver id to dump the stats\n         * @param agentStats The stats to dump\n         */\n        void dumpStats(int driverId, Metrics[] agentStats) {\n            double[] plotData = new double[2];\n            // plotData[0] is the ops/sec\n            // plotData[1] is the avg ops/sec\n\n            int txCnt = 0;\n            int rampUp = runInfo.rampUp; // The rampup in secs\n\n            // Get the aggregate tx\n            for (int i = 0; i < agentStats.length; i++) {\n\t\t\t\tfor (int j = 0; j < agentStats[i].txCntStdy.length; j++) {\n\t\t\t\t\ttxCnt += agentStats[i].txCntStdy[j];\n\t\t\t\t}\n\t\t\t}\n\n            // The immediate tps;\n            plotData[0] = (double) (txCnt - prevTxCnt[driverId]) / dumpSecs;\n\n            // Calculate the new average tps\n            if (elapsed > rampUp) {\n\t\t\t\tplotData[1] = (double)txCnt / (elapsed - rampUp);\n\t\t\t}\n\n            try {\n                plotServers[driverId].plot(plotData);\n            } catch (IOException e) {\n                logger.throwing(className, \"dumpStats\", e);\n                // The plot server implicitly manages connections and\n                // removes dropped connections. We don't have to worry here.\n                // Just log what happened is enough.\n            }\n\n            // Adjust the values to reflect new values.\n            prevTxCnt[driverId] = txCnt;\n            avgTps[driverId] = plotData[1];\n        }\n    }\n\n    /**\n     * Obtain the master's time for time adjustment.\n     *\n     * @return The current time on the master\n     */\n    public long currentTimeMillis() {\n        return System.currentTimeMillis();\n    }\n\n    protected void changeState(MasterState newState) {\n        synchronized (stateLock) {\n            state = newState;\n            stateLock.notifyAll();\n        }\n    }\n\n\n    /**\n     * Obtains the current state of the master.\n     * @return The current state of the master.\n     */\n    public MasterState getCurrentState() {\n        /*\n         * State is an int and changed by int assignment which is atomic.\n         * So we will get one or the other state, but not something in between.\n         * synchronization is not necessary.\n         */\n        return state;\n    }\n\n    /**\n     * Wait for a certain state on the master.\n     * @param state\n     */\n    public void waitForState(MasterState state) {\n        synchronized (stateLock) {\n            while (state.compareTo(this.state) > 0) {\n\t\t\t\ttry {\n                    stateLock.wait();\n                } catch (InterruptedException e) {\n                    logger.log(Level.FINE, \"Interrupted waiting for state!\",\n                               e);\n                }\n\t\t\t}\n        }\n    }\n\n    /**\n     * Over-estimate the time it takes to ping all agents.\n     * @return A time in ms more than enough to ping all agents\n     */\n    int estimateCommsTime() {\n        int agentCount = 0;\n        for (Agent[] agentRef : agentRefs) {\n\t\t\tif (agentRef != null) {\n\t\t\t\tagentCount += agentRef.length;\n\t\t\t}\n\t\t}\n\n        // Given 100ms per agent (more than enough), Calculate the total time.\n        int time = 100 * agentCount;\n\n        // Minimum of 2 secs.\n        if (time < 2000) {\n\t\t\ttime = 2000;\n\t\t}\n\n        return time;\n    }\n\n    /**\n     * Waits for all threads in all agents to start.\n     */\n    public void waitForThreadStart() {\n        if (agentRefs != null) {\n\t\t\tfor (int i = 0; i < agentRefs.length && !runAborted; i++) {\n\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\ttry {\n                            agentRefs[i][j].waitForThreadStart();\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE,\n                                    \"Error checking thread starts.\", e);\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    /**\n     * Sets the benchmark start time after all threads are started.\n     * @param relTime The ms time from the run epoch\n     */\n    public void setStartTime(int relTime) {\n        runInfo.benchStartTime = relTime;\n        runInfo.start = timer.toAbsMillis(relTime);\n        if (agentRefs != null) {\n\t\t\tfor (int i = 0; i < agentRefs.length && !runAborted; i++) {\n\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\ttry {\n                            agentRefs[i][j].setStartTime(relTime);\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE,\n                                    \"Error checking thread starts.\", e);\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    }\n\n    /**\n     * Notifies the master to terminate the run immediately.\n     * This usually happens if there is a fatal error in the run.\n     */\n    public synchronized void abortRun() {\n\n        if (runAborted) { // We only need to schedule the killAll once.\n\t\t\treturn;\n\t\t}\n\n        runAborted = true;\n        changeState(MasterState.ABORTED);\n\n        // Note: This is a remote call. We cannot terminate the\n        // run right here. We need to schedule the termintation\n        // asynchronously.\n        TimerTask killAll = new TimerTask() {\n\n\t\t\tpublic void run() {\n                if (agentRefs != null) {\n                    for (int i = 0; i < agentRefs.length; i++) {\n\t\t\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\t\t\ttry {\n                                    agentRefs[i][j].kill();\n                                } catch (RemoteException e) {\n                                    logger.log(Level.SEVERE,\n                                            \"Error calling kill on agent.\", e);\n                                }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                    for (int i = 0; i < agentRefs.length; i++) {\n\t\t\t\t\t\tif (agentRefs[i] != null) {\n\t\t\t\t\t\t\tfor (int j = 0; j < agentRefs[i].length; j++) {\n\t\t\t\t\t\t\t\ttry {\n                                    agentRefs[i][j].join();\n                                } catch (RemoteException e) {\n                                    logger.log(Level.SEVERE,\n                                            \"Error calling join on agent.\", e);\n                                }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n                }\n                logger.severe(\"Run aborted. Master terminating!\");\n                System.exit(1);\n            }\n        };\n        scheduler.schedule(killAll, 1000);\n    }\n\n\n    /**\n     * The main method to start the master. No arguments\n     * are required. The -noexit argument will cause the master\n     * to wait. The only actual expectation is the benchmark.properties\n     * property pointing to the properties file.\n     * @param args The command line arguments are ignored.\n     */\n    public static void main(String[] args) {\n\n        // Check whether -noexit is set.\n        boolean normalExit = true;\n        for (String arg : args) {\n            if (\"-noexit\".equals(arg)) {\n                normalExit = false;\n                break;\n            }\n        }\n        MasterImpl m = null;\n        try {\n            m = new MasterImpl();\n        } catch  (RemoteException e) {\n            // We have no master so we have no logger, create a new one\n            // for logging this message.\n            Logger logger = Logger.getLogger(Master.class.getName());\n            logger.log(Level.SEVERE, \"Cannot initialize remote object, \" +\n                    \"stubs may not be generated properly.\", e);\n            System.exit(1);\n        }\n        try {\n            m.runBenchmark();\n            if (normalExit) {\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n        } catch (Throwable t) {\n            m.logger.log(Level.SEVERE, \"Master terminated with errors.\", t);\n            System.exit(1);\n        }\n    }\n}\n","lineNo":759}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id: Uploader.java,v 1.6 2009/02/18 20:47:03 sheetalpatil Exp $\n*\n* Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\n\nimport com.sun.faban.harness.util.FileHelper;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.io.File;\nimport java.util.logging.Logger;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javax.servlet.ServletException;\nimport org.apache.commons.fileupload.DiskFileUpload;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * @author Sheetal Patil\n */\n\npublic class Uploader {\n  private static Logger logger = Logger.getLogger(ResultAction.class.getName());\n\n  public String checkRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            HashSet<String> duplicateSet = new HashSet<String>();\n            String host = request.getParameter(\"host\");\n            String[] runIds = request.getParameterValues(\"runId\");\n            String[] ts = request.getParameterValues(\"ts\");\n            for (int r=0; r< runIds.length ; r++){\n                String runId = runIds[r];\n                if (checkIfArchived(host+\".\"+runId)){\n                    //check for runId timestamp\n                    String reposTs =\n                          getRunIdTimestamp(host + \".\" + runId, Config.OUT_DIR);\n                    if (ts[r].equals(reposTs)) {\n                        duplicateSet.add(runId);\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n\n        private String getRunIdTimestamp(String runId,  String dir) {\n            char[] cBuf = null;\n            String[] status = new String[2];\n            int length = -1;\n            try {\n               FileReader reader = new FileReader(dir + runId + '/'\n                                                         + Config.RESULT_INFO);\n               cBuf = new char[128];\n               length = reader.read(cBuf);\n               reader.close();\n            } catch (IOException e) {\n               // Do nothing, length = -1.\n            }\n            String content = new String(cBuf, 0, length);\n            int idx = content.indexOf('\\t');\n            if (idx != -1) {\n               status[0] = content.substring(0, idx).trim();\n               status[1] = content.substring(++idx).trim();\n            } else {\n               status[0] = content.trim();\n            }\n            return status[1];\n        }\n\n        private String getNextRunId(String runId) {\n            RunId current = new RunId(runId);\n            String seq = current.getRunSeq(); // Say \"1A1\"\n            int i = 0;\n            for (; i < seq.length(); i++) {\n                if (Character.isLetter(seq.charAt(i)))\n                    break;\n            } // i now points to 'A'\n            String origSeq = seq.substring(0, i + 1); // origSeq = \"1A\"\n            String cDup = seq.substring(i + 1);       // cDup = \"1\"\n            String nDup = null;\n            if (cDup.length() == 0) {\n                nDup = \"0\";\n            } else {\n                int x = Integer.parseInt(cDup, 16);  // x = (int) 1\n                nDup = Integer.toHexString(++x).toUpperCase(); // nDup - \"2\"\n            }\n            RunId next = new RunId(current.getHostName(),\n                    current.getBenchName(), origSeq + nDup);\n            return next.toString();\n        }\n        \n        private boolean checkIfArchived(String runId) throws IOException {\n            boolean found = false;\n            File file = new File(Config.OUT_DIR + runId + '/' +\n                                                            Config.RESULT_INFO);\n            found = file.exists();\n            return found;\n        }\n\n        private void uploadTags(String runId) throws IOException, ClassNotFoundException {\n            File file = new File(Config.OUT_DIR + runId + \"/META-INF/tags\");\n            String tags = FileHelper.readContentFromFile(file);\n            TagEngine te = new TagEngine();\n            File filename = new File(Config.OUT_DIR + \"/tagenginefile\");\n            if (filename.exists()) {\n                ObjectInputStream in = new ObjectInputStream(\n                        new FileInputStream(filename));\n                te = (TagEngine) in.readObject();\n                in.close();\n            }\n            String[] tagsArray;\n            if(!tags.equals(\"\")){                \n                StringTokenizer tok = new StringTokenizer(tags,\" \");\n                tagsArray = new String[tok.countTokens()];\n                int count = tok.countTokens();\n                int i=0;\n                while(i < count){\n                    String nextT = tok.nextToken().trim();\n                    tagsArray[i] = nextT;\n                    i++;\n                }\n                te.add(runId, tagsArray);\n            }\n            ObjectOutputStream out = new ObjectOutputStream(\n                                            new FileOutputStream(filename));\n            out.writeObject(te);\n            out.close();\n        }\n\n        public String uploadRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException, ClassNotFoundException {\n            // 3. Upload the run\n            HashSet<String> duplicateSet = new HashSet<String>();\n            HashSet<String> replaceSet = new HashSet<String>();\n            String host = null;\n            String key = null;\n            boolean origin = false; // Whether the upload is to the original\n            // run requestor. If so, key is needed.\n            DiskFileUpload fu = new DiskFileUpload();\n            // No maximum size\n            fu.setSizeMax(-1);\n            // maximum size that will be stored in memory\n            fu.setSizeThreshold(4096);\n            // the location for saving data that is larger than\n            // getSizeThreshold()\n            fu.setRepositoryPath(Config.TMP_DIR);\n\n            List fileItems = null;\n            try {\n                fileItems = fu.parseRequest(request);\n            } catch (FileUploadException e) {\n                throw new ServletException(e);\n            }\n            // assume we know there are two files. The first file is a small\n            // text file, the second is unknown and is written to a file on\n            // the server\n            for (Iterator i = fileItems.iterator(); i.hasNext();) {\n                FileItem item = (FileItem) i.next();\n                String fieldName = item.getFieldName();\n                if (item.isFormField()) {\n                    if (\"host\".equals(fieldName)) {\n                        host = item.getString();\n                    } else if (\"replace\".equals(fieldName)) {\n                        replaceSet.add(item.getString());\n                    } else if (\"key\".equals(fieldName)) {\n                        key = item.getString();\n                    } else if (\"origin\".equals(fieldName)) {\n                        String value = item.getString();\n                        origin = Boolean.parseBoolean(value);\n                    }\n                    continue;\n                }\n\n                if (host == null) {\n                    logger.warning(\"Host not received on upload request!\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    break;\n                }\n\n                // The host, origin, key info must be here before we receive\n                // any file.\n                if (origin) {\n                    if (Config.daemonMode != Config.DaemonModes.POLLEE) {\n                        logger.warning(\"Origin upload requested. Not pollee!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (key == null) {\n                        logger.warning(\"Origin upload requested. No key!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (!RunRetriever.authenticate(host, key)) {\n                        logger.warning(\"Origin upload requested. \" +\n                                \"Host/key mismatch: \" +host + '/' + key + \"!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                }\n\n                if (!\"jarfile\".equals(fieldName)) // ignore\n                    continue;\n\n                String fileName = item.getName();\n\n                if (fileName == null) // We don't process files without names\n                    continue;\n\n                // Now, this name may have a path attached, dependent on the\n                // source browser. We need to cover all possible clients...\n                char[] pathSeparators = {'/', '\\\\'};\n                // Well, if there is another separator we did not account for,\n                // just add it above.\n\n                for (int j = 0; j < pathSeparators.length; j++) {\n                    int idx = fileName.lastIndexOf(pathSeparators[j]);\n                    if (idx != -1) {\n                        fileName = fileName.substring(idx + 1);\n                        break;\n                    }\n                }\n\n                // Ignore all non-jarfiles.\n                if (!fileName.toLowerCase().endsWith(\".jar\"))\n                    continue;\n                File uploadFile = new File(Config.TMP_DIR, host + '.' +\n                                                                     fileName);\n                try {\n                    item.write(uploadFile);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n                int runIdx = fileName.lastIndexOf(\".\");\n                String runName = host + '.' + fileName.substring(0, runIdx);\n                File runTmp = unjarTmp(uploadFile);\n                //Check if archived recently\n                if (checkIfArchived(runName) &&\n                       !(replaceSet.contains(fileName.substring(0, runIdx)))) {\n                    //Now check if timestamps are same\n                    //Get the timestamp of run being uploaded at this point\n                    //ts is timestamp of run being uploaded\n                    String ts = getRunIdTimestamp(runName,Config.TMP_DIR);\n                    l1: while (true) {                      \n                        //reposTs is timestamp of run being compared in the\n                        //repository\n                        String reposTs =\n                                getRunIdTimestamp(runName,Config.OUT_DIR);\n                        if (reposTs.equals(ts)){\n                            duplicateSet.add(fileName.substring(0, runIdx));\n                        }else{\n                            runName = getNextRunId(runName);\n                            if (checkIfArchived(runName))\n                                continue l1;\n                            if (recursiveCopy(runTmp, new File(Config.OUT_DIR,\n                                                                  runName))) {\n                                uploadTags(runName);\n                                uploadFile.delete();\n                                recursiveDelete(runTmp);\n                            } else {\n                                logger.warning(\"Origin upload requested. \" +\n                                                                \"Copy error!\");\n                                response.sendError(\n                                        HttpServletResponse.SC_NOT_ACCEPTABLE);\n                                break;\n                            }\n                            response.setStatus(HttpServletResponse.SC_CREATED);\n                        }\n                        break;\n                    }\n                }else{\n                    //File runTmp = unjarTmp(uploadFile);\n\n                    String runId = null;\n\n                    if (origin) {\n                        // Change origin file to know where this run came from.\n                        File metaInf = new File(runTmp, \"META-INF\");\n                        File originFile = new File(metaInf, \"origin\");\n                        if (!originFile.exists()) {\n                            logger.warning(\"Origin upload requested. \" +\n                                           \"Origin file does not exist!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file does not exist!\");\n                            break;\n                        }\n\n                        RunId origRun;\n                        try {\n                            origRun = new RunId(\n                                    readStringFromFile(originFile).trim());\n                        } catch (IndexOutOfBoundsException e) {\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file error. \" + e.getMessage());\n                            break;\n                        }\n\n                        runId = origRun.getBenchName() + '.' +\n                                                           origRun.getRunSeq();\n                        String localHost = origRun.getHostName();\n                        if (!localHost.equals(Config.FABAN_HOST)) {\n                            logger.warning(\"Origin upload requested. Origin \" +\n                            \"host\" + localHost + \" does not match this host \" +\n                                           Config.FABAN_HOST + '!');\n                            response.sendError(\n                                    HttpServletResponse.SC_FORBIDDEN);\n                            break;\n                        }\n                        writeStringToFile(runTmp.getName(), originFile);\n                    }  else {\n                        runId = runTmp.getName();\n                    }\n\n                    if (recursiveCopy(runTmp, new File(Config.OUT_DIR, runId))){\n                        uploadFile.delete();\n                        uploadTags(runId);\n                        recursiveDelete(runTmp);\n                    } else {\n                        logger.warning(\"Origin upload requested. Copy error!\");\n                        response.sendError(\n                                HttpServletResponse.SC_NOT_ACCEPTABLE);\n                        break;\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_CREATED);\n                //break;\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id: Uploader.java,v 1.7 2009/02/19 19:51:30 sheetalpatil Exp $\n*\n* Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\n\nimport com.sun.faban.harness.util.FileHelper;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.io.File;\nimport java.util.logging.Logger;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javax.servlet.ServletException;\nimport org.apache.commons.fileupload.DiskFileUpload;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * @author Sheetal Patil\n */\n\npublic class Uploader {\n  private static Logger logger = Logger.getLogger(ResultAction.class.getName());\n\n  public String checkRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            HashSet<String> duplicateSet = new HashSet<String>();\n            String host = request.getParameter(\"host\");\n            String[] runIds = request.getParameterValues(\"runId\");\n            String[] ts = request.getParameterValues(\"ts\");\n            for (int r=0; r< runIds.length ; r++){\n                String runId = runIds[r];\n                if (checkIfArchived(host+\".\"+runId)){\n                    //check for runId timestamp\n                    String reposTs =\n                          getRunIdTimestamp(host + \".\" + runId, Config.OUT_DIR);\n                    if (ts[r].equals(reposTs)) {\n                        duplicateSet.add(runId);\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n\n        private String getRunIdTimestamp(String runId,  String dir) {\n            char[] cBuf = null;\n            String[] status = new String[2];\n            int length = -1;\n            try {\n               FileReader reader = new FileReader(dir + runId + '/'\n                                                         + Config.RESULT_INFO);\n               cBuf = new char[128];\n               length = reader.read(cBuf);\n               reader.close();\n            } catch (IOException e) {\n               // Do nothing, length = -1.\n            }\n            String content = new String(cBuf, 0, length);\n            int idx = content.indexOf('\\t');\n            if (idx != -1) {\n               status[0] = content.substring(0, idx).trim();\n               status[1] = content.substring(++idx).trim();\n            } else {\n               status[0] = content.trim();\n            }\n            return status[1];\n        }\n\n        private String getNextRunId(String runId) {\n            RunId current = new RunId(runId);\n            String seq = current.getRunSeq(); // Say \"1A1\"\n            int i = 0;\n            for (; i < seq.length(); i++) {\n                if (Character.isLetter(seq.charAt(i)))\n                    break;\n            } // i now points to 'A'\n            String origSeq = seq.substring(0, i + 1); // origSeq = \"1A\"\n            String cDup = seq.substring(i + 1);       // cDup = \"1\"\n            String nDup = null;\n            if (cDup.length() == 0) {\n                nDup = \"0\";\n            } else {\n                int x = Integer.parseInt(cDup, 16);  // x = (int) 1\n                nDup = Integer.toHexString(++x).toUpperCase(); // nDup - \"2\"\n            }\n            RunId next = new RunId(current.getHostName(),\n                    current.getBenchName(), origSeq + nDup);\n            return next.toString();\n        }\n        \n        private boolean checkIfArchived(String runId) throws IOException {\n            boolean found = false;\n            File file = new File(Config.OUT_DIR + runId + '/' +\n                                                            Config.RESULT_INFO);\n            found = file.exists();\n            return found;\n        }\n\n        private void uploadTags(String runId) throws IOException, ClassNotFoundException {\n            File file = new File(Config.OUT_DIR + runId + \"/META-INF/tags\");\n            String tags = FileHelper.readContentFromFile(file);\n            TagEngine te = TagEngine.getInstance();\n            String[] tagsArray;\n            if(!tags.equals(\"\")){                \n                StringTokenizer tok = new StringTokenizer(tags,\" \");\n                tagsArray = new String[tok.countTokens()];\n                int count = tok.countTokens();\n                int i=0;\n                while(i < count){\n                    String nextT = tok.nextToken().trim();\n                    tagsArray[i] = nextT;\n                    i++;\n                }\n                te.add(runId, tagsArray);\n            }\n            te.save();\n        }\n\n        public String uploadRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException, ClassNotFoundException {\n            // 3. Upload the run\n            HashSet<String> duplicateSet = new HashSet<String>();\n            HashSet<String> replaceSet = new HashSet<String>();\n            String host = null;\n            String key = null;\n            boolean origin = false; // Whether the upload is to the original\n            // run requestor. If so, key is needed.\n            DiskFileUpload fu = new DiskFileUpload();\n            // No maximum size\n            fu.setSizeMax(-1);\n            // maximum size that will be stored in memory\n            fu.setSizeThreshold(4096);\n            // the location for saving data that is larger than\n            // getSizeThreshold()\n            fu.setRepositoryPath(Config.TMP_DIR);\n\n            List fileItems = null;\n            try {\n                fileItems = fu.parseRequest(request);\n            } catch (FileUploadException e) {\n                throw new ServletException(e);\n            }\n            // assume we know there are two files. The first file is a small\n            // text file, the second is unknown and is written to a file on\n            // the server\n            for (Iterator i = fileItems.iterator(); i.hasNext();) {\n                FileItem item = (FileItem) i.next();\n                String fieldName = item.getFieldName();\n                if (item.isFormField()) {\n                    if (\"host\".equals(fieldName)) {\n                        host = item.getString();\n                    } else if (\"replace\".equals(fieldName)) {\n                        replaceSet.add(item.getString());\n                    } else if (\"key\".equals(fieldName)) {\n                        key = item.getString();\n                    } else if (\"origin\".equals(fieldName)) {\n                        String value = item.getString();\n                        origin = Boolean.parseBoolean(value);\n                    }\n                    continue;\n                }\n\n                if (host == null) {\n                    logger.warning(\"Host not received on upload request!\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    break;\n                }\n\n                // The host, origin, key info must be here before we receive\n                // any file.\n                if (origin) {\n                    if (Config.daemonMode != Config.DaemonModes.POLLEE) {\n                        logger.warning(\"Origin upload requested. Not pollee!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (key == null) {\n                        logger.warning(\"Origin upload requested. No key!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (!RunRetriever.authenticate(host, key)) {\n                        logger.warning(\"Origin upload requested. \" +\n                                \"Host/key mismatch: \" +host + '/' + key + \"!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                }\n\n                if (!\"jarfile\".equals(fieldName)) // ignore\n                    continue;\n\n                String fileName = item.getName();\n\n                if (fileName == null) // We don't process files without names\n                    continue;\n\n                // Now, this name may have a path attached, dependent on the\n                // source browser. We need to cover all possible clients...\n                char[] pathSeparators = {'/', '\\\\'};\n                // Well, if there is another separator we did not account for,\n                // just add it above.\n\n                for (int j = 0; j < pathSeparators.length; j++) {\n                    int idx = fileName.lastIndexOf(pathSeparators[j]);\n                    if (idx != -1) {\n                        fileName = fileName.substring(idx + 1);\n                        break;\n                    }\n                }\n\n                // Ignore all non-jarfiles.\n                if (!fileName.toLowerCase().endsWith(\".jar\"))\n                    continue;\n                File uploadFile = new File(Config.TMP_DIR, host + '.' +\n                                                                     fileName);\n                try {\n                    item.write(uploadFile);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n                int runIdx = fileName.lastIndexOf(\".\");\n                String runName = host + '.' + fileName.substring(0, runIdx);\n                File runTmp = unjarTmp(uploadFile);\n                //Check if archived recently\n                if (checkIfArchived(runName) &&\n                       !(replaceSet.contains(fileName.substring(0, runIdx)))) {\n                    //Now check if timestamps are same\n                    //Get the timestamp of run being uploaded at this point\n                    //ts is timestamp of run being uploaded\n                    String ts = getRunIdTimestamp(runName,Config.TMP_DIR);\n                    l1: while (true) {                      \n                        //reposTs is timestamp of run being compared in the\n                        //repository\n                        String reposTs =\n                                getRunIdTimestamp(runName,Config.OUT_DIR);\n                        if (reposTs.equals(ts)){\n                            duplicateSet.add(fileName.substring(0, runIdx));\n                        }else{\n                            runName = getNextRunId(runName);\n                            if (checkIfArchived(runName))\n                                continue l1;\n                            File newRunNameFile = new File(Config.OUT_DIR,\n                                    runName);\n                            if (recursiveCopy(runTmp, newRunNameFile)) {\n                                newRunNameFile.setLastModified(runTmp.lastModified());\n                                uploadTags(runName);\n                                uploadFile.delete();\n                                recursiveDelete(runTmp);\n                            } else {\n                                logger.warning(\"Origin upload requested. \" +\n                                                                \"Copy error!\");\n                                response.sendError(\n                                        HttpServletResponse.SC_NOT_ACCEPTABLE);\n                                break;\n                            }\n                            response.setStatus(HttpServletResponse.SC_CREATED);\n                        }\n                        break;\n                    }\n                }else{\n                    //File runTmp = unjarTmp(uploadFile);\n\n                    String runId = null;\n\n                    if (origin) {\n                        // Change origin file to know where this run came from.\n                        File metaInf = new File(runTmp, \"META-INF\");\n                        File originFile = new File(metaInf, \"origin\");\n                        if (!originFile.exists()) {\n                            logger.warning(\"Origin upload requested. \" +\n                                           \"Origin file does not exist!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file does not exist!\");\n                            break;\n                        }\n\n                        RunId origRun;\n                        try {\n                            origRun = new RunId(\n                                    readStringFromFile(originFile).trim());\n                        } catch (IndexOutOfBoundsException e) {\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file error. \" + e.getMessage());\n                            break;\n                        }\n\n                        runId = origRun.getBenchName() + '.' +\n                                                           origRun.getRunSeq();\n                        String localHost = origRun.getHostName();\n                        if (!localHost.equals(Config.FABAN_HOST)) {\n                            logger.warning(\"Origin upload requested. Origin \" +\n                            \"host\" + localHost + \" does not match this host \" +\n                                           Config.FABAN_HOST + '!');\n                            response.sendError(\n                                    HttpServletResponse.SC_FORBIDDEN);\n                            break;\n                        }\n                        writeStringToFile(runTmp.getName(), originFile);\n                    }  else {\n                        runId = runTmp.getName();\n                    }\n                    File newRunFile = new File(Config.OUT_DIR, runId);\n                    if (recursiveCopy(runTmp, newRunFile)){\n                        newRunFile.setLastModified(runTmp.lastModified());\n                        uploadFile.delete();\n                        uploadTags(runId);\n                        recursiveDelete(runTmp);\n                    } else {\n                        logger.warning(\"Origin upload requested. Copy error!\");\n                        response.sendError(\n                                HttpServletResponse.SC_NOT_ACCEPTABLE);\n                        break;\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_CREATED);\n                //break;\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n}\n","lineNo":272}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id: Uploader.java,v 1.6 2009/02/18 20:47:03 sheetalpatil Exp $\n*\n* Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\n\nimport com.sun.faban.harness.util.FileHelper;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.io.File;\nimport java.util.logging.Logger;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javax.servlet.ServletException;\nimport org.apache.commons.fileupload.DiskFileUpload;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * @author Sheetal Patil\n */\n\npublic class Uploader {\n  private static Logger logger = Logger.getLogger(ResultAction.class.getName());\n\n  public String checkRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            HashSet<String> duplicateSet = new HashSet<String>();\n            String host = request.getParameter(\"host\");\n            String[] runIds = request.getParameterValues(\"runId\");\n            String[] ts = request.getParameterValues(\"ts\");\n            for (int r=0; r< runIds.length ; r++){\n                String runId = runIds[r];\n                if (checkIfArchived(host+\".\"+runId)){\n                    //check for runId timestamp\n                    String reposTs =\n                          getRunIdTimestamp(host + \".\" + runId, Config.OUT_DIR);\n                    if (ts[r].equals(reposTs)) {\n                        duplicateSet.add(runId);\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n\n        private String getRunIdTimestamp(String runId,  String dir) {\n            char[] cBuf = null;\n            String[] status = new String[2];\n            int length = -1;\n            try {\n               FileReader reader = new FileReader(dir + runId + '/'\n                                                         + Config.RESULT_INFO);\n               cBuf = new char[128];\n               length = reader.read(cBuf);\n               reader.close();\n            } catch (IOException e) {\n               // Do nothing, length = -1.\n            }\n            String content = new String(cBuf, 0, length);\n            int idx = content.indexOf('\\t');\n            if (idx != -1) {\n               status[0] = content.substring(0, idx).trim();\n               status[1] = content.substring(++idx).trim();\n            } else {\n               status[0] = content.trim();\n            }\n            return status[1];\n        }\n\n        private String getNextRunId(String runId) {\n            RunId current = new RunId(runId);\n            String seq = current.getRunSeq(); // Say \"1A1\"\n            int i = 0;\n            for (; i < seq.length(); i++) {\n                if (Character.isLetter(seq.charAt(i)))\n                    break;\n            } // i now points to 'A'\n            String origSeq = seq.substring(0, i + 1); // origSeq = \"1A\"\n            String cDup = seq.substring(i + 1);       // cDup = \"1\"\n            String nDup = null;\n            if (cDup.length() == 0) {\n                nDup = \"0\";\n            } else {\n                int x = Integer.parseInt(cDup, 16);  // x = (int) 1\n                nDup = Integer.toHexString(++x).toUpperCase(); // nDup - \"2\"\n            }\n            RunId next = new RunId(current.getHostName(),\n                    current.getBenchName(), origSeq + nDup);\n            return next.toString();\n        }\n        \n        private boolean checkIfArchived(String runId) throws IOException {\n            boolean found = false;\n            File file = new File(Config.OUT_DIR + runId + '/' +\n                                                            Config.RESULT_INFO);\n            found = file.exists();\n            return found;\n        }\n\n        private void uploadTags(String runId) throws IOException, ClassNotFoundException {\n            File file = new File(Config.OUT_DIR + runId + \"/META-INF/tags\");\n            String tags = FileHelper.readContentFromFile(file);\n            TagEngine te = new TagEngine();\n            File filename = new File(Config.OUT_DIR + \"/tagenginefile\");\n            if (filename.exists()) {\n                ObjectInputStream in = new ObjectInputStream(\n                        new FileInputStream(filename));\n                te = (TagEngine) in.readObject();\n                in.close();\n            }\n            String[] tagsArray;\n            if(!tags.equals(\"\")){                \n                StringTokenizer tok = new StringTokenizer(tags,\" \");\n                tagsArray = new String[tok.countTokens()];\n                int count = tok.countTokens();\n                int i=0;\n                while(i < count){\n                    String nextT = tok.nextToken().trim();\n                    tagsArray[i] = nextT;\n                    i++;\n                }\n                te.add(runId, tagsArray);\n            }\n            ObjectOutputStream out = new ObjectOutputStream(\n                                            new FileOutputStream(filename));\n            out.writeObject(te);\n            out.close();\n        }\n\n        public String uploadRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException, ClassNotFoundException {\n            // 3. Upload the run\n            HashSet<String> duplicateSet = new HashSet<String>();\n            HashSet<String> replaceSet = new HashSet<String>();\n            String host = null;\n            String key = null;\n            boolean origin = false; // Whether the upload is to the original\n            // run requestor. If so, key is needed.\n            DiskFileUpload fu = new DiskFileUpload();\n            // No maximum size\n            fu.setSizeMax(-1);\n            // maximum size that will be stored in memory\n            fu.setSizeThreshold(4096);\n            // the location for saving data that is larger than\n            // getSizeThreshold()\n            fu.setRepositoryPath(Config.TMP_DIR);\n\n            List fileItems = null;\n            try {\n                fileItems = fu.parseRequest(request);\n            } catch (FileUploadException e) {\n                throw new ServletException(e);\n            }\n            // assume we know there are two files. The first file is a small\n            // text file, the second is unknown and is written to a file on\n            // the server\n            for (Iterator i = fileItems.iterator(); i.hasNext();) {\n                FileItem item = (FileItem) i.next();\n                String fieldName = item.getFieldName();\n                if (item.isFormField()) {\n                    if (\"host\".equals(fieldName)) {\n                        host = item.getString();\n                    } else if (\"replace\".equals(fieldName)) {\n                        replaceSet.add(item.getString());\n                    } else if (\"key\".equals(fieldName)) {\n                        key = item.getString();\n                    } else if (\"origin\".equals(fieldName)) {\n                        String value = item.getString();\n                        origin = Boolean.parseBoolean(value);\n                    }\n                    continue;\n                }\n\n                if (host == null) {\n                    logger.warning(\"Host not received on upload request!\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    break;\n                }\n\n                // The host, origin, key info must be here before we receive\n                // any file.\n                if (origin) {\n                    if (Config.daemonMode != Config.DaemonModes.POLLEE) {\n                        logger.warning(\"Origin upload requested. Not pollee!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (key == null) {\n                        logger.warning(\"Origin upload requested. No key!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (!RunRetriever.authenticate(host, key)) {\n                        logger.warning(\"Origin upload requested. \" +\n                                \"Host/key mismatch: \" +host + '/' + key + \"!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                }\n\n                if (!\"jarfile\".equals(fieldName)) // ignore\n                    continue;\n\n                String fileName = item.getName();\n\n                if (fileName == null) // We don't process files without names\n                    continue;\n\n                // Now, this name may have a path attached, dependent on the\n                // source browser. We need to cover all possible clients...\n                char[] pathSeparators = {'/', '\\\\'};\n                // Well, if there is another separator we did not account for,\n                // just add it above.\n\n                for (int j = 0; j < pathSeparators.length; j++) {\n                    int idx = fileName.lastIndexOf(pathSeparators[j]);\n                    if (idx != -1) {\n                        fileName = fileName.substring(idx + 1);\n                        break;\n                    }\n                }\n\n                // Ignore all non-jarfiles.\n                if (!fileName.toLowerCase().endsWith(\".jar\"))\n                    continue;\n                File uploadFile = new File(Config.TMP_DIR, host + '.' +\n                                                                     fileName);\n                try {\n                    item.write(uploadFile);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n                int runIdx = fileName.lastIndexOf(\".\");\n                String runName = host + '.' + fileName.substring(0, runIdx);\n                File runTmp = unjarTmp(uploadFile);\n                //Check if archived recently\n                if (checkIfArchived(runName) &&\n                       !(replaceSet.contains(fileName.substring(0, runIdx)))) {\n                    //Now check if timestamps are same\n                    //Get the timestamp of run being uploaded at this point\n                    //ts is timestamp of run being uploaded\n                    String ts = getRunIdTimestamp(runName,Config.TMP_DIR);\n                    l1: while (true) {                      \n                        //reposTs is timestamp of run being compared in the\n                        //repository\n                        String reposTs =\n                                getRunIdTimestamp(runName,Config.OUT_DIR);\n                        if (reposTs.equals(ts)){\n                            duplicateSet.add(fileName.substring(0, runIdx));\n                        }else{\n                            runName = getNextRunId(runName);\n                            if (checkIfArchived(runName))\n                                continue l1;\n                            if (recursiveCopy(runTmp, new File(Config.OUT_DIR,\n                                                                  runName))) {\n                                uploadTags(runName);\n                                uploadFile.delete();\n                                recursiveDelete(runTmp);\n                            } else {\n                                logger.warning(\"Origin upload requested. \" +\n                                                                \"Copy error!\");\n                                response.sendError(\n                                        HttpServletResponse.SC_NOT_ACCEPTABLE);\n                                break;\n                            }\n                            response.setStatus(HttpServletResponse.SC_CREATED);\n                        }\n                        break;\n                    }\n                }else{\n                    //File runTmp = unjarTmp(uploadFile);\n\n                    String runId = null;\n\n                    if (origin) {\n                        // Change origin file to know where this run came from.\n                        File metaInf = new File(runTmp, \"META-INF\");\n                        File originFile = new File(metaInf, \"origin\");\n                        if (!originFile.exists()) {\n                            logger.warning(\"Origin upload requested. \" +\n                                           \"Origin file does not exist!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file does not exist!\");\n                            break;\n                        }\n\n                        RunId origRun;\n                        try {\n                            origRun = new RunId(\n                                    readStringFromFile(originFile).trim());\n                        } catch (IndexOutOfBoundsException e) {\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file error. \" + e.getMessage());\n                            break;\n                        }\n\n                        runId = origRun.getBenchName() + '.' +\n                                                           origRun.getRunSeq();\n                        String localHost = origRun.getHostName();\n                        if (!localHost.equals(Config.FABAN_HOST)) {\n                            logger.warning(\"Origin upload requested. Origin \" +\n                            \"host\" + localHost + \" does not match this host \" +\n                                           Config.FABAN_HOST + '!');\n                            response.sendError(\n                                    HttpServletResponse.SC_FORBIDDEN);\n                            break;\n                        }\n                        writeStringToFile(runTmp.getName(), originFile);\n                    }  else {\n                        runId = runTmp.getName();\n                    }\n\n                    if (recursiveCopy(runTmp, new File(Config.OUT_DIR, runId))){\n                        uploadFile.delete();\n                        uploadTags(runId);\n                        recursiveDelete(runTmp);\n                    } else {\n                        logger.warning(\"Origin upload requested. Copy error!\");\n                        response.sendError(\n                                HttpServletResponse.SC_NOT_ACCEPTABLE);\n                        break;\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_CREATED);\n                //break;\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id: Uploader.java,v 1.7 2009/02/19 19:51:30 sheetalpatil Exp $\n*\n* Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\n\nimport com.sun.faban.harness.util.FileHelper;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.io.File;\nimport java.util.logging.Logger;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport javax.servlet.ServletException;\nimport org.apache.commons.fileupload.DiskFileUpload;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * @author Sheetal Patil\n */\n\npublic class Uploader {\n  private static Logger logger = Logger.getLogger(ResultAction.class.getName());\n\n  public String checkRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            HashSet<String> duplicateSet = new HashSet<String>();\n            String host = request.getParameter(\"host\");\n            String[] runIds = request.getParameterValues(\"runId\");\n            String[] ts = request.getParameterValues(\"ts\");\n            for (int r=0; r< runIds.length ; r++){\n                String runId = runIds[r];\n                if (checkIfArchived(host+\".\"+runId)){\n                    //check for runId timestamp\n                    String reposTs =\n                          getRunIdTimestamp(host + \".\" + runId, Config.OUT_DIR);\n                    if (ts[r].equals(reposTs)) {\n                        duplicateSet.add(runId);\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n\n        private String getRunIdTimestamp(String runId,  String dir) {\n            char[] cBuf = null;\n            String[] status = new String[2];\n            int length = -1;\n            try {\n               FileReader reader = new FileReader(dir + runId + '/'\n                                                         + Config.RESULT_INFO);\n               cBuf = new char[128];\n               length = reader.read(cBuf);\n               reader.close();\n            } catch (IOException e) {\n               // Do nothing, length = -1.\n            }\n            String content = new String(cBuf, 0, length);\n            int idx = content.indexOf('\\t');\n            if (idx != -1) {\n               status[0] = content.substring(0, idx).trim();\n               status[1] = content.substring(++idx).trim();\n            } else {\n               status[0] = content.trim();\n            }\n            return status[1];\n        }\n\n        private String getNextRunId(String runId) {\n            RunId current = new RunId(runId);\n            String seq = current.getRunSeq(); // Say \"1A1\"\n            int i = 0;\n            for (; i < seq.length(); i++) {\n                if (Character.isLetter(seq.charAt(i)))\n                    break;\n            } // i now points to 'A'\n            String origSeq = seq.substring(0, i + 1); // origSeq = \"1A\"\n            String cDup = seq.substring(i + 1);       // cDup = \"1\"\n            String nDup = null;\n            if (cDup.length() == 0) {\n                nDup = \"0\";\n            } else {\n                int x = Integer.parseInt(cDup, 16);  // x = (int) 1\n                nDup = Integer.toHexString(++x).toUpperCase(); // nDup - \"2\"\n            }\n            RunId next = new RunId(current.getHostName(),\n                    current.getBenchName(), origSeq + nDup);\n            return next.toString();\n        }\n        \n        private boolean checkIfArchived(String runId) throws IOException {\n            boolean found = false;\n            File file = new File(Config.OUT_DIR + runId + '/' +\n                                                            Config.RESULT_INFO);\n            found = file.exists();\n            return found;\n        }\n\n        private void uploadTags(String runId) throws IOException, ClassNotFoundException {\n            File file = new File(Config.OUT_DIR + runId + \"/META-INF/tags\");\n            String tags = FileHelper.readContentFromFile(file);\n            TagEngine te = TagEngine.getInstance();\n            String[] tagsArray;\n            if(!tags.equals(\"\")){                \n                StringTokenizer tok = new StringTokenizer(tags,\" \");\n                tagsArray = new String[tok.countTokens()];\n                int count = tok.countTokens();\n                int i=0;\n                while(i < count){\n                    String nextT = tok.nextToken().trim();\n                    tagsArray[i] = nextT;\n                    i++;\n                }\n                te.add(runId, tagsArray);\n            }\n            te.save();\n        }\n\n        public String uploadRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException, ClassNotFoundException {\n            // 3. Upload the run\n            HashSet<String> duplicateSet = new HashSet<String>();\n            HashSet<String> replaceSet = new HashSet<String>();\n            String host = null;\n            String key = null;\n            boolean origin = false; // Whether the upload is to the original\n            // run requestor. If so, key is needed.\n            DiskFileUpload fu = new DiskFileUpload();\n            // No maximum size\n            fu.setSizeMax(-1);\n            // maximum size that will be stored in memory\n            fu.setSizeThreshold(4096);\n            // the location for saving data that is larger than\n            // getSizeThreshold()\n            fu.setRepositoryPath(Config.TMP_DIR);\n\n            List fileItems = null;\n            try {\n                fileItems = fu.parseRequest(request);\n            } catch (FileUploadException e) {\n                throw new ServletException(e);\n            }\n            // assume we know there are two files. The first file is a small\n            // text file, the second is unknown and is written to a file on\n            // the server\n            for (Iterator i = fileItems.iterator(); i.hasNext();) {\n                FileItem item = (FileItem) i.next();\n                String fieldName = item.getFieldName();\n                if (item.isFormField()) {\n                    if (\"host\".equals(fieldName)) {\n                        host = item.getString();\n                    } else if (\"replace\".equals(fieldName)) {\n                        replaceSet.add(item.getString());\n                    } else if (\"key\".equals(fieldName)) {\n                        key = item.getString();\n                    } else if (\"origin\".equals(fieldName)) {\n                        String value = item.getString();\n                        origin = Boolean.parseBoolean(value);\n                    }\n                    continue;\n                }\n\n                if (host == null) {\n                    logger.warning(\"Host not received on upload request!\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    break;\n                }\n\n                // The host, origin, key info must be here before we receive\n                // any file.\n                if (origin) {\n                    if (Config.daemonMode != Config.DaemonModes.POLLEE) {\n                        logger.warning(\"Origin upload requested. Not pollee!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (key == null) {\n                        logger.warning(\"Origin upload requested. No key!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (!RunRetriever.authenticate(host, key)) {\n                        logger.warning(\"Origin upload requested. \" +\n                                \"Host/key mismatch: \" +host + '/' + key + \"!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                }\n\n                if (!\"jarfile\".equals(fieldName)) // ignore\n                    continue;\n\n                String fileName = item.getName();\n\n                if (fileName == null) // We don't process files without names\n                    continue;\n\n                // Now, this name may have a path attached, dependent on the\n                // source browser. We need to cover all possible clients...\n                char[] pathSeparators = {'/', '\\\\'};\n                // Well, if there is another separator we did not account for,\n                // just add it above.\n\n                for (int j = 0; j < pathSeparators.length; j++) {\n                    int idx = fileName.lastIndexOf(pathSeparators[j]);\n                    if (idx != -1) {\n                        fileName = fileName.substring(idx + 1);\n                        break;\n                    }\n                }\n\n                // Ignore all non-jarfiles.\n                if (!fileName.toLowerCase().endsWith(\".jar\"))\n                    continue;\n                File uploadFile = new File(Config.TMP_DIR, host + '.' +\n                                                                     fileName);\n                try {\n                    item.write(uploadFile);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n                int runIdx = fileName.lastIndexOf(\".\");\n                String runName = host + '.' + fileName.substring(0, runIdx);\n                File runTmp = unjarTmp(uploadFile);\n                //Check if archived recently\n                if (checkIfArchived(runName) &&\n                       !(replaceSet.contains(fileName.substring(0, runIdx)))) {\n                    //Now check if timestamps are same\n                    //Get the timestamp of run being uploaded at this point\n                    //ts is timestamp of run being uploaded\n                    String ts = getRunIdTimestamp(runName,Config.TMP_DIR);\n                    l1: while (true) {                      \n                        //reposTs is timestamp of run being compared in the\n                        //repository\n                        String reposTs =\n                                getRunIdTimestamp(runName,Config.OUT_DIR);\n                        if (reposTs.equals(ts)){\n                            duplicateSet.add(fileName.substring(0, runIdx));\n                        }else{\n                            runName = getNextRunId(runName);\n                            if (checkIfArchived(runName))\n                                continue l1;\n                            File newRunNameFile = new File(Config.OUT_DIR,\n                                    runName);\n                            if (recursiveCopy(runTmp, newRunNameFile)) {\n                                newRunNameFile.setLastModified(runTmp.lastModified());\n                                uploadTags(runName);\n                                uploadFile.delete();\n                                recursiveDelete(runTmp);\n                            } else {\n                                logger.warning(\"Origin upload requested. \" +\n                                                                \"Copy error!\");\n                                response.sendError(\n                                        HttpServletResponse.SC_NOT_ACCEPTABLE);\n                                break;\n                            }\n                            response.setStatus(HttpServletResponse.SC_CREATED);\n                        }\n                        break;\n                    }\n                }else{\n                    //File runTmp = unjarTmp(uploadFile);\n\n                    String runId = null;\n\n                    if (origin) {\n                        // Change origin file to know where this run came from.\n                        File metaInf = new File(runTmp, \"META-INF\");\n                        File originFile = new File(metaInf, \"origin\");\n                        if (!originFile.exists()) {\n                            logger.warning(\"Origin upload requested. \" +\n                                           \"Origin file does not exist!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file does not exist!\");\n                            break;\n                        }\n\n                        RunId origRun;\n                        try {\n                            origRun = new RunId(\n                                    readStringFromFile(originFile).trim());\n                        } catch (IndexOutOfBoundsException e) {\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file error. \" + e.getMessage());\n                            break;\n                        }\n\n                        runId = origRun.getBenchName() + '.' +\n                                                           origRun.getRunSeq();\n                        String localHost = origRun.getHostName();\n                        if (!localHost.equals(Config.FABAN_HOST)) {\n                            logger.warning(\"Origin upload requested. Origin \" +\n                            \"host\" + localHost + \" does not match this host \" +\n                                           Config.FABAN_HOST + '!');\n                            response.sendError(\n                                    HttpServletResponse.SC_FORBIDDEN);\n                            break;\n                        }\n                        writeStringToFile(runTmp.getName(), originFile);\n                    }  else {\n                        runId = runTmp.getName();\n                    }\n                    File newRunFile = new File(Config.OUT_DIR, runId);\n                    if (recursiveCopy(runTmp, newRunFile)){\n                        newRunFile.setLastModified(runTmp.lastModified());\n                        uploadFile.delete();\n                        uploadTags(runId);\n                        recursiveDelete(runTmp);\n                    } else {\n                        logger.warning(\"Origin upload requested. Copy error!\");\n                        response.sendError(\n                                HttpServletResponse.SC_NOT_ACCEPTABLE);\n                        break;\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_CREATED);\n                //break;\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n}\n","lineNo":334}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id: Uploader.java,v 1.2 2008/12/09 23:59:09 sheetalpatil Exp $\n*\n* Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.io.File;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.servlet.ServletException;\nimport org.apache.commons.fileupload.DiskFileUpload;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * @author Sheetal Patil\n */\n\npublic class Uploader {\n  private static Logger logger = Logger.getLogger(ResultAction.class.getName());\n\n  public String checkRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            HashSet<String> duplicateSet = new HashSet<String>();\n            String host = request.getParameter(\"host\");\n            String[] runIds = request.getParameterValues(\"runId\");\n            String[] ts = request.getParameterValues(\"ts\");\n            for (int r=0; r< runIds.length ; r++){\n                String runId = runIds[r];\n                if (checkIfArchived(host+\".\"+runId)){\n                        //check for runId timestamp\n                        String reposTs = getRunIdTimestamp(host+\".\"+runId);\n                        if (ts[r].equals(reposTs)) {\n                            duplicateSet.add(runId);\n                        }\n                }\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n\n        private String getRunIdTimestamp(String runId) {\n            char[] cBuf = null;\n            String[] status = new String[2];\n            int length = -1;\n            try {\n               FileReader reader = new FileReader(Config.OUT_DIR + runId + '/'\n                                                         + Config.RESULT_INFO);\n               cBuf = new char[128];\n               length = reader.read(cBuf);\n               reader.close();\n            } catch (IOException e) {\n               // Do nothing, length = -1.\n            }\n            String content = new String(cBuf, 0, length);\n            int idx = content.indexOf('\\t');\n            if (idx != -1) {\n               status[0] = content.substring(0, idx).trim();\n               status[1] = content.substring(++idx).trim();\n            } else {\n               status[0] = content.trim();\n            }\n            return status[1];\n        }\n\n        private String getNextRunId(String runId) {\n            RunId current = new RunId(runId);\n            String seq = current.getRunSeq();\n            int i = 0;\n            for (; i < seq.length(); i++) {\n                if (Character.isLetter(seq.charAt(i)))\n                    break;\n            }\n            String cDup = seq.substring(i + 1);\n            String nDup = null;\n            if (cDup.length() == 0) {\n                nDup = \"0\";\n            } else {\n                int x = Integer.parseInt(cDup, 16);\n                nDup = Integer.toHexString(++x).toUpperCase();\n            }\n            RunId next = new RunId(current.getHostName(),\n                    current.getBenchName(), seq + nDup);\n            return next.toString();\n        }\n        \n        private boolean checkIfArchived(String runId) throws IOException {\n            boolean found = false;\n            File file = new File(Config.OUT_DIR + runId + '/' +\n                                                            Config.RESULT_INFO);\n            found = file.exists();\n            return found;\n        }\n\n        public String uploadRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            // 3. Upload the run\n            HashSet<String> duplicateSet = new HashSet<String>();\n            HashSet<String> replaceSet = new HashSet<String>();\n            String host = null;\n            String key = null;\n            boolean origin = false; // Whether the upload is to the original\n            // run requestor. If so, key is needed.\n            DiskFileUpload fu = new DiskFileUpload();\n            // No maximum size\n            fu.setSizeMax(-1);\n            // maximum size that will be stored in memory\n            fu.setSizeThreshold(4096);\n            // the location for saving data that is larger than getSizeThreshold()\n            fu.setRepositoryPath(Config.TMP_DIR);\n\n            List fileItems = null;\n            try {\n                fileItems = fu.parseRequest(request);\n            } catch (FileUploadException e) {\n                throw new ServletException(e);\n            }\n            // assume we know there are two files. The first file is a small\n            // text file, the second is unknown and is written to a file on\n            // the server\n            for (Iterator i = fileItems.iterator(); i.hasNext();) {\n                FileItem item = (FileItem) i.next();\n                String fieldName = item.getFieldName();\n                if (item.isFormField()) {\n                    if (\"host\".equals(fieldName)) {\n                        host = item.getString();\n                    } else if (\"replace\".equals(fieldName)) {\n                        replaceSet.add(item.getString());\n                    } else if (\"key\".equals(fieldName)) {\n                        key = item.getString();\n                    } else if (\"origin\".equals(fieldName)) {\n                        String value = item.getString();\n                        origin = Boolean.parseBoolean(value);\n                    }\n                    continue;\n                }\n\n                if (host == null) {\n                    logger.warning(\"Host not received on upload request!\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    break;\n                }\n\n                // The host, origin, key info must be here before we receive\n                // any file.\n                if (origin) {\n                    if (Config.daemonMode != Config.DaemonModes.POLLEE) {\n                        logger.warning(\"Origin upload requested. Not pollee!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (key == null) {\n                        logger.warning(\"Origin upload requested. No key!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (!RunRetriever.authenticate(host, key)) {\n                        logger.warning(\"Origin upload requested. \" +\n                                \"Host/key mismatch: \" +host + '/' + key + \"!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                }\n\n                if (!\"jarfile\".equals(fieldName)) // ignore\n                    continue;\n\n                String fileName = item.getName();\n\n                if (fileName == null) // We don't process files without names\n                    continue;\n\n                // Now, this name may have a path attached, dependent on the\n                // source browser. We need to cover all possible clients...\n                char[] pathSeparators = {'/', '\\\\'};\n                // Well, if there is another separator we did not account for,\n                // just add it above.\n\n                for (int j = 0; j < pathSeparators.length; j++) {\n                    int idx = fileName.lastIndexOf(pathSeparators[j]);\n                    if (idx != -1) {\n                        fileName = fileName.substring(idx + 1);\n                        break;\n                    }\n                }\n\n                // Ignore all non-jarfiles.\n                if (!fileName.toLowerCase().endsWith(\".jar\"))\n                    continue;\n                File uploadFile = new File(Config.TMP_DIR, host + '.' +\n                                                                     fileName);\n                try {\n                    item.write(uploadFile);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n                int runIdx = fileName.lastIndexOf(\".\");\n                String runName = host + '.' + fileName.substring(0, runIdx);\n                File runTmp = unjarTmp(uploadFile);\n                if ( checkIfArchived(runName) &&\n                       !(replaceSet.contains(fileName.substring(0, runIdx))) ) {\n                    char[] cBuf = null;\n                    int length = -1;\n                    try {\n                       FileReader reader = new FileReader(Config.TMP_DIR +\n                                           runName + '/' + Config.RESULT_INFO);\n                       cBuf = new char[128];\n                       length = reader.read(cBuf);\n                       reader.close();\n                    } catch (IOException e) {\n                       // Do nothing, length = -1.\n                    }\n                    String content = new String(cBuf, 0, length);\n                    int idx = content.indexOf('\\t');\n                    String ts = content.substring(++idx);\n                    if (ts.equals(getRunIdTimestamp(runName))){\n                        duplicateSet.add(fileName.substring(0, runIdx));\n                    }else{\n                        String runId = getNextRunId(runName);\n                        if (recursiveCopy(runTmp, new File(Config.OUT_DIR,\n                                                                      runId))) {\n                            uploadFile.delete();\n                            recursiveDelete(runTmp);\n                        } else {\n                            logger.warning(\"Origin upload requested. \" +\n                                                                \"Copy error!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE);\n                            break;\n                        }\n                        response.setStatus(HttpServletResponse.SC_CREATED);\n                    }\n                }else{\n                    //File runTmp = unjarTmp(uploadFile);\n\n                    String runId = null;\n\n                    if (origin) {\n                        // Change origin file to know where this run came from.\n                        File metaInf = new File(runTmp, \"META-INF\");\n                        File originFile = new File(metaInf, \"origin\");\n                        if (!originFile.exists()) {\n                            logger.warning(\"Origin upload requested. \" +\n                                           \"Origin file does not exist!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file does not exist!\");\n                            break;\n                        }\n\n                        RunId origRun;\n                        try {\n                            origRun = new RunId(\n                                    readStringFromFile(originFile).trim());\n                        } catch (IndexOutOfBoundsException e) {\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file error. \" + e.getMessage());\n                            break;\n                        }\n\n                        runId = origRun.getBenchName() + '.' +\n                                                            origRun.getRunSeq();\n                        String localHost = origRun.getHostName();\n                        if (!localHost.equals(Config.FABAN_HOST)) {\n                            logger.warning(\"Origin upload requested. Origin \" +\n                            \"host\" + localHost + \" does not match this host \" +\n                                           Config.FABAN_HOST + '!');\n                            response.sendError(\n                                    HttpServletResponse.SC_FORBIDDEN);\n                            break;\n                        }\n                        writeStringToFile(runTmp.getName(), originFile);\n                    }  else {\n                        runId = runTmp.getName();\n                    }\n\n                    if (recursiveCopy(runTmp, new File(Config.OUT_DIR, runId))){\n                        uploadFile.delete();\n                        recursiveDelete(runTmp);\n                    } else {\n                        logger.warning(\"Origin upload requested. Copy error!\");\n                        response.sendError(\n                                HttpServletResponse.SC_NOT_ACCEPTABLE);\n                        break;\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_CREATED);\n                //break;\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n* of the Common Development and Distribution License\n* (the License). You may not use this file except in\n* compliance with the License.\n*\n* You can obtain a copy of the License at\n* http://www.sun.com/cddl/cddl.html or\n* install_dir/legal/LICENSE\n* See the License for the specific language governing\n* permission and limitations under the License.\n*\n* When distributing Covered Code, include this CDDL\n* Header Notice in each file and include the License file\n* at install_dir/legal/LICENSE.\n* If applicable, add the following below the CDDL Header,\n* with the fields enclosed by brackets [] replaced by\n* your own identifying information:\n* \"Portions Copyrighted [year] [name of copyright owner]\"\n*\n* $Id: Uploader.java,v 1.3 2008/12/11 01:22:10 sheetalpatil Exp $\n*\n* Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n*/\npackage com.sun.faban.harness.webclient;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.common.RunId;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.*;\nimport java.io.File;\nimport java.util.logging.Logger;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport javax.servlet.ServletException;\nimport org.apache.commons.fileupload.DiskFileUpload;\nimport org.apache.commons.fileupload.FileItem;\nimport org.apache.commons.fileupload.FileUploadException;\nimport static com.sun.faban.harness.util.FileHelper.*;\n\n/**\n * @author Sheetal Patil\n */\n\npublic class Uploader {\n  private static Logger logger = Logger.getLogger(ResultAction.class.getName());\n\n  public String checkRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            HashSet<String> duplicateSet = new HashSet<String>();\n            String host = request.getParameter(\"host\");\n            String[] runIds = request.getParameterValues(\"runId\");\n            String[] ts = request.getParameterValues(\"ts\");\n            for (int r=0; r< runIds.length ; r++){\n                String runId = runIds[r];\n                if (checkIfArchived(host+\".\"+runId)){\n                    //check for runId timestamp\n                    String reposTs =\n                          getRunIdTimestamp(host + \".\" + runId, Config.OUT_DIR);\n                    if (ts[r].equals(reposTs)) {\n                        duplicateSet.add(runId);\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_OK);\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n\n        private String getRunIdTimestamp(String runId,  String dir) {\n            char[] cBuf = null;\n            String[] status = new String[2];\n            int length = -1;\n            try {\n               FileReader reader = new FileReader(dir + runId + '/'\n                                                         + Config.RESULT_INFO);\n               cBuf = new char[128];\n               length = reader.read(cBuf);\n               reader.close();\n            } catch (IOException e) {\n               // Do nothing, length = -1.\n            }\n            String content = new String(cBuf, 0, length);\n            int idx = content.indexOf('\\t');\n            if (idx != -1) {\n               status[0] = content.substring(0, idx).trim();\n               status[1] = content.substring(++idx).trim();\n            } else {\n               status[0] = content.trim();\n            }\n            return status[1];\n        }\n\n        private String getNextRunId(String runId) {\n            RunId current = new RunId(runId);\n            String seq = current.getRunSeq(); // Say \"1A1\"\n            int i = 0;\n            for (; i < seq.length(); i++) {\n                if (Character.isLetter(seq.charAt(i)))\n                    break;\n            } // i now points to 'A'\n            String origSeq = seq.substring(0, i + 1); // origSeq = \"1A\"\n            String cDup = seq.substring(i + 1);       // cDup = \"1\"\n            String nDup = null;\n            if (cDup.length() == 0) {\n                nDup = \"0\";\n            } else {\n                int x = Integer.parseInt(cDup, 16);  // x = (int) 1\n                nDup = Integer.toHexString(++x).toUpperCase(); // nDup - \"2\"\n            }\n            RunId next = new RunId(current.getHostName(),\n                    current.getBenchName(), origSeq + nDup);\n            return next.toString();\n        }\n        \n        private boolean checkIfArchived(String runId) throws IOException {\n            boolean found = false;\n            File file = new File(Config.OUT_DIR + runId + '/' +\n                                                            Config.RESULT_INFO);\n            found = file.exists();\n            return found;\n        }\n\n        public String uploadRuns(HttpServletRequest request, HttpServletResponse\n                                response) throws IOException, ServletException {\n            // 3. Upload the run\n            HashSet<String> duplicateSet = new HashSet<String>();\n            HashSet<String> replaceSet = new HashSet<String>();\n            String host = null;\n            String key = null;\n            boolean origin = false; // Whether the upload is to the original\n            // run requestor. If so, key is needed.\n            DiskFileUpload fu = new DiskFileUpload();\n            // No maximum size\n            fu.setSizeMax(-1);\n            // maximum size that will be stored in memory\n            fu.setSizeThreshold(4096);\n            // the location for saving data that is larger than\n            // getSizeThreshold()\n            fu.setRepositoryPath(Config.TMP_DIR);\n\n            List fileItems = null;\n            try {\n                fileItems = fu.parseRequest(request);\n            } catch (FileUploadException e) {\n                throw new ServletException(e);\n            }\n            // assume we know there are two files. The first file is a small\n            // text file, the second is unknown and is written to a file on\n            // the server\n            for (Iterator i = fileItems.iterator(); i.hasNext();) {\n                FileItem item = (FileItem) i.next();\n                String fieldName = item.getFieldName();\n                if (item.isFormField()) {\n                    if (\"host\".equals(fieldName)) {\n                        host = item.getString();\n                    } else if (\"replace\".equals(fieldName)) {\n                        replaceSet.add(item.getString());\n                    } else if (\"key\".equals(fieldName)) {\n                        key = item.getString();\n                    } else if (\"origin\".equals(fieldName)) {\n                        String value = item.getString();\n                        origin = Boolean.parseBoolean(value);\n                    }\n                    continue;\n                }\n\n                if (host == null) {\n                    logger.warning(\"Host not received on upload request!\");\n                    response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                    break;\n                }\n\n                // The host, origin, key info must be here before we receive\n                // any file.\n                if (origin) {\n                    if (Config.daemonMode != Config.DaemonModes.POLLEE) {\n                        logger.warning(\"Origin upload requested. Not pollee!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (key == null) {\n                        logger.warning(\"Origin upload requested. No key!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                    if (!RunRetriever.authenticate(host, key)) {\n                        logger.warning(\"Origin upload requested. \" +\n                                \"Host/key mismatch: \" +host + '/' + key + \"!\");\n                        response.sendError(HttpServletResponse.SC_FORBIDDEN);\n                        break;\n                    }\n                }\n\n                if (!\"jarfile\".equals(fieldName)) // ignore\n                    continue;\n\n                String fileName = item.getName();\n\n                if (fileName == null) // We don't process files without names\n                    continue;\n\n                // Now, this name may have a path attached, dependent on the\n                // source browser. We need to cover all possible clients...\n                char[] pathSeparators = {'/', '\\\\'};\n                // Well, if there is another separator we did not account for,\n                // just add it above.\n\n                for (int j = 0; j < pathSeparators.length; j++) {\n                    int idx = fileName.lastIndexOf(pathSeparators[j]);\n                    if (idx != -1) {\n                        fileName = fileName.substring(idx + 1);\n                        break;\n                    }\n                }\n\n                // Ignore all non-jarfiles.\n                if (!fileName.toLowerCase().endsWith(\".jar\"))\n                    continue;\n                File uploadFile = new File(Config.TMP_DIR, host + '.' +\n                                                                     fileName);\n                try {\n                    item.write(uploadFile);\n                } catch (Exception e) {\n                    throw new ServletException(e);\n                }\n                int runIdx = fileName.lastIndexOf(\".\");\n                String runName = host + '.' + fileName.substring(0, runIdx);\n                File runTmp = unjarTmp(uploadFile);\n                //Check if archived recently\n                if (checkIfArchived(runName) &&\n                       !(replaceSet.contains(fileName.substring(0, runIdx)))) {\n                    //Now check if timestamps are same\n                    //Get the timestamp of run being uploaded at this point\n                    //ts is timestamp of run being uploaded\n                    String ts = getRunIdTimestamp(runName,Config.TMP_DIR);\n                    l1: while (true) {                      \n                        //reposTs is timestamp of run being compared in the\n                        //repository\n                        String reposTs =\n                                getRunIdTimestamp(runName,Config.OUT_DIR);\n                        if (reposTs.equals(ts)){\n                            duplicateSet.add(fileName.substring(0, runIdx));\n                        }else{\n                            runName = getNextRunId(runName);\n                            if (checkIfArchived(runName))\n                                continue l1;\n                            if (recursiveCopy(runTmp, new File(Config.OUT_DIR,\n                                                                  runName))) {\n                                uploadFile.delete();\n                                recursiveDelete(runTmp);\n                            } else {\n                                logger.warning(\"Origin upload requested. \" +\n                                                                \"Copy error!\");\n                                response.sendError(\n                                        HttpServletResponse.SC_NOT_ACCEPTABLE);\n                                break;\n                            }\n                            response.setStatus(HttpServletResponse.SC_CREATED);\n                        }\n                        break;\n                    }\n                }else{\n                    //File runTmp = unjarTmp(uploadFile);\n\n                    String runId = null;\n\n                    if (origin) {\n                        // Change origin file to know where this run came from.\n                        File metaInf = new File(runTmp, \"META-INF\");\n                        File originFile = new File(metaInf, \"origin\");\n                        if (!originFile.exists()) {\n                            logger.warning(\"Origin upload requested. \" +\n                                           \"Origin file does not exist!\");\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file does not exist!\");\n                            break;\n                        }\n\n                        RunId origRun;\n                        try {\n                            origRun = new RunId(\n                                    readStringFromFile(originFile).trim());\n                        } catch (IndexOutOfBoundsException e) {\n                            response.sendError(\n                                    HttpServletResponse.SC_NOT_ACCEPTABLE,\n                                    \"Origin file error. \" + e.getMessage());\n                            break;\n                        }\n\n                        runId = origRun.getBenchName() + '.' +\n                                                           origRun.getRunSeq();\n                        String localHost = origRun.getHostName();\n                        if (!localHost.equals(Config.FABAN_HOST)) {\n                            logger.warning(\"Origin upload requested. Origin \" +\n                            \"host\" + localHost + \" does not match this host \" +\n                                           Config.FABAN_HOST + '!');\n                            response.sendError(\n                                    HttpServletResponse.SC_FORBIDDEN);\n                            break;\n                        }\n                        writeStringToFile(runTmp.getName(), originFile);\n                    }  else {\n                        runId = runTmp.getName();\n                    }\n\n                    if (recursiveCopy(runTmp, new File(Config.OUT_DIR, runId))){\n                        uploadFile.delete();\n                        recursiveDelete(runTmp);\n                    } else {\n                        logger.warning(\"Origin upload requested. Copy error!\");\n                        response.sendError(\n                                HttpServletResponse.SC_NOT_ACCEPTABLE);\n                        break;\n                    }\n                }\n                response.setStatus(HttpServletResponse.SC_CREATED);\n                //break;\n            }\n            request.setAttribute(\"duplicates\", duplicateSet);\n            return \"/duplicates.jsp\";\n        }\n}\n","lineNo":104}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Run.java,v 1.5 2006/10/25 23:04:42 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.common;\nimport java.io.*;\n\n/**\n * This is the benchmark run object. The run can either be in the\n * RunQ (before it executes) or in the output directory when and after\n * it finishes executing.\n * This class keeps track of the various files in a run.\n * An object of this class is created by the Engine and passed as a\n * a parameter to the various services and benchmark code.\n *\n * @author Ramesh Ramachandran\n */\npublic class Run implements Serializable {\n    private BenchmarkDescription benchDesc;\n    private String outdir;\t\t// output directory name for this run\n    private String runqdir;\t\t// Runq directory name for this run\n    private String runSeq;\n    private String runId;\n    private boolean inRunQ;\n\n    public Run(String runSeq, BenchmarkDescription benchDesc) {\n        this.benchDesc = benchDesc;\n        runId = benchDesc.shortName + \".\" + runSeq;\n        this.runSeq = runSeq;\n\n        runqdir = Config.RUNQ_DIR + runId + File.separator;\n        outdir = Config.OUT_DIR + runId + File.separator;\n\n        // Check if run is in RunQ\n        if((new File(runqdir)).exists())\n            inRunQ = true;\n        else\n            inRunQ = false;\n    }\n\n    /**\n     * Get the id of the run.\n     *\n     */\n    public String getRunSeq() {\n        return runSeq;\n    }\n\n    /**\n     * Get the name of this run. \n     *\n     */\n    public String getRunId() {\n        return runId;\n    }\n\n    /**\n     * Obtains the short name of the benchmark run.\n     * @return The benchmark's short name\n     */     \n    public String getBenchmarkName() {\n        return benchDesc.shortName;\n    }\n\n    /**\n     * Get name of benchmark\n     */\n    public BenchmarkDescription getBenchDesc() {\n        return benchDesc;\n    }\n\n    /**\n     * Get pathname of log for this run\n     */\n    public String getLog() {\n        return(outdir + Config.LOG_FILE);\n    }\n\n    /**\n     * Get full pathname of ParamRepository for this run\n     * This method checks in the run is in the RunQ or output\n     * directories, and returns the appropriate path.\n     */\n    public String getParamFile() {\n        if (inRunQ)\n            return(runqdir + benchDesc.configFileName);\n        else\n            return(outdir + benchDesc.configFileName);\n    }\n\n    /**\n     * Get output directory pathname\n     */\n    public String getOutDir() {\n        return outdir;\n    }\n\n    /**\n     * Updates the run status in the result info file.\n     * @param status The new run status\n     * @throws IOException If the update fails\n     */\n    public void updateStatus(String status) throws IOException {\n        // Update the resultinfo file with Status\n        File resultInfo = new File(outdir, Config.RESULT_INFO);\n        resultInfo.delete();\n        resultInfo.createNewFile();\n        FileWriter writer = new FileWriter(resultInfo);\n        writer.write(status);\n        writer.flush();\n        writer.close();\n    }\n}\n\n\n\n\n\n\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Run.java,v 1.6 2008/12/05 22:02:14 sheetalpatil Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.common;\nimport java.io.*;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * This is the benchmark run object. The run can either be in the\n * RunQ (before it executes) or in the output directory when and after\n * it finishes executing.\n * This class keeps track of the various files in a run.\n * An object of this class is created by the Engine and passed as a\n * a parameter to the various services and benchmark code.\n *\n * @author Ramesh Ramachandran\n */\npublic class Run implements Serializable {\n    private BenchmarkDescription benchDesc;\n    private String outdir;\t\t// output directory name for this run\n    private String runqdir;\t\t// Runq directory name for this run\n    private String runSeq;\n    private String runId;\n    private boolean inRunQ;\n\n    // Formatter is used to format dates with the status changes.\n    private SimpleDateFormat formatter = new SimpleDateFormat(\n                              \"EEE MMM dd HH:mm:ss z yyyy\");\n\n\n    public Run(String runSeq, BenchmarkDescription benchDesc) {\n        this.benchDesc = benchDesc;\n        runId = benchDesc.shortName + \".\" + runSeq;\n        this.runSeq = runSeq;\n\n        runqdir = Config.RUNQ_DIR + runId + File.separator;\n        outdir = Config.OUT_DIR + runId + File.separator;\n\n        // Check if run is in RunQ\n        if((new File(runqdir)).exists())\n            inRunQ = true;\n        else\n            inRunQ = false;\n    }\n\n    /**\n     * Get the id of the run.\n     *\n     */\n    public String getRunSeq() {\n        return runSeq;\n    }\n\n    /**\n     * Get the name of this run. \n     *\n     */\n    public String getRunId() {\n        return runId;\n    }\n\n    /**\n     * Obtains the short name of the benchmark run.\n     * @return The benchmark's short name\n     */     \n    public String getBenchmarkName() {\n        return benchDesc.shortName;\n    }\n\n    /**\n     * Get name of benchmark\n     */\n    public BenchmarkDescription getBenchDesc() {\n        return benchDesc;\n    }\n\n    /**\n     * Get pathname of log for this run\n     */\n    public String getLog() {\n        return(outdir + Config.LOG_FILE);\n    }\n\n    /**\n     * Get full pathname of ParamRepository for this run\n     * This method checks in the run is in the RunQ or output\n     * directories, and returns the appropriate path.\n     */\n    public String getParamFile() {\n        if (inRunQ)\n            return(runqdir + benchDesc.configFileName);\n        else\n            return(outdir + benchDesc.configFileName);\n    }\n\n    /**\n     * Get output directory pathname\n     */\n    public String getOutDir() {\n        return outdir;\n    }\n\n    /**\n     * Updates the run status in the result info file.\n     * @param status The new run status\n     * @throws IOException If the update fails\n     */\n    public void updateStatus(String status) throws IOException {\n        // Update the resultinfo file with Status\n        File resultInfo = new File(outdir, Config.RESULT_INFO);\n        resultInfo.delete();\n        resultInfo.createNewFile();\n        FileWriter writer = new FileWriter(resultInfo);\n        String content = status + '\\t' + formatter.format(new Date());\n        writer.write(content);\n        writer.flush();\n        writer.close();\n    }\n}\n\n\n\n\n\n\n","lineNo":135}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: FileHelper.java,v 1.14 2008/04/11 07:52:54 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.agent.CmdAgentImpl;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.agent.FileServiceException;\nimport com.sun.faban.harness.common.Config;\n\nimport java.io.*;\nimport java.nio.channels.FileChannel;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class FileHelper {\n    \n    private static Logger logger = Logger.getLogger(FileHelper.class.getName());\n    /**\n      * This method copies a file\n      * @param srcFile  - the full pathname of the source file\n      * @param destFile  - the full pathname of the destination file\n      * @param append - should destination file be appended with source file\n      */    \n    public static boolean copyFile(String srcFile, String destFile, boolean append) {\n        try {\n            FileChannel src = (new FileInputStream(srcFile)).getChannel();\n            FileChannel dest = (new FileOutputStream(destFile)).getChannel();\n            if (append)\n                dest.position(dest.size());\n            src.transferTo(0, src.size(), dest);\n            dest.close();\n            src.close();\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Could not copy \" + srcFile + \" to \" +\n                                     destFile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n      * This method opens, traverses through the file and \n      * finds the properties and replaces the values \n      * This updates only the first occurrence of the prop\n      * in the file to eliminate cases where it changes\n      * props defined like PROP=$PROP:MYPROP\n      * We expect only one prop per line in the file\n      * @param fileName  - the full pathname of the file\n      * @param prop - property names and their new values\n      */    \n    public static boolean editPropFile(String fileName, Properties prop, String backupFileName) {\n\n        String tmpFile = Config.TMP_DIR + \".FileHelper\";\n        //copy the file\n        if(backupFileName == null)\n            backupFileName = tmpFile;\n            \n        if(!FileHelper.copyFile(fileName, backupFileName, false))\n            return false; // Failed to backup the file\n\n        // Do not modify the passed prop as it may be used by the caller\n        // Call by reference pitfalls (:-)\n        Properties props = new Properties(prop);\n\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(backupFileName));\n            BufferedWriter out = new BufferedWriter(new FileWriter(fileName));\n            String line;\n            while((line = in.readLine()) != null) {\n                line = line.trim();\n                if((line.length() > 3) && (Character.isLetterOrDigit(line.charAt(0)))) {\n                    Enumeration e = props.propertyNames();\n                    while (e.hasMoreElements()) {\n                        String propName = (String) e.nextElement();\n                        if((line.indexOf(propName) != -1) &&\n                           (line.charAt(line.indexOf(propName) + propName.length()) == '=')) {\n                            StringBuffer sb = new StringBuffer(propName);\n                            sb.append(\"=\").append(props.getProperty(propName));\n                            line = sb.toString();\n                            // Will update only the first instance of the prop\n                            props.remove(propName);\n                            // We expect only one prop per line\n                            break;\n                        }\n                    }\n                }\n                // Write the line to file\n                out.write(line, 0, line.length());\n                out.newLine();\n            }\n            in.close();\n            out.close();           \n            \n            // Delete the temp file\n            if(tmpFile == backupFileName) \n                (new File(tmpFile)).delete();\n        }\n        catch (Exception e) {\n            logger.severe(\"Failed with \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            return false;\n        }\n        return true;\n    }       \n    \n    /**\n      * This method opens, traverses through the file and\n      * finds the token and replaces it with new value\n      * This method updates only the first occurrence of\n      * the token in the file to eliminate cases where it\n      * changes props defined like PROP=$PROP:MYPROP\n      * @param fileName  - the full pathname of the file\n      * @param token - to find\n      * @param replacement - the replacement string\n      * @param backupFileName - if needed pass a backup file name\n      */\n    public static boolean tokenReplace(String fileName, String token, String replacement, String backupFileName) {\n\n        String tmpFile = Config.TMP_DIR + \".FileHelper\";\n\n        //copy the file\n        if(backupFileName == null)\n            backupFileName = tmpFile;\n\n        if(!FileHelper.copyFile(fileName, backupFileName, false))\n            return false; // Failed to backup the file\n\n        System.out.println(\"Token : \" + token);\n        System.out.println(\"Replacement : \" + replacement);\n\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(backupFileName));\n            BufferedWriter out = new BufferedWriter(new FileWriter(fileName));\n            String line;\n            boolean replaced = false;\n            while((line = in.readLine()) != null) {\n                // replace only the first occurrence of the token\n                if((!replaced) && (line.indexOf(token) != -1)) {\n                    System.err.println(\"FileHelper.tokenReplace : replacing \" + token + \" with \" + replacement);\n                    StringBuffer sb = new StringBuffer();\n                    // to escape special chars in token\n                    for(int i = 0; i < token.length(); i++) {\n                        if(Character.isLetterOrDigit(token.charAt(i)))\n                            sb.append(token.charAt(i));\n                        else\n                            sb.append(\"\\\\\").append(token.charAt(i));\n                    }\n\n                    // to escape special chars in replacement string\n                    token = sb.toString();\n                    sb = new StringBuffer();\n                    for(int i = 0; i < replacement.length(); i++) {\n                        if(Character.isLetterOrDigit(replacement.charAt(i)))\n                            sb.append(replacement.charAt(i));\n                        else\n                            sb.append(\"\\\\\").append(replacement.charAt(i));\n                    }\n                    replacement = sb.toString();\n\n                    line = line.replaceAll(token, replacement);\n                    replaced = true;\n                }\n                // Write the line to file\n                out.write(line, 0, line.length());\n                out.newLine();\n            }\n            in.close();\n            out.close();\n\n            // Delete the temp file\n            if(tmpFile == backupFileName)\n                (new File(tmpFile)).delete();\n        }\n        catch (Exception e) {\n            logger.severe(\"Failed with \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n      * This method opens, traverses through the file and\n      * finds the token, it will avoid comments when searching\n      * @param fileName  - the full pathname of the file\n      * @param token - token to serch for\n      */\n    public static boolean isInFile(String fileName, String token) {\n        boolean found = false;\n\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(fileName));\n            String line;\n            while((line = in.readLine()) != null) {\n                // Avoid comments\n                if(line.length() > token.length() &&\n                   Character.isLetterOrDigit(line.charAt(0)) && line.indexOf(token) != -1) {\n                    found = true;\n                    break;\n                }\n            }\n            in.close();\n        }\n        catch (Exception e) {\n            logger.severe(\"Failed with \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            return false;\n        }\n        return found;\n    }\n\n    /**\n     * This  method is used to delete a directory and \n     * recursively delete files and subdirectories within it.\n     *\n     * @param file The file or directory to delete\n     */\n    public static boolean recursiveDelete(File file) {\n        // Does a post-order traversal of the directory hierarchy and deletes\n        // all the nodes in its path.\n\t\n        boolean success = true;\n \n\t    try {\n            if (file.isDirectory()) {\n                File[] list = file.listFiles();\n                for (int i = 0; i < list.length; i++)\n                    if (!recursiveDelete(list[i])) {\n                        logger.severe(\"Delete failed for file \" +\n                                file.getPath());\n                        success = false;\n                    }\n            }\n            if (!file.delete()) {\n                logger.severe(\"Delete failed for file \" + file.getPath());\n                success = false;\n            }\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Delete failed\", e);\n            success = false;\n        }\n        return success;\n    }\n\n    /**\n     * Deletes all files matched by the filter in a certain directory.\n     * @param dir The directory to look for files to delete\n     * @param filter The file name filter\n     * @return True if all deletes succeeded, false otherwise\n     */\n    public static boolean delete(File dir, FileFilter filter) {\n        boolean success = true;\n\n        try {\n            if (!dir.isDirectory())\n                return false;\n            File[] list = dir.listFiles(filter);\n            for (File file : list)\n                if (!recursiveDelete(file)) {\n                    logger.severe(\"Delete failed for file \" + file.getPath());\n                    success = false;\n                }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Delete failed\", e);\n            success = false;\n        }\n        return success;\n    }\n\n    /**\n     * This method is used to delete a directory and\n     * recursively delete files and subdirectories within it.\n     *\n     * @param parentDir : the file object corresponding to the parent directory\n     * @param name : name of the directory to be deleted\n     *\n     */\n    public static boolean recursiveDelete(File parentDir, String name) {\n        return recursiveDelete(new File(parentDir, name));\n    }\n\n    /**\n     * Copies a file from source to dest. If src is a directory, the whole\n     * directory tree is copied.\n     * @param src The source file\n     * @param dest The dest file, must not exist before calling method\n     * @return true if copy succeeded, false afterwise\n     */\n    public static boolean recursiveCopy(File src, File dest) {\n        if (src.isDirectory()) {\n            if (!dest.exists() && !dest.mkdir())\n                return false;\n            File[] files = src.listFiles();\n            for (File s : files) {\n                File d = new File(dest, s.getName());\n                if (!recursiveCopy(s, d))\n                    return false;\n            }\n        } else {\n            return copyFile(src.getAbsolutePath(), dest.getAbsolutePath(),\n                            false);\n        }\n        return true;\n    }\n\n    /**\n     * Jars up a directory to a given Jar file\n     * @param dir The base directory to jar (not included in output)\n     * @param fileNames The file names to jar, can be multiple\n     * @param jarPath The pathname of the jar file\n     * @throws IOException There is a problem jarring up\n     */\n    public static void jar(String dir, String fileNames, String jarPath)\n            throws IOException {\n\n        logger.fine(\"Jar'ring up \" + dir + \" to \" + jarPath + '.');\n\n        String jarCmd = Utilities.getJavaHome() + File.separator + \"bin\" +\n                File.separator + \"jar\";\n        Command cmd = new Command(jarCmd, \"cf\", jarPath, fileNames);\n        cmd.setWorkingDirectory(dir);\n        try {\n            CommandHandle handle = cmd.execute();\n            int exitValue = handle.exitValue();\n            if (exitValue != 0)\n                throw new IOException(\"Command \\\"jar cf\\\" has exit value \" +\n                                      exitValue);\n        } catch (InterruptedException e) {\n            logger.log(Level.SEVERE, \"Jar interrupted\", e);\n        }\n    }\n\n    /**\n     * Unjars a jar file into an output directory.\n     * @param jarPath The path to the jar file\n     * @param outputDir The output directory\n     * @throws IOException If there is an error running unjar\n     */\n    public static void unjar(String jarPath, String outputDir)\n            throws IOException {\n\n        logger.fine(\"Unjar'ring \" + jarPath + \" to \" + outputDir + '.');\n        String jarCmd = Utilities.getJavaHome() + File.separator + \"bin\" +\n                File.separator + \"jar\";\n        Command cmd = new Command(jarCmd, \"xf\", jarPath);\n        cmd.setWorkingDirectory(outputDir);\n        try {\n            CommandHandle handle = cmd.execute();\n            int exitValue = handle.exitValue();\n            if (exitValue != 0)\n                throw new IOException(\"Command \\\"jar xf\\\" has exit value \" +\n                                      exitValue);\n        } catch (InterruptedException e) {\n            logger.log(Level.SEVERE, \"Unjar interrupted\", e);\n        }\n    }\n\n    /**\n     * Unjars a temporary jar file xxxx.jar under the directory\n     * xxxx in the same path\n     * @param tmpJarFile The temporary jar file\n     * @return The file reference to the resulting directory\n     * @throws IOException If there is an error unjaring\n     */\n    public static File unjarTmp(File tmpJarFile) throws IOException {\n        logger.info(\"Preparing run from \" + tmpJarFile.getAbsolutePath() + '.');\n\n        String dirName = tmpJarFile.getName();\n        int dotPos = dirName.lastIndexOf('.');\n        dirName = dirName.substring(0, dotPos);\n        File unjarDir = new File(tmpJarFile.getParent(), dirName);\n        unjarDir.mkdir();\n\n        unjar(tmpJarFile.getAbsolutePath(), unjarDir.getAbsolutePath());\n        return unjarDir;\n    }\n\n    /**\n     * Writes a string to a file. Replaces the file if it already exists.\n     * @param string The string to be written\n     * @param file The target file\n     * @throws IOException If the write fails\n     */\n    public static void writeStringToFile(String string, File file)\n            throws IOException {\n        file.delete();\n        file.createNewFile();\n        FileOutputStream out = new FileOutputStream(file);\n        out.write(string.getBytes());\n        out.flush();\n        out.close();\n    }\n\n    /**\n     * Reads a whole file and obtains the contents as a string.\n     * @param file The file to be read\n     * @return The string representing the whole content of the file\n     * @throws IOException If the read fails\n     */\n    public static String readStringFromFile(File file) throws IOException {\n        String content = null;\n        if (file.isFile())\n            content = new String(getContent(file.getAbsolutePath()));\n        return content;\n    }\n\n\n    /**\n     * Transfers a file from the current host to the Faban master.\n     * @param inFile The input file name on the current host\n     * @param outFile The output file name on the Faban master\n     * @param move Whether to remove the original file or not\n     * @return True if the transfer is complete, false otherwise.\n     */\n    public static boolean xferFile(String inFile, String outFile, boolean move) {\n        File f = new File(inFile);\n        if(!f.exists())\n            return false ;\n\n        // Use FileAgent on master machine to copy log\n        FileAgent fa = null;\n         try {\n            String s = Config.FILE_AGENT;\n            fa = (FileAgent) CmdAgentImpl.getRegistry().getService(s);\n         } catch (Exception e) {\n            logger.severe(\"Unable to get File Service\");\n             return false;\n         }\n\n        logger.fine(\"Input File = \" + inFile + \" Output File = \"+ outFile);\n\n        try {\n            BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n            byte[] buf = new byte[8192];\n            int i = in.read(buf);\n\n            if(i > 0) {\n                FileService outfp = fa.open(outFile, FileAgent.WRITE);\n                while (i > 0) {\n                    outfp.writeBytes(buf, 0, i);\n                    i = in.read(buf);\n                }\n                outfp.close();\n            }\n            in.close();\n        } catch (FileServiceException fe) {\n            logger.severe(\"Error in creating file \" + outFile);\n            logger.log(Level.FINE, \"Exception\", fe);\n        } catch (IOException e) {\n            logger.severe(\"Error in reading file \" + inFile);\n            logger.log(Level.FINE, \"Exception\", e);\n        } catch (Exception e) {\n            logger.severe(\"Error Xfering file \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            if(move)\n                f.delete();\n        }\n        return true;\n    }\n\n    /**\n     * Obtains the whole content of a local file in a byte array.\n     * @param file The file name\n     * @return The byte content of the file\n     * @throws IOException If the file cannot be read.\n     */\n    public static byte[] getContent(String file) throws IOException {\n        return getContent(new File(file));\n    }\n\n    /**\n     * Obtains the whole content of a local file in a byte array.\n     * @param file The file name\n     * @return The byte content of the file\n     * @throws IOException If the file cannot be read.\n     */\n    public static byte[] getContent(File file) throws IOException {\n        long size = file.length();\n        if (size == 0)\n            throw new IOException(\"Cannot determine file size.\");\n        if (size >= Integer.MAX_VALUE)\n            throw new IOException(\"Cannot handle file size >= 2GB.\");\n        byte[] content = new byte[(int) size];\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            int readLength = 0;\n            while (readLength < size) {\n                int bytes = in.read(content, readLength,\n                            (int) size - readLength);\n                if (bytes == -1) // EOS\n                    break;\n                readLength += bytes;\n            }\n        } finally {\n            if (in != null)\n                in.close();\n        }\n        return content;\n    }\n\n\n    // Unit test the functionality\n    public static void main(String[] args) {\n        if (args.length < 3) {\n//            System.out.println(\"Usage: java FileHelper File Key Value\");\n            System.out.println(\"Usage: java FileHelper File token replacement\");\n            return;\n        }\n        Properties prop = new Properties();\n        prop.setProperty(args[1], args[2]);\n\n        //FileHelper.editPropFile(args[0], prop, null);\n        // FileHelper.tokenReplace(args[0], args[1], args[2], null);\n        //FileHelper.tokenReplace(System.getProperty(\"java.io.tmpdir\") +\n        //      \"/t\", \"\\\"$JAVA_HOME\\\"/bin/java\",\n        // \"profcmd= \\n\\\\$profcmd \\\"\\\\$JAVA_HOME\\\"/bin/java\", null);\n        FileHelper.tokenReplace(System.getProperty(\"java.io.tmpdir\") + \"/t\",\n                \"\\\"$JAVA_HOME\\\"/bin/java\",\n                \"profcmd= \\n$profcmd \\\"$JAVA_HOME\\\"/bin/java\", null);\n    }\n}\n/*\n// This code will replace properties which is specified anywhere in the line\n// But will messup cases where there are blanks in it.\n                        if((line.indexOf(propName)) != -1) {\n                            StringBuffer sb = new StringBuffer();\n                            StringTokenizer st = new StringTokenizer(line);\n                            while (st.hasMoreTokens()) {\n                                String tk = st.nextToken();\n                                if(tk.indexOf(propName) != -1)\n                                    sb.append(propName).append(\"=\")\n                                      .append(props.getProperty(propName)).append(\" \");\n                                else\n                                    sb.append(tk).append(\" \");\n                            }\n                            line = sb.toString();\n                        }\n\n*/\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: FileHelper.java,v 1.15 2008/12/05 22:03:32 sheetalpatil Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.harness.agent.CmdAgentImpl;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.agent.FileServiceException;\nimport com.sun.faban.harness.common.Config;\n\nimport java.io.*;\nimport java.nio.channels.FileChannel;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.Properties;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\npublic class FileHelper {\n    \n    private static Logger logger = Logger.getLogger(FileHelper.class.getName());\n    /**\n      * This method copies a file\n      * @param srcFile  - the full pathname of the source file\n      * @param destFile  - the full pathname of the destination file\n      * @param append - should destination file be appended with source file\n      */    \n    public static boolean copyFile(String srcFile, String destFile, boolean append) {\n        try {\n            FileChannel src = (new FileInputStream(srcFile)).getChannel();\n            FileChannel dest = (new FileOutputStream(destFile)).getChannel();\n            if (append)\n                dest.position(dest.size());\n            src.transferTo(0, src.size(), dest);\n            dest.close();\n            src.close();\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"Could not copy \" + srcFile + \" to \" +\n                                     destFile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n      * This method opens, traverses through the file and \n      * finds the properties and replaces the values \n      * This updates only the first occurrence of the prop\n      * in the file to eliminate cases where it changes\n      * props defined like PROP=$PROP:MYPROP\n      * We expect only one prop per line in the file\n      * @param fileName  - the full pathname of the file\n      * @param prop - property names and their new values\n      */    \n    public static boolean editPropFile(String fileName, Properties prop, String backupFileName) {\n\n        String tmpFile = Config.TMP_DIR + \".FileHelper\";\n        //copy the file\n        if(backupFileName == null)\n            backupFileName = tmpFile;\n            \n        if(!FileHelper.copyFile(fileName, backupFileName, false))\n            return false; // Failed to backup the file\n\n        // Do not modify the passed prop as it may be used by the caller\n        // Call by reference pitfalls (:-)\n        Properties props = new Properties(prop);\n\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(backupFileName));\n            BufferedWriter out = new BufferedWriter(new FileWriter(fileName));\n            String line;\n            while((line = in.readLine()) != null) {\n                line = line.trim();\n                if((line.length() > 3) && (Character.isLetterOrDigit(line.charAt(0)))) {\n                    Enumeration e = props.propertyNames();\n                    while (e.hasMoreElements()) {\n                        String propName = (String) e.nextElement();\n                        if((line.indexOf(propName) != -1) &&\n                           (line.charAt(line.indexOf(propName) + propName.length()) == '=')) {\n                            StringBuffer sb = new StringBuffer(propName);\n                            sb.append(\"=\").append(props.getProperty(propName));\n                            line = sb.toString();\n                            // Will update only the first instance of the prop\n                            props.remove(propName);\n                            // We expect only one prop per line\n                            break;\n                        }\n                    }\n                }\n                // Write the line to file\n                out.write(line, 0, line.length());\n                out.newLine();\n            }\n            in.close();\n            out.close();           \n            \n            // Delete the temp file\n            if(tmpFile == backupFileName) \n                (new File(tmpFile)).delete();\n        }\n        catch (Exception e) {\n            logger.severe(\"Failed with \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            return false;\n        }\n        return true;\n    }       \n    \n    /**\n      * This method opens, traverses through the file and\n      * finds the token and replaces it with new value\n      * This method updates only the first occurrence of\n      * the token in the file to eliminate cases where it\n      * changes props defined like PROP=$PROP:MYPROP\n      * @param fileName  - the full pathname of the file\n      * @param token - to find\n      * @param replacement - the replacement string\n      * @param backupFileName - if needed pass a backup file name\n      */\n    public static boolean tokenReplace(String fileName, String token, String replacement, String backupFileName) {\n\n        String tmpFile = Config.TMP_DIR + \".FileHelper\";\n\n        //copy the file\n        if(backupFileName == null)\n            backupFileName = tmpFile;\n\n        if(!FileHelper.copyFile(fileName, backupFileName, false))\n            return false; // Failed to backup the file\n\n        System.out.println(\"Token : \" + token);\n        System.out.println(\"Replacement : \" + replacement);\n\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(backupFileName));\n            BufferedWriter out = new BufferedWriter(new FileWriter(fileName));\n            String line;\n            boolean replaced = false;\n            while((line = in.readLine()) != null) {\n                // replace only the first occurrence of the token\n                if((!replaced) && (line.indexOf(token) != -1)) {\n                    System.err.println(\"FileHelper.tokenReplace : replacing \" + token + \" with \" + replacement);\n                    StringBuffer sb = new StringBuffer();\n                    // to escape special chars in token\n                    for(int i = 0; i < token.length(); i++) {\n                        if(Character.isLetterOrDigit(token.charAt(i)))\n                            sb.append(token.charAt(i));\n                        else\n                            sb.append(\"\\\\\").append(token.charAt(i));\n                    }\n\n                    // to escape special chars in replacement string\n                    token = sb.toString();\n                    sb = new StringBuffer();\n                    for(int i = 0; i < replacement.length(); i++) {\n                        if(Character.isLetterOrDigit(replacement.charAt(i)))\n                            sb.append(replacement.charAt(i));\n                        else\n                            sb.append(\"\\\\\").append(replacement.charAt(i));\n                    }\n                    replacement = sb.toString();\n\n                    line = line.replaceAll(token, replacement);\n                    replaced = true;\n                }\n                // Write the line to file\n                out.write(line, 0, line.length());\n                out.newLine();\n            }\n            in.close();\n            out.close();\n\n            // Delete the temp file\n            if(tmpFile == backupFileName)\n                (new File(tmpFile)).delete();\n        }\n        catch (Exception e) {\n            logger.severe(\"Failed with \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n      * This method opens, traverses through the file and\n      * finds the token, it will avoid comments when searching\n      * @param fileName  - the full pathname of the file\n      * @param token - token to serch for\n      */\n    public static boolean isInFile(String fileName, String token) {\n        boolean found = false;\n\n        try {\n            BufferedReader in = new BufferedReader(new FileReader(fileName));\n            String line;\n            while((line = in.readLine()) != null) {\n                // Avoid comments\n                if(line.length() > token.length() &&\n                   Character.isLetterOrDigit(line.charAt(0)) && line.indexOf(token) != -1) {\n                    found = true;\n                    break;\n                }\n            }\n            in.close();\n        }\n        catch (Exception e) {\n            logger.severe(\"Failed with \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            return false;\n        }\n        return found;\n    }\n\n    /**\n     * This  method is used to delete a directory and \n     * recursively delete files and subdirectories within it.\n     *\n     * @param file The file or directory to delete\n     */\n    public static boolean recursiveDelete(File file) {\n        // Does a post-order traversal of the directory hierarchy and deletes\n        // all the nodes in its path.\n\t\n        boolean success = true;\n \n\t    try {\n            if (file.isDirectory()) {\n                File[] list = file.listFiles();\n                for (int i = 0; i < list.length; i++)\n                    if (!recursiveDelete(list[i])) {\n                        logger.severe(\"Delete failed for file \" +\n                                file.getPath());\n                        success = false;\n                    }\n            }\n            if (!file.delete()) {\n                logger.severe(\"Delete failed for file \" + file.getPath());\n                success = false;\n            }\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Delete failed\", e);\n            success = false;\n        }\n        return success;\n    }\n\n    /**\n     * Deletes all files matched by the filter in a certain directory.\n     * @param dir The directory to look for files to delete\n     * @param filter The file name filter\n     * @return True if all deletes succeeded, false otherwise\n     */\n    public static boolean delete(File dir, FileFilter filter) {\n        boolean success = true;\n\n        try {\n            if (!dir.isDirectory())\n                return false;\n            File[] list = dir.listFiles(filter);\n            for (File file : list)\n                if (!recursiveDelete(file)) {\n                    logger.severe(\"Delete failed for file \" + file.getPath());\n                    success = false;\n                }\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Delete failed\", e);\n            success = false;\n        }\n        return success;\n    }\n\n    /**\n     * This method is used to delete a directory and\n     * recursively delete files and subdirectories within it.\n     *\n     * @param parentDir : the file object corresponding to the parent directory\n     * @param name : name of the directory to be deleted\n     *\n     */\n    public static boolean recursiveDelete(File parentDir, String name) {\n        return recursiveDelete(new File(parentDir, name));\n    }\n\n    /**\n     * Copies a file from source to dest. If src is a directory, the whole\n     * directory tree is copied.\n     * @param src The source file\n     * @param dest The dest file, must not exist before calling method\n     * @return true if copy succeeded, false afterwise\n     */\n    public static boolean recursiveCopy(File src, File dest) {\n        if (src.isDirectory()) {\n            if (!dest.exists() && !dest.mkdir())\n                return false;\n            File[] files = src.listFiles();\n            for (File s : files) {\n                File d = new File(dest, s.getName());\n                if (!recursiveCopy(s, d))\n                    return false;\n            }\n        } else {\n            return copyFile(src.getAbsolutePath(), dest.getAbsolutePath(),\n                            false);\n        }\n        return true;\n    }\n\n    /**\n     * Jars up a directory to a given Jar file\n     * @param dir The base directory to jar (not included in output)\n     * @param fileNames The file names to jar, can be multiple\n     * @param jarPath The pathname of the jar file\n     * @throws IOException There is a problem jarring up\n     */\n    public static void jar(String dir, String[] fileNames, String jarPath)\n            throws IOException {\n\n        logger.fine(\"Jar'ring up \" + dir + \" to \" + jarPath + '.');\n\n        ArrayList<String> cmdList = new ArrayList<String>(fileNames.length + 3);\n        String jarCmd = Utilities.getJavaHome() + File.separator + \"bin\" +\n                File.separator + \"jar\";\n        cmdList.add(jarCmd);\n        cmdList.add(\"cf\");\n        cmdList.add(jarPath);\n        for (String fileName : fileNames) {\n            cmdList.add(fileName);\n        }\n        Command cmd = new Command(cmdList);\n        cmd.setWorkingDirectory(dir);\n        try {\n            CommandHandle handle = cmd.execute();\n            int exitValue = handle.exitValue();\n            if (exitValue != 0){\n                handle.destroy();\n                //throw new IOException(\"Command \\\"jar cf\\\" has exit value \" + exitValue);\n            }\n        } catch (InterruptedException e) {\n            logger.log(Level.SEVERE, \"Jar interrupted\", e);\n        }\n    }\n\n    /**\n     * Unjars a jar file into an output directory.\n     * @param jarPath The path to the jar file\n     * @param outputDir The output directory\n     * @throws IOException If there is an error running unjar\n     */\n    public static void unjar(String jarPath, String outputDir)\n            throws IOException {\n\n        logger.fine(\"Unjar'ring \" + jarPath + \" to \" + outputDir + '.');\n        String jarCmd = Utilities.getJavaHome() + File.separator + \"bin\" +\n                File.separator + \"jar\";\n        Command cmd = new Command(jarCmd, \"xf\", jarPath);\n        cmd.setWorkingDirectory(outputDir);\n        try {\n            CommandHandle handle = cmd.execute();\n            int exitValue = handle.exitValue();\n            if (exitValue != 0)\n                throw new IOException(\"Command \\\"jar xf\\\" has exit value \" +\n                                      exitValue);\n        } catch (InterruptedException e) {\n            logger.log(Level.SEVERE, \"Unjar interrupted\", e);\n        }\n    }\n\n    /**\n     * Unjars a temporary jar file xxxx.jar under the directory\n     * xxxx in the same path\n     * @param tmpJarFile The temporary jar file\n     * @return The file reference to the resulting directory\n     * @throws IOException If there is an error unjaring\n     */\n    public static File unjarTmp(File tmpJarFile) throws IOException {\n        logger.info(\"Preparing run from \" + tmpJarFile.getAbsolutePath() + '.');\n\n        String dirName = tmpJarFile.getName();\n        int dotPos = dirName.lastIndexOf('.');\n        dirName = dirName.substring(0, dotPos);\n        File unjarDir = new File(tmpJarFile.getParent(), dirName);\n        unjarDir.mkdir();\n\n        unjar(tmpJarFile.getAbsolutePath(), unjarDir.getAbsolutePath());\n        return unjarDir;\n    }\n\n    /**\n     * Writes a string to a file. Replaces the file if it already exists.\n     * @param string The string to be written\n     * @param file The target file\n     * @throws IOException If the write fails\n     */\n    public static void writeStringToFile(String string, File file)\n            throws IOException {\n        file.delete();\n        file.createNewFile();\n        FileOutputStream out = new FileOutputStream(file);\n        out.write(string.getBytes());\n        out.flush();\n        out.close();\n    }\n\n    /**\n     * Reads a whole file and obtains the contents as a string.\n     * @param file The file to be read\n     * @return The string representing the whole content of the file\n     * @throws IOException If the read fails\n     */\n    public static String readStringFromFile(File file) throws IOException {\n        String content = null;\n        if (file.isFile())\n            content = new String(getContent(file.getAbsolutePath()));\n        return content;\n    }\n\n\n    /**\n     * Transfers a file from the current host to the Faban master.\n     * @param inFile The input file name on the current host\n     * @param outFile The output file name on the Faban master\n     * @param move Whether to remove the original file or not\n     * @return True if the transfer is complete, false otherwise.\n     */\n    public static boolean xferFile(String inFile, String outFile, boolean move) {\n        File f = new File(inFile);\n        if(!f.exists())\n            return false ;\n\n        // Use FileAgent on master machine to copy log\n        FileAgent fa = null;\n         try {\n            String s = Config.FILE_AGENT;\n            fa = (FileAgent) CmdAgentImpl.getRegistry().getService(s);\n         } catch (Exception e) {\n            logger.severe(\"Unable to get File Service\");\n             return false;\n         }\n\n        logger.fine(\"Input File = \" + inFile + \" Output File = \"+ outFile);\n\n        try {\n            BufferedInputStream in = new BufferedInputStream(new FileInputStream(f));\n            byte[] buf = new byte[8192];\n            int i = in.read(buf);\n\n            if(i > 0) {\n                FileService outfp = fa.open(outFile, FileAgent.WRITE);\n                while (i > 0) {\n                    outfp.writeBytes(buf, 0, i);\n                    i = in.read(buf);\n                }\n                outfp.close();\n            }\n            in.close();\n        } catch (FileServiceException fe) {\n            logger.severe(\"Error in creating file \" + outFile);\n            logger.log(Level.FINE, \"Exception\", fe);\n        } catch (IOException e) {\n            logger.severe(\"Error in reading file \" + inFile);\n            logger.log(Level.FINE, \"Exception\", e);\n        } catch (Exception e) {\n            logger.severe(\"Error Xfering file \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n            if(move)\n                f.delete();\n        }\n        return true;\n    }\n\n    /**\n     * Obtains the whole content of a local file in a byte array.\n     * @param file The file name\n     * @return The byte content of the file\n     * @throws IOException If the file cannot be read.\n     */\n    public static byte[] getContent(String file) throws IOException {\n        return getContent(new File(file));\n    }\n\n    /**\n     * Obtains the whole content of a local file in a byte array.\n     * @param file The file name\n     * @return The byte content of the file\n     * @throws IOException If the file cannot be read.\n     */\n    public static byte[] getContent(File file) throws IOException {\n        long size = file.length();\n        if (size == 0)\n            throw new IOException(\"Cannot determine file size.\");\n        if (size >= Integer.MAX_VALUE)\n            throw new IOException(\"Cannot handle file size >= 2GB.\");\n        byte[] content = new byte[(int) size];\n        FileInputStream in = null;\n        try {\n            in = new FileInputStream(file);\n            int readLength = 0;\n            while (readLength < size) {\n                int bytes = in.read(content, readLength,\n                            (int) size - readLength);\n                if (bytes == -1) // EOS\n                    break;\n                readLength += bytes;\n            }\n        } finally {\n            if (in != null)\n                in.close();\n        }\n        return content;\n    }\n\n\n    // Unit test the functionality\n    public static void main(String[] args) {\n        if (args.length < 3) {\n//            System.out.println(\"Usage: java FileHelper File Key Value\");\n            System.out.println(\"Usage: java FileHelper File token replacement\");\n            return;\n        }\n        Properties prop = new Properties();\n        prop.setProperty(args[1], args[2]);\n\n        //FileHelper.editPropFile(args[0], prop, null);\n        // FileHelper.tokenReplace(args[0], args[1], args[2], null);\n        //FileHelper.tokenReplace(System.getProperty(\"java.io.tmpdir\") +\n        //      \"/t\", \"\\\"$JAVA_HOME\\\"/bin/java\",\n        // \"profcmd= \\n\\\\$profcmd \\\"\\\\$JAVA_HOME\\\"/bin/java\", null);\n        FileHelper.tokenReplace(System.getProperty(\"java.io.tmpdir\") + \"/t\",\n                \"\\\"$JAVA_HOME\\\"/bin/java\",\n                \"profcmd= \\n$profcmd \\\"$JAVA_HOME\\\"/bin/java\", null);\n    }\n}\n/*\n// This code will replace properties which is specified anywhere in the line\n// But will messup cases where there are blanks in it.\n                        if((line.indexOf(propName)) != -1) {\n                            StringBuffer sb = new StringBuffer();\n                            StringTokenizer st = new StringTokenizer(line);\n                            while (st.hasMoreTokens()) {\n                                String tk = st.nextToken();\n                                if(tk.indexOf(propName) != -1)\n                                    sb.append(propName).append(\"=\")\n                                      .append(props.getProperty(propName)).append(\" \");\n                                else\n                                    sb.append(tk).append(\" \");\n                            }\n                            line = sb.toString();\n                        }\n\n*/\n","lineNo":346}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: BenchmarkDescription.java,v 1.10 2008/06/02 21:02:08 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.common;\n\nimport org.w3c.dom.Node;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.sun.faban.harness.util.DeployUtil;\n\n/**\n * This is a value class describing the benchmark.\n *\n * @author Akara Sucharitakul\n */\npublic class BenchmarkDescription implements Serializable {\n\n    /** The max time to cache a map, 10 secs. */\n    public static final int MAP_TIMEOUT = 10000;\n\n    /** The short name of the benchmark, and also the directory names. */\n    public String shortName;\n\n    /** The full name of the benchmark. This name may contain spaces. */\n    public String name;\n\n    /** The version of the benchmark. */\n    public String version;\n\n    /** The form used to configure the benchmark. */\n    public String configForm = \"config.xhtml\";\n\n    /** The stylesheet used to format the form, if any */\n    public String configStylesheet;\n\n    /** The file used for configuring the benchmark. */\n    public String configFileName = \"run.xml\";\n\n    /** The result file path relative to the output directory */\n    public String resultFilePath = \"summary.xml\";\n\n    /** The benchmark class name. */\n    public String benchmarkClass;\n\n    /** The benchmark metric. */\n    public String metric;\n\n    /** The name of the benchmark scale. */\n    public String scaleName;\n\n    /** The name of the benchmark unit. */\n    public String scaleUnit;\n\n    static final Logger logger = Logger.getLogger(\n            BenchmarkDescription.class.getName());\n    static final XPath xPath = XPathFactory.newInstance().newXPath();\n    static final ParserPool parserPool = new ParserPool();\n\n    static HashMap<String, BenchmarkDescription> benchNameMap;\n    static HashMap<String, BenchmarkDescription> benchDirMap;\n    static long mapTimeStamp = 0l;\n\n    /**\n     * Obtains a map of benchmarks using the directory (or short name)\n     * as the key.\n     * @return The directory map of currently deployed benchmarks\n     */\n    public static Map<String, BenchmarkDescription> getBenchDirMap() {\n        checkMaps(true);\n        return benchDirMap;\n    }\n\n    public static Map<String, BenchmarkDescription> getBenchDirMap(\n            boolean deploy) {\n        checkMaps(deploy);\n        return benchDirMap;\n    }\n\n    /**\n     * Obtains a map of benchmarks using the full name as the key.\n     * @return The name map of currently deployed benchmarks\n     */\n    public static HashMap<String, BenchmarkDescription> getBenchNameMap() {\n        checkMaps(true);\n        return benchNameMap;\n    }\n\n    /**\n     * Obtains the benchmark description for a certain deploy directory\n     * or short name.\n     * @param dir The deploy directory or short name of the benchmark\n     * @return The benchmark description or null of none exists\n     */\n    public static BenchmarkDescription getDescription(String dir) {\n        checkMaps(true);\n        return (BenchmarkDescription) benchDirMap.get(dir);\n    }\n\n    /**\n     * Returns the name to display on the banner. If only one benchmark\n     * is deployed, the benchmark name and version will be used for the\n     * banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The name to display on the banner page\n     */\n    public static String getBannerName() {\n        checkMaps(true);\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription) benchDirMap.values().iterator().\n                    next()).name;\n        }\n        return Config.HARNESS_NAME;\n    }\n\n    /**\n     * Returns the version number to display on the banner. If only one\n     * benchmark is deployed, the benchmark name and version will be used for\n     * the banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The version to display on the banner\n     */\n    public static String getBannerVersion() {\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription)benchDirMap.values().iterator().\n                    next()).version;\n        }\n        return Config.HARNESS_VERSION;\n    }\n\n\n\n    private static synchronized void checkMaps(boolean deploy) {\n        if (System.currentTimeMillis() - mapTimeStamp > MAP_TIMEOUT)\n            generateMaps(deploy);\n    }\n\n\n    private static void generateMaps(boolean deploy) {\n        HashMap<String, BenchmarkDescription> nameMap =\n                new HashMap<String, BenchmarkDescription>();\n        HashMap<String, BenchmarkDescription> dirMap =\n                new HashMap<String, BenchmarkDescription>();\n\n        if (deploy)\n            DeployUtil.checkDeploy();\n\n        File[] benchmarks = DeployUtil.BENCHMARKDIR.listFiles();\n        for (int i = 0; i < benchmarks.length; i++) {\n            logger.finest(\"Found benchmark directory \" + benchmarks[i]);\n            BenchmarkDescription desc = readDescription(benchmarks[i].getName(),\n                                        benchmarks[i].getAbsolutePath());\n            if (desc == null)\n                continue;\n            BenchmarkDescription otherDesc = (BenchmarkDescription)\n                                       nameMap.put(desc.name, desc);\n            if (otherDesc == null) {\n                dirMap.put(desc.shortName, desc);\n            } else {\n                logger.log(Level.WARNING, \"benchmark \" + desc.name +\n                        \" found duplicate in \" + otherDesc.\n                        shortName + \" and \" + desc.shortName +\n                        \". Ignoring \" + desc.shortName + '.');\n                nameMap.put(otherDesc.name, otherDesc);\n            }\n        }\n        benchNameMap = nameMap;\n        benchDirMap = dirMap;\n        mapTimeStamp = System.currentTimeMillis();\n    }\n\n   /**\n    * Reads the benchmark description from a directory. This can be either\n    * the benchmark deployment directory or the benchmark result dir. The\n    * benchmark directory is given as an absolute path.\n    * @param shortName The short benchmark name, equals the deployment directory\n    * @param dir The benchmark directory\n    * @return The benchmark description object.\n    */\n    public static BenchmarkDescription readDescription(String shortName,\n                                                       String dir) {\n        BenchmarkDescription desc = null;\n        String metaInf = dir + File.separator + \"META-INF\" + File.separator;\n        File benchmarkXml = new File(metaInf + \"benchmark.xml\");\n        try {\n            desc = new BenchmarkDescription();\n            DocumentBuilder parser = parserPool.get();\n            Node root = null;\n            if (benchmarkXml.exists()) {\n               root = parser.parse(benchmarkXml).getDocumentElement();\n               desc.benchmarkClass = xPath.evaluate(\"benchmark-class\", root);\n            }\n            boolean fdExists = readFabanDescription(desc, metaInf, parser);\n            parserPool.release(parser);\n\n            if (!fdExists && root == null)\n                throw new IOException(\"Missing benchmark.xml!\");\n\n            desc.shortName = shortName ;\n\n            if (root != null) {\n                String value = xPath.evaluate(\"config-file-name\", root);\n                if (value != null && value.length() > 0)\n                    desc.configFileName = value;\n\n                value = xPath.evaluate(\"config-stylesheet\", root);\n                if (value != null && value.length() > 0)\n                    desc.configStylesheet = value;\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    throw new IOException(\"Element <benchmark-class> empty \" +\n                            \"or missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"name\", root);\n                if (value != null && value.length() > 0)\n                    desc.name = value;\n                if (desc.name == null)\n                    throw new IOException(\"Element <name> empty or missing \" +\n                                        \"in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"version\", root);\n                if (value != null && value.length() > 0)\n                    desc.version = value;\n                if (desc.version == null)\n                    throw new IOException(\"Element <version> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"config-form\", root);\n                if (value != null && value.length() > 0)\n                    desc.configForm = value;\n\n                value = xPath.evaluate(\"result-file-path\", root);\n                if (value != null && value.length() > 0)\n                    desc.resultFilePath = value;\n\n                value = xPath.evaluate(\"metric\", root);\n                if (value != null && value.length() > 0)\n                    desc.metric = value;\n                if (desc.metric == null)\n                    throw new IOException(\"Element <metric> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"scaleName\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleName = value;\n                if (desc.scaleName == null)\n                    desc.scaleName = \"\";\n\n                value = xPath.evaluate(\"scaleUnit\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleUnit = value;\n                if (desc.scaleUnit == null)\n                    desc.scaleUnit = \"\";\n\n                if (desc.scaleName.length() == 0 &&\n                    desc.scaleUnit.length() == 0)\n                    throw new IOException(\"Both element <scaleName> and \" +\n                            \"<scaleUnit> empty or missing in \" +\n                            benchmarkXml.getAbsolutePath());\n            }\n       } catch (Exception e) {\n           desc = null;\n           logger.log(Level.WARNING, \"Error reading benchmark \" +\n                   \"descriptor for \" + dir, e);\n       }\n       return desc;\n    }\n\n    private static boolean readFabanDescription(BenchmarkDescription desc,\n                                             String metaInf,\n                                             DocumentBuilder parser) {\n        File fabanXml = new File(metaInf + \"faban.xml\");\n        if (fabanXml.exists())\n            try {\n                Node root = parser.parse(fabanXml).getDocumentElement();\n                desc.name = xPath.evaluate(\"name\", root);\n                desc.version = xPath.evaluate(\"version\", root);\n                desc.metric = xPath.evaluate(\"metric\", root);\n                desc.scaleName = xPath.evaluate(\"scaleName\", root);\n                desc.scaleUnit = xPath.evaluate(\"scaleUnit\", root);\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    desc.benchmarkClass =\n                            \"com.sun.faban.harness.DefaultFabanBenchmark\";\n                return true;\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error reading faban driver \" +\n                        \"descriptor for \" + desc.shortName, e);\n                return false;\n            }\n        else\n            return false;\n    }\n\n    private BenchmarkDescription() {\n    }\n\n    /**\n     * Simple pool of DOM parsers.\n     */\n    private static class ParserPool {\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        ArrayList<DocumentBuilder> pool = new ArrayList<DocumentBuilder>();\n\n        synchronized DocumentBuilder get() throws ParserConfigurationException {\n            DocumentBuilder parser = null;\n            int size = pool.size();\n            if (size > 0) {\n                parser = pool.remove(size - 1);\n            } else {\n                parser = factory.newDocumentBuilder();\n            }\n            return parser;\n        }\n\n        synchronized void release(DocumentBuilder parser) {\n            pool.add(parser);\n        }\n\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: BenchmarkDescription.java,v 1.11 2008/06/03 18:00:32 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.common;\n\nimport org.w3c.dom.Node;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.sun.faban.harness.util.DeployUtil;\n\n/**\n * This is a value class describing the benchmark.\n *\n * @author Akara Sucharitakul\n */\npublic class BenchmarkDescription implements Serializable {\n\n    /** The max time to cache a map, 10 secs. */\n    public static final int MAP_TIMEOUT = 10000;\n\n    /** The short name of the benchmark, and also the directory names. */\n    public String shortName;\n\n    /** The full name of the benchmark. This name may contain spaces. */\n    public String name;\n\n    /** The version of the benchmark. */\n    public String version;\n\n    /** The form used to configure the benchmark. */\n    public String configForm = \"config.xhtml\";\n\n    /** The stylesheet used to format the form, if any */\n    public String configStylesheet;\n\n    /** The file used for configuring the benchmark. */\n    public String configFileName = \"run.xml\";\n\n    /** The result file path relative to the output directory */\n    public String resultFilePath = \"summary.xml\";\n\n    /** The benchmark class name. */\n    public String benchmarkClass;\n\n    /** The benchmark metric. */\n    public String metric;\n\n    /** The name of the benchmark scale. */\n    public String scaleName;\n\n    /** The name of the benchmark unit. */\n    public String scaleUnit;\n\n    static final Logger logger = Logger.getLogger(\n            BenchmarkDescription.class.getName());\n    static final XPath xPath = XPathFactory.newInstance().newXPath();\n    static final ParserPool parserPool = new ParserPool();\n\n    static HashMap<String, BenchmarkDescription> benchNameMap;\n    static HashMap<String, BenchmarkDescription> benchDirMap;\n    static long mapTimeStamp = 0l;\n\n    /**\n     * Obtains a map of benchmarks using the directory (or short name)\n     * as the key.\n     * @return The directory map of currently deployed benchmarks\n     */\n    public static Map<String, BenchmarkDescription> getBenchDirMap() {\n        checkMaps(true);\n        return benchDirMap;\n    }\n\n    public static Map<String, BenchmarkDescription> getBenchDirMap(\n            boolean deploy) {\n        checkMaps(deploy);\n        return benchDirMap;\n    }\n\n    /**\n     * Obtains a map of benchmarks using the full name as the key.\n     * @return The name map of currently deployed benchmarks\n     */\n    public static HashMap<String, BenchmarkDescription> getBenchNameMap() {\n        checkMaps(true);\n        return benchNameMap;\n    }\n\n    /**\n     * Obtains the benchmark description for a certain deploy directory\n     * or short name.\n     * @param dir The deploy directory or short name of the benchmark\n     * @return The benchmark description or null of none exists\n     */\n    public static BenchmarkDescription getDescription(String dir) {\n        checkMaps(true);\n        return (BenchmarkDescription) benchDirMap.get(dir);\n    }\n\n    /**\n     * Returns the name to display on the banner. If only one benchmark\n     * is deployed, the benchmark name and version will be used for the\n     * banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The name to display on the banner page\n     */\n    public static String getBannerName() {\n        checkMaps(true);\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription) benchDirMap.values().iterator().\n                    next()).name;\n        }\n        return Config.HARNESS_NAME;\n    }\n\n    /**\n     * Returns the version number to display on the banner. If only one\n     * benchmark is deployed, the benchmark name and version will be used for\n     * the banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The version to display on the banner\n     */\n    public static String getBannerVersion() {\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription)benchDirMap.values().iterator().\n                    next()).version;\n        }\n        return Config.HARNESS_VERSION;\n    }\n\n\n\n    private static synchronized void checkMaps(boolean deploy) {\n        if (System.currentTimeMillis() - mapTimeStamp > MAP_TIMEOUT)\n            generateMaps(deploy);\n    }\n\n\n    private static void generateMaps(boolean deploy) {\n        HashMap<String, BenchmarkDescription> nameMap =\n                new HashMap<String, BenchmarkDescription>();\n        HashMap<String, BenchmarkDescription> dirMap =\n                new HashMap<String, BenchmarkDescription>();\n\n        if (deploy)\n            DeployUtil.checkDeploy();\n\n        File[] benchmarks = DeployUtil.BENCHMARKDIR.listFiles();\n        for (int i = 0; i < benchmarks.length; i++) {\n            logger.finest(\"Found benchmark directory \" + benchmarks[i]);\n            BenchmarkDescription desc = readDescription(benchmarks[i].getName(),\n                                        benchmarks[i].getAbsolutePath());\n            if (desc == null)\n                continue;\n            BenchmarkDescription otherDesc = (BenchmarkDescription)\n                                       nameMap.put(desc.name, desc);\n            if (otherDesc == null) {\n                dirMap.put(desc.shortName, desc);\n            } else {\n                logger.log(Level.WARNING, \"benchmark \" + desc.name +\n                        \" found duplicate in \" + otherDesc.\n                        shortName + \" and \" + desc.shortName +\n                        \". Ignoring \" + desc.shortName + '.');\n                nameMap.put(otherDesc.name, otherDesc);\n            }\n        }\n        benchNameMap = nameMap;\n        benchDirMap = dirMap;\n        mapTimeStamp = System.currentTimeMillis();\n    }\n\n   /**\n    * Reads the benchmark description from a directory. This can be either\n    * the benchmark deployment directory or the benchmark result dir. The\n    * benchmark directory is given as an absolute path.\n    * @param shortName The short benchmark name, equals the deployment directory\n    * @param dir The benchmark directory\n    * @return The benchmark description object.\n    */\n    public static BenchmarkDescription readDescription(String shortName,\n                                                       String dir) {\n        BenchmarkDescription desc = null;\n        String metaInf = dir + File.separator + \"META-INF\";\n        File metaInfDir = new File(metaInf);\n        if (!metaInfDir.isDirectory())\n            return null;\n\n        File benchmarkXml = new File(metaInfDir, \"benchmark.xml\");\n\n        try {\n            desc = new BenchmarkDescription();\n            DocumentBuilder parser = parserPool.get();\n            Node root = null;\n            if (benchmarkXml.exists()) {\n               root = parser.parse(benchmarkXml).getDocumentElement();\n               desc.benchmarkClass = xPath.evaluate(\"benchmark-class\", root);\n            }\n            boolean fdExists = readFabanDescription(desc, metaInfDir, parser);\n            parserPool.release(parser);\n\n            if (!fdExists && root == null)\n                throw new IOException(\"Missing benchmark.xml!\");\n\n            desc.shortName = shortName ;\n\n            if (root != null) {\n                String value = xPath.evaluate(\"config-file-name\", root);\n                if (value != null && value.length() > 0)\n                    desc.configFileName = value;\n\n                value = xPath.evaluate(\"config-stylesheet\", root);\n                if (value != null && value.length() > 0)\n                    desc.configStylesheet = value;\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    throw new IOException(\"Element <benchmark-class> empty \" +\n                            \"or missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"name\", root);\n                if (value != null && value.length() > 0)\n                    desc.name = value;\n                if (desc.name == null)\n                    throw new IOException(\"Element <name> empty or missing \" +\n                                        \"in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"version\", root);\n                if (value != null && value.length() > 0)\n                    desc.version = value;\n                if (desc.version == null)\n                    throw new IOException(\"Element <version> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"config-form\", root);\n                if (value != null && value.length() > 0)\n                    desc.configForm = value;\n\n                value = xPath.evaluate(\"result-file-path\", root);\n                if (value != null && value.length() > 0)\n                    desc.resultFilePath = value;\n\n                value = xPath.evaluate(\"metric\", root);\n                if (value != null && value.length() > 0)\n                    desc.metric = value;\n                if (desc.metric == null)\n                    throw new IOException(\"Element <metric> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"scaleName\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleName = value;\n                if (desc.scaleName == null)\n                    desc.scaleName = \"\";\n\n                value = xPath.evaluate(\"scaleUnit\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleUnit = value;\n                if (desc.scaleUnit == null)\n                    desc.scaleUnit = \"\";\n\n                if (desc.scaleName.length() == 0 &&\n                    desc.scaleUnit.length() == 0)\n                    throw new IOException(\"Both element <scaleName> and \" +\n                            \"<scaleUnit> empty or missing in \" +\n                            benchmarkXml.getAbsolutePath());\n            }\n       } catch (Exception e) {\n           desc = null;\n           logger.log(Level.WARNING, \"Error reading benchmark \" +\n                   \"descriptor for \" + dir, e);\n       }\n       return desc;\n    }\n\n    private static boolean readFabanDescription(BenchmarkDescription desc,\n                                             File metaInfDir,\n                                             DocumentBuilder parser) {\n        File fabanXml = new File(metaInfDir, \"faban.xml\");\n        if (fabanXml.exists())\n            try {\n                Node root = parser.parse(fabanXml).getDocumentElement();\n                desc.name = xPath.evaluate(\"name\", root);\n                desc.version = xPath.evaluate(\"version\", root);\n                desc.metric = xPath.evaluate(\"metric\", root);\n                desc.scaleName = xPath.evaluate(\"scaleName\", root);\n                desc.scaleUnit = xPath.evaluate(\"scaleUnit\", root);\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    desc.benchmarkClass =\n                            \"com.sun.faban.harness.DefaultFabanBenchmark\";\n                return true;\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error reading faban driver \" +\n                        \"descriptor for \" + desc.shortName, e);\n                return false;\n            }\n        else\n            return false;\n    }\n\n    private BenchmarkDescription() {\n    }\n\n    /**\n     * Simple pool of DOM parsers.\n     */\n    private static class ParserPool {\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        ArrayList<DocumentBuilder> pool = new ArrayList<DocumentBuilder>();\n\n        synchronized DocumentBuilder get() throws ParserConfigurationException {\n            DocumentBuilder parser = null;\n            int size = pool.size();\n            if (size > 0) {\n                parser = pool.remove(size - 1);\n            } else {\n                parser = factory.newDocumentBuilder();\n            }\n            return parser;\n        }\n\n        synchronized void release(DocumentBuilder parser) {\n            pool.add(parser);\n        }\n\n    }\n}\n","lineNo":214}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: BenchmarkDescription.java,v 1.9 2007/07/21 01:41:58 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.common;\n\nimport org.w3c.dom.Node;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.sun.faban.harness.util.DeployUtil;\n\n/**\n * This is a value class describing the benchmark.\n *\n * @author Akara Sucharitakul\n */\npublic class BenchmarkDescription implements Serializable {\n\n    /** The max time to cache a map, 10 secs. */\n    public static final int MAP_TIMEOUT = 10000;\n\n    /** The short name of the benchmark, and also the directory names. */\n    public String shortName;\n\n    /** The full name of the benchmark. This name may contain spaces. */\n    public String name;\n\n    /** The version of the benchmark. */\n    public String version;\n\n    /** The form used to configure the benchmark. */\n    public String configForm;\n\n    /** The stylesheet used to format the form, if any */\n    public String configStylesheet;\n\n    /** The file used for configuring the benchmark. */\n    public String configFileName;\n\n    /** The result file path relative to the output directory */\n    public String resultFilePath = \"summary.xml\";\n\n    /** The benchmark class name. */\n    public String benchmarkClass;\n\n    /** The benchmark metric. */\n    public String metric;\n\n    /** The name of the benchmark scale. */\n    public String scaleName;\n\n    /** The name of the benchmark unit. */\n    public String scaleUnit;\n\n    static final Logger logger = Logger.getLogger(\n            BenchmarkDescription.class.getName());\n    static final XPath xPath = XPathFactory.newInstance().newXPath();\n    static final ParserPool parserPool = new ParserPool();\n\n    static HashMap<String, BenchmarkDescription> benchNameMap;\n    static HashMap<String, BenchmarkDescription> benchDirMap;\n    static long mapTimeStamp = 0l;\n\n    /**\n     * Obtains a map of benchmarks using the directory (or short name)\n     * as the key.\n     * @return The directory map of currently deployed benchmarks\n     */\n    public static Map<String, BenchmarkDescription> getBenchDirMap() {\n        checkMaps(true);\n        return benchDirMap;\n    }\n\n    public static Map<String, BenchmarkDescription> getBenchDirMap(\n            boolean deploy) {\n        checkMaps(deploy);\n        return benchDirMap;\n    }\n\n    /**\n     * Obtains a map of benchmarks using the full name as the key.\n     * @return The name map of currently deployed benchmarks\n     */\n    public static HashMap<String, BenchmarkDescription> getBenchNameMap() {\n        checkMaps(true);\n        return benchNameMap;\n    }\n\n    /**\n     * Obtains the benchmark description for a certain deploy directory\n     * or short name.\n     * @param dir The deploy directory or short name of the benchmark\n     * @return The benchmark description or null of none exists\n     */\n    public static BenchmarkDescription getDescription(String dir) {\n        checkMaps(true);\n        return (BenchmarkDescription) benchDirMap.get(dir);\n    }\n\n    /**\n     * Returns the name to display on the banner. If only one benchmark\n     * is deployed, the benchmark name and version will be used for the\n     * banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The name to display on the banner page\n     */\n    public static String getBannerName() {\n        checkMaps(true);\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription) benchDirMap.values().iterator().\n                    next()).name;\n        }\n        return Config.HARNESS_NAME;\n    }\n\n    /**\n     * Returns the version number to display on the banner. If only one\n     * benchmark is deployed, the benchmark name and version will be used for\n     * the banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The version to display on the banner\n     */\n    public static String getBannerVersion() {\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription)benchDirMap.values().iterator().\n                    next()).version;\n        }\n        return Config.HARNESS_VERSION;\n    }\n\n\n\n    private static synchronized void checkMaps(boolean deploy) {\n        if (System.currentTimeMillis() - mapTimeStamp > MAP_TIMEOUT)\n            generateMaps(deploy);\n    }\n\n\n    private static void generateMaps(boolean deploy) {\n        HashMap<String, BenchmarkDescription> nameMap =\n                new HashMap<String, BenchmarkDescription>();\n        HashMap<String, BenchmarkDescription> dirMap =\n                new HashMap<String, BenchmarkDescription>();\n\n        if (deploy)\n            DeployUtil.checkDeploy();\n\n        File[] benchmarks = DeployUtil.BENCHMARKDIR.listFiles();\n        for (int i = 0; i < benchmarks.length; i++) {\n            logger.finest(\"Found benchmark directory \" + benchmarks[i]);\n            BenchmarkDescription desc = readDescription(benchmarks[i].getName(),\n                                        benchmarks[i].getAbsolutePath());\n            if (desc == null)\n                continue;\n            BenchmarkDescription otherDesc = (BenchmarkDescription)\n                                       nameMap.put(desc.name, desc);\n            if (otherDesc == null) {\n                dirMap.put(desc.shortName, desc);\n            } else {\n                logger.log(Level.WARNING, \"benchmark \" + desc.name +\n                        \" found duplicate in \" + otherDesc.\n                        shortName + \" and \" + desc.shortName +\n                        \". Ignoring \" + desc.shortName + '.');\n                nameMap.put(otherDesc.name, otherDesc);\n            }\n        }\n        benchNameMap = nameMap;\n        benchDirMap = dirMap;\n        mapTimeStamp = System.currentTimeMillis();\n    }\n\n   /**\n    * Reads the benchmark description from a directory. This can be either\n    * the benchmark deployment directory or the benchmark result dir. The\n    * benchmark directory is given as an absolute path.\n    * @param shortName The short benchmark name, equals the deployment directory\n    * @param dir The benchmark directory\n    * @return The benchmark description object.\n    */\n    public static BenchmarkDescription readDescription(String shortName, String dir) {\n        BenchmarkDescription desc = null;\n        String metaInf = dir + File.separator + \"META-INF\" + File.separator;\n        File benchmarkXml = new File(metaInf + \"benchmark.xml\");\n        if (benchmarkXml.exists())\n            try {\n                desc = new BenchmarkDescription();\n\n                DocumentBuilder parser = parserPool.get();\n                Node root = parser.parse(benchmarkXml).getDocumentElement();\n                desc.benchmarkClass = xPath.evaluate(\"benchmark-class\", root);\n                readFabanDescription(desc, metaInf, parser);\n                parserPool.release(parser);\n\n                desc.shortName = shortName ;\n\n                desc.configFileName = xPath.evaluate(\"config-file-name\", root);\n                if (desc.configFileName == null ||\n                        desc.configFileName.length() == 0)\n                    throw new IOException(\"Element <config-file-name> empty \" +\n                            \"or missing in \" + benchmarkXml.getAbsolutePath());\n\n                desc.configStylesheet = xPath.evaluate(\n                                                    \"config-stylesheet\", root);\n                if (\"\".equals(desc.configStylesheet))\n                    desc.configStylesheet = null;\n\n                if (desc.benchmarkClass == null ||\n                        desc.benchmarkClass.length() == 0)\n                    throw new IOException(\"Element <benchmark-class> empty \" +\n                            \"or missing in \" + benchmarkXml.getAbsolutePath());\n\n                String value = xPath.evaluate(\"name\", root);\n                if (value != null && value.length() > 0)\n                    desc.name = value;\n                if (desc == null)\n                    throw new IOException(\"Element <name> empty or missing \" +\n                            \"in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"version\", root);\n                if (value != null && value.length() > 0)\n                    desc.version = value;\n                if (desc.version == null)\n                    throw new IOException(\"Element <version> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                desc.configForm = xPath.evaluate(\"config-form\", root);\n                if (desc.configForm == null || desc.configForm.length() == 0)\n                    throw new IOException(\"Element <config-form> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"result-file-path\", root);\n                if (value != null && value.length() > 0)\n                    desc.resultFilePath = value;\n\n                value = xPath.evaluate(\"metric\", root);\n                if (value != null && value.length() > 0)\n                    desc.metric = value;\n                if (desc.metric == null)\n                    throw new IOException(\"Element <metric> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"scaleName\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleName = value;\n                if (desc.scaleName == null)\n                    desc.scaleName = \"\";\n\n                value = xPath.evaluate(\"scaleUnit\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleUnit = value;\n                if (desc.scaleUnit == null)\n                    desc.scaleUnit = \"\";\n\n                if (desc.scaleName.length() == 0 &&\n                    desc.scaleUnit.length() == 0)\n                    throw new IOException(\"Both element <scaleName> and \" +\n                            \"<scaleUnit> empty or missing in \" +\n                            benchmarkXml.getAbsolutePath());\n            } catch (Exception e) {\n                desc = null;\n                logger.log(Level.WARNING, \"Error reading benchmark \" +\n                        \"descriptor for \" + dir, e);\n            }\n        return desc;\n    }\n\n    private static void readFabanDescription(BenchmarkDescription desc,\n                                             String metaInf,\n                                             DocumentBuilder parser) {\n        File fabanXml = new File(metaInf + \"faban.xml\");\n        if (fabanXml.exists())\n            try {\n                Node root = parser.parse(fabanXml).getDocumentElement();\n                desc.name = xPath.evaluate(\"name\", root);\n                desc.version = xPath.evaluate(\"version\", root);\n                desc.metric = xPath.evaluate(\"metric\", root);\n                desc.scaleName = xPath.evaluate(\"scaleName\", root);\n                desc.scaleUnit = xPath.evaluate(\"scaleUnit\", root);\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    desc.benchmarkClass =\n                            \"com.sun.faban.harness.DefaultFabanBenchmark\";\n\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error reading faban driver \" +\n                        \"descriptor for \" + desc.shortName, e);\n            }\n    }\n\n    private BenchmarkDescription() {\n    }\n\n    /**\n     * Simple pool of DOM parsers.\n     */\n    private static class ParserPool {\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        ArrayList<DocumentBuilder> pool = new ArrayList<DocumentBuilder>();\n\n        synchronized DocumentBuilder get() throws ParserConfigurationException {\n            DocumentBuilder parser = null;\n            int size = pool.size();\n            if (size > 0) {\n                parser = pool.remove(size - 1);\n            } else {\n                parser = factory.newDocumentBuilder();\n            }\n            return parser;\n        }\n\n        synchronized void release(DocumentBuilder parser) {\n            pool.add(parser);\n        }\n\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: BenchmarkDescription.java,v 1.10 2008/06/02 21:02:08 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.common;\n\nimport org.w3c.dom.Node;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport com.sun.faban.harness.util.DeployUtil;\n\n/**\n * This is a value class describing the benchmark.\n *\n * @author Akara Sucharitakul\n */\npublic class BenchmarkDescription implements Serializable {\n\n    /** The max time to cache a map, 10 secs. */\n    public static final int MAP_TIMEOUT = 10000;\n\n    /** The short name of the benchmark, and also the directory names. */\n    public String shortName;\n\n    /** The full name of the benchmark. This name may contain spaces. */\n    public String name;\n\n    /** The version of the benchmark. */\n    public String version;\n\n    /** The form used to configure the benchmark. */\n    public String configForm = \"config.xhtml\";\n\n    /** The stylesheet used to format the form, if any */\n    public String configStylesheet;\n\n    /** The file used for configuring the benchmark. */\n    public String configFileName = \"run.xml\";\n\n    /** The result file path relative to the output directory */\n    public String resultFilePath = \"summary.xml\";\n\n    /** The benchmark class name. */\n    public String benchmarkClass;\n\n    /** The benchmark metric. */\n    public String metric;\n\n    /** The name of the benchmark scale. */\n    public String scaleName;\n\n    /** The name of the benchmark unit. */\n    public String scaleUnit;\n\n    static final Logger logger = Logger.getLogger(\n            BenchmarkDescription.class.getName());\n    static final XPath xPath = XPathFactory.newInstance().newXPath();\n    static final ParserPool parserPool = new ParserPool();\n\n    static HashMap<String, BenchmarkDescription> benchNameMap;\n    static HashMap<String, BenchmarkDescription> benchDirMap;\n    static long mapTimeStamp = 0l;\n\n    /**\n     * Obtains a map of benchmarks using the directory (or short name)\n     * as the key.\n     * @return The directory map of currently deployed benchmarks\n     */\n    public static Map<String, BenchmarkDescription> getBenchDirMap() {\n        checkMaps(true);\n        return benchDirMap;\n    }\n\n    public static Map<String, BenchmarkDescription> getBenchDirMap(\n            boolean deploy) {\n        checkMaps(deploy);\n        return benchDirMap;\n    }\n\n    /**\n     * Obtains a map of benchmarks using the full name as the key.\n     * @return The name map of currently deployed benchmarks\n     */\n    public static HashMap<String, BenchmarkDescription> getBenchNameMap() {\n        checkMaps(true);\n        return benchNameMap;\n    }\n\n    /**\n     * Obtains the benchmark description for a certain deploy directory\n     * or short name.\n     * @param dir The deploy directory or short name of the benchmark\n     * @return The benchmark description or null of none exists\n     */\n    public static BenchmarkDescription getDescription(String dir) {\n        checkMaps(true);\n        return (BenchmarkDescription) benchDirMap.get(dir);\n    }\n\n    /**\n     * Returns the name to display on the banner. If only one benchmark\n     * is deployed, the benchmark name and version will be used for the\n     * banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The name to display on the banner page\n     */\n    public static String getBannerName() {\n        checkMaps(true);\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription) benchDirMap.values().iterator().\n                    next()).name;\n        }\n        return Config.HARNESS_NAME;\n    }\n\n    /**\n     * Returns the version number to display on the banner. If only one\n     * benchmark is deployed, the benchmark name and version will be used for\n     * the banner. Otherwise the name \"Faban\" and the faban version will be used\n     * for the banner.\n     * @return The version to display on the banner\n     */\n    public static String getBannerVersion() {\n        if (benchDirMap.size() == 1) {\n            return ((BenchmarkDescription)benchDirMap.values().iterator().\n                    next()).version;\n        }\n        return Config.HARNESS_VERSION;\n    }\n\n\n\n    private static synchronized void checkMaps(boolean deploy) {\n        if (System.currentTimeMillis() - mapTimeStamp > MAP_TIMEOUT)\n            generateMaps(deploy);\n    }\n\n\n    private static void generateMaps(boolean deploy) {\n        HashMap<String, BenchmarkDescription> nameMap =\n                new HashMap<String, BenchmarkDescription>();\n        HashMap<String, BenchmarkDescription> dirMap =\n                new HashMap<String, BenchmarkDescription>();\n\n        if (deploy)\n            DeployUtil.checkDeploy();\n\n        File[] benchmarks = DeployUtil.BENCHMARKDIR.listFiles();\n        for (int i = 0; i < benchmarks.length; i++) {\n            logger.finest(\"Found benchmark directory \" + benchmarks[i]);\n            BenchmarkDescription desc = readDescription(benchmarks[i].getName(),\n                                        benchmarks[i].getAbsolutePath());\n            if (desc == null)\n                continue;\n            BenchmarkDescription otherDesc = (BenchmarkDescription)\n                                       nameMap.put(desc.name, desc);\n            if (otherDesc == null) {\n                dirMap.put(desc.shortName, desc);\n            } else {\n                logger.log(Level.WARNING, \"benchmark \" + desc.name +\n                        \" found duplicate in \" + otherDesc.\n                        shortName + \" and \" + desc.shortName +\n                        \". Ignoring \" + desc.shortName + '.');\n                nameMap.put(otherDesc.name, otherDesc);\n            }\n        }\n        benchNameMap = nameMap;\n        benchDirMap = dirMap;\n        mapTimeStamp = System.currentTimeMillis();\n    }\n\n   /**\n    * Reads the benchmark description from a directory. This can be either\n    * the benchmark deployment directory or the benchmark result dir. The\n    * benchmark directory is given as an absolute path.\n    * @param shortName The short benchmark name, equals the deployment directory\n    * @param dir The benchmark directory\n    * @return The benchmark description object.\n    */\n    public static BenchmarkDescription readDescription(String shortName,\n                                                       String dir) {\n        BenchmarkDescription desc = null;\n        String metaInf = dir + File.separator + \"META-INF\" + File.separator;\n        File benchmarkXml = new File(metaInf + \"benchmark.xml\");\n        try {\n            desc = new BenchmarkDescription();\n            DocumentBuilder parser = parserPool.get();\n            Node root = null;\n            if (benchmarkXml.exists()) {\n               root = parser.parse(benchmarkXml).getDocumentElement();\n               desc.benchmarkClass = xPath.evaluate(\"benchmark-class\", root);\n            }\n            boolean fdExists = readFabanDescription(desc, metaInf, parser);\n            parserPool.release(parser);\n\n            if (!fdExists && root == null)\n                throw new IOException(\"Missing benchmark.xml!\");\n\n            desc.shortName = shortName ;\n\n            if (root != null) {\n                String value = xPath.evaluate(\"config-file-name\", root);\n                if (value != null && value.length() > 0)\n                    desc.configFileName = value;\n\n                value = xPath.evaluate(\"config-stylesheet\", root);\n                if (value != null && value.length() > 0)\n                    desc.configStylesheet = value;\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    throw new IOException(\"Element <benchmark-class> empty \" +\n                            \"or missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"name\", root);\n                if (value != null && value.length() > 0)\n                    desc.name = value;\n                if (desc.name == null)\n                    throw new IOException(\"Element <name> empty or missing \" +\n                                        \"in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"version\", root);\n                if (value != null && value.length() > 0)\n                    desc.version = value;\n                if (desc.version == null)\n                    throw new IOException(\"Element <version> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"config-form\", root);\n                if (value != null && value.length() > 0)\n                    desc.configForm = value;\n\n                value = xPath.evaluate(\"result-file-path\", root);\n                if (value != null && value.length() > 0)\n                    desc.resultFilePath = value;\n\n                value = xPath.evaluate(\"metric\", root);\n                if (value != null && value.length() > 0)\n                    desc.metric = value;\n                if (desc.metric == null)\n                    throw new IOException(\"Element <metric> empty or \" +\n                            \"missing in \" + benchmarkXml.getAbsolutePath());\n\n                value = xPath.evaluate(\"scaleName\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleName = value;\n                if (desc.scaleName == null)\n                    desc.scaleName = \"\";\n\n                value = xPath.evaluate(\"scaleUnit\", root);\n                if (value != null && value.length() > 0)\n                    desc.scaleUnit = value;\n                if (desc.scaleUnit == null)\n                    desc.scaleUnit = \"\";\n\n                if (desc.scaleName.length() == 0 &&\n                    desc.scaleUnit.length() == 0)\n                    throw new IOException(\"Both element <scaleName> and \" +\n                            \"<scaleUnit> empty or missing in \" +\n                            benchmarkXml.getAbsolutePath());\n            }\n       } catch (Exception e) {\n           desc = null;\n           logger.log(Level.WARNING, \"Error reading benchmark \" +\n                   \"descriptor for \" + dir, e);\n       }\n       return desc;\n    }\n\n    private static boolean readFabanDescription(BenchmarkDescription desc,\n                                             String metaInf,\n                                             DocumentBuilder parser) {\n        File fabanXml = new File(metaInf + \"faban.xml\");\n        if (fabanXml.exists())\n            try {\n                Node root = parser.parse(fabanXml).getDocumentElement();\n                desc.name = xPath.evaluate(\"name\", root);\n                desc.version = xPath.evaluate(\"version\", root);\n                desc.metric = xPath.evaluate(\"metric\", root);\n                desc.scaleName = xPath.evaluate(\"scaleName\", root);\n                desc.scaleUnit = xPath.evaluate(\"scaleUnit\", root);\n\n                if (desc.benchmarkClass == null ||\n                    desc.benchmarkClass.length() == 0)\n                    desc.benchmarkClass =\n                            \"com.sun.faban.harness.DefaultFabanBenchmark\";\n                return true;\n            } catch (Exception e) {\n                logger.log(Level.WARNING, \"Error reading faban driver \" +\n                        \"descriptor for \" + desc.shortName, e);\n                return false;\n            }\n        else\n            return false;\n    }\n\n    private BenchmarkDescription() {\n    }\n\n    /**\n     * Simple pool of DOM parsers.\n     */\n    private static class ParserPool {\n\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        ArrayList<DocumentBuilder> pool = new ArrayList<DocumentBuilder>();\n\n        synchronized DocumentBuilder get() throws ParserConfigurationException {\n            DocumentBuilder parser = null;\n            int size = pool.size();\n            if (size > 0) {\n                parser = pool.remove(size - 1);\n            } else {\n                parser = factory.newDocumentBuilder();\n            }\n            return parser;\n        }\n\n        synchronized void release(DocumentBuilder parser) {\n            pool.add(parser);\n        }\n\n    }\n}\n","lineNo":232}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.19 2008/05/15 07:21:53 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n    /*\n    Response Histogram\n    ~~~~~~~~~~~~~~~~~~\n    Use fine and coarse bucket sizes for response time.\n    Use fine buckets for up to 1.5 * Max90th\n    Use coarse bucket sizes for 1.5 * Max90th to 5 * Max90th\n    We do not care much about accuracy when we're far beyond the Max90th.\n    We use 200 buckets up to Max90th. This means 300 buckets for up to\n    1.5 * Max90th. Beyond that, we reduce the accuracy by 10x so only 70\n    coarse buckets are needed. Altogether, we use 370 buckets, which is\n    63% savings when compared to 1000 buckets. The logic will be slightly\n    more complicated but by not much.\n    */\n    public static final int COARSE_RESPBUCKETS = 70;\n    public static final int FINE_RESPBUCKETS = 300;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    // We use double here to prevent cumulative errors\n    protected long fineRespBucketSize;  // Size of the fine and coarse\n    protected long coarseRespBucketSize; // response time buckets, in ns.\n    protected long fineRespHistMax; // Max fine response time\n    protected long coarseRespHistMax; // Max coarse response time\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n\n        txTypes = driverConfig.operations.length;\n\n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][FINE_RESPBUCKETS + COARSE_RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        // Calculate the response time histograms.\n        double precision = driverConfig.responseTimeUnit.toNanos(1l);\n        long max90nanos = Math.round(max90th * precision);\n\n        // Find 1.5 * max90th without incurring float errors.\n        long t = max90nanos * 3l;\n        long mod = t % 2l;\n        t /= 2l;\n        if (mod > 0)\n            t += 1;\n\n        // Find an integer bucket size.\n        mod = t % FINE_RESPBUCKETS;\n        fineRespBucketSize = t / FINE_RESPBUCKETS;\n        if (mod > 0)\n            fineRespBucketSize += 1l;\n\n        fineRespHistMax = fineRespBucketSize * FINE_RESPBUCKETS;\n\n        coarseRespBucketSize = fineRespBucketSize * 10l;\n        coarseRespHistMax = coarseRespBucketSize * COARSE_RESPBUCKETS +\n                                                    fineRespHistMax;\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            int bucket;\n            if (responseTime < fineRespHistMax) {\n                bucket = (int) (responseTime / fineRespBucketSize);\n            } else if (responseTime < coarseRespHistMax) {\n                bucket = (int) (((responseTime - fineRespHistMax) /\n                        coarseRespBucketSize) + FINE_RESPBUCKETS);\n            } else {\n                bucket = FINE_RESPBUCKETS + COARSE_RESPBUCKETS - 1;\n            }\n            respHist[txType][bucket]++;\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        int bucket = (int) (actualDelayTime / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][bucket]++;\n\t\t}\n        bucket = (int) (thread.delayTime[thread.mixId] / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < FINE_RESPBUCKETS + COARSE_RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < FINE_RESPBUCKETS + COARSE_RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90d);\n                int j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp90 = j * fineRespBucketSize;\n                else if (j < COARSE_RESPBUCKETS)\n                    resp90 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else\n                    resp90 = coarseRespHistMax;\n                resp90 /= precision;\n\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * The respHist, or response histogram has a special structure:\n     * The lower buckets are fine-grained buckets. The higher buckets\n     * are coarse-grained bucket covering 10x as much time. It is done this\n     * way to save memory (from 1000 entries per thread per operation, down to\n     * 370 entries). For low response times, we care a lot about the exact\n     * response time and therefore we use fine-grained buckets. For large\n     * response times we just want to know the ballpark, but not the exact\n     * number. So it does not make sense to keep the same bucket size\n     * throughout. We use fine granularity below 1.5x largest set 90th% and\n     * coarse granularity for anything beyond that.\n     *\n     * Now, we need to flatten the response time histogram into a flat one\n     * before plotting. We do this, here. We'll end up with more entries, but\n     * we really don't care since this is one copy, once per run at report time.\n     */\n    private void flattenRespHist() {\n        int limit = getBucketLimit(respHist);\n        if (limit > FINE_RESPBUCKETS) {\n            int size = (limit - FINE_RESPBUCKETS) * 10 + FINE_RESPBUCKETS;\n            int[][] respHist = new int[txTypes][size];\n            for (int i = 0; i < txTypes; i++) {\n\n                // Copy the fine buckets unchanged.\n                for (int j = 0; j < FINE_RESPBUCKETS; j++)\n                    respHist[i][j] = this.respHist[i][j];\n\n                for (int j = FINE_RESPBUCKETS; j < limit; j++) {\n                    int count = this.respHist[i][j];\n                    // Spread the count among all 10 flat buckets.\n                    int base = count / 10;\n                    int remainder = count % 10;\n                    int baseIdx = (j - FINE_RESPBUCKETS) * 10 +\n                                    FINE_RESPBUCKETS;\n                    int k = 9;\n                    // The higher buckets get the base\n                    for (; k >= remainder; k--)\n                        respHist[i][baseIdx + k] = base;\n                    // The lower remaining buckets get the base + 1\n                    ++base;\n                    for (; k >= 0; k--)\n                        respHist[i][baseIdx + k] = base;\n                }\n            }\n            this.respHist = respHist;\n        }\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        flattenRespHist();\n\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times (\" +\n                responseTimeUnit + \")\", fineRespBucketSize / precision, \"%.5f\",\n                respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times \" +\n                \"(seconds)\", delayBucketSize / 1e9d, \"%.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times (seconds)\", delayBucketSize / 1e9d, \"%.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.20 2008/05/15 15:49:36 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n    /*\n    Response Histogram\n    ~~~~~~~~~~~~~~~~~~\n    Use fine and coarse bucket sizes for response time.\n    Use fine buckets for up to 1.5 * Max90th\n    Use coarse bucket sizes for 1.5 * Max90th to 5 * Max90th\n    We do not care much about accuracy when we're far beyond the Max90th.\n    We use 200 buckets up to Max90th. This means 300 buckets for up to\n    1.5 * Max90th. Beyond that, we reduce the accuracy by 10x so only 70\n    coarse buckets are needed. Altogether, we use 370 buckets, which is\n    63% savings when compared to 1000 buckets. The logic will be slightly\n    more complicated but by not much.\n    */\n    public static final int COARSE_RESPBUCKETS = 70;\n    public static final int FINE_RESPBUCKETS = 300;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    // We use double here to prevent cumulative errors\n    protected long fineRespBucketSize;  // Size of the fine and coarse\n    protected long coarseRespBucketSize; // response time buckets, in ns.\n    protected long fineRespHistMax; // Max fine response time\n    protected long coarseRespHistMax; // Max coarse response time\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n\n        txTypes = driverConfig.operations.length;\n\n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][FINE_RESPBUCKETS + COARSE_RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        // Calculate the response time histograms.\n        double precision = driverConfig.responseTimeUnit.toNanos(1l);\n        long max90nanos = Math.round(max90th * precision);\n        fineRespBucketSize = max90nanos / 200l;  // 20% of scale of 1000\n        fineRespHistMax = fineRespBucketSize * FINE_RESPBUCKETS;\n        coarseRespBucketSize = fineRespBucketSize * 10l;\n        coarseRespHistMax = coarseRespBucketSize * COARSE_RESPBUCKETS +\n                                                    fineRespHistMax;\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            int bucket;\n            if (responseTime < fineRespHistMax) {\n                bucket = (int) (responseTime / fineRespBucketSize);\n            } else if (responseTime < coarseRespHistMax) {\n                bucket = (int) (((responseTime - fineRespHistMax) /\n                        coarseRespBucketSize) + FINE_RESPBUCKETS);\n            } else {\n                bucket = FINE_RESPBUCKETS + COARSE_RESPBUCKETS - 1;\n            }\n            respHist[txType][bucket]++;\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        int bucket = (int) (actualDelayTime / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][bucket]++;\n\t\t}\n        bucket = (int) (thread.delayTime[thread.mixId] / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < FINE_RESPBUCKETS + COARSE_RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < FINE_RESPBUCKETS + COARSE_RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg;\n        long resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            long max90nanos = Math.round(max90 * precision);\n\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90d);\n                int j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp90 = j * fineRespBucketSize;\n                else if (j < COARSE_RESPBUCKETS)\n                    resp90 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else\n                    resp90 = coarseRespHistMax;\n\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90 / precision);\n                if (resp90 > max90nanos) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * The respHist, or response histogram has a special structure:\n     * The lower buckets are fine-grained buckets. The higher buckets\n     * are coarse-grained bucket covering 10x as much time. It is done this\n     * way to save memory (from 1000 entries per thread per operation, down to\n     * 370 entries). For low response times, we care a lot about the exact\n     * response time and therefore we use fine-grained buckets. For large\n     * response times we just want to know the ballpark, but not the exact\n     * number. So it does not make sense to keep the same bucket size\n     * throughout. We use fine granularity below 1.5x largest set 90th% and\n     * coarse granularity for anything beyond that.\n     *\n     * Now, we need to flatten the response time histogram into a flat one\n     * before plotting. We do this, here. We'll end up with more entries, but\n     * we really don't care since this is one copy, once per run at report time.\n     */\n    private void flattenRespHist() {\n        int limit = getBucketLimit(respHist);\n        if (limit > FINE_RESPBUCKETS) {\n            int size = (limit - FINE_RESPBUCKETS) * 10 + FINE_RESPBUCKETS;\n            int[][] respHist = new int[txTypes][size];\n            for (int i = 0; i < txTypes; i++) {\n\n                // Copy the fine buckets unchanged.\n                for (int j = 0; j < FINE_RESPBUCKETS; j++)\n                    respHist[i][j] = this.respHist[i][j];\n\n                for (int j = FINE_RESPBUCKETS; j < limit; j++) {\n                    int count = this.respHist[i][j];\n                    // Spread the count among all 10 flat buckets.\n                    int base = count / 10;\n                    int remainder = count % 10;\n                    int baseIdx = (j - FINE_RESPBUCKETS) * 10 +\n                                    FINE_RESPBUCKETS;\n                    int k = 9;\n                    // The higher buckets get the base\n                    for (; k >= remainder; k--)\n                        respHist[i][baseIdx + k] = base;\n                    // The lower remaining buckets get the base + 1\n                    ++base;\n                    for (; k >= 0; k--)\n                        respHist[i][baseIdx + k] = base;\n                }\n            }\n            this.respHist = respHist;\n        }\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        flattenRespHist();\n\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times (\" +\n                responseTimeUnit + \")\", fineRespBucketSize / precision, \"%.5f\",\n                respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times \" +\n                \"(seconds)\", delayBucketSize / 1e9d, \"%.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times (seconds)\", delayBucketSize / 1e9d, \"%.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","lineNo":775}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.17 2008/05/14 16:49:40 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/** Number of response time buckets in histogram. */\n    public static final int RESPBUCKETS = 1000;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    protected long respBucketSize;  // Size of each response time bucket, in ns\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n        \n        txTypes = driverConfig.operations.length;\n        \n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        double respHistMax = max90th * 5d;  // 5 x max response time\n        double precision = driverConfig.responseTimeUnit.toNanos(1l);\n        respBucketSize = (long) Math.ceil(precision * respHistMax / RESPBUCKETS);\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            if ((responseTime / respBucketSize) >= RESPBUCKETS) {\n                respHist[txType][RESPBUCKETS - 1]++;\n\t\t\t} else {\n                respHist[txType][(int) (responseTime / respBucketSize)]++;\n\t\t\t}\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        int bucket = (int) (actualDelayTime / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][bucket]++;\n\t\t}\n        bucket = (int) (thread.delayTime[thread.mixId] / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90);\n                int j = 0;\n                for (; j < RESPBUCKETS; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                resp90 = (j + 1) * respBucketSize / precision;\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        double precision = driver.responseTimeUnit.toNanos(1l);\n\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times (\" +\n                responseTimeUnit + \")\", respBucketSize / precision, \"%.5f\",\n                respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times \" +\n                \"(seconds)\", delayBucketSize / 1e9d, \"%.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times (seconds)\", delayBucketSize / 1e9d, \"%.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.18 2008/05/15 06:33:25 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n    /*\n    Response Histogram\n    ~~~~~~~~~~~~~~~~~~\n    Use fine and coarse bucket sizes for response time.\n    Use fine buckets for up to 1.5 * Max90th\n    Use coarse bucket sizes for 1.5 * Max90th to 5 * Max90th\n    We do not care much about accuracy when we're far beyond the Max90th.\n    We use 200 buckets up to Max90th. This means 300 buckets for up to\n    1.5 * Max90th. Beyond that, we reduce the accuracy by 10x so only 70\n    coarse buckets are needed. Altogether, we use 370 buckets, which is\n    63% savings when compared to 1000 buckets. The logic will be slightly\n    more complicated but by not much.\n    */\n    public static final int COARSE_RESPBUCKETS = 70;\n    public static final int FINE_RESPBUCKETS = 300;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    // We use double here to prevent cumulative errors\n    protected long fineRespBucketSize;  // Size of the fine and coarse\n    protected long coarseRespBucketSize; // response time buckets, in ns.\n    protected long fineRespHistMax; // Max fine response time\n    protected long coarseRespHistMax; // Max coarse response time\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n\n        txTypes = driverConfig.operations.length;\n\n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][FINE_RESPBUCKETS + COARSE_RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        // Calculate the response time histograms.\n        double precision = driverConfig.responseTimeUnit.toNanos(1l);\n        long max90nanos = Math.round(max90th * precision);\n\n        // Find 1.5 * max90th without incurring float errors.\n        long t = max90nanos * 3l;\n        long mod = t % 2l;\n        t /= 2l;\n        if (mod > 0)\n            t += 1;\n\n        // Find an integer bucket size.\n        mod = t % FINE_RESPBUCKETS;\n        fineRespBucketSize = t / FINE_RESPBUCKETS;\n        if (mod > 0)\n            fineRespBucketSize += 1l;\n\n        fineRespHistMax = fineRespBucketSize * FINE_RESPBUCKETS;\n\n        coarseRespBucketSize = fineRespBucketSize * 10l;\n        coarseRespHistMax = coarseRespBucketSize * COARSE_RESPBUCKETS +\n                                                    fineRespHistMax;\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            int bucket;\n            if (responseTime < fineRespHistMax) {\n                bucket = (int) (responseTime / fineRespBucketSize);\n            } else if (responseTime < coarseRespHistMax) {\n                bucket = (int) (((responseTime - fineRespHistMax) /\n                        coarseRespBucketSize) + FINE_RESPBUCKETS);\n            } else {\n                bucket = FINE_RESPBUCKETS + COARSE_RESPBUCKETS - 1;\n            }\n            respHist[txType][bucket]++;\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        int bucket = (int) (actualDelayTime / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][bucket]++;\n\t\t}\n        bucket = (int) (thread.delayTime[thread.mixId] / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < FINE_RESPBUCKETS + COARSE_RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < FINE_RESPBUCKETS + COARSE_RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90d);\n                int j = 0;\n                for (; j < respHist[i].length; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                // We report the base of the next bucket.\n                ++j;\n                if (j < FINE_RESPBUCKETS)\n                    resp90 = j * fineRespBucketSize;\n                else if (j < COARSE_RESPBUCKETS)\n                    resp90 = (j - FINE_RESPBUCKETS) * coarseRespBucketSize +\n                            fineRespHistMax;\n                else\n                    resp90 = coarseRespHistMax;\n                resp90 /= precision;\n\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * The respHist, or response histogram has a special structure:\n     * The lower buckets are fine-grained buckets. The higher buckets\n     * are coarse-grained bucket covering 10x as much time. It is done this\n     * way to save memory (from 1000 entries per thread per operation, down to\n     * 370 entries). For low response times, we care a lot about the exact\n     * response time and therefore we use fine-grained buckets. For large\n     * response times we just want to know the ballpark, but not the exact\n     * nunmber. So it does not make sense to keep the same bucket size\n     * throughout. We use fine granularity below 1.5x largest set 90th% and\n     * coarse granularity for anything beyond that.\n     *\n     * Now, we need to flatten the response time histogram into a flat one\n     * before plotting. We do this, here. We'll end up with more entries, but\n     * we really don't care since this is one copy, once per run at report time.\n     */\n    private void flattenRespHist() {\n        int limit = getBucketLimit(respHist);\n        if (limit > FINE_RESPBUCKETS) {\n            int size = (limit - FINE_RESPBUCKETS) * 10 + FINE_RESPBUCKETS;\n            int[][] respHist = new int[txTypes][size];\n            for (int i = 0; i < txTypes; i++) {\n\n                // Copy the fine buckets unchanged.\n                for (int j = 0; j < FINE_RESPBUCKETS; j++)\n                    respHist[i][j] = this.respHist[i][j];\n\n                for (int j = FINE_RESPBUCKETS; j < limit; j++) {\n                    int count = this.respHist[i][j];\n                    // Spread the count among all 10 flat buckets.\n                    int base = count / 10;\n                    int remainder = count % 10;\n                    int baseIdx = (j - FINE_RESPBUCKETS) * 10 +\n                                    FINE_RESPBUCKETS;\n                    int k = 9;\n                    // The higher buckets get the base\n                    for (; k >= remainder; k--)\n                        respHist[i][baseIdx + k] = base;\n                    // The lower remaining buckets get the base + 1\n                    ++base;\n                    for (; k >= 0; k--)\n                        respHist[i][baseIdx + k] = base;\n                }\n            }\n            this.respHist = respHist;\n        }\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        flattenRespHist();\n\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times (\" +\n                responseTimeUnit + \")\", fineRespBucketSize / precision, \"%.5f\",\n                respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times \" +\n                \"(seconds)\", delayBucketSize / 1e9d, \"%.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times (seconds)\", delayBucketSize / 1e9d, \"%.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","lineNo":268}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: AgentImpl.java,v 1.11 2008/03/05 02:50:26 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.driver.util.Timer;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.rmi.RMISecurityManager;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * AgentImpl executes the driver threads of any given subtype.\n * It receives commands from the Master.\n * The AgentImpl is responsible for spawning and managing\n * threads, synchronizing between the threads and aggregating\n * the stats from all threads.\n *\n * @author Shanti Subramanyam\n * @see com.sun.faban.driver.core.Agent\n * @see com.sun.faban.driver.core.AgentThread\n */\npublic class AgentImpl extends UnicastRemoteObject\n        implements Agent, Unreferenced, Runnable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tstatic AgentImpl agentImpl;\n    Master master;\n    RunInfo runInfo;\n    int driverType;\n    Timer timer;\n    AgentThread[] agentThreads;\n    String agentType;\n    Metrics results[] = null;\n    int numThreads;\n    String driverBase;\n    private Logger logger;\n    private String agentName;\n    private String agentId;\n    private String displayName;\n    private String className;\n    CountDownLatch threadStartLatch;\n    CountDownLatch timeSetLatch;\n    CountDownLatch preRunLatch;\n    CountDownLatch postRunLatch;\n    private boolean runAborted = false;\n\n    /**\n     * Constructor\n     * Create properties object from file\n     */\n    AgentImpl(String driverName, String agentId, String master)\n            throws Exception {\n        this (driverName, agentId);\n\n        RegistryLocator.getRegistry(master).\n                reregister(agentType, agentName, this);\n\n        logger.fine(displayName + \" started ...\");\n    }\n\n\n    AgentImpl(String driverName, String agentId) throws RemoteException {\n        className = getClass().getName();\n        logger = Logger.getLogger(className);\n        agentType = driverName + \"Agent\";\n        agentName = driverName + '.' + agentId;\n        displayName = agentType + '[' + agentId + ']';\n        this.agentId = agentId;\n        Thread.setDefaultUncaughtExceptionHandler(\n                new Thread.UncaughtExceptionHandler() {\n                    public void uncaughtException(Thread t, Throwable e) {\n                        logger.log(Level.SEVERE, t.getName() + \": \" +\n                                e.getMessage(), e);\n                    }\n                }\n        );\n    }\n\n    /**\n     * Configures each agents with the props passed\n     * The threads are created at this point\n     * @param master the remote interface to the Master\n     * @param runInfo run information passed by Master\n     * @param driverType \n     * @param timer BenchmarkDefinition Start time\n     * @throws RemoteException \n     */\n    public void configure(Master master, RunInfo runInfo, int driverType,\n                          Timer timer) throws RemoteException {\n\n        runAborted = false;\n        this.master = master;\n        this.runInfo = runInfo;\n        this.driverType = driverType;\n        this.timer = timer;\n\n        // driverBase most accurate if faban.driver.base is provided.\n        driverBase = System.getProperty(\"faban.driver.base\");\n        if (driverBase == null) {\n            File driverJar = Utilities.getJarFile(\n                                    runInfo.driverConfig.driverClass);\n            if (driverJar != null)\n                // Else find with jarpath/..\n                driverBase = driverJar.getParentFile().getParent();\n        }\n\n        threadStartLatch = new CountDownLatch(runInfo.agentInfo.threads);\n        timeSetLatch = new CountDownLatch(1);\n        if (runInfo.agentInfo.startThreadNumber == 0) { // first agent\n            if (runInfo.driverConfig.preRun != null) {\n\t\t\t\tpreRunLatch = new CountDownLatch(1);\n\t\t\t}\n            if (runInfo.driverConfig.postRun != null) {\n\t\t\t\tpostRunLatch = new CountDownLatch(1);\n\t\t\t}\n        }\n        try {\n            runInfo.postDeserialize();\n        } catch (ClassNotFoundException e) {\n            logger.severe(e.getMessage());\n            logger.throwing(className, \"configure\", e);\n            master.abortRun();\n        }\n\n        runInfo.agentInfo.agentType = agentType;\n        results = null;\t\t// so that we don't use old results\n        calibrateTime();\n\n        // Agents will Start the threads in parallel if\n        // parallelThreadStart is set.\n        if (runInfo.parallelAgentThreadStart) {\n            // start thread and return\n            new Thread(this).start();\n            if (runInfo.agentInfo.startThreadNumber == 0 &&\n                    runInfo.driverConfig.preRun != null) {\n\t\t\t\ttry {\n                    preRunLatch.await();\n                } catch (InterruptedException e) {\n                    // Do nothing.\n                }\n\t\t\t}\n        } else {\n            // block until done and return\n            this.run();\n        }\n    }\n\n    /**\n     * Calibrates the time with the master.\n     * @throws RemoteException A network error occurred.\n     */\n    private void calibrateTime() throws RemoteException {\n        long t1 = 0;\n        long tm = 0;\n        int diff = 0;\n        int retries = 0;\n\n        // Just in case we run into GC situations, the times can be nasty.\n        // In that case we retry up to 5 times.\n        for (; retries < 5; retries++) {\n            t1 = System.currentTimeMillis();\n            tm = master.currentTimeMillis();\n            long t2 = System.currentTimeMillis();\n\n            // We really don't know when between t1 and t2 tm occurred.\n            // but if we assume it to be short enough, we can savely\n            // use the avg with errors in the 5 millisec range.\n            diff  = (int) (t2 - t1);\n            if (diff <= 10) {\n\t\t\t\tbreak;\n\t\t\t}\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            \tlogger.fine(\"Sleep Interrupted: \" + e.getMessage());\n            }\n        }\n\n        // After 5 retries, if the simple call to Master.currentTimeMillis\n        // is still too time consuming, we abort the whole thing.\n        if (retries >= 5) {\n                logger.log(Level.SEVERE, \"Roundtrip to master took \" + diff +\n                        \" ms. Too high latency!\");\n                master.abortRun();\n        }\n\n        // Doing a simple avg on millis can overwhelm the long system.\n        // So we subtract first.\n        int offset = diff / 2 + ((int) (t1 - tm));\n        timer.adjustBaseTime(offset);\n    }\n\n    /**\n     * @see java.lang.Runnable#run()\n     */\n    public void run() {\n        // Create the required number of threads\n        numThreads = runInfo.agentInfo.threads;\n        agentThreads = new AgentThread[numThreads];\n        try {\n            int baseTime = timer.getTime();\n            int count = 0;\n            for (; count < numThreads && !runAborted; count++) {\n                int globalThreadId = runInfo.agentInfo.startThreadNumber +\n                        count;\n                agentThreads[count] = AgentThread.getInstance(agentType,\n                        agentId, globalThreadId,\n                        runInfo.driverConfig.driverClass, timer, this);\n                agentThreads[count].start();\n\n                // Ensure the preRun is done before proceeding.\n                if (globalThreadId == 0 &&\n                        runInfo.driverConfig.preRun != null) {\n                    preRunLatch.await();\n\n                    // Adjust baseTime if the preRun takes long.\n                    int currentTime = timer.getTime();\n                    if (currentTime - baseTime > runInfo.msBetweenThreadStart) {\n\t\t\t\t\t\tbaseTime = currentTime - runInfo.msBetweenThreadStart;\n\t\t\t\t\t}                    \n                }\n\n                // We ensure we catch up with the configured thread starting\n                // rate. If we fall short, we sleep less until we caught up.\n                int sleepTime = runInfo.msBetweenThreadStart * (count + 1) +\n                        baseTime - timer.getTime();\n\n                // In case we fall short, we sleep only 1/3 the interval\n                if (sleepTime <= 0) {\n\t\t\t\t\tsleepTime = runInfo.msBetweenThreadStart / 3;\n\t\t\t\t}\n\n                // If the configured time is low, we can still end up\n                // with 0 on an integer operation, so we just check again.\n                if (sleepTime > 0) {\n\t\t\t\t\ttry {\n                        Thread.sleep(sleepTime);\n                    } catch (InterruptedException ie) {\n                    \tlogger.log(Level.FINE, ie.getMessage(), ie);\n                    }\n\t\t\t\t}\n            }\n            if (runAborted) {\n\t\t\t\tlogger.warning(displayName + \": Run aborted before starting \" +\n                        numThreads + \" driver threads.\\n\" + count +\n                        \" threads were started.\");\n\t\t\t} else {\n\t\t\t\tlogger.info(displayName + \": Successfully started \" +\n                        numThreads + \" driver threads.\");\n\t\t\t}\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage(), e);\n            try {\n                master.abortRun();\n            } catch (RemoteException e1) {\n            \tlogger.log(Level.FINE, e1.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * Contacts the master to abort the run. Don't kill until\n     * master calls kill.\n     */\n    public synchronized void abortRun() {\n        if (runAborted) {\n\t\t\treturn;     // the master again. Once per agent is enough.\n\t\t}\n        runAborted = true;\n        try {\n            master.abortRun();\n        } catch (RemoteException e) {\n            logger.log(Level.SEVERE, \"Error contacting master to abort run.\",\n                    e);\n        }\n    }\n\n    /**\n     * Wait until all threads are started.\n     */\n    public void waitForThreadStart() {\n        if (!runAborted) {\n\t\t\ttry {\n                threadStartLatch.await();\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n\t\t}\n    }\n\n    /**\n     * Sets the actual run start time.\n     * @param time The relative time of the benchmark start\n     */\n    public void setStartTime(int time) {\n        runInfo.benchStartTime = time;\n        runInfo.start = time + timer.getOffsetTime();        \n        timeSetLatch.countDown();\n\n        // After we know the start time, we calibrate\n        // the timer during the rampup.\n        timer.calibrate(displayName,\n                runInfo.benchStartTime + runInfo.rampUp * 1000);\n    }\n\n    /**\n     * This method kills off the current run.\n     * It terminates all threads.\n     */\n    public synchronized void kill() {\n        runAborted = true;\n        logger.warning(displayName + \": Killing benchmark run\");\n        for (int i = 0; i < numThreads; i++) {\n\t\t\tif (agentThreads[i] != null && agentThreads[i].isAlive()) {\n\t\t\t\ttry {\n                    agentThreads[i].stopExecution();\n                } catch (Throwable t) {\n                    logger.log(Level.SEVERE, agentThreads[i].name +\n                            \": Error killing thread.\", t);\n                }\n\t\t\t}\n\t\t}\n        // cleanup\n        results = null;\n    }\n\n    /**\n     * Terminates all leftover threads remaining at the end of the run.\n     * Logs the stack trace for all these threads but does not actually\n     * wait for the threads to terminate (join). Terminate is called\n     * while join is hanging on some thread that refuses to terminate.\n     */\n    public synchronized void terminate() {\n        boolean terminationLogged = false;\n        int terminationCount = 0;\n        Throwable t = null;\n        for (int i = numThreads - 1; i > 0; i--) {\n\t\t\tif (agentThreads[i] != null && agentThreads[i].isAlive()) {\n\t\t\t\ttry {\n                    if (!terminationLogged) { // Log this only once.\n                        logger.warning(displayName +\n                                \": Forcefully terminating benchmark run\");\n                        terminationLogged = true;\n                    }\n                    t = new Throwable(\n                            \"Stack of non-terminating thread.\");\n                    t.setStackTrace(agentThreads[i].getStackTrace());\n                    logger.log(Level.FINE, agentThreads[i].name +\n                            \": Thread not Terminated. \" +\n                            \"Dumping stack and force termination.\", t);\n                    ++terminationCount;\n                    agentThreads[i].stopExecution();\n                } catch (Throwable e) {\n                    logger.log(Level.SEVERE, agentThreads[i].name +\n                            \": Error killing thread.\", e);\n                }\n\t\t\t}\n\t\t}\n\n        if (runInfo.agentInfo.startThreadNumber == 0 &&\n                runInfo.driverConfig.postRun != null &&\n                agentThreads[0] != null) {\n            if (agentThreads[0].getThreadState() ==\n                    AgentThread.RunState.RUNNING) {\n                try {\n                    if (!terminationLogged) { // Log this only once.\n                        logger.warning(displayName +\n                                \": Forcefully terminating benchmark run\");\n                        terminationLogged = true;\n                    }\n                    t = new Throwable(\n                            \"Stack of non-terminating thread.\");\n                    t.setStackTrace(agentThreads[0].getStackTrace());\n                    logger.log(Level.FINE, agentThreads[0].name +\n                            \": Thread not Terminated. \" +\n                            \"Dumping stack and force termination.\", t);\n                    ++terminationCount;\n                    agentThreads[0].stopExecution();\n                } catch (Throwable e) {\n                    logger.log(Level.SEVERE, agentThreads[0].name +\n                            \": Error killing thread.\", e);\n                }\n            }\n            postRunLatch.countDown();\n            agentThreads[0].waitThreadState(AgentThread.RunState.ENDED);\n        } else if (agentThreads[0] != null && agentThreads[0].isAlive()) {\n            try { // Just terminate it like any other thread.\n                if (!terminationLogged) { // Log this only once.\n                    logger.warning(displayName +\n                            \": Forcefully terminating benchmark run\");\n                    terminationLogged = true;\n                }\n                t = new Throwable(\n                        \"Stack of non-terminating thread.\");\n                t.setStackTrace(agentThreads[0].getStackTrace());\n                logger.log(Level.FINE, agentThreads[0].name +\n                        \": Thread not Terminated. \" +\n                        \"Dumping stack and force termination.\", t);\n                ++terminationCount;\n                agentThreads[0].stopExecution();\n            } catch (Throwable e) {\n                logger.log(Level.SEVERE, agentThreads[0].name +\n                        \": Error killing thread.\", e);\n            }\n        }\n        if (terminationCount > 0) {\n\t\t\tlogger.log(Level.WARNING, displayName + \": \" + terminationCount +\n                           \" threads forcefully terminated.\", t);\n\t\t}\n    }\n\n    /**\n     * Report stats from a run\n     * Each thread's result is obtained by calling that thread's getResult()\n     * All these results are then aggregated by calling one of the\n     * thread's getAggregateResult method.\n     * @return results\n     */\n    public Serializable getResults() {\n        Metrics[] results = new Metrics[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            results[i] = agentThreads[i].getResult();\n        }\n        Metrics agentStats = (Metrics) results[0].clone();\n        for (int index = 1; index < results.length; index++) {\n\t\t\tagentStats.add(results[index]);\n\t\t}\n        return agentStats;\n    }\n\n    /**\n     * Waits for all the threads to terminate.\n     */\n    public void join() {\n        for (int i = agentThreads.length - 1; i > 0; i--) {\n\t\t\twhile(agentThreads[i] != null && agentThreads[i].isAlive()) {\n\t\t\t\ttry {\n                    agentThreads[i].join();\n                } catch (InterruptedException e) {\n                \tlogger.log(Level.FINE, e.getMessage(), e);\n                }\n\t\t\t}\n\t\t}\n        if (runInfo.agentInfo.startThreadNumber == 0 &&\n                runInfo.driverConfig.postRun != null &&\n                agentThreads[0] != null) {// first agent, preRun\n            postRunLatch.countDown();\n            try {\n                agentThreads[0].join();\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }            \n        } else if (agentThreads[0] != null && agentThreads[0].isAlive()) {\n            try {\n                agentThreads[0].join();\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n        }\n        master = null;\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     */\n    public void unreferenced() {\n        logger.warning(displayName + \": unreferenced() called!\");\n        // Seems like there is a bug in JDK1.5 and unreferenced is called\n        // sporadically. So it is better we do not really kill it.\n        /*\n        kill();\n        join();\n        */\n    }\n\n    /**\n     * AgentImpl's main method\n     * @param argv the arguments passed to the java command\n     */\n    public static void main(String [] argv) {\n\n        //\t\tLocateRegistry.createRegistry();\n        System.setSecurityManager (new RMISecurityManager());\n        if (argv.length != 3) {\n            System.err.println(\"Usage: AgentImpl\" +\n                    \" <driverName> <agentId> <masterMachine>\");\n            System.exit(-1);\n        }\n        String driverName = argv[0];\n        String agentId = argv[1];\n        String master = argv[2];\n\n        // This needs to be set by the driver code instead\n        // URL.setURLStreamHandlerFactory(new URLStreamHandlerFactory());\n\n        try {\n            agentImpl = new AgentImpl(driverName, agentId, master);\n        } catch(Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    /*\n    static class ContextFactory implements TimeRecorderFactory {\n        public TimeRecorder getTimeRecorder() {\n            return DriverContext.getContext();\n        }\n    }\n    */\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: AgentImpl.java,v 1.12 2008/05/14 07:06:00 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.common.Utilities;\nimport com.sun.faban.driver.util.Timer;\n\nimport java.io.File;\nimport java.io.Serializable;\nimport java.rmi.RMISecurityManager;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * AgentImpl executes the driver threads of any given subtype.\n * It receives commands from the Master.\n * The AgentImpl is responsible for spawning and managing\n * threads, synchronizing between the threads and aggregating\n * the stats from all threads.\n *\n * @author Shanti Subramanyam\n * @see com.sun.faban.driver.core.Agent\n * @see com.sun.faban.driver.core.AgentThread\n */\npublic class AgentImpl extends UnicastRemoteObject\n        implements Agent, Unreferenced, Runnable {\n\n\tprivate static final long serialVersionUID = 1L;\n\tstatic AgentImpl agentImpl;\n    Master master;\n    RunInfo runInfo;\n    int driverType;\n    Timer timer;\n    AgentThread[] agentThreads;\n    String agentType;\n    Metrics results[] = null;\n    int numThreads;\n    String driverBase;\n    private Logger logger;\n    private String agentName;\n    private String agentId;\n    private String displayName;\n    private String className;\n    long startTime = Long.MIN_VALUE;\n    CountDownLatch threadStartLatch;\n    CountDownLatch timeSetLatch;\n    CountDownLatch preRunLatch;\n    CountDownLatch postRunLatch;\n    private boolean runAborted = false;\n\n    /**\n     * Constructor\n     * Create properties object from file\n     */\n    AgentImpl(String driverName, String agentId, String master)\n            throws Exception {\n        this (driverName, agentId);\n\n        RegistryLocator.getRegistry(master).\n                reregister(agentType, agentName, this);\n\n        logger.fine(displayName + \" started ...\");\n    }\n\n\n    AgentImpl(String driverName, String agentId) throws RemoteException {\n        className = getClass().getName();\n        logger = Logger.getLogger(className);\n        agentType = driverName + \"Agent\";\n        agentName = driverName + '.' + agentId;\n        displayName = agentType + '[' + agentId + ']';\n        this.agentId = agentId;\n        Thread.setDefaultUncaughtExceptionHandler(\n                new Thread.UncaughtExceptionHandler() {\n                    public void uncaughtException(Thread t, Throwable e) {\n                        logger.log(Level.SEVERE, t.getName() + \": \" +\n                                e.getMessage(), e);\n                    }\n                }\n        );\n    }\n\n    /**\n     * Configures each agents with the props passed\n     * The threads are created at this point\n     * @param master the remote interface to the Master\n     * @param runInfo run information passed by Master\n     * @param driverType \n     * @param timer BenchmarkDefinition Start time\n     * @throws RemoteException \n     */\n    public void configure(Master master, RunInfo runInfo, int driverType,\n                          Timer timer) throws RemoteException {\n\n        runAborted = false;\n        this.master = master;\n        this.runInfo = runInfo;\n        this.driverType = driverType;\n        this.timer = timer;\n\n        // driverBase most accurate if faban.driver.base is provided.\n        driverBase = System.getProperty(\"faban.driver.base\");\n        if (driverBase == null) {\n            File driverJar = Utilities.getJarFile(\n                                    runInfo.driverConfig.driverClass);\n            if (driverJar != null)\n                // Else find with jarpath/..\n                driverBase = driverJar.getParentFile().getParent();\n        }\n\n        threadStartLatch = new CountDownLatch(runInfo.agentInfo.threads);\n        timeSetLatch = new CountDownLatch(1);\n        if (runInfo.agentInfo.startThreadNumber == 0) { // first agent\n            if (runInfo.driverConfig.preRun != null) {\n\t\t\t\tpreRunLatch = new CountDownLatch(1);\n\t\t\t}\n            if (runInfo.driverConfig.postRun != null) {\n\t\t\t\tpostRunLatch = new CountDownLatch(1);\n\t\t\t}\n        }\n        try {\n            runInfo.postDeserialize();\n        } catch (ClassNotFoundException e) {\n            logger.severe(e.getMessage());\n            logger.throwing(className, \"configure\", e);\n            master.abortRun();\n        }\n\n        runInfo.agentInfo.agentType = agentType;\n        results = null;\t\t// so that we don't use old results\n        calibrateTime();\n\n        // Agents will Start the threads in parallel if\n        // parallelThreadStart is set.\n        if (runInfo.parallelAgentThreadStart) {\n            // start thread and return\n            new Thread(this).start();\n            if (runInfo.agentInfo.startThreadNumber == 0 &&\n                    runInfo.driverConfig.preRun != null) {\n\t\t\t\ttry {\n                    preRunLatch.await();\n                } catch (InterruptedException e) {\n                    // Do nothing.\n                }\n\t\t\t}\n        } else {\n            // block until done and return\n            this.run();\n        }\n    }\n\n    /**\n     * Calibrates the time with the master.\n     * @throws RemoteException A network error occurred.\n     */\n    private void calibrateTime() throws RemoteException {\n        long t1 = 0;\n        long tm = 0;\n        int diff = 0;\n        int retries = 0;\n\n        // Just in case we run into GC situations, the times can be nasty.\n        // In that case we retry up to 5 times.\n        for (; retries < 5; retries++) {\n            t1 = System.currentTimeMillis();\n            tm = master.currentTimeMillis();\n            long t2 = System.currentTimeMillis();\n\n            // We really don't know when between t1 and t2 tm occurred.\n            // but if we assume it to be short enough, we can savely\n            // use the avg with errors in the 5 millisec range.\n            diff  = (int) (t2 - t1);\n            if (diff <= 10) {\n\t\t\t\tbreak;\n\t\t\t}\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            \tlogger.fine(\"Sleep Interrupted: \" + e.getMessage());\n            }\n        }\n\n        // After 5 retries, if the simple call to Master.currentTimeMillis\n        // is still too time consuming, we abort the whole thing.\n        if (retries >= 5) {\n                logger.log(Level.SEVERE, \"Roundtrip to master took \" + diff +\n                        \" ms. Too high latency!\");\n                master.abortRun();\n        }\n\n        // Doing a simple avg on millis can overwhelm the long system.\n        // So we subtract first.\n        int offset = diff / 2 + ((int) (t1 - tm));\n        timer.adjustBaseTime(offset);\n    }\n\n    /**\n     * @see java.lang.Runnable#run()\n     */\n    public void run() {\n        // Create the required number of threads\n        numThreads = runInfo.agentInfo.threads;\n        agentThreads = new AgentThread[numThreads];\n        long nsBetweenThreadStart = runInfo.msBetweenThreadStart * 1000000;\n        try {\n            // We use System.nanoTime() here directly\n            // instead of timer.getTime().\n            long baseTime = System.nanoTime();\n            int count = 0;\n            for (; count < numThreads && !runAborted; count++) {\n                int globalThreadId = runInfo.agentInfo.startThreadNumber +\n                        count;\n                agentThreads[count] = AgentThread.getInstance(agentType,\n                        agentId, globalThreadId,\n                        runInfo.driverConfig.driverClass, timer, this);\n                agentThreads[count].start();\n\n                // Ensure the preRun is done before proceeding.\n                if (globalThreadId == 0 &&\n                        runInfo.driverConfig.preRun != null) {\n                    preRunLatch.await();\n\n                    // Adjust baseTime if the preRun takes long.\n                    long currentTime = System.nanoTime();\n\n                    if (currentTime - baseTime > nsBetweenThreadStart) {\n\t\t\t\t\t\tbaseTime = currentTime - nsBetweenThreadStart;\n\t\t\t\t\t}                    \n                }\n\n                // We ensure we catch up with the configured thread starting\n                // rate. If we fall short, we sleep less until we caught up.\n                long wakeupTime = nsBetweenThreadStart * (count + 1) +\n                        baseTime;\n                long sleepTime = wakeupTime - System.nanoTime();\n\n                // In case we fall short, we sleep only 1/3 the interval\n                if (sleepTime <= 0) {\n\t\t\t\t\tsleepTime = nsBetweenThreadStart / 3;\n                    wakeupTime = System.nanoTime() + sleepTime;\n\t\t\t\t}\n\n                timer.wakeupAt(wakeupTime);\n            }\n            if (runAborted) {\n\t\t\t\tlogger.warning(displayName + \": Run aborted before starting \" +\n                        numThreads + \" driver threads.\\n\" + count +\n                        \" threads were started.\");\n\t\t\t} else {\n\t\t\t\tlogger.info(displayName + \": Successfully started \" +\n                        numThreads + \" driver threads.\");\n\t\t\t}\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage(), e);\n            try {\n                master.abortRun();\n            } catch (RemoteException e1) {\n            \tlogger.log(Level.FINE, e1.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * Contacts the master to abort the run. Don't kill until\n     * master calls kill.\n     */\n    public synchronized void abortRun() {\n        if (runAborted) {\n\t\t\treturn;     // the master again. Once per agent is enough.\n\t\t}\n        runAborted = true;\n        try {\n            master.abortRun();\n        } catch (RemoteException e) {\n            logger.log(Level.SEVERE, \"Error contacting master to abort run.\",\n                    e);\n        }\n    }\n\n    /**\n     * Wait until all threads are started.\n     */\n    public void waitForThreadStart() {\n        if (!runAborted) {\n\t\t\ttry {\n                threadStartLatch.await();\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n\t\t}\n    }\n\n    /**\n     * Sets the actual run start time.\n     * @param time The relative millisec time of the benchmark start\n     */\n    public void setStartTime(int time) {\n        runInfo.benchStartTime = time;\n        startTime = timer.toAbsNanos(time);\n        runInfo.start = timer.toAbsMillis(time);\n        timeSetLatch.countDown();\n\n        // After we know the start time, we calibrate\n        // the timer during the rampup.\n        timer.calibrate(displayName, time + runInfo.rampUp * 1000000000l);\n    }\n\n    /**\n     * This method kills off the current run.\n     * It terminates all threads.\n     */\n    public synchronized void kill() {\n        runAborted = true;\n        logger.warning(displayName + \": Killing benchmark run\");\n        for (int i = 0; i < numThreads; i++) {\n\t\t\tif (agentThreads[i] != null && agentThreads[i].isAlive()) {\n\t\t\t\ttry {\n                    agentThreads[i].stopExecution();\n                } catch (Throwable t) {\n                    logger.log(Level.SEVERE, agentThreads[i].name +\n                            \": Error killing thread.\", t);\n                }\n\t\t\t}\n\t\t}\n        // cleanup\n        results = null;\n    }\n\n    /**\n     * Terminates all leftover threads remaining at the end of the run.\n     * Logs the stack trace for all these threads but does not actually\n     * wait for the threads to terminate (join). Terminate is called\n     * while join is hanging on some thread that refuses to terminate.\n     */\n    public synchronized void terminate() {\n        boolean terminationLogged = false;\n        int terminationCount = 0;\n        Throwable t = null;\n        for (int i = numThreads - 1; i > 0; i--) {\n\t\t\tif (agentThreads[i] != null && agentThreads[i].isAlive()) {\n\t\t\t\ttry {\n                    if (!terminationLogged) { // Log this only once.\n                        logger.warning(displayName +\n                                \": Forcefully terminating benchmark run\");\n                        terminationLogged = true;\n                    }\n                    t = new Throwable(\n                            \"Stack of non-terminating thread.\");\n                    t.setStackTrace(agentThreads[i].getStackTrace());\n                    logger.log(Level.FINE, agentThreads[i].name +\n                            \": Thread not Terminated. \" +\n                            \"Dumping stack and force termination.\", t);\n                    ++terminationCount;\n                    agentThreads[i].stopExecution();\n                } catch (Throwable e) {\n                    logger.log(Level.SEVERE, agentThreads[i].name +\n                            \": Error killing thread.\", e);\n                }\n\t\t\t}\n\t\t}\n\n        if (runInfo.agentInfo.startThreadNumber == 0 &&\n                runInfo.driverConfig.postRun != null &&\n                agentThreads[0] != null) {\n            if (agentThreads[0].getThreadState() ==\n                    AgentThread.RunState.RUNNING) {\n                try {\n                    if (!terminationLogged) { // Log this only once.\n                        logger.warning(displayName +\n                                \": Forcefully terminating benchmark run\");\n                        terminationLogged = true;\n                    }\n                    t = new Throwable(\n                            \"Stack of non-terminating thread.\");\n                    t.setStackTrace(agentThreads[0].getStackTrace());\n                    logger.log(Level.FINE, agentThreads[0].name +\n                            \": Thread not Terminated. \" +\n                            \"Dumping stack and force termination.\", t);\n                    ++terminationCount;\n                    agentThreads[0].stopExecution();\n                } catch (Throwable e) {\n                    logger.log(Level.SEVERE, agentThreads[0].name +\n                            \": Error killing thread.\", e);\n                }\n            }\n            postRunLatch.countDown();\n            agentThreads[0].waitThreadState(AgentThread.RunState.ENDED);\n        } else if (agentThreads[0] != null && agentThreads[0].isAlive()) {\n            try { // Just terminate it like any other thread.\n                if (!terminationLogged) { // Log this only once.\n                    logger.warning(displayName +\n                            \": Forcefully terminating benchmark run\");\n                    terminationLogged = true;\n                }\n                t = new Throwable(\n                        \"Stack of non-terminating thread.\");\n                t.setStackTrace(agentThreads[0].getStackTrace());\n                logger.log(Level.FINE, agentThreads[0].name +\n                        \": Thread not Terminated. \" +\n                        \"Dumping stack and force termination.\", t);\n                ++terminationCount;\n                agentThreads[0].stopExecution();\n            } catch (Throwable e) {\n                logger.log(Level.SEVERE, agentThreads[0].name +\n                        \": Error killing thread.\", e);\n            }\n        }\n        if (terminationCount > 0) {\n\t\t\tlogger.log(Level.WARNING, displayName + \": \" + terminationCount +\n                           \" threads forcefully terminated.\", t);\n\t\t}\n    }\n\n    /**\n     * Report stats from a run\n     * Each thread's result is obtained by calling that thread's getResult()\n     * All these results are then aggregated by calling one of the\n     * thread's getAggregateResult method.\n     * @return results\n     */\n    public Serializable getResults() {\n        Metrics[] results = new Metrics[numThreads];\n        for (int i = 0; i < numThreads; i++) {\n            results[i] = agentThreads[i].getResult();\n        }\n        Metrics agentStats = (Metrics) results[0].clone();\n        for (int index = 1; index < results.length; index++) {\n\t\t\tagentStats.add(results[index]);\n\t\t}\n        return agentStats;\n    }\n\n    /**\n     * Waits for all the threads to terminate.\n     */\n    public void join() {\n        for (int i = agentThreads.length - 1; i > 0; i--) {\n\t\t\twhile(agentThreads[i] != null && agentThreads[i].isAlive()) {\n\t\t\t\ttry {\n                    agentThreads[i].join();\n                } catch (InterruptedException e) {\n                \tlogger.log(Level.FINE, e.getMessage(), e);\n                }\n\t\t\t}\n\t\t}\n        if (runInfo.agentInfo.startThreadNumber == 0 &&\n                runInfo.driverConfig.postRun != null &&\n                agentThreads[0] != null) {// first agent, preRun\n            postRunLatch.countDown();\n            try {\n                agentThreads[0].join();\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }            \n        } else if (agentThreads[0] != null && agentThreads[0].isAlive()) {\n            try {\n                agentThreads[0].join();\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n        }\n        master = null;\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     */\n    public void unreferenced() {\n        logger.warning(displayName + \": unreferenced() called!\");\n        // Seems like there is a bug in JDK1.5 and unreferenced is called\n        // sporadically. So it is better we do not really kill it.\n        /*\n        kill();\n        join();\n        */\n    }\n\n    /**\n     * AgentImpl's main method\n     * @param argv the arguments passed to the java command\n     */\n    public static void main(String [] argv) {\n\n        //\t\tLocateRegistry.createRegistry();\n        System.setSecurityManager (new RMISecurityManager());\n        if (argv.length != 3) {\n            System.err.println(\"Usage: AgentImpl\" +\n                    \" <driverName> <agentId> <masterMachine>\");\n            System.exit(-1);\n        }\n        String driverName = argv[0];\n        String agentId = argv[1];\n        String master = argv[2];\n\n        // This needs to be set by the driver code instead\n        // URL.setURLStreamHandlerFactory(new URLStreamHandlerFactory());\n\n        try {\n            agentImpl = new AgentImpl(driverName, agentId, master);\n        } catch(Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    /*\n    static class ContextFactory implements TimeRecorderFactory {\n        public TimeRecorder getTimeRecorder() {\n            return DriverContext.getContext();\n        }\n    }\n    */\n}\n","lineNo":230}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.14 2008/03/05 02:50:26 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/** Number of response time buckets in histogram. */\n    public static final int RESPBUCKETS = 100;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    protected int respBucketSize;  // Size of each response time bucket, in ms\n    protected int delayBucketSize; // Size of each delay time bucket, in ms\n    protected int graphBucketSize;  // Size of each graph bucket, in ms\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected int[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected int[] delayMax;\n\n    /** Minimum delay times. */\n    protected int[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time */\n    protected long startTime;\n\n    /** End time as offset from start time */\n    protected int endTime;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected int[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n        \n        txTypes = driverConfig.operations.length;\n        \n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new int[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new int[txTypes];\n        delayMin = new int[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ms.\n        graphBucketSize = driverConfig.graphInterval * 1000;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new int[txTypes][graphBuckets];\n\n        // TODO: Consider the Unit of time on the operation\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        double respHistMax = max90th * 5d;  // 5 x max response time\n        respBucketSize = (int) Math.ceil(1000d * respHistMax / RESPBUCKETS);\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ms\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTime = timingInfo.respondTime;\n        int responseTime = endTime - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTime +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        int elapsedTime = endTime - RunInfo.getInstance().benchStartTime;\n\n        if(elapsedTime > 0) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                thruputGraph[txType][elapsedTime / graphBucketSize]++;\n                respGraph[txType][elapsedTime / graphBucketSize] +=\n                        responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            if ((responseTime / respBucketSize) >= RESPBUCKETS) {\n                respHist[txType][RESPBUCKETS - 1]++;\n\t\t\t} else {\n                respHist[txType][responseTime / respBucketSize]++;\n\t\t\t}\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTime = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        int actualDelayTime = -1;\n        int actualCycleTime = -1;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        if ((actualDelayTime / delayBucketSize) >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][actualDelayTime / delayBucketSize]++;\n\t\t}\n        if ((thread.delayTime[thread.mixId] / delayBucketSize) >=\n                DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType]\n                    [thread.delayTime[thread.mixId] / delayBucketSize]++;\n\t\t}\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] +=\n                                        s.targetedDelayHist[i][j];\n\t\t\t}\n\t\t}\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new int[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1000d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        space(8, buffer).append(\"<responseTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / 1000d);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / 1000d);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90);\n                int j = 0;\n                for (; j < RESPBUCKETS; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                resp90 = (j + 1) * respBucketSize / 1000d;\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1000d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1000d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1000d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1000d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        printGraph(b, \"Throughput\", graphBucketSize / 1000d,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize / 1000d);\n\n        printGraph(b, \"Response Times\", graphBucketSize / 1000d,\n                \"%.0f\", \"%.5f\", respGraph, thruputGraph, 1000d);\n\n        printHistogram(b, \"Frequency Distribution of Response Times\",\n                respBucketSize / 1000d, \"%5.3f\", respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times\",\n                delayBucketSize / 1000d, \"%5.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times\", delayBucketSize / 1000d, \"%5.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.15 2008/05/14 07:06:02 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/** Number of response time buckets in histogram. */\n    public static final int RESPBUCKETS = 100;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    protected long respBucketSize;  // Size of each response time bucket, in ns\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n        \n        txTypes = driverConfig.operations.length;\n        \n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        double respHistMax = max90th * 5d;  // 5 x max response time\n        respBucketSize = (long) Math.ceil(1e9d * respHistMax / RESPBUCKETS);\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            if ((responseTime / respBucketSize) >= RESPBUCKETS) {\n                respHist[txType][RESPBUCKETS - 1]++;\n\t\t\t} else {\n                respHist[txType][(int) (responseTime / respBucketSize)]++;\n\t\t\t}\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        int bucket = (int) (actualDelayTime / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][bucket]++;\n\t\t}\n        bucket = (int) (thread.delayTime[thread.mixId] / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90);\n                int j = 0;\n                for (; j < RESPBUCKETS; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                resp90 = (j + 1) * respBucketSize / precision;\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        long precision = driver.responseTimeUnit.toNanos(1l);\n\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times\",\n                respBucketSize / 1e9d, \"%5.3f\", respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times\",\n                delayBucketSize / 1e9d, \"%5.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times\", delayBucketSize / 1e9d, \"%5.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","lineNo":299}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.14 2008/03/05 02:50:26 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/** Number of response time buckets in histogram. */\n    public static final int RESPBUCKETS = 100;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    protected int respBucketSize;  // Size of each response time bucket, in ms\n    protected int delayBucketSize; // Size of each delay time bucket, in ms\n    protected int graphBucketSize;  // Size of each graph bucket, in ms\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected int[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected int[] delayMax;\n\n    /** Minimum delay times. */\n    protected int[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time */\n    protected long startTime;\n\n    /** End time as offset from start time */\n    protected int endTime;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected int[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n        \n        txTypes = driverConfig.operations.length;\n        \n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new int[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new int[txTypes];\n        delayMin = new int[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ms.\n        graphBucketSize = driverConfig.graphInterval * 1000;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new int[txTypes][graphBuckets];\n\n        // TODO: Consider the Unit of time on the operation\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        double respHistMax = max90th * 5d;  // 5 x max response time\n        respBucketSize = (int) Math.ceil(1000d * respHistMax / RESPBUCKETS);\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ms\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTime = timingInfo.respondTime;\n        int responseTime = endTime - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTime +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        int elapsedTime = endTime - RunInfo.getInstance().benchStartTime;\n\n        if(elapsedTime > 0) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                thruputGraph[txType][elapsedTime / graphBucketSize]++;\n                respGraph[txType][elapsedTime / graphBucketSize] +=\n                        responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            if ((responseTime / respBucketSize) >= RESPBUCKETS) {\n                respHist[txType][RESPBUCKETS - 1]++;\n\t\t\t} else {\n                respHist[txType][responseTime / respBucketSize]++;\n\t\t\t}\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTime = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        int actualDelayTime = -1;\n        int actualCycleTime = -1;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        if ((actualDelayTime / delayBucketSize) >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][actualDelayTime / delayBucketSize]++;\n\t\t}\n        if ((thread.delayTime[thread.mixId] / delayBucketSize) >=\n                DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType]\n                    [thread.delayTime[thread.mixId] / delayBucketSize]++;\n\t\t}\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] +=\n                                        s.targetedDelayHist[i][j];\n\t\t\t}\n\t\t}\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new int[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1000d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        space(8, buffer).append(\"<responseTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / 1000d);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / 1000d);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90);\n                int j = 0;\n                for (; j < RESPBUCKETS; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                resp90 = (j + 1) * respBucketSize / 1000d;\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1000d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1000d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1000d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1000d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        printGraph(b, \"Throughput\", graphBucketSize / 1000d,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize / 1000d);\n\n        printGraph(b, \"Response Times\", graphBucketSize / 1000d,\n                \"%.0f\", \"%.5f\", respGraph, thruputGraph, 1000d);\n\n        printHistogram(b, \"Frequency Distribution of Response Times\",\n                respBucketSize / 1000d, \"%5.3f\", respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times\",\n                delayBucketSize / 1000d, \"%5.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times\", delayBucketSize / 1000d, \"%5.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Metrics.java,v 1.15 2008/05/14 07:06:02 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.common.TextTable;\nimport com.sun.faban.driver.CustomMetrics;\nimport com.sun.faban.driver.CycleType;\nimport com.sun.faban.driver.RunControl;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.Formatter;\nimport java.util.logging.Logger;\n\n/**\n * Generic statistics collection and reporting facility. For simple agents\n * without any additional statistics, this class can be used right away.\n * This class should also be extended to collect all additional statistics.\n *\n * @author Akara Sucharitakul\n */\npublic class Metrics implements Serializable, Cloneable {\n\n\tprivate static final long serialVersionUID = 1L;\n\n\t/** Number of response time buckets in histogram. */\n    public static final int RESPBUCKETS = 100;\n\n    /** Number of delay time buckets in histogram. */\n    public static final int DELAYBUCKETS = 100;\n\n    protected long respBucketSize;  // Size of each response time bucket, in ns\n    protected long delayBucketSize; // Size of each delay time bucket, in ns\n    protected long graphBucketSize;  // Size of each graph bucket, in ns\n    protected int graphBuckets;     // Number of graph buckets\n\n    int threadCnt = 0;\t\t// Threads this stat object is representing\n\n    /* Stats for all transaction types - the first dimension of the array\n     * is always the operation id. This is the index into the operations\n     * array of the mix. The second dimension, existent only for histograms\n     * is the bucket.\n     */\n\n\t/**\n     * Number of successful transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] txCntStdy;\n\n    /**\n     * Number of successful transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] txCntTotal;\n\n    /**\n     * Number of failed transactions during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected int[] errCntStdy;\n\n    /**\n     * Number of failed transactions total.\n     * This is used for in-flight reporting only.\n     */\n    protected int[] errCntTotal;\n\n    /**\n     * The mix ratio of the operation during steady state.\n     */\n    protected double[] mixRatio;\n\n    /**\n     * Number of transactions the delay time\n     * was successfuly recorded. Note that some transactions\n     * while failing may still have the delay time recorded.\n     * Transactions that do not have the delay time recorded\n     * are transactions that fail before the critical section.\n     */\n    protected int[] delayCntStdy;\n    /**\n     * Sum of response times during steady state.\n     * This is used for final reporting and in-flight reporting of averages.\n     */\n    protected double[] respSumStdy;\n\n    /**\n     * Sun of response times total.\n     * This is used for in-flight reporting only.\n     */\n    protected double[] respSumTotal;\n\n    /** Max. response time. */\n    protected long[] respMax;\n\n    /** Sum of delay (cycle/think) times. */\n    protected long[] delaySum;\n\n    /** Targeted delay times. */\n    protected long[] targetedDelaySum;\n\n    /** Maximum delay times. */\n    protected long[] delayMax;\n\n    /** Minimum delay times. */\n    protected long[] delayMin;\n\n    /** Sum of cycle time (not think time) for little's law verification. */\n    protected long cycleSum = 0;\n\n    /** Sum of elapsed times. */\n    protected double[] elapse;\n\n    /** Response time histogram. */\n    protected int[][] respHist;\n\n    /** Histogram of actual delay times. */\n    protected int[][] delayHist;\n\n    /** Histogram of selected delay times. */\n    protected int[][] targetedDelayHist;\n\n    /** Start time as absolute time, in ms */\n    protected long startTime;\n\n    /** End time as ms offset from start time */\n    protected long endTime;\n\n    /** End time as nanosec time */\n    protected transient long endTimeNanos;\n\n    /**\n     * The thruput graph. This is updated throughout the run, not only\n     * in steady state. The graph accumulates tx count during the run. The\n     * final results need to be divided by the graph bucket size.\n     */\n    protected int[][] thruputGraph;\t/* Thruput graph */\n\n    /**\n     * Graph of accumulated response times over the course of the run.\n     * This data need to be divided by the accumulated tx count for the\n     * bucket to get the avg response time in that bucket.\n     */\n    protected long[][] respGraph;\n\n    /** The attached custom metrics */\n    protected CustomMetrics attachment = null;\n\n    /**\n     * The final resulting metric. This field is only populated after\n     * printing the summary report\n     */\n    protected double metric;\n\n    /* Convenience variables */\n    protected int driverType;\n    protected String driverName;\n    protected int txTypes;\n    protected String[] txNames;\n    protected int stdyState;\n    protected transient AgentThread thread;    \n    \n    /**\n     * @param agent\n     */\n    public Metrics(AgentThread agent) {\n        this.thread = agent;\n        RunInfo runInfo = RunInfo.getInstance();\n        driverType = agent.agent.driverType;\n        RunInfo.DriverConfig driverConfig = runInfo.driverConfig;\n        driverName = driverConfig.name;\n        \n        txTypes = driverConfig.operations.length;\n        \n        stdyState = runInfo.stdyState;\n\n        // We cannot serialize the agent itself but we only need the names.\n        txNames = new String[txTypes];\n        for (int i = 0; i < driverConfig.operations.length; i++) {\n\t\t\ttxNames[i] = driverConfig.operations[i].name;\n\t\t}\n\n        // Initialize all the arrays.\n        txCntStdy = new int[txTypes];\n        txCntTotal = new int[txTypes];\n        errCntStdy = new int[txTypes];\n        errCntTotal = new int[txTypes];\n        delayCntStdy = new int[txTypes];\n        respSumStdy = new double[txTypes];\n        respSumTotal = new double[txTypes];\n        respMax = new long[txTypes];\n        delaySum = new long[txTypes];\n        delayMax = new long[txTypes];\n        delayMin = new long[txTypes];\n        for (int i = 0; i < delayMin.length; i++) {\n\t\t\tdelayMin[i] = Integer.MAX_VALUE; // init to the largest number\n\t\t}\n        targetedDelaySum = new long[txTypes];\n        elapse = new double[txTypes];\n        respHist = new int[txTypes][RESPBUCKETS];\n        delayHist = new int[txTypes][DELAYBUCKETS];\n        targetedDelayHist = new int[txTypes][DELAYBUCKETS];\n\n        // The actual run configuration is used in case it represents time.\n        // This prevents us from over-allocating the thruput histogram.\n        if (driverConfig.runControl == RunControl.TIME) {\n\t\t\tgraphBuckets = 1 + (runInfo.rampUp + runInfo.stdyState +\n                    runInfo.rampDown) / driverConfig.graphInterval;\n\t\t} else {\n\t\t\tgraphBuckets = (int) Math.ceil(3600d * // Convert hr => s\n                    runInfo.maxRunTime / driverConfig.graphInterval);\n\t\t}\n\n        // Convert to ns.\n        graphBucketSize = driverConfig.graphInterval * 1000000000l;\n        thruputGraph = new int[txTypes][graphBuckets];\n        respGraph = new long[txTypes][graphBuckets];\n\n        // Find the maximum 90th% resp among all ops, in seconds\n        double max90th = driverConfig.operations[0].max90th;\n        for (int i = 1; i < txTypes; i++) {\n\t\t\tif (driverConfig.operations[i].max90th > max90th) {\n\t\t\t\tmax90th = driverConfig.operations[i].max90th;\n\t\t\t}\n\t\t}\n\n        double respHistMax = max90th * 5d;  // 5 x max response time\n        respBucketSize = (long) Math.ceil(1e9d * respHistMax / RESPBUCKETS);\n\n        double delayHistMax = driverConfig.operations[0].\n                cycle.getHistogramMax();\n\n        // Find the max delay time histogram among ops, in ns\n        for (int i = 1; i < txTypes; i++) {\n            double opMaxDelay = driverConfig.operations[i].\n                    cycle.getHistogramMax();\n            if (opMaxDelay > delayHistMax) {\n\t\t\t\tdelayHistMax = opMaxDelay;\n\t\t\t}\n        }\n        delayBucketSize = (int) Math.ceil(delayHistMax / DELAYBUCKETS);\n    }\n\n    /**\n     * Updates the various stats for a successful transaction.\n     */\n    public void recordTx() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n        endTimeNanos = timingInfo.respondTime;\n        long responseTime = endTimeNanos - timingInfo.invokeTime -\n                           timingInfo.pauseTime;\n        if (responseTime < 0) {\n            thread.logger.warning(thread.name +\n                    \":Pause time too large - invoke : \" +\n                    timingInfo.invokeTime + \", respond : \" + endTimeNanos +\n                    \", pause : \" + timingInfo.pauseTime);\n            responseTime = 0; // Set it to 0 in this case so it does not\n                              // destroy the whole run.\n        }\n\n        long elapsedTime = Long.MIN_VALUE;\n        if (thread.agent.startTime != Long.MIN_VALUE)\n            elapsedTime = endTimeNanos - thread.agent.startTime;\n\n        if(elapsedTime > 0l) {\n            if ((elapsedTime / graphBucketSize) >= graphBuckets) {\n                thruputGraph[txType][graphBuckets - 1]++;\n                respGraph[txType][graphBuckets - 1] += responseTime;\n            } else {\n                int bucket = (int) (elapsedTime / graphBucketSize);\n                thruputGraph[txType][bucket]++;\n                respGraph[txType][bucket] += responseTime;\n            }\n        }\n\n        txCntTotal[txType]++;\n        respSumTotal[txType] += responseTime;\n\n        if (!thread.inRamp) {\n            txCntStdy[txType]++;\n            respSumStdy[txType] += responseTime;\n\n            // post in histogram of response times\n            if ((responseTime / respBucketSize) >= RESPBUCKETS) {\n                respHist[txType][RESPBUCKETS - 1]++;\n\t\t\t} else {\n                respHist[txType][(int) (responseTime / respBucketSize)]++;\n\t\t\t}\n\n            if (responseTime > respMax[txType]) {\n\t\t\t\trespMax[txType] = responseTime;\n\t\t\t}\n        }\n    }\n\n    /**\n     * Records the error count for an unsuccessful transaction.\n     */\n    public void recordError() {\n\n        if (threadCnt == 0) {\n            threadCnt = 1;\n\t\t}\n\n        int txType = thread.currentOperation;\n\n        errCntTotal[txType]++;\n\n        if (!thread.inRamp) {\n            errCntStdy[txType]++;\n\t\t}\n\n        endTimeNanos = thread.driverContext.timingInfo.respondTime;\n    }\n\n    /**\n     * Records the delay (think/cycle) time. The delay time is recorded\n     * regardless of whether a transaction succeeds or fails.\n     */\n    public void recordDelayTime() {\n\n        int txType = thread.previousOperation[thread.mixId];\n        if (txType < 0) {// First cycle, previous op is not there. Don't record.\n            return;\n\t\t}\n\n        DriverContext.TimingInfo timingInfo =\n                thread.driverContext.timingInfo;\n\n        long actualDelayTime = -1l;\n        long actualCycleTime = -1l;\n\n        if (thread.isSteadyState(thread.startTime[thread.mixId],\n                                 timingInfo.invokeTime)) {\n            actualCycleTime = timingInfo.invokeTime -\n                              thread.startTime[thread.mixId];\n\t\t}\n\n        CycleType cycleType = RunInfo.getInstance().driverConfig.\n                operations[thread.currentOperation].cycle.cycleType;\n        switch (cycleType) {\n            case CYCLETIME :\n                actualDelayTime = actualCycleTime; break;\n            case THINKTIME :\n                if (thread.endTime[thread.mixId] >= 0) {// Normal\n                    if (thread.isSteadyState(thread.endTime[thread.mixId],\n                                             timingInfo.invokeTime)) {\n                        actualDelayTime = timingInfo.invokeTime -\n                                thread.endTime[thread.mixId];\n\t\t\t\t\t}\n                } else { // Exceptions occurred, no respond time available\n                    actualDelayTime = actualCycleTime;\n                }\n        }\n\n        if (thread.mixId == 0 && actualCycleTime >= 0) {\n        // cycleSum is for little's law verification.\n        // We do not count background cycles to the cycleSum or the\n        // verification will be totally off.\n            cycleSum += actualCycleTime;\n\t\t}\n\n        if (actualDelayTime < 0) {\n            return;\n\t\t}\n\n        ++delayCntStdy[txType];\n        delaySum[txType] += actualDelayTime;\n        targetedDelaySum[txType] += thread.delayTime[thread.mixId];\n\n\n        if (actualDelayTime > delayMax[txType]) {\n            delayMax[txType] = actualDelayTime;\n\t\t}\n        if (actualDelayTime < delayMin[txType]) {\n            delayMin[txType] = actualDelayTime;\n\t\t}\n\n        int bucket = (int) (actualDelayTime / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            delayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            delayHist[txType][bucket]++;\n\t\t}\n        bucket = (int) (thread.delayTime[thread.mixId] / delayBucketSize);\n        if (bucket >= DELAYBUCKETS) {\n            targetedDelayHist[txType][DELAYBUCKETS - 1]++;\n\t\t} else {\n            targetedDelayHist[txType][bucket]++;\n        }\n    }\n\n    /**\n     * Wraps up the metric for serialization/transportation and/or\n     * further processing.\n     */\n    public void wrap() {\n        endTime = (endTimeNanos - thread.agent.startTime) / 1000000l;\n    }\n\n    /**\n     * This method aggregates the stats with the stats of another thread.\n     * It is called repeatedly, and the called passes it the stats of a\n     * different thread, each time\n     * @param s stats of next thread to be aggregated\n     */\n\tpublic void add(Metrics s) {\n        // Add up the thread count\n\t\tthreadCnt += s.threadCnt;\n\n        Logger logger = Logger.getLogger(getClass().getName());\n        logger.finest(\"Adding cycleSum \" + cycleSum + \" and \" + s.cycleSum);\n\n        cycleSum += s.cycleSum;\n        // Standard statistics\n\t\tfor (int i = 0; i < txTypes; i++) {\n\t\t\ttxCntStdy[i] += s.txCntStdy[i];\n            txCntTotal[i] += s.txCntTotal[i];\n            errCntStdy[i] += s.errCntStdy[i];\n            errCntTotal[i] += s.errCntTotal[i];\n            delayCntStdy[i] += s.delayCntStdy[i];\n\t\t\trespSumStdy[i] += s.respSumStdy[i];\n            respSumTotal[i] += s.respSumTotal[i];\n\t\t\tdelaySum[i] += s.delaySum[i];\n\t\t\ttargetedDelaySum[i] += s.targetedDelaySum[i];\n\t\t\tif (s.respMax[i] > respMax[i]) {\n\t\t\t\trespMax[i] = s.respMax[i];\n\t\t\t}\n\t\t\tif (s.delayMax[i] > delayMax[i]) {\n\t\t\t\tdelayMax[i] = s.delayMax[i];\n\t\t\t}\n\t\t\tif (s.delayMin[i] < delayMin[i]) {\n\t\t\t\tdelayMin[i] = s.delayMin[i];\n\t\t\t}\n\n\t\t\t// sum up histogram buckets\n\t\t\tfor (int j = 0; j < RESPBUCKETS; j++) {\n\t\t\t\trespHist[i][j] += s.respHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < graphBuckets; j++) {\n\t\t\t\tthruputGraph[i][j] += s.thruputGraph[i][j];\n                respGraph[i][j] += s.respGraph[i][j];\n            }\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\tdelayHist[i][j] += s.delayHist[i][j];\n\t\t\t}\n\t\t\tfor (int j = 0; j < DELAYBUCKETS; j++) {\n\t\t\t\ttargetedDelayHist[i][j] += s.targetedDelayHist[i][j];\n            }\n        }\n\n        if (s.startTime < startTime) {\n            startTime = s.startTime;\n\t\t}\n\n        // We want the last end time.\n        if (s.endTime > endTime) {\n            endTime = s.endTime;\n\t\t}\n\n        if (attachment != null && s.attachment != null) {\n\t\t\tattachment.add(s.attachment);\n\t\t}\n\t}\n\n    /**\n     * @see java.lang.Object#clone()\n     */\n    @Override\n    public Object clone() {\n        Metrics clone = null;\n        try {\n            clone = (Metrics) super.clone();\n            clone.txCntStdy = txCntStdy.clone();\n            clone.txCntTotal = txCntTotal.clone();\n            clone.errCntStdy = errCntStdy.clone();\n            clone.errCntTotal = errCntTotal.clone();\n            clone.delayCntStdy = delayCntStdy.clone();\n            clone.respSumStdy = respSumStdy.clone();\n            clone.respSumTotal = respSumTotal.clone();\n            clone.respMax = respMax.clone();\n            clone.delaySum = delaySum.clone();\n            clone.targetedDelaySum = targetedDelaySum.clone();\n            clone.delayMax = delayMax.clone();\n            clone.delayMin = delayMin.clone();\n            clone.respHist = new int[respHist.length][];\n            for (int i = 0; i < respHist.length; i++) {\n                clone.respHist[i] = respHist[i].clone();\n\t\t\t}\n            clone.delayHist = new int[delayHist.length][];\n            for (int i = 0; i < delayHist.length; i++) {\n                clone.delayHist[i] = delayHist[i].clone();\n\t\t\t}\n            clone.targetedDelayHist = new int[targetedDelayHist.length][];\n            for (int i = 0; i < targetedDelayHist.length; i++) {\n                clone.targetedDelayHist[i] = targetedDelayHist[i].clone();\n\t\t\t}\n            clone.thruputGraph = new int[thruputGraph.length][];\n            clone.respGraph = new long[respGraph.length][];\n            for (int i = 0; i < thruputGraph.length; i++) {\n                clone.thruputGraph[i] = thruputGraph[i].clone();\n                clone.respGraph[i] = respGraph[i].clone();\n            }\n            if (attachment != null) {\n                clone.attachment = (CustomMetrics) attachment.clone();\n\t\t\t}\n\n        } catch (CloneNotSupportedException e) {\n            // This should not happen as we already implement cloneable.\n        }\n        return clone;\n    }\n\n    /**\n     * Calculates the aggregate TPS from the current stats.\n     * @return The current aggregate TPS\n     */\n    public double getTps() {\n        int totalCnt = 0;\n        for (int i = 0; i < txTypes; i++) {\n            totalCnt += txCntStdy[i];\n\t\t}\n        return totalCnt * 1000d / stdyState;\n    }\n\n    /**\n     * Provides a string presentation of the current stats.\n     * @return The string representing the statistics.\n     */\n    @Override\n    public String toString() {\n        StringBuilder buffer = new StringBuilder();\n\n        buffer.append(\"sumusers=\" + threadCnt);\n        buffer.append(\"\\nruntime=\" + stdyState);\n\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(\"\\nsum\" + txNames[i] + \"Count=\" + txCntStdy[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Resp=\" + respSumStdy[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Resp=\" + respMax[i]);\n            buffer.append(\"\\nsum\" + txNames[i] + \"Delay=\" + delaySum[i]);\n            buffer.append(\"\\nmax\" + txNames[i] + \"Delay=\" + delayMax[i]);\n            buffer.append(\"\\nmin\" + txNames[i] + \"Delay=\" + delayMin[i]);\n            buffer.append('\\n');\n        }\n\n        buffer.append(\"Total cycle time = \" + cycleSum);\n\n        /* Now print out the histogram data */\n        for (int i = 0; i < txTypes; i++) {\n            buffer.append(txNames[i] + \" Response Times Histogram\\n\");\n            for (int j = 0; j < RESPBUCKETS; j++) {\n                buffer.append(\" \" + respHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Throughput Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + thruputGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Response Time Graph\\n\");\n            for (int j = 0; j < graphBuckets; j++) {\n                buffer.append(\" \" + respGraph[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n            buffer.append(txNames[i] + \" Cycle Times Histogram\\n\");\n            for (int j = 0; j < DELAYBUCKETS; j++) {\n                buffer.append(\" \" + delayHist[i][j]);\n\t\t\t}\n            buffer.append('\\n');\n        }\n        return(buffer.toString());\n    }\n\n    /**\n     * Prints the summary report for the statistics. This will\n     * usually be called once the statistics have been accumulated.\n     *\n     * @param buffer The buffer for outputting the summary\n     * @param benchDef The benchmark definition\n     * @return true if this driver passed, false if not\n     */\n    @SuppressWarnings(\"boxing\")\n    public boolean printSummary(StringBuilder buffer,\n                                BenchmarkDefinition benchDef) {\n        int metricTxCnt = 0;\n        int sumTxCnt = 0;\n        int sumFgTxCnt = 0;\n        mixRatio = new double[txTypes];\n        boolean success = true;\n        double avg, tavg, resp90;\n        int sumtx, cnt90;\n        RunInfo runInfo = RunInfo.getInstance();\n        Formatter formatter = new Formatter(buffer);\n\n        BenchmarkDefinition.Driver driver;\n        if (benchDef.configPrecedence) {\n            driver = runInfo.driverConfigs[driverType];\n        } else {\n            driver = benchDef.drivers[driverType];\n        }\n\n        int fgTxTypes = driver.mix[0].operations.length;\n\n        space(4, buffer).append(\"<driverSummary name=\\\"\").append(driverName).\n                append(\"\\\">\\n\");\n\n        for (int i = 0; i < txTypes; i++) {\n            sumTxCnt += txCntStdy[i];\n            if (driver.operations[i].countToMetric)\n                metricTxCnt += txCntStdy[i];\n\t\t}\n\n        for (int i = 0; i < fgTxTypes; i++) {\n            sumFgTxCnt += txCntStdy[i];\n\t\t}\n\n        int sumBgTxCnt = sumTxCnt - sumFgTxCnt;\n\n        metric = metricTxCnt / (double) runInfo.stdyState;\n        if (sumFgTxCnt > 0) {\n            for (int i = 0; i < fgTxTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumFgTxCnt;\n\t\t\t}\n        }\n        if (sumBgTxCnt > 0) {\n            for (int i = fgTxTypes; i < txTypes; i++) {\n\t\t\t\tmixRatio[i] = txCntStdy[i] / (double) sumBgTxCnt;\n\t\t\t}\n        }\n        space(8, buffer);\n        formatter.format(\"<metric unit=\\\"%s\\\">%.03f<\/metric>\\n\", driver.metric,\n                metric);\n        space(8, buffer).append(\"<startTime>\").append(new Date(startTime)).\n                append(\"<\/startTime>\\n\");\n        space(8, buffer).append(\"<endTime>\").append(new Date(startTime +\n                endTime)).append(\"<\/endTime>\\n\");\n        space(8, buffer).append(\"<totalOps unit=\\\"\").append(driver.opsUnit).\n                append(\"\\\">\").append(sumTxCnt).append(\"<\/totalOps>\\n\");\n        space(8, buffer).append(\"<users>\").append(threadCnt).\n                append(\"<\/users>\\n\");\n\n        /* avg.rt = cycle time = tx. rt + cycle time */\n        space(8, buffer);\n        formatter.format(\"<rtXtps>%.04f<\/rtXtps>\\n\",\n                cycleSum / (runInfo.stdyState * 1e9d));\n\n        space(8, buffer).append(\"<passed>\");\n        int passStrOffset = buffer.length();\n        buffer.append(\"true<\/passed>\\n\"); // We first assume passed\n        // and will come correct it later if this is false;\n\n        FlatMix[] mix;\n        if (txTypes > fgTxTypes) {\n            mix = new FlatMix[2];\n            mix[1] = driver.mix[1].flatMix();\n        } else {\n            mix = new FlatMix[1];\n        }\n            \n        mix[0] = driver.mix[0].flatMix();\n        \n        space(8, buffer);\n        formatter.format(\n                \"<mix allowedDeviation=\\\"%.04f\\\">\\n\", mix[0].deviation / 100d);\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier = \"\";\n            double targetMix, targetDev;\n            if (i < fgTxTypes) {\n                targetMix = mix[0].mix[i];\n                targetDev = mix[0].deviation;\n            } else  { // Check that bg mix exists\n                targetMix = mix[1].mix[i - fgTxTypes];\n                targetDev = mix[1].deviation;\n                nameModifier = \" &amp;\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\">\\n\");\n            space(16, buffer).append(\"<successes>\").append(txCntStdy[i]).\n                    append(\"<\/successes>\\n\");\n            space(16, buffer).append(\"<failures>\").append(errCntStdy[i]).\n                    append(\"<\/failures>\\n\");\n            space(16, buffer);\n            formatter.format(\"<mix>%.04f<\/mix>\\n\", mixRatio[i]);\n            space(16, buffer);\n            \n            formatter.format(\"<requiredMix>%.04f<\/requiredMix>\\n\", targetMix);\n            boolean passed = true;\n            double deviation = 100d * Math.abs(mixRatio[i] - targetMix);\n            if (deviation > targetDev) {\n                passed = false;\n                success = false;\n            }\n            space(16, buffer).append(\"<passed>\").append(passed).\n                    append(\"<\/passed>\\n\");\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/mix>\\n\");\n\n        // The precision of the response time, in nanosecs.\n        // If sec, pecision is 1E9 nanos,\n        // if microsec, precision is 1E3 nanos, etc.\n        double precision = driver.responseTimeUnit.toNanos(1l);\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n\n        space(8, buffer).append(\"<responseTimes unit=\\\"\").\n                append(responseTimeUnit).append(\"\\\">\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n            double max90 = driver.operations[i].max90th;\n            space(12, buffer);\n            formatter.format(\"<operation name=\\\"%s%s\\\" r90th=\\\"%5.3f\\\">\\n\",\n                    txNames[i], nameModifier, max90);\n            if (txCntStdy[i] > 0) {\n                boolean pass90 = true;\n                space(16, buffer);\n                formatter.format(\"<avg>%5.3f<\/avg>\\n\",\n                        (respSumStdy[i]/txCntStdy[i]) / precision);\n                space(16, buffer);\n                formatter.format(\"<max>%5.3f<\/max>\\n\", respMax[i] / precision);\n                sumtx = 0;\n                cnt90 = (int)(txCntStdy[i] * .90);\n                int j = 0;\n                for (; j < RESPBUCKETS; j++) {\n                    sumtx += respHist[i][j];\n                    if (sumtx >= cnt90)\t{\t/* 90% of tx. got */\n                        break;\n                    }\n                }\n                resp90 = (j + 1) * respBucketSize / precision;\n                space(16, buffer);\n                formatter.format(\"<p90th>%5.3f<\/p90th>\\n\", resp90);\n                if (resp90 > max90) {\n                    pass90 = false;\n                    success = false;\n                }\n                space(16, buffer).append(\"<passed>\").append(pass90).\n                        append(\"<\/passed>\\n\");\n            } else {\n                space(16, buffer).append(\"<avg/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<p90th/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/responseTimes>\\n\");\n\n        space(8, buffer).append(\"<delayTimes>\\n\");\n        for (int i = 0; i < txNames.length; i++) {\n            \n            String nameModifier;\n            if (i < fgTxTypes) {\n                nameModifier = \"\";\n            } else {\n                nameModifier = \" &amp;\";\n            }\n\n            String typeString = null;\n            switch (driver.operations[i].cycle.cycleType) {\n                case CYCLETIME: typeString = \"cycleTime\"; break;\n                case THINKTIME: typeString = \"thinkTime\";\n            }\n            space(12, buffer).append(\"<operation name=\\\"\").append(txNames[i]).\n                    append(nameModifier).append(\"\\\" type=\\\"\").\n                    append(typeString).append(\"\\\">\\n\");\n            if (delayCntStdy[i] > 0) {\n                avg = delaySum[i] / (delayCntStdy[i] * 1e9d);\n                tavg =  targetedDelaySum[i] / (delayCntStdy[i] * 1e9d);\n                space(16, buffer);\n                formatter.format(\"<targetedAvg>%.3f<\/targetedAvg>\\n\",tavg);\n                space(16, buffer);\n                formatter.format(\"<actualAvg>%.3f<\/actualAvg>\\n\", avg);\n                space(16, buffer);\n                formatter.format(\"<min>%.3f<\/min>\\n\", delayMin[i]/1e9d);\n                space(16, buffer);\n                formatter.format(\"<max>%.3f<\/max>\\n\", delayMax[i]/1e9d);\n\n                boolean passDelay = true;\n\n                // Make sure we're not dealing with the 0 think time case.\n                // We cannot check a deviation on 0 think time.\n                if (driver.operations[i].cycle.cycleType == CycleType.CYCLETIME\n                        || tavg > 0.001d) {\n                    passDelay = (Math.abs(avg - tavg)/tavg <=\n                            driver.operations[i].cycle.cycleDeviation /100d);\n\t\t\t\t}\n\n                space(16, buffer);\n                buffer.append(\"<passed>\").append(passDelay).\n                        append(\"<\/passed>\\n\");\n                if (!passDelay) {\n                    success = false;\n\t\t\t\t}\n            } else {\n                space(16, buffer).append(\"<targetedAvg/>\\n\");\n                space(16, buffer).append(\"<actualAvg/>\\n\");\n                space(16, buffer).append(\"<min/>\\n\");\n                space(16, buffer).append(\"<max/>\\n\");\n                space(16, buffer).append(\"<passed/>\\n\");\n            }\n            space(12, buffer).append(\"<\/operation>\\n\");\n        }\n        space(8, buffer).append(\"<\/delayTimes>\\n\");\n\n        if (attachment != null) {\n            Result.init(this); // Creates the result for the attachment to use.\n            CustomMetrics.Element[] elements = attachment.getResults();\n            if (elements != null && elements.length > 0) {\n                space(8, buffer).append(\"<miscStats>\\n\");\n                for (CustomMetrics.Element element: elements) {\n                    if (element == null) {\n                        Logger logger = Logger.getLogger(\n                                                    this.getClass().getName());\n                        logger.warning(\"Null element returned from \" +\n                                attachment.getClass().getName() +\n                                \".getResults, ignored!\");\n                        continue;\n                    }\n                    space(12, buffer).append(\"<stat>\\n\");\n                    if (element.description != null) {\n                        space(16, buffer).append(\"<description>\").append(\n                                element.description).append(\"<\/description>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<description/>\\n\");\n                    }\n                    if (element.result != null) {\n                        space(16, buffer).append(\"<result>\").\n                                append(element.result).append(\"<\/result>\\n\");\n                    } else {\n                        space(16, buffer).append(\"<result/>\\n\");\n                    }\n                    if (element.target != null) {\n                        space(16, buffer).append(\"<target>\").append(\n                                element.target).append(\"<\/target>\\n\");\n                    }\n                    if (element.allowedDeviation != null) {\n                        space(16, buffer).append(\"<allowedDeviation>\").\n                                append(element.allowedDeviation).\n                                append(\"<\/allowedDeviation>\\n\");\n                    }\n                    if (element.passed != null) {\n                        space(16, buffer).append(\"<passed>\").append(element.\n                                passed.booleanValue()).append(\"<\/passed>\\n\");\n                        if (!element.passed.booleanValue())\n                            success = false;\n                    }\n                    space(12, buffer).append(\"<\/stat>\\n\");\n                }\n                space(8, buffer).append(\"<\/miscStats>\\n\");\n            }\n        }\n\n        space(4, buffer).append(\"<\/driverSummary>\\n\");\n\n        // Go back and correct the driver-level pass/fail if not success\n        if (!success) {\n            buffer.replace(passStrOffset, passStrOffset + \"true\".length(),\n                    \"false\");\n\t\t}\n\n        return success;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(int[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * Scans the data for the upper limit of used buckets.\n     * @param data The data, histogram or graph\n     * @return The index of the first unused bucket\n     */\n    private int getBucketLimit(long[][] data) {\n        int maxBucketId = data[0].length - 1;\n\n        bucketScanLoop:\n        for (; maxBucketId >= 0; maxBucketId--) {\n\t\t\tfor (int i = 0; i < data.length; i++) {\n\t\t\t\tif (data[i][maxBucketId] != 0) {\n                    break bucketScanLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n        ++maxBucketId;\n        if (maxBucketId < data[0].length) {\n            ++maxBucketId; // Include one row of zeros if not last row.\n\t\t}\n        return maxBucketId;\n    }\n\n    /**\n     * @param b\n     */\n    public void printDetail(StringBuilder b)  {\n        RunInfo runInfo = RunInfo.getInstance();\n        BenchmarkDefinition.Driver driver = runInfo.driverConfigs[driverType];\n        long precision = driver.responseTimeUnit.toNanos(1l);\n\n        double graphBucketSize = this.graphBucketSize / 1e9d;\n        String responseTimeUnit = driver.responseTimeUnit.toString().\n                toLowerCase();\n        printGraph(b, \"Throughput\", graphBucketSize,\n                \"%.0f\", \"%.2f\", thruputGraph, graphBucketSize);\n\n        printGraph(b, \"Response Times (\" + responseTimeUnit +\n                \")\", graphBucketSize, \"%.0f\", \"%.6f\", respGraph,\n                thruputGraph, precision);\n\n        printHistogram(b, \"Frequency Distribution of Response Times\",\n                respBucketSize / 1e9d, \"%5.3f\", respHist);\n\n        printHistogram(b, \"Frequency Distribution of Cycle/Think Times\",\n                delayBucketSize / 1e9d, \"%5.3f\", delayHist);\n\n        printHistogram(b, \"Frequency Distribution of Targeted Cycle/Think \" +\n                \"Times\", delayBucketSize / 1e9d, \"%5.3f\",\n                targetedDelayHist);\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            int[][] rawGraph, double divider) {\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                table.setField(i, j + 1,\n                        String.format(dataFormat, rawGraph[j][i]/divider));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printGraph(StringBuilder b, String label, double unit,\n                            String unitFormat, String dataFormat,\n                            long[][] rawGraph, int[][] divider, double divider2){\n\n        int bucketLimit = rawGraph[0].length;\n\n        // Check the histogram and do not output unused buckets if needed.\n        // The graph buckets are sized according to the run time.\n        // So we'll scan only if the run is cycleControl.\n        if (RunInfo.getInstance().driverConfigs[driverType].\n                runControl == RunControl.CYCLES) {\n            bucketLimit = getBucketLimit(rawGraph);\n\t\t}\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n                double data = 0d;\n                if (divider[j][i] != 0) {\n                    data = rawGraph[j][i] / (divider2 * divider[j][i]);\n\t\t\t\t}\n                table.setField(i, j + 1, String.format(dataFormat, data));\n            }\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    @SuppressWarnings(\"boxing\")\n    private void printHistogram(StringBuilder b, String label, double unit,\n                                String unitFormat, int[][] histogram) {\n\n        // First, check the histogram and do not output unused buckets.\n        int bucketLimit = getBucketLimit(histogram);\n\n        // Data header\n        b.append(\"Section: \").append(driverName).append(' ').append(label).\n                append('\\n');\n        b.append(\"Display: Line\\n\");\n\n        TextTable table = new TextTable(bucketLimit, txTypes + 1);\n\n        // The X axis headers and column headers, or legends\n        table.setHeader(0, \"Time (s)\");\n        for (int j = 0; j < txTypes; j++) {\n            table.setHeader(j + 1, txNames[j]);\n\t\t}\n\n        // The X axis and the data\n        for (int i = 0; i < bucketLimit; i++) {\n            // The X axis\n            table.setField(i, 0, String.format(unitFormat, unit * i));\n\n            // The data\n            for (int j = 0; j < txTypes; j++) {\n\t\t\t\ttable.setField(i, j + 1, String.valueOf(histogram[j][i]));\n\t\t\t}\n        }\n        table.format(b);\n        b.append('\\n');\n    }\n\n    static StringBuilder space(int space, StringBuilder buffer) {\n        for (int i = 0; i < space; i++) {\n            buffer.append(' ');\n\t\t}\n        return buffer;\n    }\n}\n","lineNo":408}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Timer.java,v 1.2 2006/06/29 19:38:39 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.util;\n\nimport java.io.Serializable;\nimport java.util.Random;\nimport java.util.logging.Logger;\n\n/**\n * This class has the functions to get timestamps\n */\npublic class Timer implements Serializable {\n\tlong baseTime;\n    private transient Logger logger;\n    private int compensation = 5;  // Some pretty good starting numbers\n    private double deviation = 5d; // for both fields.\n\n    /**\n     * Default Constructor which saves the current time\n     * as baseTime (the start of the benchmark). The resolution\n     * is unknown.\n     */\n\tpublic Timer() {\n\t\tbaseTime = System.currentTimeMillis();\n        getLogger().fine(\"Timer: baseTime in getOffsetTime = \" + baseTime);\n\t}\n\n    private Logger getLogger() {\n        if (logger == null)\n            logger = Logger.getLogger(getClass().getName());\n        return logger;\n    }\n\n    /**\n        * this method is used to print the benchmark report\n        * @return baseTime the start of the benchmark time\n        */\n\tpublic long getOffsetTime() {\n\t\treturn baseTime;\n\t}\n\n\n\t/**\n\t * This  method returns the current time relative to baseTime.\n\t * This way, we don't need to keep track of large numbers and\n\t * worry about long variables\n         * @return int duration the difference between start and current time\n\t */\n\tpublic int getTime() {\n\t\tlong c = System.currentTimeMillis();\n\t\treturn (int) (c - baseTime);\n\t}\n\n    /**\n     * Sets the actual measured sleep time deviation. This is called from\n     * the calibrator. Since the deviation is rarely read and certainly not\n     * read concurrently we do not need to protect it. The compensation\n     * will automatically be set as a round-up of deviation.\n     * @param deviation The deviation.\n     */\n    private void setDeviation(double deviation) {\n        this.deviation = deviation;\n        int compensation = (int) deviation;     // A low cost way to\n        if (deviation - compensation > 0d)      // round up the deviation.\n            ++compensation;\n        // Make a single atomic int assignment in order to avoid race conditions\n        this.compensation = compensation;\n    }\n\n    /**\n     * Reads the compensation value.\n     * @return The compensation\n     */\n    public int getCompensation() {\n        return compensation;\n    }\n\n    /**\n     * Reads the deviation value.\n     * @return The deviation\n     */\n    public double getDeviation() {\n        return deviation;\n    }\n\n    /**\n     * Causes this thread to sleep until the wakeup time as referenced\n     * by this timer. Timer.sleep is not a minimum sleep time as in\n     * Thread.sleep, but rather a calibrated and compensated sleep\n     * time which gives the best statistical opportunity to wake up\n     * at the required time. The actual wakeup can be slightly before\n     * or slightly after the wakeup time but the average discrepancy\n     * should be close to zero.\n     * @param wakeupTime The time this thread is supposed to wakeup.\n     */\n    public void sleep(int wakeupTime) {\n        int currentTime;\n        if ((currentTime = getTime()) < wakeupTime - compensation)\n            try {\n                Thread.sleep(wakeupTime - currentTime - compensation);\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\n                        \"Sleep interrupted. Run terminating.\");\n                // If we get an interrupt, the run is killed/terminated.\n                // Just stop sleeping.\n            }\n    }\n\n    /**\n     * Runs a timer sleep time calibration for a certain amount of time.\n     * @param id The agent identifier - used for logging purposes.\n     * @param endTime The time to end the calibration, referencing this timer.\n     */\n    public void calibrate(String id, int endTime) {\n        // Only calibrate if we have at least 5 secs to do so.\n        // Otherwise it does not make sense at all.\n        if (endTime - getTime() > 5000) {\n            Calibrator calibrator = new Calibrator(id, endTime);\n            calibrator.start();\n        }\n    }\n\n    /**\n     * Adjusts the base time based on the clock differences of this JVM to\n     * the master's JVM.\n     * @param offset\n     */\n    public void adjustBaseTime(int offset) {\n        baseTime += offset;\n    }\n\n    /**\n     * The Calibrator thread is used to calibrate the deviation of the sleep\n     * time for compensation purposes. We already know the semantics of sleep\n     * points to the minimum sleep time. The actual time calculated from<ul>\n     *      <li>System.currentTimeMillis()\n     *      <li>Thread.sleep(sleepTime)\n     *      <li>System.currentTimeMillis()\n     *\n     * <\/ul>is always higher than sleepTime. The difference varies largely\n     * between systems and could dramatically skew the driver cycles. It is\n     * however expected to be in the 10s of milliseconds or less than 10\n     * milliseconds range.<p>\n     *\n     * The Calibrator must be run by each agent during the rampup time.\n     * Assuming the rampup is adequately long, it should capture a pretty good\n     * average deviation which will include the effects of several garbage\n     * collections and use this difference to compensate the sleep time.\n     *\n     * @author Akara Sucharitakul\n     */\n    class Calibrator extends Thread {\n\n        private String id;\n        private int endTime;\n\n        /**\n         * Constructs the calibrator.\n         * @param endTime The time to end the calibration, based on this timer\n         */\n        Calibrator(String id, int endTime) {\n            this.id = id;\n            this.endTime = endTime;\n            setName(\"Calibrator\");\n        }\n\n        /**\n         * Runs the calibrator thread.\n         */\n        public void run() {\n            int timeAfter = Integer.MIN_VALUE;\n            int maxSleep = -1; // Initial value\n            Random random = new Random();\n\n            int count = 0;\n            int devSum = 0;\n            for (;;) {\n                // We random the intended sleep between 10 and 30 ms\n                // thus assuming the systems running the driver will\n                // have a timer resolution of 10ms or better.\n                // The avg sleep time is 20ms as a result.\n                int intendedSleep = random.nextInt(21) + 10;\n                if (maxSleep == -1) // Set maxSleep for first check.\n                    maxSleep = intendedSleep;\n                if (timeAfter + maxSleep >= endTime) {\n                    setDeviation((double) devSum/count); // Final one.\n                    break;\n                }\n                int timeBefore = Integer.MAX_VALUE;\n                try {\n                    timeBefore = getTime();\n                    Thread.sleep(intendedSleep);\n                    timeAfter = getTime();\n                } catch (InterruptedException e) {\n                }\n                if (timeAfter > timeBefore) { // If not interrupted.\n                    int actualSleep = timeAfter - timeBefore;\n                    int deviation = actualSleep - intendedSleep;\n                    devSum += deviation;\n                    ++count;\n                    if (actualSleep > maxSleep)\n                        maxSleep = actualSleep;\n                    // Keep converging the deviation to the final value\n                    // until this thread exits, just before steady state.\n                    if (count % 50 == 0) // Sets every 50 experiments, ~1 sec.\n                        setDeviation((double) devSum/count);\n                }\n            }\n\n            // Check whether we're in debug mode. Debug mode will make\n            // the Faban driver less timing sensitive.\n            boolean debug = false;\n            String debugSwitch = System.getProperty(\"faban.debug\");\n            if (debugSwitch != null)\n                debug = Boolean.parseBoolean(debugSwitch);\n\n            // Test for qualifying final compensation...\n            if (!debug && compensation > 100) {\n                getLogger().severe(id + \": System needed time compensation \" +\n                        \"of \" + compensation + \".\\nValues over 100ms are \" +\n                        \"unacceptable for a driver. \\nPlease use a faster \" +\n                        \"system or tune the driver JVM/GC.\\nExiting...\");\n                System.exit(1);\n            }\n            getLogger().fine(id + \": Calibration succeeded. Sleep time \" +\n                    \"deviation: \" + getDeviation() + \" compensation: \" +\n                    compensation + \" ms.\");\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: Timer.java,v 1.3 2008/05/14 07:06:03 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.util;\n\nimport com.sun.faban.driver.FatalException;\n\nimport java.io.Serializable;\nimport java.util.Random;\nimport java.util.logging.Logger;\n\n/**\n * This class has the functions to get timestamps\n */\npublic class Timer implements Serializable {\n    /** The millisec epoch time of this benchmark */\n\tlong epochMillis;\n\n    /** The nanosec epoch time of this benchmark */\n    transient long epochNanos; // This has no meaning on a different system.\n\n    transient long diffms; // The epoch difference, millisec part\n    transient int diffns; // The epoch difference, nanosec part\n\n    private transient Logger logger;\n    private long compensation = 5000000l;  // Some pretty good starting numbers\n    private double deviation = 5000000d; // for both fields.\n\n    /**\n     * Default Constructor which saves the current time\n     * as epochMillis and epochNanos (the start of the benchmark).\n     * The resolution is unknown. Note that this is only constructed on the\n     * master so the initial values before adjustments pertain to the master\n     * alone.\n     */\n\tpublic Timer() {\n        // This is the closest we could possibly get, to put the two epochs\n        // at the same time. The accuracy is different, but both epochs will\n        // be in the same millisec.\n        long epochMillis0 = 0l;\n        int retries = 100;\n        do {\n            epochMillis0 = System.currentTimeMillis();\n            epochNanos = System.nanoTime();\n\t\t    epochMillis = System.currentTimeMillis();\n            if (retries-- <= 0)\n                throw new FatalException(\"Cannot establish epoch times, \" +\n                                         \"system may be too busy.\");\n        } while (epochMillis0 != epochMillis);\n\n        diffms = epochMillis - epochNanos / 1000000l;\n        diffns = (int) (epochNanos % 1000000l);\n\n        getLogger().fine(\"Timer: baseTime ms: \" + epochMillis +\n                         \", ns: \" + epochNanos);\n\t}\n\n    private Logger getLogger() {\n        if (logger == null)\n            logger = Logger.getLogger(getClass().getName());\n        return logger;\n    }\n\n    /**\n     * Converts the millisec relative time to absolute nanosecs.\n     * @param relTimeMillis The millisec relative time\n     * @return The corresponding nanosec time\n     */\n    public long toAbsNanos(int relTimeMillis) {\n        return (relTimeMillis + epochMillis - diffms) * 1000000l + diffns;\n    }\n\n    /**\n     * Converts the nanosecond time relative to the run's epoch to absolute\n     * millisec comparable to System.currentTimeMillis().\n     * @param relTimeNanos The relative time in nanosecs\n     * @return The absolute time in millisecs\n     */\n    public long toAbsMillis(long relTimeNanos) {\n        return (relTimeNanos + epochNanos) / 1000000l + diffms;\n    }\n\n    /**\n     * Converts the millisec time relative to the run's epoch to absolute\n     * millisec comparable to System.currentTimeMillis().\n     * @param relTimeMillis The relative time in nanosecs\n     * @return the absolute time in millisecs\n     */\n    public long toAbsMillis(int relTimeMillis) {\n        return relTimeMillis + epochMillis;\n    }\n\n    /**\n     * Obtains the current time relative to the base time, in\n     * milliseconds. This is mainly used to determine the current state of\n     * of the run. The base time is synchronized between the Faban\n     * master and all driver agents.\n     * @return The nanoseconds from the base time.\n     */\n    public int getTime() {\n        long c = System.currentTimeMillis();\n        return (int) (c - epochMillis);\n    }\n\n    /**\n     * Obtains the time relative to the base time, given a nanoTime\n     * with an unknown datum. The base time is synchronized between the Faban\n     * master and all driver agents.\n     * @param nanoTime The nanotime obtained from System.nanoTime()\n     * @return The nanosecond time relative to our base time.\n     */\n    public long toRelTime(long nanoTime) {\n        return nanoTime - epochNanos;\n    }\n\n    /**\n     * Obtains the nano time comparable to System.nanoTime() from a given\n     * nanotime relative to the base time.\n     * @param relNanos The relative nanosecond time\n     * @return The nanoseconds comparable to System.nanoTime.\n     */\n    public long toAbsTime(long relNanos) {\n        return relNanos + epochNanos;\n    }\n\n    /**\n     * Sets the actual measured sleep time deviation. This is called from\n     * the calibrator. Since the deviation is rarely read and certainly not\n     * read concurrently we do not need to protect it. The compensation\n     * will automatically be set as a round-up of deviation.\n     * @param deviation The deviation, in nanosecs.\n     */\n    private void setDeviation(double deviation) {\n        this.deviation = deviation;\n        int compensation = (int) (deviation / 1000000); // A low cost way to\n        ++compensation;                                 // round up.\n        // Note: There's a 1:10^6 chance we round up a full millis.\n        // But that's better than not rounding up at all.\n\n        // Make a single atomic int assignment in order to avoid race conditions\n        this.compensation = compensation * 1000000l;\n    }\n\n    /**\n     * Reads the compensation value.\n     * @return The compensation\n     */\n    public long getCompensation() {\n        return compensation;\n    }\n\n    /**\n     * Reads the deviation value.\n     * @return The deviation\n     */\n    public double getDeviation() {\n        return deviation;\n    }\n\n    /**\n     * Causes this thread to sleep until the wakeup time as referenced\n     * by this timer. Timer.sleep is not a minimum sleep time as in\n     * Thread.sleep, but rather a calibrated and compensated sleep\n     * time which gives the best statistical opportunity to wake up\n     * at the required time. The actual wakeup can be slightly before\n     * or slightly after the wakeup time but the average discrepancy\n     * should be close to zero.\n     * @param wakeupTime The time this thread is supposed to wakeup.\n     */\n    public void wakeupAt(long wakeupTime) {\n        long currentTime;\n        if ((currentTime = System.nanoTime()) < wakeupTime - compensation)\n            try {\n                long sleepTime = wakeupTime - currentTime - compensation;\n                Thread.sleep(sleepTime / 1000000l, (int) (sleepTime % 1000000l));\n            } catch (InterruptedException e) {\n                throw new RuntimeException(\n                        \"Sleep interrupted. Run terminating.\");\n                // If we get an interrupt, the run is killed/terminated.\n                // Just stop sleeping.\n            }\n    }\n\n    /**\n     * Runs a timer sleep time calibration for a certain amount of time.\n     * @param id The agent identifier - used for logging purposes.\n     * @param endTime The time to end the calibration, referencing this JVMs\n     *        nanosec timer.\n     */\n    public void calibrate(String id, long endTime) {\n        // Convert relative time to abs time.\n        endTime = toAbsTime(endTime);\n        // Only calibrate if we have at least 5 secs to do so.\n        // Otherwise it does not make sense at all.\n        if (endTime - System.nanoTime() > 5000000000l) {\n            Calibrator calibrator = new Calibrator(id, endTime);\n            calibrator.start();\n        }\n    }\n\n    /**\n     * Adjusts the base time based on the clock differences of this JVM to\n     * the master's JVM. This is done at the millisecond accuracy. Since\n     * remote calls are usually not much faster than a millisec, it does\n     * not make much sense to be too ideological about accuracy here.\n     * @param offset The millisec offset between systems\n     */\n    public void adjustBaseTime(int offset) {\n\n        long refMillis0 = 0l;\n        long refMillis = 0l;\n        long refNanos = Long.MIN_VALUE;\n\n        // First, establish the local relationship between\n        // the nanos and millis clocks.\n        int retries = 100;\n        do {\n            refMillis0 = System.currentTimeMillis();\n            refNanos = System.nanoTime();\n\t\t    refMillis = System.currentTimeMillis();\n            if (retries-- <= 0)\n                throw new FatalException(\"Cannot establish ref times, \" +\n                                         \"system may be too busy.\");\n        } while (refMillis0 != refMillis);\n\n        diffms = refMillis - refNanos / 1000000l;\n        diffns = (int) (refNanos % 1000000l);\n\n        // Then, we use the provided offset to calculate the millis\n        // reprsenting the same timestamp on a remote system.\n        epochMillis += offset;\n\n        // And based on our local differences between the nanos and millis\n        // clock, we set the epochNanos reopresenting the same instance in time.\n        epochNanos = (epochMillis - diffms) * 1000000l + diffns;\n    }\n\n    /**\n     * The Calibrator thread is used to calibrate the deviation of the sleep\n     * time for compensation purposes. We already know the semantics of sleep\n     * points to the minimum sleep time. The actual time calculated from<ul>\n     *      <li>System.currentTimeMillis()\n     *      <li>Thread.sleep(sleepTime)\n     *      <li>System.currentTimeMillis()\n     *\n     * <\/ul>is always higher than sleepTime. The difference varies largely\n     * between systems and could dramatically skew the driver cycles. It is\n     * however expected to be in the 10s of milliseconds or less than 10\n     * milliseconds range.<p>\n     *\n     * The Calibrator must be run by each agent during the rampup time.\n     * Assuming the rampup is adequately long, it should capture a pretty good\n     * average deviation which will include the effects of several garbage\n     * collections and use this difference to compensate the sleep time.\n     *\n     * @author Akara Sucharitakul\n     */\n    class Calibrator extends Thread {\n\n        private String id;\n        private long endTime;\n\n        /**\n         * Constructs the calibrator.\n         * @param endTime The time to end the calibration, based on this timer\n         */\n        Calibrator(String id, long endTime) {\n            this.id = id;\n            this.endTime = endTime;\n            setName(\"Calibrator\");\n        }\n\n        /**\n         * Runs the calibrator thread.\n         */\n        public void run() {\n            long timeAfter = Long.MIN_VALUE;\n            int maxSleep = -1; // Initial value\n            Random random = new Random();\n\n            int count = 0;\n            long devSum = 0l;\n            for (;;) {\n                // We random the intended sleep between 10 and 30 ms\n                // thus assuming the systems running the driver will\n                // have a timer resolution of 10ms or better.\n                // The avg sleep time is 20ms as a result.\n                int intendedSleep = random.nextInt(21) + 10;\n                if (maxSleep == -1) // Set maxSleep for first check.\n                    maxSleep = intendedSleep;\n                if (timeAfter + maxSleep >= endTime) {\n                    setDeviation((double) devSum/count); // Final one.\n                    break;\n                }\n                long timeBefore = Long.MAX_VALUE;\n                try {\n                    timeBefore = System.nanoTime();\n                    Thread.sleep(intendedSleep, 0);\n                    timeAfter = System.nanoTime();\n                } catch (InterruptedException e) {\n                }\n                if (timeAfter > timeBefore) { // If not interrupted.\n                    long actualSleep = timeAfter - timeBefore;\n                    long deviation = actualSleep - intendedSleep * 1000000l;\n                    devSum += deviation;\n                    ++count;\n                    if (actualSleep > maxSleep)\n                        maxSleep = (int) (actualSleep / 1000000l);\n                    // Keep converging the deviation to the final value\n                    // until this thread exits, just before steady state.\n                    if (count % 50 == 0) // Sets every 50 experiments, ~1 sec.\n                        setDeviation((double) devSum/count);\n                }\n            }\n\n            // Check whether we're in debug mode. Debug mode will make\n            // the Faban driver less timing sensitive.\n            boolean debug = false;\n            String debugSwitch = System.getProperty(\"faban.debug\");\n            if (debugSwitch != null)\n                debug = Boolean.parseBoolean(debugSwitch);\n\n            // Test for qualifying final compensation...\n            if (!debug && compensation > 100000000l) {\n                getLogger().severe(id + \": System needed time compensation \" +\n                        \"of \" + compensation / 1000000l + \".\\nValues over \" +\n                        \"100ms are unacceptable for a driver. \\nPlease use a \" +\n                        \"faster system or tune the driver JVM/GC.\\nExiting...\");\n                System.exit(1);\n            }\n            getLogger().fine(id + \": Calibration succeeded. Sleep time \" +\n                    \"deviation: \" + getDeviation() + \" ns, compensation: \" +\n                    compensation + \" ns.\");\n        }\n    }\n}\n","lineNo":194}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: LighttpdService.java,v 1.3 2008/02/25 20:41:22 shanti_s Exp $\n *\n * Copyright 2008 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\n\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.RunContext;\nimport java.io.BufferedReader;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n *\n * This class implements the service to start/stop lighttpd instances.\n * It also provides functionality to transfer the portion of the lighttpd\n * error.log for a run to the run output directory.\n * It can be used by any lighttpd benchmark to manage lighttpd servers and\n * perform these operations remotely using this Service.\n *\n * @author Shanti Subramanyam\n */\nfinal public class LighttpdService implements WebServerService {\n\n    private static LighttpdService service = null;\n    private String[] myServers = new String[1];\n    private Logger logger;\n    private static String lightyCmd,  errlogFile,  acclogFile, confFile, pidFile;\n    private CommandHandle[] ch = null;\n\n    /**\n     *\n     * Private Constructor for a singleton object.\n     *\n     */\n    private LighttpdService() {\n        logger = Logger.getLogger(this.getClass().getName());\n        logger.fine(this.getClass().getName() + \" Created\");\n    }\n\n    /**\n     *\n     * Get the reference to the singleton object.\n     * Use this method to get access to the service.\n\t * @return LighttpdService - service object handle\n     */\n    public static LighttpdService getHandle() {\n        if (service == null) {\n            service = new LighttpdService();\n        }\n\n        return service;\n    }\n\n    /**\n     * The setup method is called to set up a benchmark run. \n     * It is assumed that all servers have the same installation directory\n     *\n     * @param serverMachines - array specifying the web server machines. \n     * @param binDir - lighttpd binary location\n     * @param logsDir - lighttpd logs location\n     * @param confDir - lighttpd conf file location\n     * @param pidDir - lighttpd.pid file location\n     */\n    public void setup(String[] serverMachines, String binDir, String logsDir, \n            String confDir, String pidDir) {\n        myServers = serverMachines;\n\n        lightyCmd = binDir + File.separator + \"lighttpd \";\n        errlogFile = logsDir + File.separator + \"error.log\";\n        acclogFile = logsDir + File.separator + \"access.log\";\n        confFile = confDir + File.separator + \"lighttpd.conf\";\n        pidFile = pidDir + File.separator + \"lighttpd.pid\";\n        logger.info(\"LighttpdService setup complete.\");\n\n    }\n\n    /**\n     * Start all apache servers on configured hosts\n     * @return boolean true if start succeeded on all machines, else false\n     */\n    public boolean startServers() {\n        Integer success = 0;\n        String cmd = lightyCmd + \"-f \" + confFile;\n        Command startCmd = new Command(cmd);\n        startCmd.setSynchronous(false);\n        startCmd.setLogLevel(Command.STDOUT, Level.FINE);\n        startCmd.setLogLevel(Command.STDERR, Level.FINE);\n        ch = new CommandHandle[myServers.length];\n        for (int i = 0; i < myServers.length; i++) {\n            String server = myServers[i];\n            try {\n                // Run the command in the foreground and wait for the start\n                ch[i] = RunContext.exec(server, startCmd);\n                \n                if (checkServerStarted(server)) {\n                    logger.fine(\"Completed lightttpd startup successfully on \" + server);\n                } else {\n                    logger.severe(\"Failed to find \" + pidFile + \" on \" + server);\n                    return (false);\n                }\n\n            } catch (Exception e) {\n                logger.warning(\"Failed to start lighttpd server with \" + e.toString());\n                logger.log(Level.FINE, \"Exception\", e);\n                return (false);\n            }\n        }\n        logger.info(\"Completed lighttpd server(s) startup\");\n        return (true);\n    }\n\n    /*\n     * Check if lighttpd server started by looking for pidfile\n     */\n    private static boolean checkServerStarted(String hostName) throws Exception {\n        boolean val = false;\n        \n                // Just to make sure we don't wait for ever.\n                // We try to read the msg 120 times before we give up\n                // Sleep 1 sec between each try. So wait for 1 min\n                int attempts = 60;\n                while (attempts > 0) {\n                    if (RunContext.isFile(hostName, pidFile)) {\n                        val = true;\n                        break;\n                    } else {\n                        // Sleep for some time\n                        try {\n                            Thread.sleep(1000);\n                            attempts--;\n                        } catch (Exception e) {\n                            break;\n                        }\n                    }\n                }\n                return (val);\n\n    }\n\n    /**\n     * Restart all servers. It first stops servers, clear logs\n     * and then attempts to start them up again. If startup fails on\n\t * any server, it will stop all servers and cleanup.\n\t * @return true if all servers restarted successfully, otherwise false\n     */\n    public boolean restartServers() {\n\n        logger.info(\"Restarting lighttpd server(s). Please wait ... \");\n        // We first stop and clear the logs\n        if (this.stopServers())\n            this.clearLogs();\n\n        // Now start the servers\n        if (!startServers()) {\n            // cleanup and return\n            if (stopServers())\n                clearLogs();\n            return false;\n        }\n        return (true);\n    }\n\n    /**\n     * stop Servers\n     * @return true if stop succeeded on all machines, else false\n     */\n    public boolean stopServers() {\n        boolean success = true;\n\n        // First check if servers were started\n        // If there weren't started, simply return\n        if (ch == null || ch.length == 0) {\n            return (success);\n        }\n        for (int i = 0; i < myServers.length; i++) {\n            try {\n                if (ch[i] != null) {\n                    ch[i].destroy();\n                }                \n            } catch (RemoteException re) {\n                logger.log(Level.WARNING, \"Failed to stop lighttpd on \" +\n                        myServers[i] + \" with \" + re);\n                logger.log(Level.FINE, \"lighttpd stop Exception\", re);                \n                success = false;\n            }\n        }         \n        return (success);\n    }\n\n    /**\n     * clear server logs and session files\n     * It assumes that session files are in /tmp/sess*\n     * @return true if operation succeeded, else fail\n     */\n    public boolean clearLogs() {\n        Command cmd = new Command(\"rm -f /tmp/sess*\");\n\n        for (int i = 0; i < myServers.length; i++) {\n            if (RunContext.isFile(myServers[i], errlogFile)) {\n                if (!RunContext.deleteFile(myServers[i], errlogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + errlogFile +\n                            \" failed on \" + myServers[i]);\n                    return (false);\n                }\n            }\n            if (RunContext.isFile(myServers[i], acclogFile)) {\n                if (!RunContext.deleteFile(myServers[i], acclogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + acclogFile +\n                            \" failed on \" + myServers[i]);\n                    return (false);\n                }\n            }\n           if (RunContext.isFile(myServers[i], pidFile)) {\n                if (!RunContext.deleteFile(myServers[i], pidFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + pidFile +\n                            \" failed on \" + myServers[i]);\n                    return (false);\n                }\n            }\n\n            logger.fine(\"Logs cleared for \" + myServers[i]);\n            try {\n                // Now delete the session files\n                CommandHandle ch = RunContext.exec(myServers[i], cmd);\n                logger.fine(\"Deleted session files for \" + myServers[i]);\n            } catch (Exception e) {\n                logger.log(Level.FINE, \"Delete session files failed on \" + \n                        myServers[i] + \".\", e);\n                logger.log(Level.FINE, \"Exception\", e);\n                return (false);\n            }\n        }\n        return (true);\n    }\n\n    /**\n     * transfer log files\n\t * This method copies over the error log to the run output directory\n\t * and keeps only the portion of the log relevant for this run\n\t * @param totalRunTime - the time in seconds for this run\n     */\n    public void xferLogs(int totalRunTime) {\n\n        for (int i = 0; i < myServers.length; i++) {\n            String outFile = RunContext.getOutDir() + \"error_log.\" + myServers[i];\n\n            // copy the error_log to the master\n            if (!RunContext.getFile(myServers[i], errlogFile, outFile)) {\n                logger.warning(\"Could not copy \" + errlogFile + \" to \" + outFile);\n                return;\n            }\n\n            try {\n                // Now get the start and end times of the run\n                GregorianCalendar calendar = getGregorianCalendar(myServers[i]);\n\n                //format the end date\n                SimpleDateFormat df = new SimpleDateFormat(\"MM,dd,HH:mm:ss\");\n                String endDate = df.format(calendar.getTime());\n\n                calendar.add(Calendar.SECOND, (totalRunTime * (-1)));\n\n                String beginDate = df.format(calendar.getTime());\n\n                //parse the log file\n\t\t\t\t/*****\n                Command parseCommand = new Command(\"apache_trunc_errorlog.sh \\\"\" +\n                        beginDate + \"\\\"\" + \" \\\"\" + endDate + \"\\\" \" +\n                        outFile);\n\t\t\t\t****/\n                Command parseCommand = new Command(\"lighttpd_trunc_errorlog.sh \" +\n                        beginDate + \" \" + endDate + \" \" + outFile);\n                CommandHandle ch = RunContext.exec(parseCommand);\n\n            } catch (Exception e) {\n\n                logger.log(Level.WARNING, \"Failed to tranfer log of \" +\n                        myServers[i] + '.', e);\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n\n            logger.fine(\"XferLog Completed for \" + myServers[i]);\n        }\n\n    }\n\n    public static GregorianCalendar getGregorianCalendar(\n            String hostName)\n            throws Exception {\n        return RunContext.exec(hostName, new RemoteCallable<GregorianCalendar>() {\n\n            public GregorianCalendar call() {\n                return new GregorianCalendar();\n            }\n        });\n    }\n\n    /**\n     *\n     * Kill all servers\n     * We simply stop them instead of doing a hard kill\n     */\n    public void kill() {\n        stopServers();\n        logger.info(\"Killed all lighttpd servers\");\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: LighttpdService.java,v 1.4 2008/05/08 17:19:09 shanti_s Exp $\n *\n * Copyright 2008 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\n\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.RunContext;\nimport com.sun.faban.harness.WildcardFileFilter;\nimport java.io.BufferedReader;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.InputStreamReader;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n *\n * This class implements the service to start/stop lighttpd instances.\n * It also provides functionality to transfer the portion of the lighttpd\n * error.log for a run to the run output directory.\n * It can be used by any lighttpd benchmark to manage lighttpd servers and\n * perform these operations remotely using this Service.\n *\n * @author Shanti Subramanyam\n */\nfinal public class LighttpdService implements WebServerService {\n\n    private static LighttpdService service = null;\n    private String[] myServers = new String[1];\n    private Logger logger;\n    private static String lightyCmd,  errlogFile,  acclogFile, confFile, pidFile;\n    private CommandHandle[] ch = null;\n\n    /**\n     *\n     * Private Constructor for a singleton object.\n     *\n     */\n    private LighttpdService() {\n        logger = Logger.getLogger(this.getClass().getName());\n        logger.fine(this.getClass().getName() + \" Created\");\n    }\n\n    /**\n     *\n     * Get the reference to the singleton object.\n     * Use this method to get access to the service.\n\t * @return LighttpdService - service object handle\n     */\n    public static LighttpdService getHandle() {\n        if (service == null) {\n            service = new LighttpdService();\n        }\n\n        return service;\n    }\n\n    /**\n     * The setup method is called to set up a benchmark run. \n     * It is assumed that all servers have the same installation directory\n     *\n     * @param serverMachines - array specifying the web server machines. \n     * @param binDir - lighttpd binary location\n     * @param logsDir - lighttpd logs location\n     * @param confDir - lighttpd conf file location\n     * @param pidDir - lighttpd.pid file location\n     */\n    public void setup(String[] serverMachines, String binDir, String logsDir, \n            String confDir, String pidDir) {\n        myServers = serverMachines;\n\n        lightyCmd = binDir + File.separator + \"lighttpd \";\n        errlogFile = logsDir + File.separator + \"error.log\";\n        acclogFile = logsDir + File.separator + \"access.log\";\n        confFile = confDir + File.separator + \"lighttpd.conf\";\n        pidFile = pidDir + File.separator + \"lighttpd.pid\";\n        logger.info(\"LighttpdService setup complete.\");\n\n    }\n\n    /**\n     * Start all apache servers on configured hosts\n     * @return boolean true if start succeeded on all machines, else false\n     */\n    public boolean startServers() {\n        Integer success = 0;\n        String cmd = lightyCmd + \"-f \" + confFile;\n        Command startCmd = new Command(cmd);\n        startCmd.setSynchronous(false);\n        startCmd.setLogLevel(Command.STDOUT, Level.FINE);\n        startCmd.setLogLevel(Command.STDERR, Level.FINE);\n        ch = new CommandHandle[myServers.length];\n        for (int i = 0; i < myServers.length; i++) {\n            String server = myServers[i];\n            try {\n                // Run the command in the foreground and wait for the start\n                ch[i] = RunContext.exec(server, startCmd);\n                \n                if (checkServerStarted(server)) {\n                    logger.fine(\"Completed lightttpd startup successfully on \" + server);\n                } else {\n                    logger.severe(\"Failed to find \" + pidFile + \" on \" + server);\n                    return (false);\n                }\n\n            } catch (Exception e) {\n                logger.warning(\"Failed to start lighttpd server with \" + e.toString());\n                logger.log(Level.FINE, \"Exception\", e);\n                return (false);\n            }\n        }\n        logger.info(\"Completed lighttpd server(s) startup\");\n        return (true);\n    }\n\n    /*\n     * Check if lighttpd server started by looking for pidfile\n\t * @param String hostName\n\t * @return boolean\n     */\n    private boolean checkServerStarted(String hostName) throws Exception {\n        boolean val = false;\n        \n        // Just to make sure we don't wait for ever.\n        // We try to read the msg 120 times before we give up\n        // Sleep 1 sec between each try. So wait for 1 min\n        int attempts = 60;\n        while (attempts > 0) {\n            if (RunContext.isFile(hostName, pidFile)) {\n               val = true;\n               break;\n            } else {\n                // Sleep for some time\n                 try {\n                     Thread.sleep(1000);\n                     attempts--;\n                 } catch (Exception e) {\n                     break;\n                 }\n            }\n        }\n        return (val);\n    }\n\n    /**\n     * Restart all servers. It first stops servers, clear logs\n     * and then attempts to start them up again. If startup fails on\n\t * any server, it will stop all servers and cleanup.\n\t * @return true if all servers restarted successfully, otherwise false\n     */\n    public boolean restartServers() {\n\n        logger.info(\"Restarting lighttpd server(s). Please wait ... \");\n        // We first stop and clear the logs\n        if (this.stopServers())\n            this.clearLogs();\n\n        // Now start the servers\n        if (!startServers()) {\n            // cleanup and return\n            if (stopServers())\n                clearLogs();\n            return false;\n        }\n        return (true);\n    }\n\n    /**\n     * stop Servers\n     * @return true if stop succeeded on all machines, else false\n     */\n    public boolean stopServers() {\n        boolean success = true;\n\tint pid = -1;\n\n        /******* Changing logic to check for pidfile and kill process\n        // First check if servers were started\n        // If there weren't started, simply return\n        if (ch == null || ch.length == 0) {\n            return (success);\n        }\n         */\n        for (String hostName : myServers) {\n            /***\n            try {\n                if (ch[i] != null) {\n                    ch[i].destroy();\n                }                \n            } catch (RemoteException re) {\n                logger.log(Level.WARNING, \"Failed to stop lighttpd on \" +\n                        myServers[i] + \" with \" + re);\n                logger.log(Level.FINE, \"lighttpd stop Exception\", re);                \n                success = false;\n            }\n             */\n            if (RunContext.isFile(hostName, pidFile)) {\n                // we retrieve the pid value\n                try {\n                    pid = getPid(hostName);\n                    logger.fine(\"Found lighttpd pidvalue of \" + pid + \" on host \" + hostName);\n                } catch (Exception ee) {\n                    logger.log(Level.WARNING, \"Failed to read lighttpd pidfile on \" +\n                            hostName + \" with \" + ee);\n                    logger.log(Level.FINE, \"Exception\", ee);                \n                    success = false;\n                }\n                if ( pid <= 0)\n                    continue;\n                // Now kill the server\n                Command cmd = new Command(\"kill \" + pid);\n                try {\n                    RunContext.exec(hostName, cmd);\n                    // Check if the server truly stopped\n                    int attempts = 60;\n                    boolean b = false;\n                    while (attempts > 0) {\n                        if ( ! RunContext.isFile(hostName, pidFile)) {\n                            b = true;\n                            break;\n                        } else {\n                            // Sleep for some time\n                            try {\n                                Thread.sleep(2000);\n                                attempts--;\n                            } catch (Exception e) {\n                                break;\n                            }\n                        }\n                    }\n                    if ( !b) {\n                        success = false;\n                        logger.severe(\"Cannot kill lighttpd pid \" + pid + \" on \" + hostName);\n                    }\n                } catch (Exception e) {\n                    success = false;\n                    logger.severe(\"kill \" + pid + \" failed on \" + hostName);\n                    logger.log(Level.FINE, \"Exception\", e);\n                }\n            }\n        }                \n        return (success);\n    }\n\n    /*\n     * Return lighttpd pid\n     * It reads the pid file from the remote server host and\n     * returns the pid stored in it. \n     * @param String hostName\n     * @return int pid\n     * @throws Exception\n     */\n    private static int getPid(String hostName) throws Exception {\n        int pid;\n\n        pid = RunContext.exec(hostName, new RemoteCallable<Integer>() {\n            public Integer call() throws Exception {\n                String pidval;\n\n                FileInputStream is = new FileInputStream(pidFile);\n                BufferedReader bufR = new BufferedReader(new InputStreamReader(is));\n                pidval = bufR.readLine();\n                bufR.close();\n                return (Integer.parseInt(pidval));\n            }\n         });\n        return (pid);\n    }\n\n    /**\n     * clear server logs and session files\n\t * clears access log, error log, pidfile and session files\n     * It assumes that session files are in /tmp/sess*\n     * @return true if operation succeeded, else fail\n     */\n    public boolean clearLogs() {\n        Command cmd = new Command(\"rm -f /tmp/sess*\");\n\t\tboolean success = true;\n\n        for (int i = 0; i < myServers.length; i++) {\n            if (RunContext.isFile(myServers[i], errlogFile)) {\n                if (!RunContext.deleteFile(myServers[i], errlogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + errlogFile +\n                            \" failed on \" + myServers[i]);\n                    success = false;\n                }\n            }\n            if (RunContext.isFile(myServers[i], acclogFile)) {\n                if (!RunContext.deleteFile(myServers[i], acclogFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + acclogFile +\n                            \" failed on \" + myServers[i]);\n                    success = false;\n                }\n            }\n           if (RunContext.isFile(myServers[i], pidFile)) {\n                if (!RunContext.deleteFile(myServers[i], pidFile)) {\n                    logger.log(Level.WARNING, \"Delete of \" + pidFile +\n                            \" failed on \" + myServers[i]);\n                    success = false;\n                }\n            }\n\n            logger.fine(\"Logs cleared for \" + myServers[i]);\n             // Now delete the session files\n             if (RunContext.deleteFiles(myServers[i], \"/tmp\",\n                        new WildcardFileFilter(\"sess*\")))\n                 logger.fine(\"Deleted session files for \" + myServers[i]);\n             else\n                 logger.warning(\"Error deleting session files for \" +\n                            myServers[i]);\n        }\n        return (success);\n    }\n\n    /**\n     * transfer log files\n\t * This method copies over the error log to the run output directory\n\t * and keeps only the portion of the log relevant for this run\n\t * @param totalRunTime - the time in seconds for this run\n     */\n    public void xferLogs(int totalRunTime) {\n\n        for (int i = 0; i < myServers.length; i++) {\n            String outFile = RunContext.getOutDir() + \"error_log.\" + myServers[i];\n\n            // copy the error_log to the master\n            if (!RunContext.getFile(myServers[i], errlogFile, outFile)) {\n                logger.warning(\"Could not copy \" + errlogFile + \" to \" + outFile);\n                return;\n            }\n\n            try {\n                // Now get the start and end times of the run\n                GregorianCalendar calendar = getGregorianCalendar(myServers[i]);\n\n                //format the end date\n                SimpleDateFormat df = new SimpleDateFormat(\"MM,dd,HH:mm:ss\");\n                String endDate = df.format(calendar.getTime());\n\n                calendar.add(Calendar.SECOND, (totalRunTime * (-1)));\n\n                String beginDate = df.format(calendar.getTime());\n\n                //parse the log file\n\t\t\t\t/*****\n                Command parseCommand = new Command(\"apache_trunc_errorlog.sh \\\"\" +\n                        beginDate + \"\\\"\" + \" \\\"\" + endDate + \"\\\" \" +\n                        outFile);\n\t\t\t\t****/\n                Command parseCommand = new Command(\"lighttpd_trunc_errorlog.sh \" +\n                        beginDate + \" \" + endDate + \" \" + outFile);\n                CommandHandle ch = RunContext.exec(parseCommand);\n\n            } catch (Exception e) {\n\n                logger.log(Level.WARNING, \"Failed to tranfer log of \" +\n                        myServers[i] + '.', e);\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n\n            logger.fine(\"XferLog Completed for \" + myServers[i]);\n        }\n\n    }\n\n    public static GregorianCalendar getGregorianCalendar(\n            String hostName)\n            throws Exception {\n        return RunContext.exec(hostName, new RemoteCallable<GregorianCalendar>() {\n\n            public GregorianCalendar call() {\n                return new GregorianCalendar();\n            }\n        });\n    }\n\n    /**\n     *\n     * Kill all servers\n     * We simply stop them instead of doing a hard kill\n     */\n    public void kill() {\n        stopServers();\n        logger.info(\"Killed all lighttpd servers\");\n    }\n}\n","lineNo":304}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: AgentThread.java,v 1.10 2007/09/07 15:49:04 noahcampbell Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.driver.BenchmarkOperation;\nimport com.sun.faban.driver.FatalException;\nimport com.sun.faban.driver.Timing;\nimport com.sun.faban.driver.ExpectedException;\nimport com.sun.faban.driver.util.Random;\nimport com.sun.faban.driver.util.Timer;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.io.InterruptedIOException;\n\n\n/**\n * Abstract superclass for all driver threads. It provides a factory for\n * instantiating the right implementation depending on the driver specification.\n * Subclasses execute the provided driver, keeps track of response times,\n * think times, transaction counts, etc.\n *\n * @author Akara Sucharitakul\n */\npublic abstract class AgentThread extends Thread {\n\n\t/**\n\t * The various run states for an {@link AgentThread}.\n\t * \n\t * @author ncampbell\n\t */\n\tpublic static enum RunState {\n\t\t/* !!!\n\t\t * Please note the order is significant for this enumeration.  A\n\t\t * Enum#compareTo is used which is based on the order of these RunStates.\n\t\t * !!!\n\t\t */\n\t\t/**\n\t\t * The {@link AgentThread} thread has not started\n\t\t */\n\t    NOT_STARTED,\n\t    /**\n\t     * The {@link AgentThread} has initialized.\n\t     */\n\t    INITIALIZING,\n\t    /**\n\t     * The {@link AgentThread} is executing {@link BenchmarkOperation}s to warm\n\t     * the SUT.\n\t     */\n\t    PRE_RUN,\n\t    /**\n\t     * The {@link AgentThread} is running in steady state.\n\t     */\n\t    RUNNING,\n\t    /**\n\t     * The {@link AgentThread} is doing a post run.\n\t     */\n\t    POST_RUN,\n\t    /**\n\t     *  The {@link AgentThread} has completed.\n\t     */\n\t    ENDED\n\t}\n\n    String type;\n    String name;\n    int id;\n    int currentOperation = -1; // Global index into the current operation.\n    int[] previousOperation; // Index into the previous operation.\n    int mixId = 0; // 0 for foreground and 1 for background\n    Mix.Selector[] selector; // The selector array, size 1 if no bg, 2 if bg\n\n    DriverContext driverContext;\n    Metrics metrics;\n    Random random = new Random();\n    Timer timer;\n    AgentImpl agent;\n    RunInfo.DriverConfig driverConfig;\n    Class<?> driverClass;\n    Object driver;\n    boolean inRamp = true; // indicator for rampup or rampdown, initially true\n    int[] delayTime;  // recently calculated cycle times\n    int[] startTime; // start times for previous tx\n    int[] endTime; // end time for the recent tx ended\n\n    private RunState threadState = RunState.NOT_STARTED;\n\n    Logger logger;\n    String className;\n    int endRampUp, endStdyState, endRampDown;\n    int cycleCount = 0; // The cycles executed so far\n\n    /** Run configuration from the Master */\n    RunInfo runInfo;\n\n    boolean startTimeSet = false;\n\n    boolean stopped = false;\n\n    /**\n     * Factory method for instantiating the right type of AgentThread.\n     * @param type The type of this agent\n     * @param agentId The display id of this agent\n     * @param id The id of this agent\n     * @param driverClass The driver class\n     * @param timer The timer object reference\n     * @param agent The agent calling this thread\n     * @return An instance of the AgentThread subclass.\n     */\n    public static AgentThread getInstance(String type, String agentId, int id,\n                                Class<?> driverClass, Timer timer,\n                                AgentImpl agent) {\n        RunInfo.DriverConfig driverConfig = RunInfo.getInstance().driverConfig;\n        AgentThread agentThread = null;\n        switch (driverConfig.runControl) {\n           case TIME : if (driverConfig.mix[1] != null) {\n\t\t\tagentThread = new TimeThreadWithBackground();\n\t\t} else {\n\t\t\tagentThread = new TimeThread();\n\t\t}\n                       break;\n           case CYCLES : agentThread = new CycleThread();\n        }\n\n        agentThread.configure(type, agentId, id, driverClass, timer, agent);\n        return agentThread;\n    }\n\n    /**\n     * Configures this AgentThread.\n     *\n     * @param type The type of this agent\n     * @param agentId The display id of this agent\n     * @param id The id of this agent\n     * @param driverClass The driver class\n     * @param timer The timer object reference\n     * @param agent The agent calling this thread\n     */\n    private void configure(String type, String agentId, int id,\n                                Class<?> driverClass, Timer timer,\n                                AgentImpl agent) {\n        this.type = type;\n        this.id = id;\n        this.driverClass = driverClass;\n        this.timer = timer;\n        this.runInfo = RunInfo.getInstance();\n        this.agent = agent;\n        random = new Random(timer.getTime() + hashCode());\n        className = getClass().getName();\n        driverConfig = runInfo.driverConfig;\n        name = type + '[' + agentId + \"].\" + id;\n        setName(name);\n        logger = Logger.getLogger(className + '.' + id);\n        metrics = new Metrics(this);\n        initTimes();\n    }\n\n    /**\n     *  Allocates and initializes the timing structures which is specific\n     *  to the pseudo-thread dimensions.\n     */\n    abstract void initTimes();\n\n    /**\n     * Entry point for starting the thread. Subclasses do not override this\n     * method but override doRun instead. Run implicitly calls doRun.\n     */\n    @Override\n\tpublic final void run() {\n        try {\n            setThreadState(RunState.INITIALIZING);\n            doRun();\n        } catch (FatalException e) {\n            // A fatal exception thrown by the driver is already caught\n            // in the run methods and logged there.\n            // A fatal exception otherwise thrown by the run\n            // methods signals termination of this thread.\n            if (!e.wasLogged())  {\n                Throwable t = e.getCause();\n                if (t != null) {\n\t\t\t\t\tlogger.log(Level.SEVERE, name + \": \" + t.getMessage(), t);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Level.SEVERE, name + \": \" + e.getMessage(), e);\n\t\t\t\t}\n                e.setLogged();\n                agent.abortRun();\n            }\n        } catch (Throwable t) {\n            logger.log(Level.SEVERE, name + \": \" + t.getMessage(), t);\n            agent.abortRun();\n        } finally {\n            postRun();\n        }\n    }\n\n    /**\n     * Each thread executes in the doRun method until the benchmark time is up\n     * The main loop chooses a tx. type according to the mix specified in\n     * the parameter file and calls the appropriate transaction\n     * method to do the job.\n   \t * The stats for the entire run are stored in a Metrics object\n   \t * which is returned to the Agent via the getResult() method.\n     * @see Metrics\n     */\n    abstract void doRun();\n\n    /**\n     * Checks for a fatal exception. This is called from the invocation loop.\n     * @param e The throwable\n     * @param op The operation\n     */\n    void checkFatal(Throwable e, BenchmarkDefinition.Operation op) {\n        if (e instanceof FatalException) {\n            FatalException fatal = (FatalException) e;\n            e = fatal.getCause();\n            if (e != null) {\n\t\t\t\tlogger.log(Level.SEVERE, name + '.' + op.m.getName() +\n                        \": \" + e.getMessage(), e);\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.SEVERE, name + '.' + op.m.getName() +\n                        \": \" + fatal.getMessage(), fatal);\n\t\t\t}\n            fatal.setLogged();\n            agent.abortRun();\n            throw fatal; // Also don't continue with current thread.\n        }\n    }\n\n    /**\n     * Logs the normal errors occuring in operations. The operation is marked\n     * as failed.\n     * @param e  The throwable received\n     * @param op The operation being executed.\n     */\n    void logError(Throwable e, BenchmarkDefinition.Operation op) {\n        String message = name + \".\" + op.m.getName() + \": \" +\n                e.getMessage();\n        if (inRamp) {\n\t\t\tmessage += \"\\nNote: Error not counted in result.\" +\n                    \"\\nEither transaction start or end time is not \" +\n                    \"within steady state.\";\n\t\t}\n        Level level;\n        if (e instanceof ExpectedException) {\n\t\t\tlevel = Level.FINER;\n\t\t} else {\n\t\t\tlevel = Level.WARNING;\n\t\t}\n        logger.log(level, message, e);\n    }\n\n    private synchronized void setThreadState(RunState state) {\n        threadState = state;\n        notifyAll();\n    }\n\n    private synchronized boolean compareAndSetThreadState(RunState orig, RunState state) {\n        boolean set = threadState == orig;\n        if (set) {\n            threadState = state;\n            notifyAll();\n        }\n        return set;\n    }\n\n\n    /**\n     * Obtains the state of the current thread.\n     * @return The state of the current thread.\n     */\n    public synchronized RunState getThreadState() {\n        return threadState;\n    }\n\n    /**\n     * Waits for a given state of the thread to arrive.\n     * @param state The state to wait for.\n     */\n    public synchronized void waitThreadState(RunState state) {\n        while (threadState.compareTo(state) < 0) {\n            try {\n                wait(10000);\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * Executes the method market with @OnceBefore in thread 0\n     */\n    void preRun() {\n        // Thread 0 needs to do the preRun\n        if (id == 0 && driverConfig.preRun != null) {\n            setThreadState(RunState.PRE_RUN);\n            logger.fine(name + \": Invoking preRun @OnceBefore\");\n            try {\n                invokePrePost(driverConfig.preRun.m);\n            } catch (InterruptedIOException e) {\n                // Should not happen unless run is cancelled. And if so,\n                // we don't really care to redo this.\n            }\n            agent.preRunLatch.countDown();\n        }\n        setThreadState(RunState.RUNNING);\n    }\n\n    /**\n     * Executes the method market with @OnceAfter in thread 0\n     */\n    void postRun() {\n        if (id == 0 && driverConfig.postRun != null &&\n                compareAndSetThreadState(RunState.RUNNING, RunState.POST_RUN)) {\n            while (agent.postRunLatch.getCount() > 0l) {\n\t\t\t\ttry {\n                    agent.postRunLatch.await();\n                } catch (InterruptedException e) {\n                \tlogger.log(Level.FINE, e.getMessage(), e);\n                }\n\t\t\t}\n            // We need to make sure this method is re-run if I/O is interrupted.\n            // This may happen if terminate gets called while thread is\n            // switching to POST_RUN state.\n            boolean interrupted = false;\n            logger.fine(name + \": Invoking postRun @OnceAfter\");\n            do {\n                try {\n                    invokePrePost(driverConfig.postRun.m);\n                } catch (InterruptedIOException e) {\n                    interrupted = true;\n                }\n            } while (interrupted);\n        }\n        setThreadState(RunState.ENDED);\n    }\n\n    private void invokePrePost(Method m) throws InterruptedIOException {\n        try {\n            m.invoke(driver);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause == null) {\n\t\t\t\tcause = e;\n\t\t\t}\n            logger.log(Level.WARNING, name + \".\" + m.getName() + \": \" +\n                    e.getMessage(), e);\n            if (cause instanceof InterruptedIOException) {\n\t\t\t\tthrow (InterruptedIOException) cause;\n\t\t\t}\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, name + \".\" + m.getName() + \": \" +\n                    e.getMessage(), e);\n        }\n\n    }\n\n    /**\n     * Obtains the invoke time of the next operation. \n     * \n     * @param op The operation\n     * @param mixId The mix\n     * @return The targeted invoke time.\n     */\n    int getInvokeTime(BenchmarkDefinition.Operation op, int mixId) {\n        Cycle cycle;\n        if (op == null) {\n\t\t\t// No op, this is the initial cycle, use initialDelay\n            cycle = runInfo.driverConfig.initialDelay[mixId];\n\t\t} else {\n\t\t\t// Set the start time based on the operation selected\n            cycle = op.cycle;\n\t\t}\n\n        int invokeTime = -1;\n        delayTime[mixId] = cycle.getDelay(random);\n\n        switch (cycle.cycleType) {\n            case CYCLETIME :\n                invokeTime = startTime[mixId] + delayTime[mixId];\n                break;\n            case THINKTIME :\n                invokeTime = endTime[mixId] + delayTime[mixId];\n                break;\n        }\n        return invokeTime;\n    }\n\n    /**\n     * This method blocks until the start time is set by the master.\n     * Called by AgentThread implementations.\n     */\n    void waitStartTime() {\n        try {\n            agent.timeSetLatch.await();\n            startTimeSet = true;\n            int delay = runInfo.benchStartTime - timer.getTime();\n            if (delay <= 0) {\n                logger.severe(name + \": TriggerTime has expired. \" +\n                        \"Need \" + (-delay) + \" ms more\");\n                agent.abortRun();\n            } else {\n                // debug.println(3, ident + \"Sleeping for \" + delay + \"ms\");\n                Thread.sleep(delay);\n            }\n        } catch (InterruptedException e) { // Run is killed.\n            throw new FatalException(e);\n        }\n    }\n\n    /**\n     * Validates whether the times for a successful operation are properly\n     * captured. Called by AgentThread implementations.\n     * @param op The operation.\n     */\n    void validateTimeCompletion(BenchmarkDefinition.Operation op) {\n        DriverContext.TimingInfo timingInfo = driverContext.timingInfo;\n\n        // If there is no error, we still check for the\n        // unusual case of time not recorded and issue the\n        // proper message.\n        if (timingInfo.invokeTime == -1) {\n            String msg = null;\n            if (driverConfig.operations[\n                    currentOperation].timing == Timing.AUTO) {\n                msg = name + '.' + op.m.getName() +\n                        \": Transport not called! \" +\n                        \"Please ensure transport instantiation \" +\n                        \"before making any remote calls!\";\n            } else {\n                msg = name + '.' + op.m.getName() +\n                        \": Cannot determine time! \" +\n                        \"DriverContext.recordTime() not called \" +\n                        \"before critical section in operation.\";\n\n            }\n            logger.severe(msg);\n            agent.abortRun();\n            throw new FatalException(msg);\n        } else if (timingInfo.respondTime == -1) {\n            String msg = null;\n            if (driverConfig.operations[\n                    currentOperation].timing == Timing.AUTO) {\n                msg = name + '.' + op.m.getName() +\n                        \": Transport incomplete! \" +\n                        \"Please ensure transport exception is \" +\n                        \"thrown from operation.\";\n            } else {\n                msg = name + '.' + op.m.getName() +\n                        \": Cannot determine end time! \" +\n                        \"DriverContext.recordTime() not called \" +\n                        \"after critical section in operation.\";\n\n            }\n            logger.severe(msg);\n            agent.abortRun();\n            throw new FatalException(msg);\n        }\n    }\n\n    /**\n     * Checks whether the last operation is in the ramp-up or ramp-down or\n     * not. Updates the inRamp parameter accordingly.  This is only supposed\n     * to be called from a subclass.\n     */\n    abstract void checkRamp();\n\n    /**\n     * Tests whether the last operation is in steady state or not. This is\n     * called through the context from the driver from within the operation\n     * so we need to be careful not to change run control parameters. This\n     * method only reads the stats.\n     * @return True if the last operation is in steady state, false otherwise.\n     */\n    abstract boolean isSteadyState();\n\n    /**\n     * Tests whether the time between start and end is in steady state or not.\n     * For non time-based steady state, this will depend on the current cycle\n     * count. Otherwise time is used.\n     * @param start The start of a time span\n     * @param end The end of a time span\n     * @return true if this time span is in steady state, false otherwise.\n     */\n    abstract boolean isSteadyState(int start, int end);\n\n    /**\n     * Return results of this thread.\n     * @return Final stats\n     */\n    public Metrics getResult() {\n        return(metrics);\n    }\n\n    /**\n     * Triggers stopping and exiting of this thread.\n     */\n    public void stopExecution() {\n        stopped = true;\n        interrupt();\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: AgentThread.java,v 1.11 2008/04/18 07:11:40 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.driver.core;\n\nimport com.sun.faban.driver.BenchmarkOperation;\nimport com.sun.faban.driver.FatalException;\nimport com.sun.faban.driver.Timing;\nimport com.sun.faban.driver.ExpectedException;\nimport com.sun.faban.driver.util.Random;\nimport com.sun.faban.driver.util.Timer;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.io.InterruptedIOException;\n\n\n/**\n * Abstract superclass for all driver threads. It provides a factory for\n * instantiating the right implementation depending on the driver specification.\n * Subclasses execute the provided driver, keeps track of response times,\n * think times, transaction counts, etc.\n *\n * @author Akara Sucharitakul\n */\npublic abstract class AgentThread extends Thread {\n\n\t/**\n\t * The various run states for an {@link AgentThread}.\n\t * \n\t * @author ncampbell\n\t */\n\tpublic static enum RunState {\n\t\t/* !!!\n\t\t * Please note the order is significant for this enumeration.  A\n\t\t * Enum#compareTo is used which is based on the order of these RunStates.\n\t\t * !!!\n\t\t */\n\t\t/**\n\t\t * The {@link AgentThread} thread has not started\n\t\t */\n\t    NOT_STARTED,\n\t    /**\n\t     * The {@link AgentThread} has initialized.\n\t     */\n\t    INITIALIZING,\n\t    /**\n\t     * The {@link AgentThread} is executing {@link BenchmarkOperation}s to warm\n\t     * the SUT.\n\t     */\n\t    PRE_RUN,\n\t    /**\n\t     * The {@link AgentThread} is running in steady state.\n\t     */\n\t    RUNNING,\n\t    /**\n\t     * The {@link AgentThread} is doing a post run.\n\t     */\n\t    POST_RUN,\n\t    /**\n\t     *  The {@link AgentThread} has completed.\n\t     */\n\t    ENDED\n\t}\n\n    String type;\n    String name;\n    int id;\n    int currentOperation = -1; // Global index into the current operation.\n    int[] previousOperation; // Index into the previous operation.\n    int mixId = 0; // 0 for foreground and 1 for background\n    Mix.Selector[] selector; // The selector array, size 1 if no bg, 2 if bg\n\n    DriverContext driverContext;\n    Metrics metrics;\n    Random random = new Random();\n    Timer timer;\n    AgentImpl agent;\n    RunInfo.DriverConfig driverConfig;\n    Class<?> driverClass;\n    Object driver;\n    boolean inRamp = true; // indicator for rampup or rampdown, initially true\n    int[] delayTime;  // recently calculated cycle times\n    int[] startTime; // start times for previous tx\n    int[] endTime; // end time for the recent tx ended\n\n    private RunState threadState = RunState.NOT_STARTED;\n\n    Logger logger;\n    String className;\n    int endRampUp, endStdyState, endRampDown;\n    int cycleCount = 0; // The cycles executed so far\n\n    /** Run configuration from the Master */\n    RunInfo runInfo;\n\n    boolean startTimeSet = false;\n\n    boolean stopped = false;\n\n    /**\n     * Factory method for instantiating the right type of AgentThread.\n     * @param type The type of this agent\n     * @param agentId The display id of this agent\n     * @param id The id of this agent\n     * @param driverClass The driver class\n     * @param timer The timer object reference\n     * @param agent The agent calling this thread\n     * @return An instance of the AgentThread subclass.\n     */\n    public static AgentThread getInstance(String type, String agentId, int id,\n                                Class<?> driverClass, Timer timer,\n                                AgentImpl agent) {\n        RunInfo.DriverConfig driverConfig = RunInfo.getInstance().driverConfig;\n        AgentThread agentThread = null;\n        switch (driverConfig.runControl) {\n           case TIME : if (driverConfig.mix[1] != null) {\n\t\t\tagentThread = new TimeThreadWithBackground();\n\t\t} else {\n\t\t\tagentThread = new TimeThread();\n\t\t}\n                       break;\n           case CYCLES : agentThread = new CycleThread();\n        }\n\n        agentThread.configure(type, agentId, id, driverClass, timer, agent);\n        return agentThread;\n    }\n\n    /**\n     * Configures this AgentThread.\n     *\n     * @param type The type of this agent\n     * @param agentId The display id of this agent\n     * @param id The id of this agent\n     * @param driverClass The driver class\n     * @param timer The timer object reference\n     * @param agent The agent calling this thread\n     */\n    private void configure(String type, String agentId, int id,\n                                Class<?> driverClass, Timer timer,\n                                AgentImpl agent) {\n        this.type = type;\n        this.id = id;\n        this.driverClass = driverClass;\n        this.timer = timer;\n        this.runInfo = RunInfo.getInstance();\n        this.agent = agent;\n        random = new Random(timer.getTime() + hashCode());\n        className = getClass().getName();\n        driverConfig = runInfo.driverConfig;\n        name = type + '[' + agentId + \"].\" + id;\n        setName(name);\n        logger = Logger.getLogger(className + '.' + id);\n        metrics = new Metrics(this);\n        initTimes();\n    }\n\n    /**\n     *  Allocates and initializes the timing structures which is specific\n     *  to the pseudo-thread dimensions.\n     */\n    abstract void initTimes();\n\n    /**\n     * Entry point for starting the thread. Subclasses do not override this\n     * method but override doRun instead. Run implicitly calls doRun.\n     */\n    @Override\n\tpublic final void run() {\n        try {\n            setThreadState(RunState.INITIALIZING);\n            doRun();\n        } catch (FatalException e) {\n            // A fatal exception thrown by the driver is already caught\n            // in the run methods and logged there.\n            // A fatal exception otherwise thrown by the run\n            // methods signals termination of this thread.\n            if (!e.wasLogged())  {\n                Throwable t = e.getCause();\n                if (t != null) {\n\t\t\t\t\tlogger.log(Level.SEVERE, name + \": \" + t.getMessage(), t);\n\t\t\t\t} else {\n\t\t\t\t\tlogger.log(Level.SEVERE, name + \": \" + e.getMessage(), e);\n\t\t\t\t}\n                e.setLogged();\n                agent.abortRun();\n            }\n        } catch (Throwable t) {\n            logger.log(Level.SEVERE, name + \": \" + t.getMessage(), t);\n            agent.abortRun();\n        } finally {\n            postRun();\n        }\n    }\n\n    /**\n     * Each thread executes in the doRun method until the benchmark time is up\n     * The main loop chooses a tx. type according to the mix specified in\n     * the parameter file and calls the appropriate transaction\n     * method to do the job.\n   \t * The stats for the entire run are stored in a Metrics object\n   \t * which is returned to the Agent via the getResult() method.\n     * @see Metrics\n     */\n    abstract void doRun();\n\n    /**\n     * Checks for a fatal exception. This is called from the invocation loop.\n     * @param e The throwable\n     * @param op The operation\n     */\n    void checkFatal(Throwable e, BenchmarkDefinition.Operation op) {\n        if (e instanceof FatalException) {\n            FatalException fatal = (FatalException) e;\n            e = fatal.getCause();\n            if (e != null) {\n\t\t\t\tlogger.log(Level.SEVERE, name + '.' + op.m.getName() +\n                        \": \" + e.getMessage(), e);\n\t\t\t} else {\n\t\t\t\tlogger.log(Level.SEVERE, name + '.' + op.m.getName() +\n                        \": \" + fatal.getMessage(), fatal);\n\t\t\t}\n            fatal.setLogged();\n            agent.abortRun();\n            throw fatal; // Also don't continue with current thread.\n        }\n    }\n\n    /**\n     * Logs the normal errors occuring in operations. The operation is marked\n     * as failed.\n     * @param e  The throwable received\n     * @param op The operation being executed.\n     */\n    void logError(Throwable e, BenchmarkDefinition.Operation op) {\n        String message = e.getMessage();\n        if (message == null) { // Find the message in the highest level exception.\n            Throwable t = e.getCause();\n            while (message == null && t != null) {\n                message = t.getMessage();\n                t = t.getCause();\n            }\n        }\n        if (message == null) // If still null, artificially create message.\n            message = \"Exception in operation.\";\n        message = name + \".\" + op.m.getName() + \": \" + message;\n\n        if (inRamp) {\n\t\t\tmessage += \"\\nNote: Error not counted in result.\" +\n                    \"\\nEither transaction start or end time is not \" +\n                    \"within steady state.\";\n\t\t}\n        Level level;\n        if (e instanceof ExpectedException) {\n\t\t\tlevel = Level.FINER;\n\t\t} else {\n\t\t\tlevel = Level.WARNING;\n\t\t}\n        logger.log(level, message, e);\n    }\n\n    private synchronized void setThreadState(RunState state) {\n        threadState = state;\n        notifyAll();\n    }\n\n    private synchronized boolean compareAndSetThreadState(RunState orig, RunState state) {\n        boolean set = threadState == orig;\n        if (set) {\n            threadState = state;\n            notifyAll();\n        }\n        return set;\n    }\n\n\n    /**\n     * Obtains the state of the current thread.\n     * @return The state of the current thread.\n     */\n    public synchronized RunState getThreadState() {\n        return threadState;\n    }\n\n    /**\n     * Waits for a given state of the thread to arrive.\n     * @param state The state to wait for.\n     */\n    public synchronized void waitThreadState(RunState state) {\n        while (threadState.compareTo(state) < 0) {\n            try {\n                wait(10000);\n            } catch (InterruptedException e) {\n            \tlogger.log(Level.FINE, e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * Executes the method market with @OnceBefore in thread 0\n     */\n    void preRun() {\n        // Thread 0 needs to do the preRun\n        if (id == 0 && driverConfig.preRun != null) {\n            setThreadState(RunState.PRE_RUN);\n            logger.fine(name + \": Invoking preRun @OnceBefore\");\n            try {\n                invokePrePost(driverConfig.preRun.m);\n            } catch (InterruptedIOException e) {\n                // Should not happen unless run is cancelled. And if so,\n                // we don't really care to redo this.\n            }\n            agent.preRunLatch.countDown();\n        }\n        setThreadState(RunState.RUNNING);\n    }\n\n    /**\n     * Executes the method market with @OnceAfter in thread 0\n     */\n    void postRun() {\n        if (id == 0 && driverConfig.postRun != null &&\n                compareAndSetThreadState(RunState.RUNNING, RunState.POST_RUN)) {\n            while (agent.postRunLatch.getCount() > 0l) {\n\t\t\t\ttry {\n                    agent.postRunLatch.await();\n                } catch (InterruptedException e) {\n                \tlogger.log(Level.FINE, e.getMessage(), e);\n                }\n\t\t\t}\n            // We need to make sure this method is re-run if I/O is interrupted.\n            // This may happen if terminate gets called while thread is\n            // switching to POST_RUN state.\n            boolean interrupted = false;\n            logger.fine(name + \": Invoking postRun @OnceAfter\");\n            do {\n                try {\n                    invokePrePost(driverConfig.postRun.m);\n                } catch (InterruptedIOException e) {\n                    interrupted = true;\n                }\n            } while (interrupted);\n        }\n        setThreadState(RunState.ENDED);\n    }\n\n    private void invokePrePost(Method m) throws InterruptedIOException {\n        try {\n            m.invoke(driver);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause == null) {\n\t\t\t\tcause = e;\n\t\t\t}\n            logger.log(Level.WARNING, name + \".\" + m.getName() + \": \" +\n                    e.getMessage(), e);\n            if (cause instanceof InterruptedIOException) {\n\t\t\t\tthrow (InterruptedIOException) cause;\n\t\t\t}\n        } catch (IllegalAccessException e) {\n            logger.log(Level.SEVERE, name + \".\" + m.getName() + \": \" +\n                    e.getMessage(), e);\n        }\n\n    }\n\n    /**\n     * Obtains the invoke time of the next operation. \n     * \n     * @param op The operation\n     * @param mixId The mix\n     * @return The targeted invoke time.\n     */\n    int getInvokeTime(BenchmarkDefinition.Operation op, int mixId) {\n        Cycle cycle;\n        if (op == null) {\n\t\t\t// No op, this is the initial cycle, use initialDelay\n            cycle = runInfo.driverConfig.initialDelay[mixId];\n\t\t} else {\n\t\t\t// Set the start time based on the operation selected\n            cycle = op.cycle;\n\t\t}\n\n        int invokeTime = -1;\n        delayTime[mixId] = cycle.getDelay(random);\n\n        switch (cycle.cycleType) {\n            case CYCLETIME :\n                invokeTime = startTime[mixId] + delayTime[mixId];\n                break;\n            case THINKTIME :\n                invokeTime = endTime[mixId] + delayTime[mixId];\n                break;\n        }\n        return invokeTime;\n    }\n\n    /**\n     * This method blocks until the start time is set by the master.\n     * Called by AgentThread implementations.\n     */\n    void waitStartTime() {\n        try {\n            agent.timeSetLatch.await();\n            startTimeSet = true;\n            int delay = runInfo.benchStartTime - timer.getTime();\n            if (delay <= 0) {\n                logger.severe(name + \": TriggerTime has expired. \" +\n                        \"Need \" + (-delay) + \" ms more\");\n                agent.abortRun();\n            } else {\n                // debug.println(3, ident + \"Sleeping for \" + delay + \"ms\");\n                Thread.sleep(delay);\n            }\n        } catch (InterruptedException e) { // Run is killed.\n            throw new FatalException(e);\n        }\n    }\n\n    /**\n     * Validates whether the times for a successful operation are properly\n     * captured. Called by AgentThread implementations.\n     * @param op The operation.\n     */\n    void validateTimeCompletion(BenchmarkDefinition.Operation op) {\n        DriverContext.TimingInfo timingInfo = driverContext.timingInfo;\n\n        // If there is no error, we still check for the\n        // unusual case of time not recorded and issue the\n        // proper message.\n        if (timingInfo.invokeTime == -1) {\n            String msg = null;\n            if (driverConfig.operations[\n                    currentOperation].timing == Timing.AUTO) {\n                msg = name + '.' + op.m.getName() +\n                        \": Transport not called! \" +\n                        \"Please ensure transport instantiation \" +\n                        \"before making any remote calls!\";\n            } else {\n                msg = name + '.' + op.m.getName() +\n                        \": Cannot determine time! \" +\n                        \"DriverContext.recordTime() not called \" +\n                        \"before critical section in operation.\";\n\n            }\n            logger.severe(msg);\n            agent.abortRun();\n            throw new FatalException(msg);\n        } else if (timingInfo.respondTime == -1) {\n            String msg = null;\n            if (driverConfig.operations[\n                    currentOperation].timing == Timing.AUTO) {\n                msg = name + '.' + op.m.getName() +\n                        \": Transport incomplete! \" +\n                        \"Please ensure transport exception is \" +\n                        \"thrown from operation.\";\n            } else {\n                msg = name + '.' + op.m.getName() +\n                        \": Cannot determine end time! \" +\n                        \"DriverContext.recordTime() not called \" +\n                        \"after critical section in operation.\";\n\n            }\n            logger.severe(msg);\n            agent.abortRun();\n            throw new FatalException(msg);\n        }\n    }\n\n    /**\n     * Checks whether the last operation is in the ramp-up or ramp-down or\n     * not. Updates the inRamp parameter accordingly.  This is only supposed\n     * to be called from a subclass.\n     */\n    abstract void checkRamp();\n\n    /**\n     * Tests whether the last operation is in steady state or not. This is\n     * called through the context from the driver from within the operation\n     * so we need to be careful not to change run control parameters. This\n     * method only reads the stats.\n     * @return True if the last operation is in steady state, false otherwise.\n     */\n    abstract boolean isSteadyState();\n\n    /**\n     * Tests whether the time between start and end is in steady state or not.\n     * For non time-based steady state, this will depend on the current cycle\n     * count. Otherwise time is used.\n     * @param start The start of a time span\n     * @param end The end of a time span\n     * @return true if this time span is in steady state, false otherwise.\n     */\n    abstract boolean isSteadyState(int start, int end);\n\n    /**\n     * Return results of this thread.\n     * @return Final stats\n     */\n    public Metrics getResult() {\n        return(metrics);\n    }\n\n    /**\n     * Triggers stopping and exiting of this thread.\n     */\n    public void stopExecution() {\n        stopped = true;\n        interrupt();\n    }\n}\n","lineNo":259}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: ParamRepository.java,v 1.8 2008/04/02 07:24:50 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.harness.util.XMLReader;\nimport com.sun.faban.common.NameValuePair;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\n\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Node;\n\n/**\n * The ParamRepository is the programmatic representation of the\n * configuration file. It allows access to the xml file via xpath.\n * In addition, the ParamRepository also allows updating the configuration\n * file. Such updates should be made during the validation stage.\n */\npublic class ParamRepository {\n\n\n    private XMLReader reader;\n\n    /**\n     * Constructor: Open specified repository\n     * @param file Name of repository\n     * @param warnDeprecated Log warning when config file is deprecated\n     */\n    public ParamRepository(String file, boolean warnDeprecated) {\n        reader = new XMLReader(file, true, warnDeprecated);\n        reader.processHostPorts(); //Pre-scan the hosts:ports fields\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return value of the parameter\n     */\n    public String getParameter(String xpath) {\n        return reader.getValue(xpath);\n    }\n\n    /**\n     * Sets or replaces the parameter referenced by the XPath.\n     * @param xpath The xpath referencing the parameter\n     * @param newValue The new value to set\n     */\n    public void setParameter(String xpath, String newValue) {\n        reader.setValue(xpath, newValue);\n    }\n\n    /**\n     * Saves the parameter repository back to file if it has been modified.\n     *\n     * @throws Exception If there is an exception saving the repository.\n     */\n    public void save() throws Exception {\n        reader.save(null);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return list containing all paramters with the xpath\n     */\n    public List<String> getParameters(String xpath) {\n        return reader.getValues(xpath);\n    }\n\n    /**\n     * Gets the attribute values for the specified attribute of a certain XPath.\n     *\n     * @param elementPath The XPath of the element\n     * @param attributeName The name of the attribute\n     * @return A list of attribute values\n     */\n    public List<String> getAttributeValues(String elementPath, String attributeName) {\n        return reader.getAttributeValues(elementPath, attributeName);\n    }\n\n    /**\n     * This returns tokenized values of parameters in a list.\n     * Mainly used to get host(s)\n     * @param xpath The xpath to the parameters\n     * @return List of tokenized values\n     */\n    public List<String[]> getTokenizedParameters(String xpath) {\n        ArrayList<String[]> params = new ArrayList<String[]>();\n        List<String> entries = reader.getValues(xpath);\n        for (String entry : entries) {\n            StringTokenizer st = new StringTokenizer(entry);\n            String[] values = new String[st.countTokens()];\n            for (int i = 0; st.hasMoreTokens(); i++)\n                values[i] = st.nextToken();\n            params.add(values);\n        }\n        return params;\n    }\n\n    /**\n     *\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath) {\n\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     *\n     * @param xpath XPath expression to get  ',' and SPACE seperated \n     * values from a single parameter. For Example sutConfig/instances\n     * The values are seperated by ',' and then by SPACE\n     * @return List of arrays of hostnames.\n     */\n    public List<String[]> getTokenizedList(String xpath) {\n        // Each value should be passed as , and SPACE seperated strings\n        ArrayList<String[]> list = new ArrayList<String[]>();\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        while (st.hasMoreTokens()) {\n            ArrayList<String> l = new ArrayList<String>();\n            StringTokenizer st2 = new  StringTokenizer(st.nextToken(), \",\");\n            while (st2.hasMoreTokens())\n                l.add(st2.nextToken());\n\n            list.add(l.toArray(new String[1]));\n        }\n        return list;\n    }\n\n    /**\n     * Obtains the host:port name value pair list from the element\n     * matching this XPath.\n     * @param xPathExpr\n     * @return The list of host:port elements, or null if the XPath does\n     * not exist or does not point to a host:port node.\n     */\n    public List<NameValuePair<Integer>> getHostPorts(String xPathExpr) {\n        return reader.getHostPorts(xPathExpr);\n    }\n\n    public List<NameValuePair<String>> getHostTypes() {\n        String hostsXPath = \"fa:hostConfig/fa:host\";\n        ArrayList<NameValuePair<String>> hostTypeList =\n                new ArrayList<NameValuePair<String>>();\n        NodeList nodes = reader.getNodeList(hostsXPath);\n        int length = nodes.getLength();\n        for (int i = 0; i < length; i++) {\n            Node node = nodes.item(i);\n            Node typeNode = node.getParentNode().getParentNode();\n            String type = typeNode.getNodeName();\n            String hosts = node.getFirstChild().getNodeValue();\n            StringTokenizer st = new StringTokenizer(hosts, \" ,\");\n            while (st.hasMoreTokens()) {\n                NameValuePair<String> hostType = new NameValuePair<String>();\n                hostType.name = st.nextToken();\n                hostType.value = type;\n                hostTypeList.add(hostType);\n            }\n        }\n        return hostTypeList;\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean\n     * @param xpath XPath expression to the value which is true or false\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath) {\n        return  Boolean.valueOf(reader.getValue(xpath)).booleanValue();\n    }\n\n\n}\n\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: ParamRepository.java,v 1.9 2008/04/15 07:11:12 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness;\n\nimport com.sun.faban.harness.util.XMLReader;\nimport com.sun.faban.common.NameValuePair;\n\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.ArrayList;\n\nimport org.w3c.dom.NodeList;\nimport org.w3c.dom.Node;\n\n/**\n * The ParamRepository is the programmatic representation of the\n * configuration file. It allows access to the xml file via xpath.\n * In addition, the ParamRepository also allows updating the configuration\n * file. Such updates should be made during the validation stage.\n */\npublic class ParamRepository {\n\n\n    private XMLReader reader;\n\n    /**\n     * Constructor: Open specified repository\n     * @param file Name of repository\n     * @param warnDeprecated Log warning when config file is deprecated\n     */\n    public ParamRepository(String file, boolean warnDeprecated) {\n        reader = new XMLReader(file, true, warnDeprecated);\n        reader.processHostPorts(); //Pre-scan the hosts:ports fields\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return value of the parameter\n     */\n    public String getParameter(String xpath) {\n        return reader.getValue(xpath);\n    }\n\n    /**\n     * Sets or replaces the parameter referenced by the XPath.\n     * @param xpath The xpath referencing the parameter\n     * @param newValue The new value to set\n     */\n    public void setParameter(String xpath, String newValue) {\n        reader.setValue(xpath, newValue);\n    }\n\n    /**\n     * Saves the parameter repository back to file if it has been modified.\n     *\n     * @throws Exception If there is an exception saving the repository.\n     */\n    public void save() throws Exception {\n        reader.save(null);\n    }\n\n    /**\n     * Generic parameter access method.\n     * @param xpath\n     * @return list containing all paramters with the xpath\n     */\n    public List<String> getParameters(String xpath) {\n        return reader.getValues(xpath);\n    }\n\n    /**\n     * Gets the attribute values for the specified attribute of a certain XPath.\n     *\n     * @param elementPath The XPath of the element\n     * @param attributeName The name of the attribute\n     * @return A list of attribute values\n     */\n    public List<String> getAttributeValues(String elementPath, String attributeName) {\n        return reader.getAttributeValues(elementPath, attributeName);\n    }\n\n    /**\n     * This returns tokenized values of parameters in a list.\n     * Mainly used to get host(s)\n     * @param xpath The xpath to the parameters\n     * @return List of tokenized values\n     */\n    public List<String[]> getTokenizedParameters(String xpath) {\n        ArrayList<String[]> params = new ArrayList<String[]>();\n        List<String> entries = reader.getValues(xpath);\n        for (String entry : entries) {\n            StringTokenizer st = new StringTokenizer(entry);\n            String[] values = new String[st.countTokens()];\n            for (int i = 0; st.hasMoreTokens(); i++)\n                values[i] = st.nextToken();\n            params.add(values);\n        }\n        return params;\n    }\n\n    /**\n     *\n     * @param xpath XPath expression to get SPACE seperated values from a single\n     * parameter. For Example sutConfig/host The values are seperated by SPACE\n     * @return An array of hostnames.\n     */\n    public String[] getTokenizedValue(String xpath) {\n\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        String[] hosts = new String[st.countTokens()];\n        for (int i = 0; st.hasMoreTokens(); i++)\n            hosts[i] = st.nextToken();\n        return hosts;\n    }\n\n    /**\n     *\n     * @param xpath XPath expression to get  ',' and SPACE seperated \n     * values from a single parameter. For Example sutConfig/instances\n     * The values are seperated by ',' and then by SPACE\n     * @return List of arrays of hostnames.\n     */\n    public List<String[]> getTokenizedList(String xpath) {\n        // Each value should be passed as , and SPACE seperated strings\n        ArrayList<String[]> list = new ArrayList<String[]>();\n        StringTokenizer st = new StringTokenizer(reader.getValue(xpath));\n        while (st.hasMoreTokens()) {\n            ArrayList<String> l = new ArrayList<String>();\n            StringTokenizer st2 = new  StringTokenizer(st.nextToken(), \",\");\n            while (st2.hasMoreTokens())\n                l.add(st2.nextToken());\n\n            list.add(l.toArray(new String[1]));\n        }\n        return list;\n    }\n\n    /**\n     * Obtains the host:port name value pair list from the element\n     * matching this XPath.\n     * @param xPathExpr\n     * @return The list of host:port elements, or null if the XPath does\n     * not exist or does not point to a host:port node.\n     */\n    public List<NameValuePair<Integer>> getHostPorts(String xPathExpr) {\n        return reader.getHostPorts(xPathExpr);\n    }\n\n    public List<NameValuePair<String>> getHostTypes() {\n        String hostsXPath = \"fa:hostConfig/fa:host\";\n        ArrayList<NameValuePair<String>> hostTypeList =\n                new ArrayList<NameValuePair<String>>();\n        NodeList nodes = reader.getNodeList(hostsXPath);\n        int length = nodes.getLength();\n        for (int i = 0; i < length; i++) {\n            Node node = nodes.item(i);\n            Node typeNode = node.getParentNode().getParentNode();\n            String type = typeNode.getNodeName();\n            Node hostTextNode = node.getFirstChild();\n            if (hostTextNode == null)\n                continue;\n            String hosts = hostTextNode.getNodeValue().trim();\n            if (hosts == null || hosts.length() == 0)\n                continue;\n            StringTokenizer st = new StringTokenizer(hosts, \" ,\");\n            while (st.hasMoreTokens()) {\n                NameValuePair<String> hostType = new NameValuePair<String>();\n                hostType.name = st.nextToken();\n                hostType.value = type;\n                hostTypeList.add(hostType);\n            }\n        }\n        return hostTypeList;\n    }\n\n    /**\n     * This method reads a value using the XPath and converts it to a boolean\n     * @param xpath XPath expression to the value which is true or false\n     * @return true or false\n     */\n    public boolean getBooleanValue(String xpath) {\n        return  Boolean.valueOf(reader.getValue(xpath)).booleanValue();\n    }\n\n\n}\n\n","lineNo":181}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdMap.java,v 1.8 2008/03/15 07:31:45 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Checks the binary paths and the command mapping file and creates the exec\n * map.\n *\n * @author Akara Sucharitakul\n */\npublic class CmdMap {\n\n    static Logger logger = Logger.getLogger(CmdMap.class.getName());\n\n    /**\n     * Scans the bin directories and command map file and returns the command\n     * map.\n     * @param benchName The name of the benchmark,\n     *                  null if the map is not benchmark-specific\n     * @return The command map\n     * @throws Exception Something went wrong obtaining the command map.\n     */\n    public static HashMap<String, String> getCmdMap(String benchName)\n            throws Exception {\n        HashMap<String, String> binMap = new HashMap<String, String>();\n        // The platform-specific and benchmark-specific binaries\n        // take precedence, add last to map.\n        File binDir = new File(Config.FABAN_HOME + \"bin\"); // $FABAN_HOME/bin\n        addExecMap(binDir, binMap, null);\n        File sbinDir = new File(binDir, Config.OS_DIR); // $FABAN_HOME/bin/SunOS\n        addExecMap(sbinDir, binMap, null);\n        sbinDir = new File(binDir, Config.ARCH_DIR); // $FABAN_HOME/bin/SunOS/sparc\n        addExecMap(sbinDir, binMap, null);\n\n        if (benchName != null)\n            addBenchMap(binMap, benchName);\n\n        mapPathExt(binMap);\n\n        addCmdMapFile(binMap);\n\n        // Dump the binMap for debugging\n        if (logger.isLoggable(Level.FINER)) {\n            StringBuilder b = new StringBuilder(\"Executable map:\\n\");\n            for (Iterator it = binMap.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                b.append(entry.getKey());\n                b.append(\" : \");\n                b.append(entry.getValue());\n                b.append('\\n');\n            }\n            logger.finer(b.toString());\n        }\n       return binMap;\n    }\n\n    private static void addBenchMap(HashMap<String, String> binMap,\n                                    String benchName) {\n        // chmod is the way to make a file executable on Unix. Other platforms\n        // like Win32 does not have it and uses a different mechanism. So\n        // we'll run chmod only if it's there.\n        File chmodCmd = new File(\"/bin/chmod\");\n        if (!chmodCmd.exists()) {\n            chmodCmd = new File(\"/usr/bin/chmod\");\n            if (!chmodCmd.exists())\n                chmodCmd = null;\n        }\n\n        StringBuilder chmod = null;\n        if (chmodCmd != null) {\n            chmod = new StringBuilder();\n            chmod.append(chmodCmd.getAbsolutePath());\n            chmod.append(\" +x \");\n        }\n        File binDir = new File(Config.BENCHMARK_DIR + benchName + \"/bin/\");\n        boolean emptyList = addExecMap(binDir, binMap, chmod);\n        File sbinDir = new File(binDir, Config.OS_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        sbinDir = new File(binDir, Config.ARCH_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        if (!emptyList)\n            try {\n                logger.fine(\"Changing mode for bin: \" + chmod);\n                Command cmd = new Command(chmod.toString());\n                CommandHandle handle = cmd.execute();\n                int exitValue = handle.exitValue();\n                if (exitValue != 0)\n                    logger.severe(\"Failed to chmod bin files. Exit value is \" +\n                                                                    exitValue);\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Cannot change mode on bin files\", e);\n            } catch (InterruptedException e) {\n                logger.log(Level.SEVERE,\n                           \"Interrupted changing mode on bin files\", e);\n            }\n    }\n\n\n    private static boolean addExecMap(File binDir,\n                                      HashMap<String, String> binMap,\n                                      StringBuilder chmod) {\n        boolean emptyList = true;\n        if (binDir.isDirectory()) {\n            File[] binFiles = binDir.listFiles();\n            for (int i = 0; i < binFiles.length; i++)\n                if (!binFiles[i].isDirectory()) {\n                    String name = binFiles[i].getName();\n                    String fullPath = binFiles[i].getAbsolutePath();\n                    binMap.put(name, fullPath);\n                    if (chmod != null) {\n                        chmod.append(fullPath);\n                        chmod.append(' ');\n                        emptyList = false;\n                    }\n                }\n        }\n        return emptyList;\n    }\n\n    /**\n     * Obtains a list of path extensions valid in this environment.\n     * @return A string array of valid path extensions\n     */\n    public static String[] getPathExt() {\n        String pathExt = System.getProperty(\"faban.pathext\");\n        if (pathExt == null)\n            return null;\n        pathExt = pathExt.trim();\n        if (pathExt.length() == 0)\n            return null;\n\n        // Ensure each of the exts are lowercase.\n        String[] pathExts = pathExt.split(File.pathSeparator);\n        for (int i = 0; i < pathExts.length; i++) {\n            pathExts[i] = pathExts[i].toLowerCase();\n        }\n        return pathExts;\n    }\n\n    /**\n     * The mapPathExt modifies the binMap according to the Win32\n     * conventions. For example, faban.cmd can be called with just faban.\n     * But calling it with faban.cmd also works. The PATHEXT needs to be\n     * passed to the JVM as a system property faban.pathext. PATHEXT\n     * matching is case insensitive. On Win32-like systems, faban.pathext\n     * would be set at the JVM invocation. On Unix systems, this property\n     * should not be set. This method would be a noop in this case.\n     * @param binMap The binMap\n     */\n    private static void mapPathExt(Map<String, String> binMap) {\n\n        String[] pathExts = getPathExt();\n        if (pathExts == null)\n            return;\n\n        // Use a separate map so we don't modify binmap while iterating\n        HashMap<String, String> pathExtMap = new HashMap<String, String>();\n\n        Set<String> binKeys = binMap.keySet();\n\n        // Scan from back to front so the frontmost one put latest\n        // overrides the others that were put before.\n        for (int i = pathExts.length - 1; i >= 0; i--)\n            for (String key : binKeys)\n                if (key.toLowerCase().endsWith(pathExts[i])) {\n                    String value = binMap.get(key);\n                    String newKey = key.substring(0, key.length() -\n                                    pathExts[i].length());\n                    pathExtMap.put(newKey, value);\n                }\n\n        binMap.putAll(pathExtMap);\n    }\n\n\n    /**\n     * Reads the command map file and adds/modifies the exec map accordingly.\n     * @param binMap\n     * @throws Exception\n     */\n    private static void addCmdMapFile(Map<String, String> binMap)\n            throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n\n        File cmdMap = new File(\n                            Config.CONFIG_DIR + Config.OS_DIR + \"cmdmap.xml\");\n\n        if (cmdMap.exists()) {\n\n            FileInputStream is = new FileInputStream(cmdMap);\n            parseStream(is, cmdList);\n\n            // Next step is to use the map command path and prefixes to the\n            // actual executable.\n            for (Iterator<CmdDetail> iter = cmdList.iterator();\n                 iter.hasNext();) {\n                CmdDetail c = iter.next();\n                if (c.exec == null) {\n                    c.exec = binMap.get(c.name);\n                } else {\n                    File f = new File(c.exec); // The exec can still be in\n                    if (!f.isAbsolute()) {     // the Faban path. May need\n                        String path = binMap.get(c.exec); // another mapping.\n                        if (path != null)      // if not absolute path. Just\n                            c.exec = path;     // ignore if not found in map.\n                    }                          // Should be in OS path instead.                        \n                }\n                if (c.exec == null)\n                    c.exec = c.name;\n                for (int i = 0; i < c.prefix.length; i++) {\n                    int spIdx = c.prefix[i].indexOf(' ');\n                    String cmd;\n                    if (spIdx == -1) // No prefix args?\n                        cmd = c.prefix[i]; // take the whole\n                    else\n                        cmd = c.prefix[i].substring(0, spIdx); // command only\n                    // Lookup the actual path from the binMap\n                    String path = binMap.get(cmd);\n                    if (path == null)\n                        path = cmd;\n                    if (spIdx == -1) // No prefix args?\n                        c.prefix[i] = path; // Set the whole\n                    else\n                        c.prefix[i] = path + c.prefix[i].substring(spIdx);\n                }\n            }\n\n            StringBuilder exec = new StringBuilder();\n            for (Iterator<CmdDetail> iter = cmdList.iterator();\n                 iter.hasNext();) {\n                CmdDetail c = iter.next();\n                for (int i = 0; i < c.prefix.length; i++) {\n                    exec.append(c.prefix[i]);\n                    exec.append(' ');\n                }\n                exec.append(c.exec);\n                binMap.put(c.name, exec.toString());\n                exec.setLength(0);\n            }\n        }\n    }\n\n    private static void parseStream(FileInputStream is,\n                                    ArrayList<CmdDetail> cmdList)\n            throws Exception {\n        SAXParserFactory sFact = SAXParserFactory.newInstance();\n        sFact.setFeature(\"http://xml.org/sax/features/validation\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/\" +\n                \"allow-java-encodings\", true);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-dtd-grammar\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-external-dtd\", false);\n        SAXParser parser = sFact.newSAXParser();\n        parser.parse(is, new MapReaderHandler(cmdList));\n    }\n\n    static class CmdDetail {\n        String name;\n        String exec;\n        String[] prefix;\n\n        public String toString() {\n            StringBuilder b = new StringBuilder();\n            b.append(name);\n            b.append(':');\n            for (int i = 0; i < prefix.length; i++) {\n                b.append(prefix[i]);\n                b.append(\" \");\n            }\n            b.append(exec);\n            return b.toString();\n        }\n    }\n\n    static class MapReaderHandler extends DefaultHandler {\n        private CmdDetail currentCmd;\n        private ArrayList stack = new ArrayList();\n        private StringBuilder buffer = new StringBuilder();\n        private TreeMap<Integer, String> prefixes =\n                new TreeMap<Integer, String>();\n        private int currentSequence = Integer.MIN_VALUE;\n        private ArrayList<CmdDetail> cmdList;\n\n        MapReaderHandler(ArrayList<CmdDetail> cmdList) {\n            this.cmdList = cmdList;\n        }\n\n        /**\n         * Receive notification of the start of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the start of\n         * each element (such as allocating a new tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri        The Namespace URI, or the empty string if the\n         *                   element has no Namespace URI or if Namespace\n         *                   processing is not being performed.\n         * @param localName  The local name (without prefix), or the\n         *                   empty string if Namespace processing is not being\n         *                   performed.\n         * @param qName      The qualified name (with prefix), or the\n         *                   empty string if qualified names are not available.\n         * @param attributes The attributes attached to the element.  If\n         *                   there are no attributes, it shall be an empty\n         *                   Attributes object.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#startElement\n         */\n        public void startElement(String uri, String localName, String qName,\n                                 Attributes attributes) throws SAXException {\n            stack.add(qName);\n            if (\"command\".equals(qName)) {\n                currentCmd = new CmdDetail();\n            } else if (\"prefix\".equals(qName)) {\n                String s = attributes.getValue(\"sequence\");\n                if (s != null) {\n                    currentSequence = Integer.parseInt(s);\n                    if (currentSequence < 0)\n                        throw new SAXException(\n                                \"Prefix sequence must be 0 or greater\");\n                }\n            }\n        }\n\n        /**\n         * Receive notification of the end of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the end of\n         * each element (such as finalising a tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri       The Namespace URI, or the empty string if the\n         *                  element has no Namespace URI or if Namespace\n         *                  processing is not being performed.\n         * @param localName The local name (without prefix), or the\n         *                  empty string if Namespace processing is not being\n         *                  performed.\n         * @param qName     The qualified name (with prefix), or the\n         *                  empty string if qualified names are not available.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#endElement\n         */\n        public void endElement(String uri, String localName, String qName)\n                throws SAXException {\n\n            int depth = stack.size();\n\n            if (!stack.remove(depth - 1).equals(qName))\n                throw new SAXException(\"endElement mismatch: \" + qName);\n\n            if (\"command\".equals(qName)) {\n                if (currentCmd.name == null)\n                    throw new SAXException(\"Command name not specified\");\n                // Get all the prefixes\n                int prefixSize = prefixes.size();\n                currentCmd.prefix = new String[prefixSize];\n                if (prefixSize > 0) {\n                    Iterator<Map.Entry<Integer, String>> iter =\n                            prefixes.entrySet().iterator();\n                    for (int i = 0; i < prefixSize; i++) {\n                        currentCmd.prefix[i] = iter.next().getValue();\n                    }\n                }\n                prefixes.clear();\n                cmdList.add(currentCmd);\n\n            } else if (\"name\".equals(qName)) {\n                currentCmd.name = buffer.toString().trim();\n            } else if (\"exec\".equals(qName)) {\n                currentCmd.exec = buffer.toString().trim();\n            } else if (\"prefix\".equals(qName)) {\n                if (currentSequence < 0)\n                    currentSequence = -1;\n                String oldPrefix =\n                        prefixes.put(currentSequence, buffer.toString().trim());\n                if (oldPrefix != null) {\n                    if (currentSequence == -1)\n                        throw new SAXException(\"Need to specify prefix \" +\n                                \"sequence for more than one prefix\");\n                    else\n                        throw new SAXException(\"Duplicate prefix sequence \" +\n                                \"found\");\n                }\n                currentSequence = Integer.MIN_VALUE;\n            }\n            buffer.setLength(0);\n        }\n\n        /**\n         * Receive notification of character data inside an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method to take specific actions for each chunk of character data\n         * (such as adding the data to a node or buffer, or printing it to\n         * a file).<\/p>\n         *\n         * @param ch     The characters.\n         * @param start  The start position in the character array.\n         * @param length The number of characters to use from the\n         *               character array.\n         * @see org.xml.sax.ContentHandler#characters\n         */\n        public void characters(char ch[], int start, int length) {\n            buffer.append(ch, start, length);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n        HashMap<String, String> binMap = new HashMap<String, String>();\n        FileInputStream is = new FileInputStream(\"cmdmap.xml\");\n        parseStream(is, cmdList);\n\n        // Next step is to use the map command path and prefixes to the\n        // actual executable.\n        for (Iterator<CmdDetail> iter = cmdList.iterator();\n             iter.hasNext();) {\n            CmdDetail c = iter.next();\n            if (c.exec == null)\n                c.exec = binMap.get(c.name);\n            if (c.exec == null)\n                c.exec = c.name;\n\n            // Try to map exec cmd back to the binMap\n            String exec = c.exec;\n\n            // Separate out args\n            int pathEndIdx = exec.indexOf(' ');\n            if (pathEndIdx > 0)\n                exec = exec.substring(0, pathEndIdx);\n\n            // Search cmd for path separators ('/')\n            int pathSepIdx = exec.indexOf(File.separator);\n\n            // If not found, still a relative path\n            if (pathSepIdx < 0) {\n                // Map it\n                exec = binMap.get(exec);\n                // And combine back with args\n                if (exec != null) {\n                    if (pathEndIdx > 0)\n                        c.exec = exec + exec.substring(pathEndIdx);\n                    else\n                        c.exec = exec;\n                }\n            }\n\n            for (int i = 0; i < c.prefix.length; i++) {\n                int spIdx = c.prefix[i].indexOf(' ');\n                String cmd;\n                if (spIdx == -1) // No prefix args?\n                    cmd = c.prefix[i]; // take the whole\n                else\n                    cmd = c.prefix[i].substring(0, spIdx); // take command only\n                // Lookup the actual exec call from the binMap\n                exec = binMap.get(cmd);\n                if (exec == null)\n                    exec = cmd;\n                if (spIdx == -1) // No prefix args?\n                    c.prefix[i] = exec; // Set the whole\n                else\n                    c.prefix[i] = exec + c.prefix[i].substring(spIdx);\n            }\n        }\n\n        for (Iterator<CmdDetail> iter = cmdList.iterator();\n             iter.hasNext();) {\n             CmdDetail c = iter.next();\n             System.out.println(c.toString());\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdMap.java,v 1.9 2008/04/04 22:09:27 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Checks the binary paths and the command mapping file and creates the exec\n * map.\n *\n * @author Akara Sucharitakul\n */\npublic class CmdMap {\n\n    static Logger logger = Logger.getLogger(CmdMap.class.getName());\n\n    /**\n     * Scans the bin directories and command map file and returns the command\n     * map.\n     * @param benchName The name of the benchmark,\n     *                  null if the map is not benchmark-specific\n     * @return The command map\n     * @throws Exception Something went wrong obtaining the command map.\n     */\n    public static HashMap<String, List<String>> getCmdMap(String benchName)\n            throws Exception {\n        HashMap<String, List<String>> binMap =\n                                        new HashMap<String, List<String>>();\n        // The platform-specific and benchmark-specific binaries\n        // take precedence, add last to map.\n        File binDir = new File(Config.FABAN_HOME + \"bin\"); // $FABAN_HOME/bin\n        addExecMap(binDir, binMap, null);\n        File sbinDir = new File(binDir, Config.OS_DIR); // $FABAN_HOME/bin/SunOS\n        addExecMap(sbinDir, binMap, null);\n        sbinDir = new File(binDir, Config.ARCH_DIR); // $FABAN_HOME/bin/SunOS/sparc\n        addExecMap(sbinDir, binMap, null);\n\n        if (benchName != null)\n            addBenchMap(binMap, benchName);\n\n        mapPathExt(binMap);\n\n        addCmdMapFile(binMap);\n\n        // Dump the binMap for debugging\n        if (logger.isLoggable(Level.FINER)) {\n            StringBuilder b = new StringBuilder(\"Executable map:\\n\");\n            for (Map.Entry<String, List<String>> entry : binMap.entrySet()) {\n                b.append(entry.getKey());\n                b.append(\" :\");\n                List<String> l = entry.getValue();\n                for (String v : l) {\n                    b.append(' ').append(v);\n                }\n                b.append('\\n');\n            }\n            logger.finer(b.toString());\n        }\n       return binMap;\n    }\n\n    private static void addBenchMap(HashMap<String, List<String>> binMap,\n                                    String benchName) {\n        // chmod is the way to make a file executable on Unix. Other platforms\n        // like Win32 does not have it and uses a different mechanism. So\n        // we'll run chmod only if it's there.\n        File chmodCmd = new File(\"/bin/chmod\");\n        if (!chmodCmd.exists()) {\n            chmodCmd = new File(\"/usr/bin/chmod\");\n            if (!chmodCmd.exists())\n                chmodCmd = null;\n        }\n\n        ArrayList<String> chmod = null;\n        if (chmodCmd != null) {\n            chmod = new ArrayList<String>();\n            chmod.add(chmodCmd.getAbsolutePath());\n            chmod.add(\"+x\");\n        }\n        File binDir = new File(Config.BENCHMARK_DIR + benchName + \"/bin/\");\n        boolean emptyList = addExecMap(binDir, binMap, chmod);\n        File sbinDir = new File(binDir, Config.OS_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        sbinDir = new File(binDir, Config.ARCH_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        if (!emptyList)\n            try {\n                logger.fine(\"Changing mode for bin directories.\");\n                Command cmd = new Command(chmod);\n                CommandHandle handle = cmd.execute();\n                int exitValue = handle.exitValue();\n                if (exitValue != 0)\n                    logger.severe(\"Failed to chmod bin files. Exit value is \" +\n                                                                    exitValue);\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Cannot change mode on bin files\", e);\n            } catch (InterruptedException e) {\n                logger.log(Level.SEVERE,\n                           \"Interrupted changing mode on bin files\", e);\n            }\n    }\n\n\n    private static boolean addExecMap(File binDir,\n                                      HashMap<String, List<String>> binMap,\n                                      List<String> chmod) {\n        boolean emptyList = true;\n        if (binDir.isDirectory()) {\n            File[] binFiles = binDir.listFiles();\n            for (int i = 0; i < binFiles.length; i++)\n                if (!binFiles[i].isDirectory()) {\n                    String name = binFiles[i].getName();\n                    String fullPath = binFiles[i].getAbsolutePath();\n                    ArrayList<String> v = new ArrayList<String>();\n                    v.add(fullPath);\n                    binMap.put(name, v);\n                    if (chmod != null) {\n                        chmod.add(fullPath);\n                        emptyList = false;\n                    }\n                }\n        }\n        return emptyList;\n    }\n\n    /**\n     * Obtains a list of path extensions valid in this environment.\n     * @return A string array of valid path extensions\n     */\n    public static String[] getPathExt() {\n        String pathExt = System.getProperty(\"faban.pathext\");\n        if (pathExt == null)\n            return null;\n        pathExt = pathExt.trim();\n        if (pathExt.length() == 0)\n            return null;\n\n        // Ensure each of the exts are lowercase.\n        String[] pathExts = pathExt.split(File.pathSeparator);\n        for (int i = 0; i < pathExts.length; i++) {\n            pathExts[i] = pathExts[i].toLowerCase();\n        }\n        return pathExts;\n    }\n\n    /**\n     * The mapPathExt modifies the binMap according to the Win32\n     * conventions. For example, faban.cmd can be called with just faban.\n     * But calling it with faban.cmd also works. The PATHEXT needs to be\n     * passed to the JVM as a system property faban.pathext. PATHEXT\n     * matching is case insensitive. On Win32-like systems, faban.pathext\n     * would be set at the JVM invocation. On Unix systems, this property\n     * should not be set. This method would be a noop in this case.\n     * @param binMap The binMap\n     */\n    private static void mapPathExt(Map<String, List<String>> binMap) {\n\n        String[] pathExts = getPathExt();\n        if (pathExts == null)\n            return;\n\n        // Use a separate map so we don't modify binmap while iterating\n        HashMap<String, List<String>> pathExtMap =\n                                new HashMap<String, List<String>>();\n\n        Set<String> binKeys = binMap.keySet();\n\n        // Scan from back to front so the frontmost one put latest\n        // overrides the others that were put before.\n        for (int i = pathExts.length - 1; i >= 0; i--)\n            for (String key : binKeys)\n                if (key.toLowerCase().endsWith(pathExts[i])) {\n                    List<String> value = binMap.get(key);\n                    String newKey = key.substring(0, key.length() -\n                                    pathExts[i].length());\n                    pathExtMap.put(newKey, value);\n                }\n\n        binMap.putAll(pathExtMap);\n    }\n\n\n    /**\n     * Reads the command map file and adds/modifies the exec map accordingly.\n     * @param binMap\n     * @throws Exception\n     */\n    private static void addCmdMapFile(Map<String, List<String>> binMap)\n            throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n\n        File cmdMap = new File(\n                            Config.CONFIG_DIR + Config.OS_DIR + \"cmdmap.xml\");\n\n        if (cmdMap.exists()) {\n\n            FileInputStream is = new FileInputStream(cmdMap);\n            parseStream(is, cmdList);\n\n            // Next step is to use the map command path and prefixes to the\n            // actual executable.\n            for (Iterator<CmdDetail> iter = cmdList.iterator();\n                 iter.hasNext();) {\n                CmdDetail c = iter.next();\n                if (c.exec == null) {\n                    c.exec = binMap.get(c.name);\n                } else {\n                    String cmd = c.exec.get(0);\n                    File f = new File(cmd); // The exec can still be in\n                    if (!f.isAbsolute()) {     // the Faban path. May need\n                        List<String> path = binMap.get(cmd); // another mapping.\n                        if (path != null)      // if not absolute path. Just\n                            c.exec.set(0, path.get(0)); // ignore if not found in map.\n                    }                          // Should be in OS path instead.                        \n                }\n                if (c.exec == null) {\n                    c.exec = new ArrayList<String>();\n                    c.exec.add(c.name);\n                }\n                for (List<String> prefix : c.prefix) {\n                    String cmd = prefix.get(0);\n                    List<String> path = binMap.get(cmd);\n                    if (path != null)\n                        replaceFirst(prefix, path);\n                }\n            }\n\n            for (CmdDetail cmd : cmdList) {\n                ArrayList<String> exec = new ArrayList<String>();\n                for (List<String> prefix : cmd.prefix)\n                    exec.addAll(prefix);\n                exec.addAll(cmd.exec);\n                binMap.put(cmd.name, exec);\n            }\n        }\n    }\n\n    private static void parseStream(FileInputStream is,\n                                    ArrayList<CmdDetail> cmdList)\n            throws Exception {\n        SAXParserFactory sFact = SAXParserFactory.newInstance();\n        sFact.setFeature(\"http://xml.org/sax/features/validation\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/\" +\n                \"allow-java-encodings\", true);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-dtd-grammar\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-external-dtd\", false);\n        SAXParser parser = sFact.newSAXParser();\n        parser.parse(is, new MapReaderHandler(cmdList));\n    }\n\n    static class CmdDetail {\n        String name;\n        List<String> exec;\n        List<List<String>> prefix;\n\n        public String toString() {\n            StringBuilder b = new StringBuilder();\n            b.append(name);\n            b.append(':');\n\n            for (List<String> p : prefix)\n                for (String e : p)\n                    b.append(e).append(' ');\n\n            b.append(exec);\n            return b.toString();\n        }\n    }\n\n    static class MapReaderHandler extends DefaultHandler {\n        private CmdDetail currentCmd;\n        private ArrayList stack = new ArrayList();\n        private StringBuilder buffer = new StringBuilder();\n        private TreeMap<Integer, String> prefixes =\n                new TreeMap<Integer, String>();\n        private int currentSequence = Integer.MIN_VALUE;\n        private ArrayList<CmdDetail> cmdList;\n\n        MapReaderHandler(ArrayList<CmdDetail> cmdList) {\n            this.cmdList = cmdList;\n        }\n\n        /**\n         * Receive notification of the start of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the start of\n         * each element (such as allocating a new tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri        The Namespace URI, or the empty string if the\n         *                   element has no Namespace URI or if Namespace\n         *                   processing is not being performed.\n         * @param localName  The local name (without prefix), or the\n         *                   empty string if Namespace processing is not being\n         *                   performed.\n         * @param qName      The qualified name (with prefix), or the\n         *                   empty string if qualified names are not available.\n         * @param attributes The attributes attached to the element.  If\n         *                   there are no attributes, it shall be an empty\n         *                   Attributes object.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#startElement\n         */\n        public void startElement(String uri, String localName, String qName,\n                                 Attributes attributes) throws SAXException {\n            stack.add(qName);\n            if (\"command\".equals(qName)) {\n                currentCmd = new CmdDetail();\n            } else if (\"prefix\".equals(qName)) {\n                String s = attributes.getValue(\"sequence\");\n                if (s != null) {\n                    currentSequence = Integer.parseInt(s);\n                    if (currentSequence < 0)\n                        throw new SAXException(\n                                \"Prefix sequence must be 0 or greater\");\n                }\n            }\n        }\n\n        /**\n         * Receive notification of the end of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the end of\n         * each element (such as finalising a tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri       The Namespace URI, or the empty string if the\n         *                  element has no Namespace URI or if Namespace\n         *                  processing is not being performed.\n         * @param localName The local name (without prefix), or the\n         *                  empty string if Namespace processing is not being\n         *                  performed.\n         * @param qName     The qualified name (with prefix), or the\n         *                  empty string if qualified names are not available.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#endElement\n         */\n        public void endElement(String uri, String localName, String qName)\n                throws SAXException {\n\n            int depth = stack.size();\n\n            if (!stack.remove(depth - 1).equals(qName))\n                throw new SAXException(\"endElement mismatch: \" + qName);\n\n            if (\"command\".equals(qName)) {\n                if (currentCmd.name == null)\n                    throw new SAXException(\"Command name not specified\");\n                // Get all the prefixes\n                int prefixSize = prefixes.size();\n                currentCmd.prefix = new ArrayList<List<String>>();\n                if (prefixSize > 0) {\n                    for (Map.Entry<Integer, String> entry : prefixes.entrySet())\n                        currentCmd.prefix.add(Command.parseArgs(\n                                                            entry.getValue()));\n                }\n                prefixes.clear();\n                cmdList.add(currentCmd);\n\n            } else if (\"name\".equals(qName)) {\n                currentCmd.name = buffer.toString().trim();\n            } else if (\"exec\".equals(qName)) {\n                currentCmd.exec = Command.parseArgs(buffer.toString().trim());\n            } else if (\"prefix\".equals(qName)) {\n                if (currentSequence < 0)\n                    currentSequence = -1;\n                String oldPrefix =\n                        prefixes.put(currentSequence, buffer.toString().trim());\n                if (oldPrefix != null) {\n                    if (currentSequence == -1)\n                        throw new SAXException(\"Need to specify prefix \" +\n                                \"sequence for more than one prefix\");\n                    else\n                        throw new SAXException(\"Duplicate prefix sequence \" +\n                                \"found\");\n                }\n                currentSequence = Integer.MIN_VALUE;\n            }\n            buffer.setLength(0);\n        }\n\n        /**\n         * Receive notification of character data inside an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method to take specific actions for each chunk of character data\n         * (such as adding the data to a node or buffer, or printing it to\n         * a file).<\/p>\n         *\n         * @param ch     The characters.\n         * @param start  The start position in the character array.\n         * @param length The number of characters to use from the\n         *               character array.\n         * @see org.xml.sax.ContentHandler#characters\n         */\n        public void characters(char ch[], int start, int length) {\n            buffer.append(ch, start, length);\n        }\n    }\n\n    public static void replaceFirst(List orig, List replacement) {\n        ArrayList tmp = new ArrayList();\n        tmp.addAll(orig);\n        orig.clear();\n        orig.addAll(replacement);\n        for (int i = 1; i < tmp.size(); i++) {\n            orig.add(tmp.get(i));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n        HashMap<String, List<String>> binMap =\n                new HashMap<String, List<String>>();\n        FileInputStream is = new FileInputStream(\"cmdmap.xml\");\n        parseStream(is, cmdList);\n\n        // Next step is to use the map command path and prefixes to the\n        // actual executable.\n        for (CmdDetail c : cmdList) {\n            if (c.exec == null)\n                c.exec = binMap.get(c.name);\n            if (c.exec == null) {\n                c.exec = new ArrayList<String>();\n                c.exec.add(c.name);\n            }\n\n            // Try to map exec cmd back to the binMap\n            String exec = c.exec.get(0);\n\n            // Search cmd for path separators ('/')\n            int pathSepIdx = exec.indexOf(File.separator);\n\n            // If not found, still a relative path\n            if (pathSepIdx < 0) {\n                // Map it\n                List<String> execList = binMap.get(exec);\n                // And combine back with args\n                if (execList != null)\n                    replaceFirst(c.exec, execList);\n            }\n\n            for (List<String> prefix : c.prefix) {\n                String cmd = prefix.get(0);\n                List<String> execList = binMap.get(cmd);\n                if (execList != null) {\n                    replaceFirst(prefix, execList);\n                }\n            }\n        }\n\n        for (Iterator<CmdDetail> iter = cmdList.iterator();\n             iter.hasNext();) {\n             CmdDetail c = iter.next();\n             System.out.println(c.toString());\n        }\n    }\n}\n","lineNo":86}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdMap.java,v 1.8 2008/03/15 07:31:45 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Checks the binary paths and the command mapping file and creates the exec\n * map.\n *\n * @author Akara Sucharitakul\n */\npublic class CmdMap {\n\n    static Logger logger = Logger.getLogger(CmdMap.class.getName());\n\n    /**\n     * Scans the bin directories and command map file and returns the command\n     * map.\n     * @param benchName The name of the benchmark,\n     *                  null if the map is not benchmark-specific\n     * @return The command map\n     * @throws Exception Something went wrong obtaining the command map.\n     */\n    public static HashMap<String, String> getCmdMap(String benchName)\n            throws Exception {\n        HashMap<String, String> binMap = new HashMap<String, String>();\n        // The platform-specific and benchmark-specific binaries\n        // take precedence, add last to map.\n        File binDir = new File(Config.FABAN_HOME + \"bin\"); // $FABAN_HOME/bin\n        addExecMap(binDir, binMap, null);\n        File sbinDir = new File(binDir, Config.OS_DIR); // $FABAN_HOME/bin/SunOS\n        addExecMap(sbinDir, binMap, null);\n        sbinDir = new File(binDir, Config.ARCH_DIR); // $FABAN_HOME/bin/SunOS/sparc\n        addExecMap(sbinDir, binMap, null);\n\n        if (benchName != null)\n            addBenchMap(binMap, benchName);\n\n        mapPathExt(binMap);\n\n        addCmdMapFile(binMap);\n\n        // Dump the binMap for debugging\n        if (logger.isLoggable(Level.FINER)) {\n            StringBuilder b = new StringBuilder(\"Executable map:\\n\");\n            for (Iterator it = binMap.entrySet().iterator(); it.hasNext();) {\n                Map.Entry entry = (Map.Entry) it.next();\n                b.append(entry.getKey());\n                b.append(\" : \");\n                b.append(entry.getValue());\n                b.append('\\n');\n            }\n            logger.finer(b.toString());\n        }\n       return binMap;\n    }\n\n    private static void addBenchMap(HashMap<String, String> binMap,\n                                    String benchName) {\n        // chmod is the way to make a file executable on Unix. Other platforms\n        // like Win32 does not have it and uses a different mechanism. So\n        // we'll run chmod only if it's there.\n        File chmodCmd = new File(\"/bin/chmod\");\n        if (!chmodCmd.exists()) {\n            chmodCmd = new File(\"/usr/bin/chmod\");\n            if (!chmodCmd.exists())\n                chmodCmd = null;\n        }\n\n        StringBuilder chmod = null;\n        if (chmodCmd != null) {\n            chmod = new StringBuilder();\n            chmod.append(chmodCmd.getAbsolutePath());\n            chmod.append(\" +x \");\n        }\n        File binDir = new File(Config.BENCHMARK_DIR + benchName + \"/bin/\");\n        boolean emptyList = addExecMap(binDir, binMap, chmod);\n        File sbinDir = new File(binDir, Config.OS_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        sbinDir = new File(binDir, Config.ARCH_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        if (!emptyList)\n            try {\n                logger.fine(\"Changing mode for bin: \" + chmod);\n                Command cmd = new Command(chmod.toString());\n                CommandHandle handle = cmd.execute();\n                int exitValue = handle.exitValue();\n                if (exitValue != 0)\n                    logger.severe(\"Failed to chmod bin files. Exit value is \" +\n                                                                    exitValue);\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Cannot change mode on bin files\", e);\n            } catch (InterruptedException e) {\n                logger.log(Level.SEVERE,\n                           \"Interrupted changing mode on bin files\", e);\n            }\n    }\n\n\n    private static boolean addExecMap(File binDir,\n                                      HashMap<String, String> binMap,\n                                      StringBuilder chmod) {\n        boolean emptyList = true;\n        if (binDir.isDirectory()) {\n            File[] binFiles = binDir.listFiles();\n            for (int i = 0; i < binFiles.length; i++)\n                if (!binFiles[i].isDirectory()) {\n                    String name = binFiles[i].getName();\n                    String fullPath = binFiles[i].getAbsolutePath();\n                    binMap.put(name, fullPath);\n                    if (chmod != null) {\n                        chmod.append(fullPath);\n                        chmod.append(' ');\n                        emptyList = false;\n                    }\n                }\n        }\n        return emptyList;\n    }\n\n    /**\n     * Obtains a list of path extensions valid in this environment.\n     * @return A string array of valid path extensions\n     */\n    public static String[] getPathExt() {\n        String pathExt = System.getProperty(\"faban.pathext\");\n        if (pathExt == null)\n            return null;\n        pathExt = pathExt.trim();\n        if (pathExt.length() == 0)\n            return null;\n\n        // Ensure each of the exts are lowercase.\n        String[] pathExts = pathExt.split(File.pathSeparator);\n        for (int i = 0; i < pathExts.length; i++) {\n            pathExts[i] = pathExts[i].toLowerCase();\n        }\n        return pathExts;\n    }\n\n    /**\n     * The mapPathExt modifies the binMap according to the Win32\n     * conventions. For example, faban.cmd can be called with just faban.\n     * But calling it with faban.cmd also works. The PATHEXT needs to be\n     * passed to the JVM as a system property faban.pathext. PATHEXT\n     * matching is case insensitive. On Win32-like systems, faban.pathext\n     * would be set at the JVM invocation. On Unix systems, this property\n     * should not be set. This method would be a noop in this case.\n     * @param binMap The binMap\n     */\n    private static void mapPathExt(Map<String, String> binMap) {\n\n        String[] pathExts = getPathExt();\n        if (pathExts == null)\n            return;\n\n        // Use a separate map so we don't modify binmap while iterating\n        HashMap<String, String> pathExtMap = new HashMap<String, String>();\n\n        Set<String> binKeys = binMap.keySet();\n\n        // Scan from back to front so the frontmost one put latest\n        // overrides the others that were put before.\n        for (int i = pathExts.length - 1; i >= 0; i--)\n            for (String key : binKeys)\n                if (key.toLowerCase().endsWith(pathExts[i])) {\n                    String value = binMap.get(key);\n                    String newKey = key.substring(0, key.length() -\n                                    pathExts[i].length());\n                    pathExtMap.put(newKey, value);\n                }\n\n        binMap.putAll(pathExtMap);\n    }\n\n\n    /**\n     * Reads the command map file and adds/modifies the exec map accordingly.\n     * @param binMap\n     * @throws Exception\n     */\n    private static void addCmdMapFile(Map<String, String> binMap)\n            throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n\n        File cmdMap = new File(\n                            Config.CONFIG_DIR + Config.OS_DIR + \"cmdmap.xml\");\n\n        if (cmdMap.exists()) {\n\n            FileInputStream is = new FileInputStream(cmdMap);\n            parseStream(is, cmdList);\n\n            // Next step is to use the map command path and prefixes to the\n            // actual executable.\n            for (Iterator<CmdDetail> iter = cmdList.iterator();\n                 iter.hasNext();) {\n                CmdDetail c = iter.next();\n                if (c.exec == null) {\n                    c.exec = binMap.get(c.name);\n                } else {\n                    File f = new File(c.exec); // The exec can still be in\n                    if (!f.isAbsolute()) {     // the Faban path. May need\n                        String path = binMap.get(c.exec); // another mapping.\n                        if (path != null)      // if not absolute path. Just\n                            c.exec = path;     // ignore if not found in map.\n                    }                          // Should be in OS path instead.                        \n                }\n                if (c.exec == null)\n                    c.exec = c.name;\n                for (int i = 0; i < c.prefix.length; i++) {\n                    int spIdx = c.prefix[i].indexOf(' ');\n                    String cmd;\n                    if (spIdx == -1) // No prefix args?\n                        cmd = c.prefix[i]; // take the whole\n                    else\n                        cmd = c.prefix[i].substring(0, spIdx); // command only\n                    // Lookup the actual path from the binMap\n                    String path = binMap.get(cmd);\n                    if (path == null)\n                        path = cmd;\n                    if (spIdx == -1) // No prefix args?\n                        c.prefix[i] = path; // Set the whole\n                    else\n                        c.prefix[i] = path + c.prefix[i].substring(spIdx);\n                }\n            }\n\n            StringBuilder exec = new StringBuilder();\n            for (Iterator<CmdDetail> iter = cmdList.iterator();\n                 iter.hasNext();) {\n                CmdDetail c = iter.next();\n                for (int i = 0; i < c.prefix.length; i++) {\n                    exec.append(c.prefix[i]);\n                    exec.append(' ');\n                }\n                exec.append(c.exec);\n                binMap.put(c.name, exec.toString());\n                exec.setLength(0);\n            }\n        }\n    }\n\n    private static void parseStream(FileInputStream is,\n                                    ArrayList<CmdDetail> cmdList)\n            throws Exception {\n        SAXParserFactory sFact = SAXParserFactory.newInstance();\n        sFact.setFeature(\"http://xml.org/sax/features/validation\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/\" +\n                \"allow-java-encodings\", true);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-dtd-grammar\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-external-dtd\", false);\n        SAXParser parser = sFact.newSAXParser();\n        parser.parse(is, new MapReaderHandler(cmdList));\n    }\n\n    static class CmdDetail {\n        String name;\n        String exec;\n        String[] prefix;\n\n        public String toString() {\n            StringBuilder b = new StringBuilder();\n            b.append(name);\n            b.append(':');\n            for (int i = 0; i < prefix.length; i++) {\n                b.append(prefix[i]);\n                b.append(\" \");\n            }\n            b.append(exec);\n            return b.toString();\n        }\n    }\n\n    static class MapReaderHandler extends DefaultHandler {\n        private CmdDetail currentCmd;\n        private ArrayList stack = new ArrayList();\n        private StringBuilder buffer = new StringBuilder();\n        private TreeMap<Integer, String> prefixes =\n                new TreeMap<Integer, String>();\n        private int currentSequence = Integer.MIN_VALUE;\n        private ArrayList<CmdDetail> cmdList;\n\n        MapReaderHandler(ArrayList<CmdDetail> cmdList) {\n            this.cmdList = cmdList;\n        }\n\n        /**\n         * Receive notification of the start of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the start of\n         * each element (such as allocating a new tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri        The Namespace URI, or the empty string if the\n         *                   element has no Namespace URI or if Namespace\n         *                   processing is not being performed.\n         * @param localName  The local name (without prefix), or the\n         *                   empty string if Namespace processing is not being\n         *                   performed.\n         * @param qName      The qualified name (with prefix), or the\n         *                   empty string if qualified names are not available.\n         * @param attributes The attributes attached to the element.  If\n         *                   there are no attributes, it shall be an empty\n         *                   Attributes object.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#startElement\n         */\n        public void startElement(String uri, String localName, String qName,\n                                 Attributes attributes) throws SAXException {\n            stack.add(qName);\n            if (\"command\".equals(qName)) {\n                currentCmd = new CmdDetail();\n            } else if (\"prefix\".equals(qName)) {\n                String s = attributes.getValue(\"sequence\");\n                if (s != null) {\n                    currentSequence = Integer.parseInt(s);\n                    if (currentSequence < 0)\n                        throw new SAXException(\n                                \"Prefix sequence must be 0 or greater\");\n                }\n            }\n        }\n\n        /**\n         * Receive notification of the end of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the end of\n         * each element (such as finalising a tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri       The Namespace URI, or the empty string if the\n         *                  element has no Namespace URI or if Namespace\n         *                  processing is not being performed.\n         * @param localName The local name (without prefix), or the\n         *                  empty string if Namespace processing is not being\n         *                  performed.\n         * @param qName     The qualified name (with prefix), or the\n         *                  empty string if qualified names are not available.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#endElement\n         */\n        public void endElement(String uri, String localName, String qName)\n                throws SAXException {\n\n            int depth = stack.size();\n\n            if (!stack.remove(depth - 1).equals(qName))\n                throw new SAXException(\"endElement mismatch: \" + qName);\n\n            if (\"command\".equals(qName)) {\n                if (currentCmd.name == null)\n                    throw new SAXException(\"Command name not specified\");\n                // Get all the prefixes\n                int prefixSize = prefixes.size();\n                currentCmd.prefix = new String[prefixSize];\n                if (prefixSize > 0) {\n                    Iterator<Map.Entry<Integer, String>> iter =\n                            prefixes.entrySet().iterator();\n                    for (int i = 0; i < prefixSize; i++) {\n                        currentCmd.prefix[i] = iter.next().getValue();\n                    }\n                }\n                prefixes.clear();\n                cmdList.add(currentCmd);\n\n            } else if (\"name\".equals(qName)) {\n                currentCmd.name = buffer.toString().trim();\n            } else if (\"exec\".equals(qName)) {\n                currentCmd.exec = buffer.toString().trim();\n            } else if (\"prefix\".equals(qName)) {\n                if (currentSequence < 0)\n                    currentSequence = -1;\n                String oldPrefix =\n                        prefixes.put(currentSequence, buffer.toString().trim());\n                if (oldPrefix != null) {\n                    if (currentSequence == -1)\n                        throw new SAXException(\"Need to specify prefix \" +\n                                \"sequence for more than one prefix\");\n                    else\n                        throw new SAXException(\"Duplicate prefix sequence \" +\n                                \"found\");\n                }\n                currentSequence = Integer.MIN_VALUE;\n            }\n            buffer.setLength(0);\n        }\n\n        /**\n         * Receive notification of character data inside an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method to take specific actions for each chunk of character data\n         * (such as adding the data to a node or buffer, or printing it to\n         * a file).<\/p>\n         *\n         * @param ch     The characters.\n         * @param start  The start position in the character array.\n         * @param length The number of characters to use from the\n         *               character array.\n         * @see org.xml.sax.ContentHandler#characters\n         */\n        public void characters(char ch[], int start, int length) {\n            buffer.append(ch, start, length);\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n        HashMap<String, String> binMap = new HashMap<String, String>();\n        FileInputStream is = new FileInputStream(\"cmdmap.xml\");\n        parseStream(is, cmdList);\n\n        // Next step is to use the map command path and prefixes to the\n        // actual executable.\n        for (Iterator<CmdDetail> iter = cmdList.iterator();\n             iter.hasNext();) {\n            CmdDetail c = iter.next();\n            if (c.exec == null)\n                c.exec = binMap.get(c.name);\n            if (c.exec == null)\n                c.exec = c.name;\n\n            // Try to map exec cmd back to the binMap\n            String exec = c.exec;\n\n            // Separate out args\n            int pathEndIdx = exec.indexOf(' ');\n            if (pathEndIdx > 0)\n                exec = exec.substring(0, pathEndIdx);\n\n            // Search cmd for path separators ('/')\n            int pathSepIdx = exec.indexOf(File.separator);\n\n            // If not found, still a relative path\n            if (pathSepIdx < 0) {\n                // Map it\n                exec = binMap.get(exec);\n                // And combine back with args\n                if (exec != null) {\n                    if (pathEndIdx > 0)\n                        c.exec = exec + exec.substring(pathEndIdx);\n                    else\n                        c.exec = exec;\n                }\n            }\n\n            for (int i = 0; i < c.prefix.length; i++) {\n                int spIdx = c.prefix[i].indexOf(' ');\n                String cmd;\n                if (spIdx == -1) // No prefix args?\n                    cmd = c.prefix[i]; // take the whole\n                else\n                    cmd = c.prefix[i].substring(0, spIdx); // take command only\n                // Lookup the actual exec call from the binMap\n                exec = binMap.get(cmd);\n                if (exec == null)\n                    exec = cmd;\n                if (spIdx == -1) // No prefix args?\n                    c.prefix[i] = exec; // Set the whole\n                else\n                    c.prefix[i] = exec + c.prefix[i].substring(spIdx);\n            }\n        }\n\n        for (Iterator<CmdDetail> iter = cmdList.iterator();\n             iter.hasNext();) {\n             CmdDetail c = iter.next();\n             System.out.println(c.toString());\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdMap.java,v 1.9 2008/04/04 22:09:27 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.util;\n\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport org.xml.sax.Attributes;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.helpers.DefaultHandler;\n\nimport javax.xml.parsers.SAXParser;\nimport javax.xml.parsers.SAXParserFactory;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Checks the binary paths and the command mapping file and creates the exec\n * map.\n *\n * @author Akara Sucharitakul\n */\npublic class CmdMap {\n\n    static Logger logger = Logger.getLogger(CmdMap.class.getName());\n\n    /**\n     * Scans the bin directories and command map file and returns the command\n     * map.\n     * @param benchName The name of the benchmark,\n     *                  null if the map is not benchmark-specific\n     * @return The command map\n     * @throws Exception Something went wrong obtaining the command map.\n     */\n    public static HashMap<String, List<String>> getCmdMap(String benchName)\n            throws Exception {\n        HashMap<String, List<String>> binMap =\n                                        new HashMap<String, List<String>>();\n        // The platform-specific and benchmark-specific binaries\n        // take precedence, add last to map.\n        File binDir = new File(Config.FABAN_HOME + \"bin\"); // $FABAN_HOME/bin\n        addExecMap(binDir, binMap, null);\n        File sbinDir = new File(binDir, Config.OS_DIR); // $FABAN_HOME/bin/SunOS\n        addExecMap(sbinDir, binMap, null);\n        sbinDir = new File(binDir, Config.ARCH_DIR); // $FABAN_HOME/bin/SunOS/sparc\n        addExecMap(sbinDir, binMap, null);\n\n        if (benchName != null)\n            addBenchMap(binMap, benchName);\n\n        mapPathExt(binMap);\n\n        addCmdMapFile(binMap);\n\n        // Dump the binMap for debugging\n        if (logger.isLoggable(Level.FINER)) {\n            StringBuilder b = new StringBuilder(\"Executable map:\\n\");\n            for (Map.Entry<String, List<String>> entry : binMap.entrySet()) {\n                b.append(entry.getKey());\n                b.append(\" :\");\n                List<String> l = entry.getValue();\n                for (String v : l) {\n                    b.append(' ').append(v);\n                }\n                b.append('\\n');\n            }\n            logger.finer(b.toString());\n        }\n       return binMap;\n    }\n\n    private static void addBenchMap(HashMap<String, List<String>> binMap,\n                                    String benchName) {\n        // chmod is the way to make a file executable on Unix. Other platforms\n        // like Win32 does not have it and uses a different mechanism. So\n        // we'll run chmod only if it's there.\n        File chmodCmd = new File(\"/bin/chmod\");\n        if (!chmodCmd.exists()) {\n            chmodCmd = new File(\"/usr/bin/chmod\");\n            if (!chmodCmd.exists())\n                chmodCmd = null;\n        }\n\n        ArrayList<String> chmod = null;\n        if (chmodCmd != null) {\n            chmod = new ArrayList<String>();\n            chmod.add(chmodCmd.getAbsolutePath());\n            chmod.add(\"+x\");\n        }\n        File binDir = new File(Config.BENCHMARK_DIR + benchName + \"/bin/\");\n        boolean emptyList = addExecMap(binDir, binMap, chmod);\n        File sbinDir = new File(binDir, Config.OS_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        sbinDir = new File(binDir, Config.ARCH_DIR);\n        emptyList = addExecMap(sbinDir, binMap, chmod) && emptyList;\n        if (!emptyList)\n            try {\n                logger.fine(\"Changing mode for bin directories.\");\n                Command cmd = new Command(chmod);\n                CommandHandle handle = cmd.execute();\n                int exitValue = handle.exitValue();\n                if (exitValue != 0)\n                    logger.severe(\"Failed to chmod bin files. Exit value is \" +\n                                                                    exitValue);\n            } catch (IOException e) {\n                logger.log(Level.SEVERE, \"Cannot change mode on bin files\", e);\n            } catch (InterruptedException e) {\n                logger.log(Level.SEVERE,\n                           \"Interrupted changing mode on bin files\", e);\n            }\n    }\n\n\n    private static boolean addExecMap(File binDir,\n                                      HashMap<String, List<String>> binMap,\n                                      List<String> chmod) {\n        boolean emptyList = true;\n        if (binDir.isDirectory()) {\n            File[] binFiles = binDir.listFiles();\n            for (int i = 0; i < binFiles.length; i++)\n                if (!binFiles[i].isDirectory()) {\n                    String name = binFiles[i].getName();\n                    String fullPath = binFiles[i].getAbsolutePath();\n                    ArrayList<String> v = new ArrayList<String>();\n                    v.add(fullPath);\n                    binMap.put(name, v);\n                    if (chmod != null) {\n                        chmod.add(fullPath);\n                        emptyList = false;\n                    }\n                }\n        }\n        return emptyList;\n    }\n\n    /**\n     * Obtains a list of path extensions valid in this environment.\n     * @return A string array of valid path extensions\n     */\n    public static String[] getPathExt() {\n        String pathExt = System.getProperty(\"faban.pathext\");\n        if (pathExt == null)\n            return null;\n        pathExt = pathExt.trim();\n        if (pathExt.length() == 0)\n            return null;\n\n        // Ensure each of the exts are lowercase.\n        String[] pathExts = pathExt.split(File.pathSeparator);\n        for (int i = 0; i < pathExts.length; i++) {\n            pathExts[i] = pathExts[i].toLowerCase();\n        }\n        return pathExts;\n    }\n\n    /**\n     * The mapPathExt modifies the binMap according to the Win32\n     * conventions. For example, faban.cmd can be called with just faban.\n     * But calling it with faban.cmd also works. The PATHEXT needs to be\n     * passed to the JVM as a system property faban.pathext. PATHEXT\n     * matching is case insensitive. On Win32-like systems, faban.pathext\n     * would be set at the JVM invocation. On Unix systems, this property\n     * should not be set. This method would be a noop in this case.\n     * @param binMap The binMap\n     */\n    private static void mapPathExt(Map<String, List<String>> binMap) {\n\n        String[] pathExts = getPathExt();\n        if (pathExts == null)\n            return;\n\n        // Use a separate map so we don't modify binmap while iterating\n        HashMap<String, List<String>> pathExtMap =\n                                new HashMap<String, List<String>>();\n\n        Set<String> binKeys = binMap.keySet();\n\n        // Scan from back to front so the frontmost one put latest\n        // overrides the others that were put before.\n        for (int i = pathExts.length - 1; i >= 0; i--)\n            for (String key : binKeys)\n                if (key.toLowerCase().endsWith(pathExts[i])) {\n                    List<String> value = binMap.get(key);\n                    String newKey = key.substring(0, key.length() -\n                                    pathExts[i].length());\n                    pathExtMap.put(newKey, value);\n                }\n\n        binMap.putAll(pathExtMap);\n    }\n\n\n    /**\n     * Reads the command map file and adds/modifies the exec map accordingly.\n     * @param binMap\n     * @throws Exception\n     */\n    private static void addCmdMapFile(Map<String, List<String>> binMap)\n            throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n\n        File cmdMap = new File(\n                            Config.CONFIG_DIR + Config.OS_DIR + \"cmdmap.xml\");\n\n        if (cmdMap.exists()) {\n\n            FileInputStream is = new FileInputStream(cmdMap);\n            parseStream(is, cmdList);\n\n            // Next step is to use the map command path and prefixes to the\n            // actual executable.\n            for (Iterator<CmdDetail> iter = cmdList.iterator();\n                 iter.hasNext();) {\n                CmdDetail c = iter.next();\n                if (c.exec == null) {\n                    c.exec = binMap.get(c.name);\n                } else {\n                    String cmd = c.exec.get(0);\n                    File f = new File(cmd); // The exec can still be in\n                    if (!f.isAbsolute()) {     // the Faban path. May need\n                        List<String> path = binMap.get(cmd); // another mapping.\n                        if (path != null)      // if not absolute path. Just\n                            c.exec.set(0, path.get(0)); // ignore if not found in map.\n                    }                          // Should be in OS path instead.                        \n                }\n                if (c.exec == null) {\n                    c.exec = new ArrayList<String>();\n                    c.exec.add(c.name);\n                }\n                for (List<String> prefix : c.prefix) {\n                    String cmd = prefix.get(0);\n                    List<String> path = binMap.get(cmd);\n                    if (path != null)\n                        replaceFirst(prefix, path);\n                }\n            }\n\n            for (CmdDetail cmd : cmdList) {\n                ArrayList<String> exec = new ArrayList<String>();\n                for (List<String> prefix : cmd.prefix)\n                    exec.addAll(prefix);\n                exec.addAll(cmd.exec);\n                binMap.put(cmd.name, exec);\n            }\n        }\n    }\n\n    private static void parseStream(FileInputStream is,\n                                    ArrayList<CmdDetail> cmdList)\n            throws Exception {\n        SAXParserFactory sFact = SAXParserFactory.newInstance();\n        sFact.setFeature(\"http://xml.org/sax/features/validation\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/\" +\n                \"allow-java-encodings\", true);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-dtd-grammar\", false);\n        sFact.setFeature(\"http://apache.org/xml/features/nonvalidating/\" +\n                \"load-external-dtd\", false);\n        SAXParser parser = sFact.newSAXParser();\n        parser.parse(is, new MapReaderHandler(cmdList));\n    }\n\n    static class CmdDetail {\n        String name;\n        List<String> exec;\n        List<List<String>> prefix;\n\n        public String toString() {\n            StringBuilder b = new StringBuilder();\n            b.append(name);\n            b.append(':');\n\n            for (List<String> p : prefix)\n                for (String e : p)\n                    b.append(e).append(' ');\n\n            b.append(exec);\n            return b.toString();\n        }\n    }\n\n    static class MapReaderHandler extends DefaultHandler {\n        private CmdDetail currentCmd;\n        private ArrayList stack = new ArrayList();\n        private StringBuilder buffer = new StringBuilder();\n        private TreeMap<Integer, String> prefixes =\n                new TreeMap<Integer, String>();\n        private int currentSequence = Integer.MIN_VALUE;\n        private ArrayList<CmdDetail> cmdList;\n\n        MapReaderHandler(ArrayList<CmdDetail> cmdList) {\n            this.cmdList = cmdList;\n        }\n\n        /**\n         * Receive notification of the start of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the start of\n         * each element (such as allocating a new tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri        The Namespace URI, or the empty string if the\n         *                   element has no Namespace URI or if Namespace\n         *                   processing is not being performed.\n         * @param localName  The local name (without prefix), or the\n         *                   empty string if Namespace processing is not being\n         *                   performed.\n         * @param qName      The qualified name (with prefix), or the\n         *                   empty string if qualified names are not available.\n         * @param attributes The attributes attached to the element.  If\n         *                   there are no attributes, it shall be an empty\n         *                   Attributes object.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#startElement\n         */\n        public void startElement(String uri, String localName, String qName,\n                                 Attributes attributes) throws SAXException {\n            stack.add(qName);\n            if (\"command\".equals(qName)) {\n                currentCmd = new CmdDetail();\n            } else if (\"prefix\".equals(qName)) {\n                String s = attributes.getValue(\"sequence\");\n                if (s != null) {\n                    currentSequence = Integer.parseInt(s);\n                    if (currentSequence < 0)\n                        throw new SAXException(\n                                \"Prefix sequence must be 0 or greater\");\n                }\n            }\n        }\n\n        /**\n         * Receive notification of the end of an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method in a subclass to take specific actions at the end of\n         * each element (such as finalising a tree node or writing\n         * output to a file).<\/p>\n         *\n         * @param uri       The Namespace URI, or the empty string if the\n         *                  element has no Namespace URI or if Namespace\n         *                  processing is not being performed.\n         * @param localName The local name (without prefix), or the\n         *                  empty string if Namespace processing is not being\n         *                  performed.\n         * @param qName     The qualified name (with prefix), or the\n         *                  empty string if qualified names are not available.\n         * @throws org.xml.sax.SAXException Any SAX exception, possibly\n         *                                  wrapping another exception.\n         * @see org.xml.sax.ContentHandler#endElement\n         */\n        public void endElement(String uri, String localName, String qName)\n                throws SAXException {\n\n            int depth = stack.size();\n\n            if (!stack.remove(depth - 1).equals(qName))\n                throw new SAXException(\"endElement mismatch: \" + qName);\n\n            if (\"command\".equals(qName)) {\n                if (currentCmd.name == null)\n                    throw new SAXException(\"Command name not specified\");\n                // Get all the prefixes\n                int prefixSize = prefixes.size();\n                currentCmd.prefix = new ArrayList<List<String>>();\n                if (prefixSize > 0) {\n                    for (Map.Entry<Integer, String> entry : prefixes.entrySet())\n                        currentCmd.prefix.add(Command.parseArgs(\n                                                            entry.getValue()));\n                }\n                prefixes.clear();\n                cmdList.add(currentCmd);\n\n            } else if (\"name\".equals(qName)) {\n                currentCmd.name = buffer.toString().trim();\n            } else if (\"exec\".equals(qName)) {\n                currentCmd.exec = Command.parseArgs(buffer.toString().trim());\n            } else if (\"prefix\".equals(qName)) {\n                if (currentSequence < 0)\n                    currentSequence = -1;\n                String oldPrefix =\n                        prefixes.put(currentSequence, buffer.toString().trim());\n                if (oldPrefix != null) {\n                    if (currentSequence == -1)\n                        throw new SAXException(\"Need to specify prefix \" +\n                                \"sequence for more than one prefix\");\n                    else\n                        throw new SAXException(\"Duplicate prefix sequence \" +\n                                \"found\");\n                }\n                currentSequence = Integer.MIN_VALUE;\n            }\n            buffer.setLength(0);\n        }\n\n        /**\n         * Receive notification of character data inside an element.\n         * <p/>\n         * <p>By default, do nothing.  Application writers may override this\n         * method to take specific actions for each chunk of character data\n         * (such as adding the data to a node or buffer, or printing it to\n         * a file).<\/p>\n         *\n         * @param ch     The characters.\n         * @param start  The start position in the character array.\n         * @param length The number of characters to use from the\n         *               character array.\n         * @see org.xml.sax.ContentHandler#characters\n         */\n        public void characters(char ch[], int start, int length) {\n            buffer.append(ch, start, length);\n        }\n    }\n\n    public static void replaceFirst(List orig, List replacement) {\n        ArrayList tmp = new ArrayList();\n        tmp.addAll(orig);\n        orig.clear();\n        orig.addAll(replacement);\n        for (int i = 1; i < tmp.size(); i++) {\n            orig.add(tmp.get(i));\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        ArrayList<CmdDetail> cmdList = new ArrayList<CmdDetail>();\n        HashMap<String, List<String>> binMap =\n                new HashMap<String, List<String>>();\n        FileInputStream is = new FileInputStream(\"cmdmap.xml\");\n        parseStream(is, cmdList);\n\n        // Next step is to use the map command path and prefixes to the\n        // actual executable.\n        for (CmdDetail c : cmdList) {\n            if (c.exec == null)\n                c.exec = binMap.get(c.name);\n            if (c.exec == null) {\n                c.exec = new ArrayList<String>();\n                c.exec.add(c.name);\n            }\n\n            // Try to map exec cmd back to the binMap\n            String exec = c.exec.get(0);\n\n            // Search cmd for path separators ('/')\n            int pathSepIdx = exec.indexOf(File.separator);\n\n            // If not found, still a relative path\n            if (pathSepIdx < 0) {\n                // Map it\n                List<String> execList = binMap.get(exec);\n                // And combine back with args\n                if (execList != null)\n                    replaceFirst(c.exec, execList);\n            }\n\n            for (List<String> prefix : c.prefix) {\n                String cmd = prefix.get(0);\n                List<String> execList = binMap.get(cmd);\n                if (execList != null) {\n                    replaceFirst(prefix, execList);\n                }\n            }\n        }\n\n        for (Iterator<CmdDetail> iter = cmdList.iterator();\n             iter.hasNext();) {\n             CmdDetail c = iter.next();\n             System.out.println(c.toString());\n        }\n    }\n}\n","lineNo":243}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdAgentImpl.java,v 1.18 2008/03/14 07:20:01 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandChecker;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * CmdAgentImpl is the class that runs remote commands for the CmdService\n * This implementation provides a robust means of running remote\n * commands. All error messages from the remote commands are logged\n * to the error log, which should help in debugging.\n * The user is encouraged not to run huge shell scripts using this\n * interface as the debugging advantages will be lost. Rather, try and\n * break up the task to running Java/native apps as far as possible\n * and use shell scripts sparingly. If the shell scripts spit out\n * periodic status messages indicating the position in its execution\n * cycle, this will aid in debugging.\n * <ul>\n * <li> It implements the CmdAgent interface; see the\n *      CmdAgent.java file for its description.\n * <li> Application-defined exceptions.\n * <\/ul>\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.CmdService\n */\npublic class CmdAgentImpl extends UnicastRemoteObject\n        implements CmdAgent, CommandChecker, Unreferenced {\n\n    private static Logger logger =\n            Logger.getLogger(CmdAgentImpl.class.getName());\n\n    // This is actually deprecated. The field is responsible for old style\n    // ident based executions.\n    private Map processMap = Collections.synchronizedMap(new HashMap());\n\n    private List<CommandHandle> handleList = Collections.synchronizedList(\n                                                new ArrayList<CommandHandle>());\n\n    private String[] baseClassPath;\n    Map<String, String> binMap;\n\n    static class CmdProcess {\n        String ident;\n        Process process;\n        String logs;\n\n        public CmdProcess() {\n        }\n\n        public CmdProcess(String ident, Process process, String logs) {\n            this.ident = ident;\n            this.process = process;\n            this.logs = logs;\n        }\n    }\n\n\n    // This class must be created only through the main method.\n    CmdAgentImpl(String benchName) throws RemoteException {\n        super();\n\n        try {\n            setBenchName(benchName);\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent.\", e);\n        }\n    }\n\n    void setBenchName(String benchName) throws Exception {\n        baseClassPath = getBaseClassPath(benchName);\n        binMap = CmdMap.getCmdMap(benchName);\n    }\n\n    // CmdAgent implementation\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     *\n     */\n    public String getHostName() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Only Other Agents should access the command agent using this method.\n     * So the access is limited to package level\n     * @return this Command Agent\n     */\n    static CmdAgent getHandle() {\n        return AgentBootstrap.cmd;\n    }\n\n    /**\n     * Obtains the tmp directory of a remote host.\n     *\n     * @return The tmp directory.\n     */\n    public String getTmpDir() {\n        return Config.TMP_DIR;\n    }\n\n    /**\n     * Set the logging level of the specified logger.\n     * @param name Name of the logger. If \"\" is passed the root logger level will be set.\n     * @param level The Log level to set\n     */\n    public void setLogLevel(String name, Level level) throws RemoteException {\n        LogManager.getLogManager().getLogger(name).setLevel(level);\n\n        //Update logging.properties file which is used by faban driver\n\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     *\n     * @param c The command to be executed\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException {\n        c.register(handleList);\n        return c.execute(this);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param c The command containing the main class\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException {\n        c.register(handleList);\n        return c.executeJava(this);\n    }\n\n    /**\n     * Executes the RemoteCallable on the target instance.\n     *\n     * @param callable The callable to execute\n     * @return The type specified at creation of the callable.\n     * @throws Exception Any exception from the callable\n     */\n    public <V extends Serializable> V exec(RemoteCallable<V> callable)\n            throws Exception {\n\n        return callable.call();\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env)\n            throws Exception {\n        return startJavaCmd(cmd, identifier, env, null);\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @param classPath the class path to prepend to the base class path\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env,\n                                String[] classPath) throws Exception {\n\n        Process p;\n\n        StringBuffer buf = new StringBuffer(\" -cp \");\n        boolean falseEnding = false;\n        if (classPath != null)\n            for (int i = 0; i < classPath.length; i++) {\n                buf.append(classPath[i]);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n        for (int i = 0; i < baseClassPath.length; i++) {\n            buf.append(baseClassPath[i]);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        buf.append(' ');\n        String classpath = buf.toString();\n\n        cmd = AgentBootstrap.javaHome + File.separator + \"bin\" + File.separator + \"java \" +\n                AgentBootstrap.jvmOptions + classpath + cmd;\n        try {\n            logger.fine(\"Starting Java \" + cmd);\n            p = Runtime.getRuntime().exec(cmd, env);\n        }\n        catch (IOException e) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", e);\n            throw e;\n        }\n        processLogs(p);\n        if (p != null) {\n            processMap.put(identifier,\n                    new CmdProcess(identifier, p, processLogs(p)));\n\n            return true;\n        }\n        else\n            return false;\n    }\n\n    public boolean startAgent(Class agentClass, String identifier) throws Exception {\n        try {\n            Remote agent = (Remote)agentClass.newInstance();\n            logger.info(\"Agent class \" + agent.getClass().getName() + \" created\");\n            AgentBootstrap.registry.reregister(identifier, agent);\n            logger.fine(\"Agent started and Registered as \" + identifier);\n        }catch(Exception e) {\n            logger.log(Level.WARNING, \"Failed to create \" +\n                    agentClass.getName(), e);\n        }\n        return true;\n    }\n\n    /**\n     * This method is responsible for starting up the specified command\n     * in background\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd - actual command to execute\n     * @param identifier\t- String to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority to run command in\n     */\n    public boolean start (String cmd, String identifier, int priority)\n            throws Exception {\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            if(identifier != null)\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            return(true);\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Start command in background and wait for the specified message\n     * @param cmd to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public boolean start(String cmd, String ident, String msg, int priority)\n            throws Exception {\n\n        boolean ret = false;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                InputStream is = p.getInputStream();\n                BufferedReader bufR = new BufferedReader(new InputStreamReader(is));\n\n                // Just to make sure we don't wait for ever.\n                // We try for 1000 times to read before we give up\n                int attempts = 1000;\n                while(attempts-- > 0) {\n                    // make sure we don't block\n                    if(is.available() > 0) {\n                        String s = bufR.readLine();\n                        if((s !=  null) && (s.indexOf(msg) != -1)) {\n                            ret = true;\n                            break;\n                        }\n                    }\n                    else {\n                        try {\n                            Thread.sleep(100);\n                        } catch(Exception e){\n                            break;\n                        }\n                    }\n                }\n                bufR.close();\n            }\n            catch (Exception e){}\n\n            if(ident != null) {\n                processMap.put(ident,\n                        new CmdProcess(ident, p, processLogs(p)));\n            } // else we don't want to wait or kill this process later.\n        }\n        return(ret);\n    }\n    /**\n     * This method is responsible for starting the command in background\n     * and returning the first line of output.\n     * @param cmd command to start\n     * @param identifier to associate with this command, null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String cmd, String identifier, int priority)\n            throws Exception {\n\n        String retVal = null;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n                retVal = bufR.readLine();\n            }\n            catch (Exception e){}\n\n            if(identifier != null) {\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            }\n        }\n        return(retVal);\n    }\n\n    /**\n     * This method starts a command in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd : command to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean start (String cmd, int priority)\n            throws Exception {\n        boolean status = false;\n        Process p = createProcess(cmd, priority);\n\n        String errfile = processLogs(p);\n\n        /* Since this is in foreground, wait for it to complete */\n        try {\n            p.waitFor();\n        }\n        catch (InterruptedException ie) {\n            /* If we are interrupted, we were probably sent the kill signal */\n            p.destroy();\n        }\n\n        /* Now xfer logs (if any) */\n        xferLogs(errfile, cmd);\n\n        // Look at the exit value\n        if(p.exitValue() == 0)\n            status = true;\n\n        return(status);\n    }\n\n    /**\n         * This method starts a command in foreground\n         * The stdout from command is captured and returned.\n         * @param cmd : command to be started\n         * @param priority - class in which cmd should be run\n         * @return StringBuffer\n         */\n        public String startAndGetStdOut (String cmd, int priority)\n                throws Exception {\n            int readSize = 0;\n            int errReadSize = 0;\n            InputStream in,err;\n            byte[] buffer = new byte[8096];\n            StringBuffer std_out = new StringBuffer();\n            StringBuffer std_err = new StringBuffer();\n            Process p = createProcess(cmd, priority);\n\n            in = p.getInputStream();\n            err = p.getErrorStream();\n\n            // std_err.append(cmd);\n            // std_err.append(\"\\nstderr:\\n\");\n\n            boolean outClosed = false;\n            boolean errClosed = false;\n            for (;;) {\n                if (!outClosed && (readSize = in.read(buffer)) > 0)\n                    std_out.append(new String(buffer, 0, readSize));\n                if (!outClosed && readSize < 0)\n                    outClosed = true;\n                if (!errClosed && (errReadSize = err.read(buffer)) > 0)\n                    std_err.append(new String(buffer, 0, errReadSize));\n                if (!errClosed && errReadSize < 0)\n                    errClosed = true;\n                if (outClosed && errClosed)\n                    break;\n            }\n            logger.info(cmd + \"\\nstdout:\\n\" + std_out + \"\\nstderr:\\n\" + std_err);\n            /* Since this is in foreground, wait for it to complete */\n            try {\n                p.waitFor();\n                int exitValue = p.exitValue();\n                if (exitValue != 0) {\n                    logger.info(\"Warning: \" + \"Command exited with exit value - \" + exitValue );\n                }\n            } catch (InterruptedException e) {\n                /* If we are interrupted, we were probably sent the kill signal */\n                p.destroy();\n            }\n            in.close();\n            err.close();\n            return(std_out.toString());\n        }\n\n\n    /**\n     * This method runs a script in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean runScript (String cmd, int priority) throws Exception {\n        return start(cmd, priority);\n    }\n\n    /**\n     * This method is responsible for waiting for a command started\n     * earlier in background\n     * @param identifier with which this cmd was started\n     * @return true if command completed successfully\n     */\n    public boolean wait(String identifier) throws Exception {\n        boolean status;\n        CmdProcess cproc = (CmdProcess) processMap.get(identifier);\n        if (cproc == null) {\n            Exception e = new Exception(AgentBootstrap.ident + \" wait \" + identifier + \" : No such identifier\");\n            logger.throwing(AgentBootstrap.ident, \"wait\", e);\n            throw e;\n        }\n        logger.fine(\"Waiting for Command Identifier \" + identifier);\n\n        // Make sure nobody else is waiting for it.\n        synchronized (cproc) {\n            try {\n                cproc.process.waitFor();\n            }\n            catch (InterruptedException ie) {\n                cproc.process.destroy();\n            }\n            /* Now xfer logs (if any)*/\n            xferLogs(cproc.logs, cproc.ident);\n\n            if(cproc.process.exitValue() == 0)\n                status = true;\n            else\n                status = false;\n        }\n\n        /* Remove this command from our cache */\n        processMap.remove(cproc.ident);\n\n        return(status);\n    }\n\n    /**\n     * This method kills off the process specified\n     *\n     */\n    public void kill(String identifier) {\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        if (cproc == null)\n            // Such process no longer exists.\n            return;\n\n        cproc.process.destroy();\n\n        /* Now xfer logs (if any) to status and error logs*/\n        xferLogs(cproc.logs, cproc.ident);\n    }\n\n    /**\n     * This method is responsible for aborting a command using the killem\n     * script\n     * @param  identifier for the process. null if not started through\n     *               command service.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem (String identifier,\n                                     String processString, int sigNum)\n            throws RemoteException, IOException {\n\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        Object sync = cproc;\n        if (cproc == null)\n            sync = this;\n\n        // use exec to avoid creating another process\n        String s = \"exec \" + Config.BIN_DIR + \"perfkillem \" +\n                processString + \" -y -\" + sigNum;\n\n        synchronized (sync) {\n            logger.warning(\"Killing process with command \" + s);\n\n            try {\n                Process p = createProcess(s, Config.DEFAULT_PRIORITY);\n                p.waitFor();\n            }\n            catch (InterruptedException ie){\n            }\n            catch (Exception e) {\n                logger.log(Level.WARNING, \"Killem failed.\", e);\n            }\n        }\n    }\n\n    /**\n     * Kill off all processes started\n     */\n    public void kill() {\n        // Use an array of Idents as the vector gets manipulated by the kill(ident) call\n        synchronized (processMap) {\n            String[] keys = new String[processMap.size()];\n            keys = (String[]) processMap.keySet().toArray(keys);\n            for (int i = 0; i < keys.length; i++) {\n                if (keys[i] != null)\n                    kill(keys[i]);\n            }\n        }\n\n        // Now iterate the handle list and kill'em all.\n        synchronized (handleList) {\n            for (CommandHandle handle : handleList) {\n                try {\n                    handle.destroy();\n                } catch (RemoteException e) {\n                    logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                            \"local CommandHandle destroy. \" +\n                            \"Please report bug.\", e);\n                }\n            }\n\n            for (int retries = 0; handleList.size() > 0 && retries < 20;\n                 retries++){\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    logger.log(Level.WARNING, \"Sleep Interrupted. Strange!\", e);\n                }\n\n                // We need to use iterator instead of foreach loop as we need\n                // to remove handles from the list while going through it.\n                Iterator<CommandHandle> iter = handleList.iterator();\n                while (iter.hasNext()) {\n                    CommandHandle handle = iter.next();\n                    boolean terminated = false;\n                    try {\n                        int exitValue = handle.exitValue();\n                        logger.finer(\"Command exited with exit value \" +\n                                exitValue + '.');\n                        terminated = true;\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle exitValue. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER, \"Registry did not terminate! \",\n                                                                            e);\n                    }\n\n                    if (terminated)\n                        iter.remove();\n                    else\n                        try { // kill again...\n                            handle.destroy();\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE, \"Caught RemoteException\" +\n                                    \"on local CommandHandle destroy. \" +\n                                    \"Please report bug.\", e);\n                        }\n                }\n            }\n        }\n\n        int leftover = handleList.size();\n        if (leftover > 0) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Process termination/cleanup unsuccessful after \");\n            msg.append(\"20 attempts. \");\n            msg.append(leftover);\n            msg.append(\" processes remaining. \");\n            msg.append(\"This may affect subsequent runs:\");\n            synchronized(handleList) {\n                for (CommandHandle handle : handleList) {\n                    msg.append(\"<br>\\n\");\n                    try {\n                        msg.append(handle.getCommandString());\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle.getCommandString(). \" +\n                                \"Please report bug.\", e);\n                    }\n                }\n            }\n\n            logger.warning(msg.toString());\n            handleList.clear();\n        }\n\n        /* Exit application */\n        try {\n            AgentBootstrap.deregisterAgents();\n        } catch (RemoteException re){\n            logger.log(Level.WARNING, re.getMessage(), re);\n        }\n\n        logger.fine(\"Killing itself\");\n\n        // *** This is to gracefully return from this method.\n        // *** The Agent will exit after 5 seconds\n        // *** If the System.exit(0) is called in this method\n        // *** the Service will get a RemoteException\n        Thread exitThread = new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(5000);\n                    AgentBootstrap.terminateAgents();\n                } catch (Exception e) {}\n            }\n        };\n        exitThread.start();\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     *\n     * @see         java.rmi.server.Unreferenced\n     *\n     */\n    public void unreferenced()\n    {\n        kill();\n    }\n\n    public static Registry getRegistry() {\n        return AgentBootstrap.registry;\n    }\n\n    public static String getHost() {\n        return AgentBootstrap.host;\n    }\n\n    public static String getMaster() {\n        return AgentBootstrap.master;\n    }\n\n    private Process createProcess(String cmd, int priority) throws Exception {\n        Process p;\n        cmd = checkCommand(cmd);\n        String args[] = new String[7];\n\n        args[0] = \"priocntl\";\n        args[1] = \"-e\";\n        args[2] = \"-c\";\n        args[3] = (priority == Config.DEFAULT_PRIORITY) ? \"TS\" : \"RT\";\n        args[4] = \"sh\";\n        args[5] = \"-c\";\n        args[6] = cmd;\n\n        try {\n            logger.fine(\"Starting Command : \" + cmd );\n            p = Runtime.getRuntime().exec(args);\n        }\n        catch (IOException ie) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", ie);\n            throw ie;\n        }\n        return p;\n    }\n\n    /**\n     * Method that handles errors from commands\n     * This method captures any messages on stderr and\n     * stdout of the given Process and logs them.\n     * @param proc Process whose stderr needs to be logged\n     * @return filename in which errors are logged\n     */\n    private String processLogs(Process proc)\n    {\n        InputStream err = proc.getErrorStream();\n        InputStream log = proc.getInputStream();\n        // Create a unique temporary log file in tmp dir\n        String errFile =\n                Config.TMP_DIR + \"cmd\" + proc.hashCode();\n        String logFile = errFile + \"-out\";\n\n        // Create Log writer for errors\n        try {\n            new LogWriter(err, errFile);\n        }\n        catch (IOException ie) {\n            logger.warning(\"Could not write to \" + errFile);\n            return(null);\n        }\n\n        // Create Log writer for stdout\n        try {\n            new LogWriter(log, logFile);\n        }\n        catch (IOException ie) {\n            try {\n                logger.warning(\"Could not write to \" + logFile);\n            }\n            catch (Exception e){}\n        }\n\n        logger.fine(\"Created Error File \" + errFile);\n        logger.fine(\"Created Log File \" + logFile);\n        return errFile;\n    }\n\n    /**\n     * This method saves messages on stderr of the given\n     * Process and logs them to the errorlog.\n     * @param errFile Filename of the stderr log\n     * @param cmd command which generated errors\n     */\n    private boolean xferLogs(String errFile, String cmd) {\n        boolean status = true;\n        // First check if file has any  error messages\n        File f = new File(errFile);\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in log identifying source of errors\n                    buf.append(cmd);\n                    buf.append(\"\\nstderr:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.warning(buf.toString());\n                    status = false;\n                }\n                in.close();\n                f.delete();\n            }\n            // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n\n        // Copy std out\n        // First check if file has any message\n        f = new File(errFile + \"-out\");\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in ststus log identifying source of messages\n                    buf.append(cmd);\n                    buf.append(\"\\nstdout:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.info(buf.toString());\n                }\n                in.close();\n                f.delete();\n            }\n                    // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n        return status;\n    }\n\n    /**\n     * Checks and completes the command, if possible.\n     * @param cmd The original command\n     * @return The completed command\n     */\n    public String checkCommand(String cmd) {\n        String bin;\n        int idx = cmd.indexOf(' ');\n        if (idx == -1)\n            bin = cmd;\n        else\n            bin = cmd.substring(0, idx);\n        if (bin.indexOf(File.separator) != -1)\n            // The path is part of the command, use it as is\n            return cmd;\n        String path = (String) binMap.get(bin);\n        if (path == null) // Don't find it, just try as is\n            return cmd;\n        if (idx == -1)\n            return path;\n        return path + cmd.substring(idx);\n    }\n\n    /**\n     * Checks and completes the java command, if possible.\n     *\n     * @param cmd The original command\n     * @return The completed java command\n     */\n    public String checkJavaCommand(String cmd) {\n\n        StringBuilder buf = new StringBuilder(AgentBootstrap.javaHome);\n        buf.append(File.separator);\n        buf.append(\"bin\");\n        buf.append(File.separator);\n        buf.append(\"java \");\n        buf.append(AgentBootstrap.jvmOptions);\n        buf.append(\" -cp \");\n\n        boolean falseEnding = false;\n        // Externally specified classpath takes precedence.\n        for (String pathElement : AgentBootstrap.extClassPath) {\n            buf.append(pathElement);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        for (String pathElement : baseClassPath) {    ;\n            buf.append(pathElement);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        buf.append(' ');\n        buf.append(cmd);\n        return buf.toString();\n    }\n\n    private static String[] getBaseClassPath(String benchName) {\n        // The benchmark-specific libs take precedence, add first to list\n        ArrayList libList = new ArrayList();\n        File libDir = new File(Config.BENCHMARK_DIR + benchName + \"/lib/\");\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        libDir = new File(Config.LIB_DIR);\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        String[] baseClassPath = new String[libList.size()];\n        baseClassPath = (String[]) libList.toArray(baseClassPath);\n        return baseClassPath;\n    }\n\n    /**\n     * Sets the time on the agent host, in GMT. The time string\n     * must be in the format MMddHHmmyyyy.ss according to Unix date specs\n     * and must be in GMT time.\n     *\n     * @param gmtTimeString Time string in format\n     */\n    public void setTime(String gmtTimeString) {\n        String cmdLine = \"date -u \" + gmtTimeString;\n        Command c = new Command(cmdLine);\n        c.setLogLevel(Command.STDOUT, Level.FINER);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            int exitValue = c.execute(this).exitValue();\n            if (exitValue != 0)\n                logger.log(Level.WARNING, \"Error on \\\"\" + cmdLine +\n                        \"\\\" command trying to set the date. Exit value: \" +\n                        exitValue);\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error setting date.\", e);\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted setting date.\", e);\n        }\n    }\n\n    /**\n     * Gets the time on the agent host, in millis.\n     *\n     * @return The time on the remote system.\n     */\n    public long getTime() {\n        return System.currentTimeMillis();\n    }\n\n    // The class which spawns a thread to read the stream of the process\n    // and dumps it into the tmp file.\n    class LogWriter extends Thread {\n        BufferedReader in;\n        PrintStream out;\n\n        /**\n         * Constructor\n         * Open files and start thread\n         *\n         * @param is InputStream to read from\n         * @param logfile String filename to log to\n         */\n        public LogWriter(InputStream is, String logfile) throws IOException {\n            in = new BufferedReader(new InputStreamReader(is));\n            out = new PrintStream(new FileOutputStream(logfile));\n            this.start();\n        }\n\n        /**\n         * Run, copying input stream's contents to output until no\n         * more data in input file. Exit thread automatically.\n         */\n        public void run() {\n            try {\n                String str = in.readLine();\n                while (str != null) {\n                    out.println(str);\n                    str = in.readLine();\n                }\n            } catch (IOException ie) {\n                return;\n            }\n            return;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdAgentImpl.java,v 1.19 2008/03/15 07:31:43 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandChecker;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * CmdAgentImpl is the class that runs remote commands for the CmdService\n * This implementation provides a robust means of running remote\n * commands. All error messages from the remote commands are logged\n * to the error log, which should help in debugging.\n * The user is encouraged not to run huge shell scripts using this\n * interface as the debugging advantages will be lost. Rather, try and\n * break up the task to running Java/native apps as far as possible\n * and use shell scripts sparingly. If the shell scripts spit out\n * periodic status messages indicating the position in its execution\n * cycle, this will aid in debugging.\n * <ul>\n * <li> It implements the CmdAgent interface; see the\n *      CmdAgent.java file for its description.\n * <li> Application-defined exceptions.\n * <\/ul>\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.CmdService\n */\npublic class CmdAgentImpl extends UnicastRemoteObject\n        implements CmdAgent, CommandChecker, Unreferenced {\n\n    private static Logger logger =\n            Logger.getLogger(CmdAgentImpl.class.getName());\n\n    // This is actually deprecated. The field is responsible for old style\n    // ident based executions.\n    private Map processMap = Collections.synchronizedMap(new HashMap());\n\n    private List<CommandHandle> handleList = Collections.synchronizedList(\n                                                new ArrayList<CommandHandle>());\n\n    private String[] baseClassPath;\n    Map<String, String> binMap;\n    private ArrayList<String> javaCmd;\n\n    static class CmdProcess {\n        String ident;\n        Process process;\n        String logs;\n\n        public CmdProcess() {\n        }\n\n        public CmdProcess(String ident, Process process, String logs) {\n            this.ident = ident;\n            this.process = process;\n            this.logs = logs;\n        }\n    }\n\n\n    // This class must be created only through the main method.\n    CmdAgentImpl() throws RemoteException {\n        super();\n    }\n\n    void setBenchName(String benchName) throws Exception {\n        baseClassPath = getBaseClassPath(benchName);\n        binMap = CmdMap.getCmdMap(benchName);\n    }\n\n    // CmdAgent implementation\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     *\n     */\n    public String getHostName() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Only Other Agents should access the command agent using this method.\n     * So the access is limited to package level\n     * @return this Command Agent\n     */\n    static CmdAgent getHandle() {\n        return AgentBootstrap.cmd;\n    }\n\n    /**\n     * Obtains the tmp directory of a remote host.\n     *\n     * @return The tmp directory.\n     */\n    public String getTmpDir() {\n        return Config.TMP_DIR;\n    }\n\n    /**\n     * Set the logging level of the specified logger.\n     * @param name Name of the logger. If \"\" is passed the root logger level will be set.\n     * @param level The Log level to set\n     */\n    public void setLogLevel(String name, Level level) throws RemoteException {\n        LogManager.getLogManager().getLogger(name).setLevel(level);\n\n        //Update logging.properties file which is used by faban driver\n\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     *\n     * @param c The command to be executed\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException {\n        c.register(handleList);\n        return c.execute(this);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param c The command containing the main class\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException {\n        c.register(handleList);\n        return c.executeJava(this);\n    }\n\n    /**\n     * Executes the RemoteCallable on the target instance.\n     *\n     * @param callable The callable to execute\n     * @return The type specified at creation of the callable.\n     * @throws Exception Any exception from the callable\n     */\n    public <V extends Serializable> V exec(RemoteCallable<V> callable)\n            throws Exception {\n\n        return callable.call();\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env)\n            throws Exception {\n        return startJavaCmd(cmd, identifier, env, null);\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @param classPath the class path to prepend to the base class path\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env,\n                                String[] classPath) throws Exception {\n\n        Process p;\n        ArrayList<String> cmds = new ArrayList<String>();\n        cmds.add(AgentBootstrap.javaHome + File.separator + \"bin\" +\n                                            File.separator + \"java\");\n        cmds.addAll(AgentBootstrap.jvmOptions);\n\n        cmds.add(\"-cp\");\n\n        StringBuilder buf = new StringBuilder();\n        boolean falseEnding = false;\n        if (classPath != null)\n            for (int i = 0; i < classPath.length; i++) {\n                buf.append(classPath[i]);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n        for (int i = 0; i < baseClassPath.length; i++) {\n            buf.append(baseClassPath[i]);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        cmds.add(buf.toString());\n\n        cmds.addAll(Command.parseArgs(cmd));\n\n        try {\n            logger.fine(\"Starting Java \" + cmd);\n            ProcessBuilder b = new ProcessBuilder(cmds);\n            p = b.start();\n        }\n        catch (IOException e) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", e);\n            throw e;\n        }\n        processLogs(p);\n        if (p != null) {\n            processMap.put(identifier,\n                    new CmdProcess(identifier, p, processLogs(p)));\n\n            return true;\n        }\n        else\n            return false;\n    }\n\n    public boolean startAgent(Class agentClass, String identifier) throws Exception {\n        try {\n            Remote agent = (Remote)agentClass.newInstance();\n            logger.info(\"Agent class \" + agent.getClass().getName() + \" created\");\n            AgentBootstrap.registry.reregister(identifier, agent);\n            logger.fine(\"Agent started and Registered as \" + identifier);\n        }catch(Exception e) {\n            logger.log(Level.WARNING, \"Failed to create \" +\n                    agentClass.getName(), e);\n        }\n        return true;\n    }\n\n    /**\n     * This method is responsible for starting up the specified command\n     * in background\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd - actual command to execute\n     * @param identifier\t- String to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority to run command in\n     */\n    public boolean start (String cmd, String identifier, int priority)\n            throws Exception {\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            if(identifier != null)\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            return(true);\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Start command in background and wait for the specified message\n     * @param cmd to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public boolean start(String cmd, String ident, String msg, int priority)\n            throws Exception {\n\n        boolean ret = false;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                InputStream is = p.getInputStream();\n                BufferedReader bufR = new BufferedReader(new InputStreamReader(is));\n\n                // Just to make sure we don't wait for ever.\n                // We try for 1000 times to read before we give up\n                int attempts = 1000;\n                while(attempts-- > 0) {\n                    // make sure we don't block\n                    if(is.available() > 0) {\n                        String s = bufR.readLine();\n                        if((s !=  null) && (s.indexOf(msg) != -1)) {\n                            ret = true;\n                            break;\n                        }\n                    }\n                    else {\n                        try {\n                            Thread.sleep(100);\n                        } catch(Exception e){\n                            break;\n                        }\n                    }\n                }\n                bufR.close();\n            }\n            catch (Exception e){}\n\n            if(ident != null) {\n                processMap.put(ident,\n                        new CmdProcess(ident, p, processLogs(p)));\n            } // else we don't want to wait or kill this process later.\n        }\n        return(ret);\n    }\n    /**\n     * This method is responsible for starting the command in background\n     * and returning the first line of output.\n     * @param cmd command to start\n     * @param identifier to associate with this command, null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String cmd, String identifier, int priority)\n            throws Exception {\n\n        String retVal = null;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n                retVal = bufR.readLine();\n            }\n            catch (Exception e){}\n\n            if(identifier != null) {\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            }\n        }\n        return(retVal);\n    }\n\n    /**\n     * This method starts a command in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd : command to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean start (String cmd, int priority)\n            throws Exception {\n        boolean status = false;\n        Process p = createProcess(cmd, priority);\n\n        String errfile = processLogs(p);\n\n        /* Since this is in foreground, wait for it to complete */\n        try {\n            p.waitFor();\n        }\n        catch (InterruptedException ie) {\n            /* If we are interrupted, we were probably sent the kill signal */\n            p.destroy();\n        }\n\n        /* Now xfer logs (if any) */\n        xferLogs(errfile, cmd);\n\n        // Look at the exit value\n        if(p.exitValue() == 0)\n            status = true;\n\n        return(status);\n    }\n\n    /**\n         * This method starts a command in foreground\n         * The stdout from command is captured and returned.\n         * @param cmd : command to be started\n         * @param priority - class in which cmd should be run\n         * @return StringBuffer\n         */\n        public String startAndGetStdOut (String cmd, int priority)\n                throws Exception {\n            int readSize = 0;\n            int errReadSize = 0;\n            InputStream in,err;\n            byte[] buffer = new byte[8096];\n            StringBuffer std_out = new StringBuffer();\n            StringBuffer std_err = new StringBuffer();\n            Process p = createProcess(cmd, priority);\n\n            in = p.getInputStream();\n            err = p.getErrorStream();\n\n            // std_err.append(cmd);\n            // std_err.append(\"\\nstderr:\\n\");\n\n            boolean outClosed = false;\n            boolean errClosed = false;\n            for (;;) {\n                if (!outClosed && (readSize = in.read(buffer)) > 0)\n                    std_out.append(new String(buffer, 0, readSize));\n                if (!outClosed && readSize < 0)\n                    outClosed = true;\n                if (!errClosed && (errReadSize = err.read(buffer)) > 0)\n                    std_err.append(new String(buffer, 0, errReadSize));\n                if (!errClosed && errReadSize < 0)\n                    errClosed = true;\n                if (outClosed && errClosed)\n                    break;\n            }\n            logger.info(cmd + \"\\nstdout:\\n\" + std_out + \"\\nstderr:\\n\" + std_err);\n            /* Since this is in foreground, wait for it to complete */\n            try {\n                p.waitFor();\n                int exitValue = p.exitValue();\n                if (exitValue != 0) {\n                    logger.info(\"Warning: \" + \"Command exited with exit value - \" + exitValue );\n                }\n            } catch (InterruptedException e) {\n                /* If we are interrupted, we were probably sent the kill signal */\n                p.destroy();\n            }\n            in.close();\n            err.close();\n            return(std_out.toString());\n        }\n\n\n    /**\n     * This method runs a script in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean runScript (String cmd, int priority) throws Exception {\n        return start(cmd, priority);\n    }\n\n    /**\n     * This method is responsible for waiting for a command started\n     * earlier in background\n     * @param identifier with which this cmd was started\n     * @return true if command completed successfully\n     */\n    public boolean wait(String identifier) throws Exception {\n        boolean status;\n        CmdProcess cproc = (CmdProcess) processMap.get(identifier);\n        if (cproc == null) {\n            Exception e = new Exception(AgentBootstrap.ident + \" wait \" + identifier + \" : No such identifier\");\n            logger.throwing(AgentBootstrap.ident, \"wait\", e);\n            throw e;\n        }\n        logger.fine(\"Waiting for Command Identifier \" + identifier);\n\n        // Make sure nobody else is waiting for it.\n        synchronized (cproc) {\n            try {\n                cproc.process.waitFor();\n            }\n            catch (InterruptedException ie) {\n                cproc.process.destroy();\n            }\n            /* Now xfer logs (if any)*/\n            xferLogs(cproc.logs, cproc.ident);\n\n            if(cproc.process.exitValue() == 0)\n                status = true;\n            else\n                status = false;\n        }\n\n        /* Remove this command from our cache */\n        processMap.remove(cproc.ident);\n\n        return(status);\n    }\n\n    /**\n     * This method kills off the process specified\n     *\n     */\n    public void kill(String identifier) {\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        if (cproc == null)\n            // Such process no longer exists.\n            return;\n\n        cproc.process.destroy();\n\n        /* Now xfer logs (if any) to status and error logs*/\n        xferLogs(cproc.logs, cproc.ident);\n    }\n\n    /**\n     * This method is responsible for aborting a command using the killem\n     * script\n     * @param  identifier for the process. null if not started through\n     *               command service.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem (String identifier,\n                                     String processString, int sigNum)\n            throws RemoteException, IOException {\n\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        Object sync = cproc;\n        if (cproc == null)\n            sync = this;\n\n        // use exec to avoid creating another process\n        String s = \"exec \" + Config.BIN_DIR + \"perfkillem \" +\n                processString + \" -y -\" + sigNum;\n\n        synchronized (sync) {\n            logger.warning(\"Killing process with command \" + s);\n\n            try {\n                Process p = createProcess(s, Config.DEFAULT_PRIORITY);\n                p.waitFor();\n            }\n            catch (InterruptedException ie){\n            }\n            catch (Exception e) {\n                logger.log(Level.WARNING, \"Killem failed.\", e);\n            }\n        }\n    }\n\n    /**\n     * Kill off all processes started\n     */\n    public void kill() {\n        // Use an array of Idents as the vector gets manipulated by the kill(ident) call\n        synchronized (processMap) {\n            String[] keys = new String[processMap.size()];\n            keys = (String[]) processMap.keySet().toArray(keys);\n            for (int i = 0; i < keys.length; i++) {\n                if (keys[i] != null)\n                    kill(keys[i]);\n            }\n        }\n\n        // Now iterate the handle list and kill'em all.\n        synchronized (handleList) {\n            for (CommandHandle handle : handleList) {\n                try {\n                    handle.destroy();\n                } catch (RemoteException e) {\n                    logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                            \"local CommandHandle destroy. \" +\n                            \"Please report bug.\", e);\n                }\n            }\n\n            for (int retries = 0; handleList.size() > 0 && retries < 20;\n                 retries++){\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    logger.log(Level.WARNING, \"Sleep Interrupted. Strange!\", e);\n                }\n\n                // We need to use iterator instead of foreach loop as we need\n                // to remove handles from the list while going through it.\n                Iterator<CommandHandle> iter = handleList.iterator();\n                while (iter.hasNext()) {\n                    CommandHandle handle = iter.next();\n                    boolean terminated = false;\n                    try {\n                        int exitValue = handle.exitValue();\n                        logger.finer(\"Command exited with exit value \" +\n                                exitValue + '.');\n                        terminated = true;\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle exitValue. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER, \"Registry did not terminate! \",\n                                                                            e);\n                    }\n\n                    if (terminated)\n                        iter.remove();\n                    else\n                        try { // kill again...\n                            handle.destroy();\n                        } catch (RemoteException e) {\n                            logger.log(Level.SEVERE, \"Caught RemoteException\" +\n                                    \"on local CommandHandle destroy. \" +\n                                    \"Please report bug.\", e);\n                        }\n                }\n            }\n        }\n\n        int leftover = handleList.size();\n        if (leftover > 0) {\n            StringBuilder msg = new StringBuilder();\n            msg.append(\"Process termination/cleanup unsuccessful after \");\n            msg.append(\"20 attempts. \");\n            msg.append(leftover);\n            msg.append(\" processes remaining. \");\n            msg.append(\"This may affect subsequent runs:\");\n            synchronized(handleList) {\n                for (CommandHandle handle : handleList) {\n                    msg.append(\"<br>\\n\");\n                    try {\n                        msg.append(handle.getCommandString());\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle.getCommandString(). \" +\n                                \"Please report bug.\", e);\n                    }\n                }\n            }\n\n            logger.warning(msg.toString());\n            handleList.clear();\n        }\n\n        /* Exit application */\n        try {\n            AgentBootstrap.deregisterAgents();\n        } catch (RemoteException re){\n            logger.log(Level.WARNING, re.getMessage(), re);\n        }\n\n        logger.fine(\"Killing itself\");\n\n        // *** This is to gracefully return from this method.\n        // *** The Agent will exit after 5 seconds\n        // *** If the System.exit(0) is called in this method\n        // *** the Service will get a RemoteException\n        Thread exitThread = new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(5000);\n                    AgentBootstrap.terminateAgents();\n                } catch (Exception e) {}\n            }\n        };\n        exitThread.start();\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     *\n     * @see         java.rmi.server.Unreferenced\n     *\n     */\n    public void unreferenced()\n    {\n        kill();\n    }\n\n    public static Registry getRegistry() {\n        return AgentBootstrap.registry;\n    }\n\n    public static String getHost() {\n        return AgentBootstrap.host;\n    }\n\n    public static String getMaster() {\n        return AgentBootstrap.master;\n    }\n\n    private Process createProcess(String cmd, int priority) throws Exception {\n        Process p;\n        List<String> cmds = Command.parseArgs(cmd);\n\n        cmds = checkCommand(cmds);\n\n        ArrayList<String> args = new ArrayList<String>();\n        args.add(\"priocntl\");\n        args.add(\"-e\");\n        args.add(\"-c\");\n        args.add(priority == Config.DEFAULT_PRIORITY ? \"TS\" : \"RT\");\n        args.add(\"sh\");\n        args.add(\"-c\");\n        args.addAll(cmds);\n\n        try {\n            logger.fine(\"Starting Command : \" + cmd );\n            ProcessBuilder b = new ProcessBuilder(args);\n            p = b.start();\n        } catch (IOException ie) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", ie);\n            throw ie;\n        }\n        return p;\n    }\n\n    /**\n     * Method that handles errors from commands\n     * This method captures any messages on stderr and\n     * stdout of the given Process and logs them.\n     * @param proc Process whose stderr needs to be logged\n     * @return filename in which errors are logged\n     */\n    private String processLogs(Process proc)\n    {\n        InputStream err = proc.getErrorStream();\n        InputStream log = proc.getInputStream();\n        // Create a unique temporary log file in tmp dir\n        String errFile =\n                Config.TMP_DIR + \"cmd\" + proc.hashCode();\n        String logFile = errFile + \"-out\";\n\n        // Create Log writer for errors\n        try {\n            new LogWriter(err, errFile);\n        }\n        catch (IOException ie) {\n            logger.warning(\"Could not write to \" + errFile);\n            return(null);\n        }\n\n        // Create Log writer for stdout\n        try {\n            new LogWriter(log, logFile);\n        }\n        catch (IOException ie) {\n            try {\n                logger.warning(\"Could not write to \" + logFile);\n            }\n            catch (Exception e){}\n        }\n\n        logger.fine(\"Created Error File \" + errFile);\n        logger.fine(\"Created Log File \" + logFile);\n        return errFile;\n    }\n\n    /**\n     * This method saves messages on stderr of the given\n     * Process and logs them to the errorlog.\n     * @param errFile Filename of the stderr log\n     * @param cmd command which generated errors\n     */\n    private boolean xferLogs(String errFile, String cmd) {\n        boolean status = true;\n        // First check if file has any  error messages\n        File f = new File(errFile);\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in log identifying source of errors\n                    buf.append(cmd);\n                    buf.append(\"\\nstderr:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.warning(buf.toString());\n                    status = false;\n                }\n                in.close();\n                f.delete();\n            }\n            // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n\n        // Copy std out\n        // First check if file has any message\n        f = new File(errFile + \"-out\");\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in ststus log identifying source of messages\n                    buf.append(cmd);\n                    buf.append(\"\\nstdout:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.info(buf.toString());\n                }\n                in.close();\n                f.delete();\n            }\n                    // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n        return status;\n    }\n\n    /**\n     * Checks and completes the command list, if possible.\n     * @param cmd The command and arg list\n     * @return The checked command\n     */\n    public List<String> checkCommand(List<String> cmd) {\n        String bin = cmd.get(0);\n        if (bin.indexOf(File.separator) == -1) {\n            // not an absolute path\n            String path = binMap.get(bin);\n            if (path != null) // Don't find it, just try as is\n                cmd.set(0, path);\n        }\n        return cmd;\n    }\n\n    /**\n     * Checks and completes the java command, if possible.\n     *\n     * @param cmd The original command\n     * @return The completed java command\n     */\n    public List<String> checkJavaCommand(List<String> cmd) {\n\n        if (javaCmd == null) { // Initialize javaCmd if needed.\n            javaCmd = new ArrayList<String>();\n\n            StringBuilder buf = new StringBuilder(AgentBootstrap.javaHome);\n            buf.append(File.separator);\n            buf.append(\"bin\");\n            buf.append(File.separator);\n            buf.append(\"java\");\n            javaCmd.add(buf.toString());\n            buf.setLength(0);\n\n            javaCmd.addAll(AgentBootstrap.jvmOptions);\n\n            javaCmd.add(\"-cp\");\n\n            boolean falseEnding = false;\n            // Externally specified classpath takes precedence.\n            for (String pathElement : AgentBootstrap.extClassPath) {\n                buf.append(pathElement);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n            for (String pathElement : baseClassPath) {\n                buf.append(pathElement);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n            if (falseEnding)\n                buf.setLength(buf.length() - File.pathSeparator.length());\n            javaCmd.add(buf.toString());\n        }\n\n        ArrayList<String> tmp = new ArrayList<String>(cmd);\n        cmd.clear();\n        cmd.addAll(javaCmd);\n        cmd.addAll(tmp);\n        return cmd;\n    }\n\n    private static String[] getBaseClassPath(String benchName) {\n        // The benchmark-specific libs take precedence, add first to list\n        ArrayList libList = new ArrayList();\n        File libDir = new File(Config.BENCHMARK_DIR + benchName + \"/lib/\");\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        libDir = new File(Config.LIB_DIR);\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        String[] baseClassPath = new String[libList.size()];\n        baseClassPath = (String[]) libList.toArray(baseClassPath);\n        return baseClassPath;\n    }\n\n    /**\n     * Sets the time on the agent host, in GMT. The time string\n     * must be in the format MMddHHmmyyyy.ss according to Unix date specs\n     * and must be in GMT time.\n     *\n     * @param gmtTimeString Time string in format\n     */\n    public void setTime(String gmtTimeString) {\n        String cmdLine = \"date -u \" + gmtTimeString;\n        Command c = new Command(cmdLine);\n        c.setLogLevel(Command.STDOUT, Level.FINER);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            int exitValue = c.execute(this).exitValue();\n            if (exitValue != 0)\n                logger.log(Level.WARNING, \"Error on \\\"\" + cmdLine +\n                        \"\\\" command trying to set the date. Exit value: \" +\n                        exitValue);\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error setting date.\", e);\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted setting date.\", e);\n        }\n    }\n\n    /**\n     * Gets the time on the agent host, in millis.\n     *\n     * @return The time on the remote system.\n     */\n    public long getTime() {\n        return System.currentTimeMillis();\n    }\n\n    // The class which spawns a thread to read the stream of the process\n    // and dumps it into the tmp file.\n    class LogWriter extends Thread {\n        BufferedReader in;\n        PrintStream out;\n\n        /**\n         * Constructor\n         * Open files and start thread\n         *\n         * @param is InputStream to read from\n         * @param logfile String filename to log to\n         */\n        public LogWriter(InputStream is, String logfile) throws IOException {\n            in = new BufferedReader(new InputStreamReader(is));\n            out = new PrintStream(new FileOutputStream(logfile));\n            this.start();\n        }\n\n        /**\n         * Run, copying input stream's contents to output until no\n         * more data in input file. Exit thread automatically.\n         */\n        public void run() {\n            try {\n                String str = in.readLine();\n                while (str != null) {\n                    out.println(str);\n                    str = in.readLine();\n                }\n            } catch (IOException ie) {\n                return;\n            }\n            return;\n        }\n    }\n}\n","lineNo":714}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdService.java,v 1.33 2008/03/14 06:47:40 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    public static final int SEQUENTIAL = 1;\t/* Sequential flag in FG mode*/\n    public static final int PARALLEL = 2;\t/* parallel flag in FG mode*/\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines */\n    private ArrayList<String> machinesList = new ArrayList<String>();\t\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private String jvmOptions;\n    private HashMap<String, String> binMap = new HashMap<String, String>();\n    private Map<String, String> ifMap;\n\n    private String rsh, agent;\n\n\n    private CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        if(cmds == null)\n            cmds = new CmdService();\n        return cmds;\n    }\n\n    /**\n     *\n     * @return master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines\n     * This method can be called multiple times to initialize multiple\n     * classes of machines\n     * @param hosts String[][] of machines\n     * @return true if successful, false if setup failed\n     *\n     */\n    public boolean setup(String benchName, String[][] hosts,\n                         String home, String options) {\n\n        // It is common for java to be in C:\\Program Files. This has a space\n        // inside the string and can cause havoc. We need to double quote this\n        // parameter as needed.\n        if (home.indexOf(' ') == -1)\n            javaHome = home;\n        else\n            javaHome = '\"' + home + '\"';\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        // Again, we ensure FABAN_HOME to be quoted if there are spaces inside.\n        if (escapedHome.indexOf(' ') != -1)\n            escapedHome = '\"' + escapedHome + '\"';\n        jvmOptions = \"-Dfaban.home=\" + escapedHome +\n                \" -Djava.security.policy=\" + escapedHome + \"config\" + fs +\n                \"faban.policy -Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties -Dfaban.registry.port=\" +\n                Config.RMI_PORT + ' ' + \"-Dfaban.logging.port=\" +\n                Config.LOGGING_PORT;\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if(!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                 log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))){\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                                String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch(IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer(\" -cp \");\n            for(int i = 0; i < libs.length; i++) {\n                if(libs[i].isFile())\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n            }\n\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            String cmd = javaHome + File.separator + \"bin\" + File.separator +\n                    \"java \" + jvmOptions + \" -Xms32m -Xmx1024m \" + classpath +\n                    \" com.sun.faban.common.RegistryImpl\" ;\n\n            logger.info(\"Starting Registry.\");\n            logger.fine(\"Starting using command \" + cmd);\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        jvmOptions += ' ' + options;\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch(InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch(Exception e) {\n            logger.severe(\"Unable to connect to Registry \" + e);\n            logger.log(Level.FINE,  \"Exception\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        outer:\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 ||    // localhost\n                        machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\") + ' ';\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\",e);\n        }\n\n        if (rsh == null)\n            rsh = \"rsh\";\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master))\n                return false;\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if(\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for(int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if(machinesList.contains(machines[i]))\n                    continue;\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0)\n                    return false;\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress))\n                    return false;\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++)\n            if (!getCmdAgent((String) machinesList.get(i)))\n                return false;\n        setClocks();\n        return true;\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n                             Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host: hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            }\n            catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                                retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return(false);\n            }\n\n            cmdp.add(c);\n            logger.fine(\"CmdService: Configuring \" + s);\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" + c.getHostName());\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            filep.add((FileAgent) registry.getService(s));\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \"\n                    + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n    * We use a script 'cmd' which will setup the CLASSPATH before\n    * invoking CmdAgent\n    */\n    private boolean startCmdAgent(String benchName, String mach,\n                                  String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        String cmdarray;\n\n        String agentParams = mach + ' ' + interfaceAddress + ' ' +\n                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +\n                        \" faban.benchmarkName=\" + benchName;\n        try {\n            if (mach.equals(master)) {\n                cmdarray = agent + agentParams;\n                logger.fine(\"Executing \" + cmdarray);\n                Command cmdAgent = new Command(cmdarray);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams += \" faban.download=\" + downloadURL.toString();\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    OutputStream socketOut = socket.getOutputStream();\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    socketOut.write(agentParams.getBytes());\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200 : agentStarted = true;\n                                   logger.fine(\"Found Agent(daemon)@\" + mach +\n                                               \". Registering agent.\");\n                                   break;\n                        case 500 : logger.warning(\"Agent(daemon)@\" + mach +\n                                              \": \" + response +\n                                              \" Please report the issue \" +\n                                              \"and provide logs from \" + mach +\n                                              \":FABAN_HOME/logs/agent.log\");\n                                   break;\n                        case 409 : logger.severe(\"Agent(daemon)@\" + mach +\n                                                 \": \" + response);\n                                   // We do not fall back in the conflict case.\n                                   return false;\n                        default  : logger.warning(\"Agent(daemon)@\" + mach +\n                                                  \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;\n                    logger.fine(\"Executing \" + cmdarray);\n                    Command cmdAgent = new Command(cmdarray);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                                                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<Future<Boolean>> tasks = new ArrayList<Future<Boolean>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    tasks.add(Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat)));\n                }\n                for (Future<Boolean> future : tasks)\n                    try {\n                        future.get(300, TimeUnit.SECONDS);\n                    } catch (Throwable t) {\n                        Throwable cause = t.getCause();\n                        while (cause != null) {\n                            t = cause;\n                            cause = t.getCause();\n                        }\n                        logger.log(Level.SEVERE, t.getMessage(), t);\n                    }\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                     SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws RemoteException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \"cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \"Cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100)\n                            ++nextSec; // If not, we go to the next sec.\n\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                                    System.currentTimeMillis();\n                        if (sleepTime > 0)\n                            Thread.sleep(sleepTime);\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0)\n            return machineName; // Cannot resolve\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        }\n        catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                          re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return execute(master, c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).execute(c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return java(master, c);\n    }\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).java(c);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c);\n        return result;\n    }\n\n    public <V extends Serializable> V\n            execute(String machine, RemoteCallable<V> callable)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable);\n    }\n\n    public <V extends Serializable> List<V>\n            execute(String[] machines, RemoteCallable<V> callable)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable));\n        return rl;\n    }\n\n\n    /**\n     * Start commands sequentially in foreground on machines\n     * The command string should include all stdin, stdout, stderr\n     * redirections (if any). Note that files referred in the command\n     * should be on the machine on which the command is run.\n     * The 'copy' method can be used to transfer files to remote machines.\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param seq flag to indicate if commands should be sequential or parallel\n     * @param priority (default or higher priority) for command\n     * @return true if all commands completed successfully, else false\n     * @see #copy (String, String, String, String, boolean)\n     */\n    public boolean start(String machines[], String cmd, int seq,\n                         int priority) throws Exception {\n\n        boolean exitcode = true;\n\n\n        for (int i = 0; i<machines.length; i++)\n            logger.fine(\"Starting command = \" + cmd +\" on machine \" + machines[i]);\n\n        if (seq == SEQUENTIAL) {\n            /* Start cmd on each m/c in foreground */\n            for (int i = 0; i < machines.length; i++) {\n                if (findCmdAgent(machines[i]).start(cmd, priority) == false)\n                    exitcode = false;\n            }\n        }\n        else if (seq == PARALLEL) {\n            /* Start cmd on each m/c in parallel, then wait for all */\n            String ident = \"Generated\";\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).start(cmd, ident, priority);\n            for (int i = 0; i < machines.length; i++)\n                if (findCmdAgent(machines[i]).wait(ident) == false)\n                    exitcode = false;\n        }\n        return(exitcode);\n    }\n\n\n    /**\n     * Start a command on a single machine\n     */\n    public boolean start(String machine, String command, int seq,\n                         int priority) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(start(m, command, seq, priority));\n    }\n\n    /**\n     * Start commands in background\n     *\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident,\n                      int priority) throws Exception {\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n            findCmdAgent(machines[i]).start(cmd, ident, priority);\n        }\n    }\n\n    /**\n     * Start command in background and wait for the\n     * specified message\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident, String msg,\n                      int priority) throws Exception {\n\n        for (int i = 0; i < machines.length; i++) {\n\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n\n            boolean ret = findCmdAgent(machines[i]).\n                    start(cmd, ident, msg, priority);\n            if(ret)\n                logger.fine(\"Started command \" + cmd + \" on machine \" + machines[i]);\n            else\n                logger.severe(\"command \" + cmd + \" on machine \" + machines[i] + \" failed\");\n        }\n    }\n\n    /**\n     * Start a command in background on a single machine\n     */\n    public void start(String machine, String command, String ident,\n                      int priority ) throws Exception {\n        String m[] = new String[1];\n        m[0] = machine;\n        start(m, command, ident, priority);\n    }\n\n\n    /**\n     * Start a  command in background and returning the first line of output.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param ident identifier to associate with this command\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String machine, String command,\n                                           String ident, int priority)\n            throws Exception {\n\n        logger.info(\"starting command = \"\n                    + command + \" on machine = \" + machine);\n        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(\n                                                command, ident, priority);\n        return retVal;\n    }\n\n\n\n    /**\n     * Start a command in foreground and returning the stdout.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param priority in which to run command\n     * @return String the standard output from the command\n     */\n    public String startAndGetStdOut (String machine, String command, int priority)\n            throws Exception {\n\n        String retVal = findCmdAgent(machine).\n                                        startAndGetStdOut(command, priority);\n        return retVal;\n    }\n\n\n\n    public void startJavaCmd(String machines[], String cmd,\n                             String ident, String env[]) throws Exception {\n\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            logger.fine(\"Starting JAVA with \" + cmd + \" on \" + machines[i]);\n            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);\n        }\n    }\n\n    /**\n     * Start the agent on a single machine\n     */\n    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     */\n    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machine on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully\n     */\n    public boolean wait(String machine, String ident) throws Exception {\n        boolean exitcode = true;\n        logger.info(\"Waiting for \" + ident + \" to complete \");\n        if (findCmdAgent(machine).wait(ident) == false)\n            exitcode = false;\n        return(exitcode);\n    }\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machines on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully on all machines\n     */\n    public boolean wait(String machines[], String ident) throws Exception {\n        boolean exitcode = true;\n        for (int i = 0; i < machines.length; i++) {\n            if(wait(machines[i], ident) == false)\n                exitcode = false;\n        }\n        return(exitcode);\n    }\n\n    /**\n     * Kill command started earlier in background\n     * This method calls kill on all the CmdAgent objects for\n     * the listed machines\n     * @param machines on which to issue kill\n     * @param ident used to identify command in 'start' call\n     */\n    public void kill(String machines[], String ident) {\n        try {\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).kill(ident);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to kill \" + ident, e);\n        }\n    }\n\n\n    /**\n\n     * Kill command started earlier in background using the killem script.\n     * This method calls killem on all the CmdAgent objects for\n     * the listed machines.\n     * @param machines on which to issue kill\n     * @param ident identifier if any if this process was previously started\n     *              through the CmdService.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem(String machines[], String ident, String processString, int sigNum) {\n        try {\n            for (int i = 0; i < machines.length; i++) {\n                findCmdAgent(machines[i]).killem(ident, processString, sigNum);\n                logger.info(\"killed \" + processString +\n                        \" on machine \" + machines[i]);\n            }\n        } catch (Exception e) { }\n    }\n\n    /**\n     * Gets a property from a given file\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n\n    /**\n     * Kill all commands currently running and cleanup\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++)\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                if (retry == 20)\n                    logger.severe(\"Registry did not terminate \" +\n                                \"after 20 termination attempts, giving up! \" +\n                                \"Subsequent runs may have problems.\");\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n                                     String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = master.getHostName();\n                String dest = cmdp.get(didx).getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Pushing - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent destf = filep.get(didx);\n        FileTransfer transfer = new FileTransfer(srcfile, destfile);\n        try {\n            if (destf.push(transfer) != transfer.getSize())\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n                                     String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = cmdp.get(sidx).getHostName();\n                String dest = master.getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Getting - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() <= 0)\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copy(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n\n        if (srcfile.equals(destfile)){\n            try{\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine\n                + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                              \":\" + srcfile + \" to \" + destmachine + \":\" + destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return true;\n    }\n\n    public synchronized boolean move(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n        // First copy the file then delete\n        try {\n            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {\n                FileAgent srcf = null;\n                int sidx = machinesList.indexOf(srcmachine);\n                int didx = machinesList.indexOf(destmachine);\n                if (sidx == didx && srcfile.equals(destfile))\n                    return(true);\n                srcf = filep.get(sidx);\n                return srcf.removeFile(srcfile);\n            }\n        }\n        catch(Exception ie) {\n            logger.severe(\"CmdService: Could not move \" + srcmachine +\n                        \":\" + srcfile + \" to \" + destmachine + \":\" +\n                        destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return false;\n    }\n\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return filep.get(index);\n    }\n\n\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n                logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                        \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile, \n                                             OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyBytes(String srcmachine,\n                                          String destmachine,\n                                          String srcfile, String destfile,\n                                          boolean append) {\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf = new byte[1000000];\n\n        //logger.info(\"CmdService: Copying \" + srcfile + \" to \" + destfile);\n        //logger.info(\"CmdService: Copying from \" + srcmachine + \" to \" + destmachine);\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                destfilep.writeBytes(buf, 0 , buf.length);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile + \" to \" + destmachine + \":\" +\n                          destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     *\n     * The hostInterfaces Properties object stores mappings of machine name\n     * in the benchmark configuration to the corresponding interface of the\n     * master machine used to connect to that machine.\n     *\n     * @return Properties - the hostInterfaces oject.\n     */\n    public Properties getHostInterfaces() {\n        return hostInterfaces;\n    }\n\n    /**\n     * Set the Log level for Agents\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdService.java,v 1.34 2008/03/14 19:42:21 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    public static final int SEQUENTIAL = 1;\t/* Sequential flag in FG mode*/\n    public static final int PARALLEL = 2;\t/* parallel flag in FG mode*/\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines */\n    private ArrayList<String> machinesList = new ArrayList<String>();\t\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private String jvmOptions;\n    private HashMap<String, String> binMap = new HashMap<String, String>();\n    private Map<String, String> ifMap;\n\n    private String rsh, agent;\n\n\n    private CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        if(cmds == null)\n            cmds = new CmdService();\n        return cmds;\n    }\n\n    /**\n     *\n     * @return master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines\n     * This method can be called multiple times to initialize multiple\n     * classes of machines\n     * @param hosts String[][] of machines\n     * @return true if successful, false if setup failed\n     *\n     */\n    public boolean setup(String benchName, String[][] hosts,\n                         String home, String options) {\n\n        // It is common for java to be in C:\\Program Files. This has a space\n        // inside the string and can cause havoc. We need to double quote this\n        // parameter as needed.\n        if (home.indexOf(' ') == -1)\n            javaHome = home;\n        else\n            javaHome = '\"' + home + '\"';\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        // Again, we ensure FABAN_HOME to be quoted if there are spaces inside.\n        if (escapedHome.indexOf(' ') != -1)\n            escapedHome = '\"' + escapedHome + '\"';\n        jvmOptions = \"-Dfaban.home=\" + escapedHome +\n                \" -Djava.security.policy=\" + escapedHome + \"config\" + fs +\n                \"faban.policy -Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties -Dfaban.registry.port=\" +\n                Config.RMI_PORT + ' ' + \"-Dfaban.logging.port=\" +\n                Config.LOGGING_PORT;\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if(!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                 log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))){\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                                String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch(IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer(\" -cp \");\n            for(int i = 0; i < libs.length; i++) {\n                if(libs[i].isFile())\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n            }\n\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            String cmd = javaHome + File.separator + \"bin\" + File.separator +\n                    \"java \" + jvmOptions + \" -Xms32m -Xmx1024m \" + classpath +\n                    \" com.sun.faban.common.RegistryImpl\" ;\n\n            logger.info(\"Starting Registry.\");\n            logger.fine(\"Starting using command \" + cmd);\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        jvmOptions += ' ' + options;\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch(InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch(Exception e) {\n            logger.severe(\"Unable to connect to Registry \" + e);\n            logger.log(Level.FINE,  \"Exception\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        outer:\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 ||    // localhost\n                        machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\") + ' ';\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\",e);\n        }\n\n        if (rsh == null)\n            rsh = \"rsh\";\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master))\n                return false;\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if(\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for(int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if(machinesList.contains(machines[i]))\n                    continue;\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0)\n                    return false;\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress))\n                    return false;\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++)\n            if (!getCmdAgent((String) machinesList.get(i)))\n                return false;\n        setClocks();\n        return true;\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n                             Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host: hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            }\n            catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                                retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return(false);\n            }\n\n            cmdp.add(c);\n            \n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"FileService: Connecting to \" + s);\n            retry = 1;\n            FileAgent f = (FileAgent) registry.getService(s);\n            for (; f == null && retry <= 20; retry++) {\n                Thread.sleep(500);\n                logger.warning(\"Retry obtaining file service from \" + s +\n                                                \", count \" + retry + '.');\n                f = (FileAgent) registry.getService(s);\n            }\n            if (f == null) {\n                logger.severe(\"Could not obtain file service from \" + s);\n                return (false);\n            }\n            filep.add(f);\n\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" +\n                                                        c.getHostName());\n            return true;\n\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \"\n                    + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n    * We use a script 'cmd' which will setup the CLASSPATH before\n    * invoking CmdAgent\n    */\n    private boolean startCmdAgent(String benchName, String mach,\n                                  String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        String cmdarray;\n\n        String agentParams = mach + ' ' + interfaceAddress + ' ' +\n                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +\n                        \" faban.benchmarkName=\" + benchName;\n        try {\n            if (mach.equals(master)) {\n                cmdarray = agent + agentParams;\n                logger.fine(\"Executing \" + cmdarray);\n                Command cmdAgent = new Command(cmdarray);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams += \" faban.download=\" + downloadURL.toString();\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    OutputStream socketOut = socket.getOutputStream();\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    socketOut.write(agentParams.getBytes());\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200 : agentStarted = true;\n                                   logger.fine(\"Found Agent(daemon)@\" + mach +\n                                               \". Registering agent.\");\n                                   break;\n                        case 500 : logger.warning(\"Agent(daemon)@\" + mach +\n                                              \": \" + response +\n                                              \" Please report the issue \" +\n                                              \"and provide logs from \" + mach +\n                                              \":FABAN_HOME/logs/agent.log\");\n                                   break;\n                        case 409 : logger.severe(\"Agent(daemon)@\" + mach +\n                                                 \": \" + response);\n                                   // We do not fall back in the conflict case.\n                                   return false;\n                        default  : logger.warning(\"Agent(daemon)@\" + mach +\n                                                  \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;\n                    logger.fine(\"Executing \" + cmdarray);\n                    Command cmdAgent = new Command(cmdarray);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                                                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<Future<Boolean>> tasks = new ArrayList<Future<Boolean>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    tasks.add(Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat)));\n                }\n                for (Future<Boolean> future : tasks)\n                    try {\n                        future.get(300, TimeUnit.SECONDS);\n                    } catch (Throwable t) {\n                        Throwable cause = t.getCause();\n                        while (cause != null) {\n                            t = cause;\n                            cause = t.getCause();\n                        }\n                        logger.log(Level.SEVERE, t.getMessage(), t);\n                    }\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                     SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws RemoteException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \"cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \"Cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100)\n                            ++nextSec; // If not, we go to the next sec.\n\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                                    System.currentTimeMillis();\n                        if (sleepTime > 0)\n                            Thread.sleep(sleepTime);\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0)\n            return machineName; // Cannot resolve\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        }\n        catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                          re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return execute(master, c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).execute(c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return java(master, c);\n    }\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).java(c);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c);\n        return result;\n    }\n\n    public <V extends Serializable> V\n            execute(String machine, RemoteCallable<V> callable)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable);\n    }\n\n    public <V extends Serializable> List<V>\n            execute(String[] machines, RemoteCallable<V> callable)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable));\n        return rl;\n    }\n\n\n    /**\n     * Start commands sequentially in foreground on machines\n     * The command string should include all stdin, stdout, stderr\n     * redirections (if any). Note that files referred in the command\n     * should be on the machine on which the command is run.\n     * The 'copy' method can be used to transfer files to remote machines.\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param seq flag to indicate if commands should be sequential or parallel\n     * @param priority (default or higher priority) for command\n     * @return true if all commands completed successfully, else false\n     * @see #copy (String, String, String, String, boolean)\n     */\n    public boolean start(String machines[], String cmd, int seq,\n                         int priority) throws Exception {\n\n        boolean exitcode = true;\n\n\n        for (int i = 0; i<machines.length; i++)\n            logger.fine(\"Starting command = \" + cmd +\" on machine \" + machines[i]);\n\n        if (seq == SEQUENTIAL) {\n            /* Start cmd on each m/c in foreground */\n            for (int i = 0; i < machines.length; i++) {\n                if (findCmdAgent(machines[i]).start(cmd, priority) == false)\n                    exitcode = false;\n            }\n        }\n        else if (seq == PARALLEL) {\n            /* Start cmd on each m/c in parallel, then wait for all */\n            String ident = \"Generated\";\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).start(cmd, ident, priority);\n            for (int i = 0; i < machines.length; i++)\n                if (findCmdAgent(machines[i]).wait(ident) == false)\n                    exitcode = false;\n        }\n        return(exitcode);\n    }\n\n\n    /**\n     * Start a command on a single machine\n     */\n    public boolean start(String machine, String command, int seq,\n                         int priority) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(start(m, command, seq, priority));\n    }\n\n    /**\n     * Start commands in background\n     *\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident,\n                      int priority) throws Exception {\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n            findCmdAgent(machines[i]).start(cmd, ident, priority);\n        }\n    }\n\n    /**\n     * Start command in background and wait for the\n     * specified message\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident, String msg,\n                      int priority) throws Exception {\n\n        for (int i = 0; i < machines.length; i++) {\n\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n\n            boolean ret = findCmdAgent(machines[i]).\n                    start(cmd, ident, msg, priority);\n            if(ret)\n                logger.fine(\"Started command \" + cmd + \" on machine \" + machines[i]);\n            else\n                logger.severe(\"command \" + cmd + \" on machine \" + machines[i] + \" failed\");\n        }\n    }\n\n    /**\n     * Start a command in background on a single machine\n     */\n    public void start(String machine, String command, String ident,\n                      int priority ) throws Exception {\n        String m[] = new String[1];\n        m[0] = machine;\n        start(m, command, ident, priority);\n    }\n\n\n    /**\n     * Start a  command in background and returning the first line of output.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param ident identifier to associate with this command\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String machine, String command,\n                                           String ident, int priority)\n            throws Exception {\n\n        logger.info(\"starting command = \"\n                    + command + \" on machine = \" + machine);\n        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(\n                                                command, ident, priority);\n        return retVal;\n    }\n\n\n\n    /**\n     * Start a command in foreground and returning the stdout.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param priority in which to run command\n     * @return String the standard output from the command\n     */\n    public String startAndGetStdOut (String machine, String command, int priority)\n            throws Exception {\n\n        String retVal = findCmdAgent(machine).\n                                        startAndGetStdOut(command, priority);\n        return retVal;\n    }\n\n\n\n    public void startJavaCmd(String machines[], String cmd,\n                             String ident, String env[]) throws Exception {\n\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            logger.fine(\"Starting JAVA with \" + cmd + \" on \" + machines[i]);\n            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);\n        }\n    }\n\n    /**\n     * Start the agent on a single machine\n     */\n    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     */\n    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machine on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully\n     */\n    public boolean wait(String machine, String ident) throws Exception {\n        boolean exitcode = true;\n        logger.info(\"Waiting for \" + ident + \" to complete \");\n        if (findCmdAgent(machine).wait(ident) == false)\n            exitcode = false;\n        return(exitcode);\n    }\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machines on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully on all machines\n     */\n    public boolean wait(String machines[], String ident) throws Exception {\n        boolean exitcode = true;\n        for (int i = 0; i < machines.length; i++) {\n            if(wait(machines[i], ident) == false)\n                exitcode = false;\n        }\n        return(exitcode);\n    }\n\n    /**\n     * Kill command started earlier in background\n     * This method calls kill on all the CmdAgent objects for\n     * the listed machines\n     * @param machines on which to issue kill\n     * @param ident used to identify command in 'start' call\n     */\n    public void kill(String machines[], String ident) {\n        try {\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).kill(ident);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to kill \" + ident, e);\n        }\n    }\n\n\n    /**\n\n     * Kill command started earlier in background using the killem script.\n     * This method calls killem on all the CmdAgent objects for\n     * the listed machines.\n     * @param machines on which to issue kill\n     * @param ident identifier if any if this process was previously started\n     *              through the CmdService.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem(String machines[], String ident, String processString, int sigNum) {\n        try {\n            for (int i = 0; i < machines.length; i++) {\n                findCmdAgent(machines[i]).killem(ident, processString, sigNum);\n                logger.info(\"killed \" + processString +\n                        \" on machine \" + machines[i]);\n            }\n        } catch (Exception e) { }\n    }\n\n    /**\n     * Gets a property from a given file\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n\n    /**\n     * Kill all commands currently running and cleanup\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++)\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                if (retry == 20)\n                    logger.severe(\"Registry did not terminate \" +\n                                \"after 20 termination attempts, giving up! \" +\n                                \"Subsequent runs may have problems.\");\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n                                     String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = master.getHostName();\n                String dest = cmdp.get(didx).getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Pushing - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent destf = filep.get(didx);\n        FileTransfer transfer = new FileTransfer(srcfile, destfile);\n        try {\n            if (destf.push(transfer) != transfer.getSize())\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n                                     String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = cmdp.get(sidx).getHostName();\n                String dest = master.getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Getting - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() <= 0)\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copy(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n\n        if (srcfile.equals(destfile)){\n            try{\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine\n                + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                              \":\" + srcfile + \" to \" + destmachine + \":\" + destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return true;\n    }\n\n    public synchronized boolean move(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n        // First copy the file then delete\n        try {\n            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {\n                FileAgent srcf = null;\n                int sidx = machinesList.indexOf(srcmachine);\n                int didx = machinesList.indexOf(destmachine);\n                if (sidx == didx && srcfile.equals(destfile))\n                    return(true);\n                srcf = filep.get(sidx);\n                return srcf.removeFile(srcfile);\n            }\n        }\n        catch(Exception ie) {\n            logger.severe(\"CmdService: Could not move \" + srcmachine +\n                        \":\" + srcfile + \" to \" + destmachine + \":\" +\n                        destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return false;\n    }\n\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return filep.get(index);\n    }\n\n\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n                logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                        \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile, \n                                             OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyBytes(String srcmachine,\n                                          String destmachine,\n                                          String srcfile, String destfile,\n                                          boolean append) {\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf = new byte[1000000];\n\n        //logger.info(\"CmdService: Copying \" + srcfile + \" to \" + destfile);\n        //logger.info(\"CmdService: Copying from \" + srcmachine + \" to \" + destmachine);\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                destfilep.writeBytes(buf, 0 , buf.length);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile + \" to \" + destmachine + \":\" +\n                          destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     *\n     * The hostInterfaces Properties object stores mappings of machine name\n     * in the benchmark configuration to the corresponding interface of the\n     * master machine used to connect to that machine.\n     *\n     * @return Properties - the hostInterfaces oject.\n     */\n    public Properties getHostInterfaces() {\n        return hostInterfaces;\n    }\n\n    /**\n     * Set the Log level for Agents\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","lineNo":527}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdService.java,v 1.32 2008/02/28 02:24:51 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.harness.agent.*;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.InterfaceProbe;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.FabanHostUnknownException;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.text.SimpleDateFormat;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    public static final int SEQUENTIAL = 1;\t/* Sequential flag in FG mode*/\n    public static final int PARALLEL = 2;\t/* parallel flag in FG mode*/\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp;\n    private ArrayList<FileAgent> filep;\n    private ArrayList<String> machinesList;\t// list of all machines\n    private Properties hostInterfaces;\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private String jvmOptions;\n    private HashMap<String, String> binMap = new HashMap<String, String>();\n    private Map<String, String> ifMap;\n\n    private String rsh, agent;\n\n\n    private CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        init();\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        if(cmds == null)\n            cmds = new CmdService();\n        return cmds;\n    }\n\n    /**\n     *\n     * @return master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList = new ArrayList<String>();\n        cmdp = new ArrayList<CmdAgent>();\n        filep = new ArrayList<FileAgent>();\n        hostInterfaces = new Properties();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines\n     * This method can be called multiple times to initialize multiple\n     * classes of machines\n     * @param hosts String[][] of machines\n     * @return true if successful, false if setup failed\n     *\n     */\n    public boolean setup(String benchName, String[][] hosts,\n                         String home, String options) {\n\n        javaHome = home;\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n        jvmOptions = \"-Dfaban.home=\" + escapedHome +\n                \" -Djava.security.policy=\" + escapedHome + \"config\" + fs +\n                \"faban.policy -Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties -Dfaban.registry.port=\" +\n                Config.RMI_PORT + ' ' + \"-Dfaban.logging.port=\" +\n                Config.LOGGING_PORT;\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if(!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                 log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))){\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                                String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch(IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer(\" -cp \");\n            for(int i = 0; i < libs.length; i++) {\n                if(libs[i].isFile())\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n            }\n\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            String cmd = javaHome + File.separator + \"bin\" + File.separator +\n                    \"java \" + jvmOptions + \" -Xms32m -Xmx1024m \" + classpath +\n                    \" com.sun.faban.common.RegistryImpl\" ;\n\n            logger.info(\"Starting Registry.\");\n            logger.fine(\"Starting using command \" + cmd);\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        jvmOptions += ' ' + options;\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch(InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch(Exception e) {\n            logger.severe(\"Unable to connect to Registry \" + e);\n            logger.log(Level.FINE,  \"Exception\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        outer:\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 ||    // localhost\n                        machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\") + ' ';\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\",e);\n        }\n\n        if (rsh == null)\n            rsh = \"rsh\";\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master))\n                return false;\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if(\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for(int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if(machinesList.contains(machines[i]))\n                    continue;\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0)\n                    return false;\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress))\n                    return false;\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++)\n            if (!getCmdAgent((String) machinesList.get(i)))\n                return false;\n        setClocks();\n        return true;\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n                             Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host: hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            }\n            catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                                retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return(false);\n            }\n\n            cmdp.add(c);\n            logger.fine(\"CmdService: Configuring \" + s);\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" + c.getHostName());\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            filep.add((FileAgent) registry.getService(s));\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \"\n                    + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n    * We use a script 'cmd' which will setup the CLASSPATH before\n    * invoking CmdAgent\n    */\n    private boolean startCmdAgent(String benchName, String mach,\n                                  String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        String cmdarray;\n\n        String agentParams = mach + ' ' + interfaceAddress + ' ' +\n                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +\n                        \" faban.benchmarkName=\" + benchName;\n        try {\n            if (mach.equals(master)) {\n                cmdarray = agent + agentParams;\n                logger.fine(\"Executing \" + cmdarray);\n                Command cmdAgent = new Command(cmdarray);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams += \" faban.download=\" + downloadURL.toString();\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    OutputStream socketOut = socket.getOutputStream();\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    socketOut.write(agentParams.getBytes());\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200 : agentStarted = true;\n                                   logger.fine(\"Found Agent(daemon)@\" + mach +\n                                               \". Registering agent.\");\n                                   break;\n                        case 500 : logger.warning(\"Agent(daemon)@\" + mach +\n                                              \": \" + response +\n                                              \" Please report the issue \" +\n                                              \"and provide logs from \" + mach +\n                                              \":FABAN_HOME/logs/agent.log\");\n                                   break;\n                        case 409 : logger.severe(\"Agent(daemon)@\" + mach +\n                                                 \": \" + response);\n                                   // We do not fall back in the conflict case.\n                                   return false;\n                        default  : logger.warning(\"Agent(daemon)@\" + mach +\n                                                  \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;\n                    logger.fine(\"Executing \" + cmdarray);\n                    Command cmdAgent = new Command(cmdarray);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                                                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<Future<Boolean>> tasks = new ArrayList<Future<Boolean>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    tasks.add(Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat)));\n                }\n                for (Future<Boolean> future : tasks)\n                    try {\n                        future.get(300, TimeUnit.SECONDS);\n                    } catch (Throwable t) {\n                        Throwable cause = t.getCause();\n                        while (cause != null) {\n                            t = cause;\n                            cause = t.getCause();\n                        }\n                        logger.log(Level.SEVERE, t.getMessage(), t);\n                    }\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                     SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws RemoteException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \"cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \"Cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100)\n                            ++nextSec; // If not, we go to the next sec.\n\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        Thread.sleep(callTime - wakeBefore -\n                                                    System.currentTimeMillis());\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0)\n            return machineName; // Cannot resolve\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        }\n        catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                          re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return execute(master, c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).execute(c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return java(master, c);\n    }\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).java(c);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c);\n        return result;\n    }\n\n    public <V extends Serializable> V\n            execute(String machine, RemoteCallable<V> callable)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable);\n    }\n\n    public <V extends Serializable> List<V>\n            execute(String[] machines, RemoteCallable<V> callable)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable));\n        return rl;\n    }\n\n\n    /**\n     * Start commands sequentially in foreground on machines\n     * The command string should include all stdin, stdout, stderr\n     * redirections (if any). Note that files referred in the command\n     * should be on the machine on which the command is run.\n     * The 'copy' method can be used to transfer files to remote machines.\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param seq flag to indicate if commands should be sequential or parallel\n     * @param priority (default or higher priority) for command\n     * @return true if all commands completed successfully, else false\n     * @see #copy (String, String, String, String, boolean)\n     */\n    public boolean start(String machines[], String cmd, int seq,\n                         int priority) throws Exception {\n\n        boolean exitcode = true;\n\n\n        for (int i = 0; i<machines.length; i++)\n            logger.fine(\"Starting command = \" + cmd +\" on machine \" + machines[i]);\n\n        if (seq == SEQUENTIAL) {\n            /* Start cmd on each m/c in foreground */\n            for (int i = 0; i < machines.length; i++) {\n                if (findCmdAgent(machines[i]).start(cmd, priority) == false)\n                    exitcode = false;\n            }\n        }\n        else if (seq == PARALLEL) {\n            /* Start cmd on each m/c in parallel, then wait for all */\n            String ident = \"Generated\";\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).start(cmd, ident, priority);\n            for (int i = 0; i < machines.length; i++)\n                if (findCmdAgent(machines[i]).wait(ident) == false)\n                    exitcode = false;\n        }\n        return(exitcode);\n    }\n\n\n    /**\n     * Start a command on a single machine\n     */\n    public boolean start(String machine, String command, int seq,\n                         int priority) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(start(m, command, seq, priority));\n    }\n\n    /**\n     * Start commands in background\n     *\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident,\n                      int priority) throws Exception {\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n            findCmdAgent(machines[i]).start(cmd, ident, priority);\n        }\n    }\n\n    /**\n     * Start command in background and wait for the\n     * specified message\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident, String msg,\n                      int priority) throws Exception {\n\n        for (int i = 0; i < machines.length; i++) {\n\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n\n            boolean ret = findCmdAgent(machines[i]).\n                    start(cmd, ident, msg, priority);\n            if(ret)\n                logger.fine(\"Started command \" + cmd + \" on machine \" + machines[i]);\n            else\n                logger.severe(\"command \" + cmd + \" on machine \" + machines[i] + \" failed\");\n        }\n    }\n\n    /**\n     * Start a command in background on a single machine\n     */\n    public void start(String machine, String command, String ident,\n                      int priority ) throws Exception {\n        String m[] = new String[1];\n        m[0] = machine;\n        start(m, command, ident, priority);\n    }\n\n\n    /**\n     * Start a  command in background and returning the first line of output.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param ident identifier to associate with this command\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String machine, String command,\n                                           String ident, int priority)\n            throws Exception {\n\n        logger.info(\"starting command = \"\n                    + command + \" on machine = \" + machine);\n        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(\n                                                command, ident, priority);\n        return retVal;\n    }\n\n\n\n    /**\n     * Start a command in foreground and returning the stdout.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param priority in which to run command\n     * @return String the standard output from the command\n     */\n    public String startAndGetStdOut (String machine, String command, int priority)\n            throws Exception {\n\n        String retVal = findCmdAgent(machine).\n                                        startAndGetStdOut(command, priority);\n        return retVal;\n    }\n\n\n\n    public void startJavaCmd(String machines[], String cmd,\n                             String ident, String env[]) throws Exception {\n\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            logger.fine(\"Starting JAVA with \" + cmd + \" on \" + machines[i]);\n            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);\n        }\n    }\n\n    /**\n     * Start the agent on a single machine\n     */\n    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     */\n    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machine on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully\n     */\n    public boolean wait(String machine, String ident) throws Exception {\n        boolean exitcode = true;\n        logger.info(\"Waiting for \" + ident + \" to complete \");\n        if (findCmdAgent(machine).wait(ident) == false)\n            exitcode = false;\n        return(exitcode);\n    }\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machines on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully on all machines\n     */\n    public boolean wait(String machines[], String ident) throws Exception {\n        boolean exitcode = true;\n        for (int i = 0; i < machines.length; i++) {\n            if(wait(machines[i], ident) == false)\n                exitcode = false;\n        }\n        return(exitcode);\n    }\n\n    /**\n     * Kill command started earlier in background\n     * This method calls kill on all the CmdAgent objects for\n     * the listed machines\n     * @param machines on which to issue kill\n     * @param ident used to identify command in 'start' call\n     */\n    public void kill(String machines[], String ident) {\n        try {\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).kill(ident);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to kill \" + ident, e);\n        }\n    }\n\n\n    /**\n\n     * Kill command started earlier in background using the killem script.\n     * This method calls killem on all the CmdAgent objects for\n     * the listed machines.\n     * @param machines on which to issue kill\n     * @param ident identifier if any if this process was previously started\n     *              through the CmdService.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem(String machines[], String ident, String processString, int sigNum) {\n        try {\n            for (int i = 0; i < machines.length; i++) {\n                findCmdAgent(machines[i]).killem(ident, processString, sigNum);\n                logger.info(\"killed \" + processString +\n                        \" on machine \" + machines[i]);\n            }\n        } catch (Exception e) { }\n    }\n\n    /**\n     * Gets a property from a given file\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n\n    /**\n     * Kill all commands currently running and cleanup\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++)\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                if (retry == 20)\n                    logger.severe(\"Registry did not terminate \" +\n                                \"after 20 termination attempts, giving up! \" +\n                                \"Subsequent runs may have problems.\");\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n                                     String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = master.getHostName();\n                String dest = cmdp.get(didx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Pushing - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent destf = filep.get(didx);\n        try {\n            FileService destfilep = destf.open(destfile, FileAgent.WRITE);\n            byte[] content = FileHelper.getContent(srcfile);\n            destfilep.write(content);\n            destfilep.close();\n        } catch (FileServiceException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, e);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copy(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n\n        if (srcfile.equals(destfile)){\n            try{\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine\n                + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                              \":\" + srcfile + \" to \" + destmachine + \":\" + destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return true;\n    }\n\n    public synchronized boolean move(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n        // First copy the file then delete\n        try {\n            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {\n                FileAgent srcf = null;\n                int sidx = machinesList.indexOf(srcmachine);\n                int didx = machinesList.indexOf(destmachine);\n                if (sidx == didx && srcfile.equals(destfile))\n                    return(true);\n                srcf = filep.get(sidx);\n                return srcf.removeFile(srcfile);\n            }\n        }\n        catch(Exception ie) {\n            logger.severe(\"CmdService: Could not move \" + srcmachine +\n                        \":\" + srcfile + \" to \" + destmachine + \":\" +\n                        destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return false;\n    }\n\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return filep.get(index);\n    }\n\n\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n                logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                        \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile, \n                                             OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyBytes(String srcmachine,\n                                          String destmachine,\n                                          String srcfile, String destfile,\n                                          boolean append) {\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf = new byte[1000000];\n\n        //logger.info(\"CmdService: Copying \" + srcfile + \" to \" + destfile);\n        //logger.info(\"CmdService: Copying from \" + srcmachine + \" to \" + destmachine);\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                destfilep.writeBytes(buf, 0 , buf.length);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile + \" to \" + destmachine + \":\" +\n                          destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     *\n     * The hostInterfaces Properties object stores mappings of machine name\n     * in the benchmark configuration to the corresponding interface of the\n     * master machine used to connect to that machine.\n     *\n     * @return Properties - the hostInterfaces oject.\n     */\n    public Properties getHostInterfaces() {\n        return hostInterfaces;\n    }\n\n    /**\n     * Set the Log level for Agents\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdService.java,v 1.33 2008/03/14 06:47:40 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    public static final int SEQUENTIAL = 1;\t/* Sequential flag in FG mode*/\n    public static final int PARALLEL = 2;\t/* parallel flag in FG mode*/\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines */\n    private ArrayList<String> machinesList = new ArrayList<String>();\t\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private String jvmOptions;\n    private HashMap<String, String> binMap = new HashMap<String, String>();\n    private Map<String, String> ifMap;\n\n    private String rsh, agent;\n\n\n    private CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        if(cmds == null)\n            cmds = new CmdService();\n        return cmds;\n    }\n\n    /**\n     *\n     * @return master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines\n     * This method can be called multiple times to initialize multiple\n     * classes of machines\n     * @param hosts String[][] of machines\n     * @return true if successful, false if setup failed\n     *\n     */\n    public boolean setup(String benchName, String[][] hosts,\n                         String home, String options) {\n\n        // It is common for java to be in C:\\Program Files. This has a space\n        // inside the string and can cause havoc. We need to double quote this\n        // parameter as needed.\n        if (home.indexOf(' ') == -1)\n            javaHome = home;\n        else\n            javaHome = '\"' + home + '\"';\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        // Again, we ensure FABAN_HOME to be quoted if there are spaces inside.\n        if (escapedHome.indexOf(' ') != -1)\n            escapedHome = '\"' + escapedHome + '\"';\n        jvmOptions = \"-Dfaban.home=\" + escapedHome +\n                \" -Djava.security.policy=\" + escapedHome + \"config\" + fs +\n                \"faban.policy -Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties -Dfaban.registry.port=\" +\n                Config.RMI_PORT + ' ' + \"-Dfaban.logging.port=\" +\n                Config.LOGGING_PORT;\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if(!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                 log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))){\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                                String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch(IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer(\" -cp \");\n            for(int i = 0; i < libs.length; i++) {\n                if(libs[i].isFile())\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n            }\n\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            String cmd = javaHome + File.separator + \"bin\" + File.separator +\n                    \"java \" + jvmOptions + \" -Xms32m -Xmx1024m \" + classpath +\n                    \" com.sun.faban.common.RegistryImpl\" ;\n\n            logger.info(\"Starting Registry.\");\n            logger.fine(\"Starting using command \" + cmd);\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        jvmOptions += ' ' + options;\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch(InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch(Exception e) {\n            logger.severe(\"Unable to connect to Registry \" + e);\n            logger.log(Level.FINE,  \"Exception\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        outer:\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 ||    // localhost\n                        machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\") + ' ';\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\",e);\n        }\n\n        if (rsh == null)\n            rsh = \"rsh\";\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master))\n                return false;\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if(\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for(int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if(machinesList.contains(machines[i]))\n                    continue;\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0)\n                    return false;\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress))\n                    return false;\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++)\n            if (!getCmdAgent((String) machinesList.get(i)))\n                return false;\n        setClocks();\n        return true;\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n                             Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host: hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            }\n            catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                                retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return(false);\n            }\n\n            cmdp.add(c);\n            logger.fine(\"CmdService: Configuring \" + s);\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" + c.getHostName());\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            filep.add((FileAgent) registry.getService(s));\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \"\n                    + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n    * We use a script 'cmd' which will setup the CLASSPATH before\n    * invoking CmdAgent\n    */\n    private boolean startCmdAgent(String benchName, String mach,\n                                  String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        String cmdarray;\n\n        String agentParams = mach + ' ' + interfaceAddress + ' ' +\n                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +\n                        \" faban.benchmarkName=\" + benchName;\n        try {\n            if (mach.equals(master)) {\n                cmdarray = agent + agentParams;\n                logger.fine(\"Executing \" + cmdarray);\n                Command cmdAgent = new Command(cmdarray);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams += \" faban.download=\" + downloadURL.toString();\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    OutputStream socketOut = socket.getOutputStream();\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    socketOut.write(agentParams.getBytes());\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200 : agentStarted = true;\n                                   logger.fine(\"Found Agent(daemon)@\" + mach +\n                                               \". Registering agent.\");\n                                   break;\n                        case 500 : logger.warning(\"Agent(daemon)@\" + mach +\n                                              \": \" + response +\n                                              \" Please report the issue \" +\n                                              \"and provide logs from \" + mach +\n                                              \":FABAN_HOME/logs/agent.log\");\n                                   break;\n                        case 409 : logger.severe(\"Agent(daemon)@\" + mach +\n                                                 \": \" + response);\n                                   // We do not fall back in the conflict case.\n                                   return false;\n                        default  : logger.warning(\"Agent(daemon)@\" + mach +\n                                                  \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;\n                    logger.fine(\"Executing \" + cmdarray);\n                    Command cmdAgent = new Command(cmdarray);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                                                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<Future<Boolean>> tasks = new ArrayList<Future<Boolean>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    tasks.add(Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat)));\n                }\n                for (Future<Boolean> future : tasks)\n                    try {\n                        future.get(300, TimeUnit.SECONDS);\n                    } catch (Throwable t) {\n                        Throwable cause = t.getCause();\n                        while (cause != null) {\n                            t = cause;\n                            cause = t.getCause();\n                        }\n                        logger.log(Level.SEVERE, t.getMessage(), t);\n                    }\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                     SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws RemoteException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \"cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \"Cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100)\n                            ++nextSec; // If not, we go to the next sec.\n\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                                    System.currentTimeMillis();\n                        if (sleepTime > 0)\n                            Thread.sleep(sleepTime);\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0)\n            return machineName; // Cannot resolve\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        }\n        catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                          re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return execute(master, c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).execute(c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return java(master, c);\n    }\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).java(c);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c);\n        return result;\n    }\n\n    public <V extends Serializable> V\n            execute(String machine, RemoteCallable<V> callable)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable);\n    }\n\n    public <V extends Serializable> List<V>\n            execute(String[] machines, RemoteCallable<V> callable)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable));\n        return rl;\n    }\n\n\n    /**\n     * Start commands sequentially in foreground on machines\n     * The command string should include all stdin, stdout, stderr\n     * redirections (if any). Note that files referred in the command\n     * should be on the machine on which the command is run.\n     * The 'copy' method can be used to transfer files to remote machines.\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param seq flag to indicate if commands should be sequential or parallel\n     * @param priority (default or higher priority) for command\n     * @return true if all commands completed successfully, else false\n     * @see #copy (String, String, String, String, boolean)\n     */\n    public boolean start(String machines[], String cmd, int seq,\n                         int priority) throws Exception {\n\n        boolean exitcode = true;\n\n\n        for (int i = 0; i<machines.length; i++)\n            logger.fine(\"Starting command = \" + cmd +\" on machine \" + machines[i]);\n\n        if (seq == SEQUENTIAL) {\n            /* Start cmd on each m/c in foreground */\n            for (int i = 0; i < machines.length; i++) {\n                if (findCmdAgent(machines[i]).start(cmd, priority) == false)\n                    exitcode = false;\n            }\n        }\n        else if (seq == PARALLEL) {\n            /* Start cmd on each m/c in parallel, then wait for all */\n            String ident = \"Generated\";\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).start(cmd, ident, priority);\n            for (int i = 0; i < machines.length; i++)\n                if (findCmdAgent(machines[i]).wait(ident) == false)\n                    exitcode = false;\n        }\n        return(exitcode);\n    }\n\n\n    /**\n     * Start a command on a single machine\n     */\n    public boolean start(String machine, String command, int seq,\n                         int priority) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(start(m, command, seq, priority));\n    }\n\n    /**\n     * Start commands in background\n     *\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident,\n                      int priority) throws Exception {\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n            findCmdAgent(machines[i]).start(cmd, ident, priority);\n        }\n    }\n\n    /**\n     * Start command in background and wait for the\n     * specified message\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident, String msg,\n                      int priority) throws Exception {\n\n        for (int i = 0; i < machines.length; i++) {\n\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n\n            boolean ret = findCmdAgent(machines[i]).\n                    start(cmd, ident, msg, priority);\n            if(ret)\n                logger.fine(\"Started command \" + cmd + \" on machine \" + machines[i]);\n            else\n                logger.severe(\"command \" + cmd + \" on machine \" + machines[i] + \" failed\");\n        }\n    }\n\n    /**\n     * Start a command in background on a single machine\n     */\n    public void start(String machine, String command, String ident,\n                      int priority ) throws Exception {\n        String m[] = new String[1];\n        m[0] = machine;\n        start(m, command, ident, priority);\n    }\n\n\n    /**\n     * Start a  command in background and returning the first line of output.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param ident identifier to associate with this command\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String machine, String command,\n                                           String ident, int priority)\n            throws Exception {\n\n        logger.info(\"starting command = \"\n                    + command + \" on machine = \" + machine);\n        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(\n                                                command, ident, priority);\n        return retVal;\n    }\n\n\n\n    /**\n     * Start a command in foreground and returning the stdout.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param priority in which to run command\n     * @return String the standard output from the command\n     */\n    public String startAndGetStdOut (String machine, String command, int priority)\n            throws Exception {\n\n        String retVal = findCmdAgent(machine).\n                                        startAndGetStdOut(command, priority);\n        return retVal;\n    }\n\n\n\n    public void startJavaCmd(String machines[], String cmd,\n                             String ident, String env[]) throws Exception {\n\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            logger.fine(\"Starting JAVA with \" + cmd + \" on \" + machines[i]);\n            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);\n        }\n    }\n\n    /**\n     * Start the agent on a single machine\n     */\n    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     */\n    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machine on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully\n     */\n    public boolean wait(String machine, String ident) throws Exception {\n        boolean exitcode = true;\n        logger.info(\"Waiting for \" + ident + \" to complete \");\n        if (findCmdAgent(machine).wait(ident) == false)\n            exitcode = false;\n        return(exitcode);\n    }\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machines on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully on all machines\n     */\n    public boolean wait(String machines[], String ident) throws Exception {\n        boolean exitcode = true;\n        for (int i = 0; i < machines.length; i++) {\n            if(wait(machines[i], ident) == false)\n                exitcode = false;\n        }\n        return(exitcode);\n    }\n\n    /**\n     * Kill command started earlier in background\n     * This method calls kill on all the CmdAgent objects for\n     * the listed machines\n     * @param machines on which to issue kill\n     * @param ident used to identify command in 'start' call\n     */\n    public void kill(String machines[], String ident) {\n        try {\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).kill(ident);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to kill \" + ident, e);\n        }\n    }\n\n\n    /**\n\n     * Kill command started earlier in background using the killem script.\n     * This method calls killem on all the CmdAgent objects for\n     * the listed machines.\n     * @param machines on which to issue kill\n     * @param ident identifier if any if this process was previously started\n     *              through the CmdService.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem(String machines[], String ident, String processString, int sigNum) {\n        try {\n            for (int i = 0; i < machines.length; i++) {\n                findCmdAgent(machines[i]).killem(ident, processString, sigNum);\n                logger.info(\"killed \" + processString +\n                        \" on machine \" + machines[i]);\n            }\n        } catch (Exception e) { }\n    }\n\n    /**\n     * Gets a property from a given file\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n\n    /**\n     * Kill all commands currently running and cleanup\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++)\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                if (retry == 20)\n                    logger.severe(\"Registry did not terminate \" +\n                                \"after 20 termination attempts, giving up! \" +\n                                \"Subsequent runs may have problems.\");\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n                                     String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = master.getHostName();\n                String dest = cmdp.get(didx).getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Pushing - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent destf = filep.get(didx);\n        FileTransfer transfer = new FileTransfer(srcfile, destfile);\n        try {\n            if (destf.push(transfer) != transfer.getSize())\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n                                     String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = cmdp.get(sidx).getHostName();\n                String dest = master.getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Getting - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() <= 0)\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copy(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n\n        if (srcfile.equals(destfile)){\n            try{\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine\n                + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                              \":\" + srcfile + \" to \" + destmachine + \":\" + destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return true;\n    }\n\n    public synchronized boolean move(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n        // First copy the file then delete\n        try {\n            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {\n                FileAgent srcf = null;\n                int sidx = machinesList.indexOf(srcmachine);\n                int didx = machinesList.indexOf(destmachine);\n                if (sidx == didx && srcfile.equals(destfile))\n                    return(true);\n                srcf = filep.get(sidx);\n                return srcf.removeFile(srcfile);\n            }\n        }\n        catch(Exception ie) {\n            logger.severe(\"CmdService: Could not move \" + srcmachine +\n                        \":\" + srcfile + \" to \" + destmachine + \":\" +\n                        destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return false;\n    }\n\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return filep.get(index);\n    }\n\n\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n                logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                        \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile, \n                                             OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyBytes(String srcmachine,\n                                          String destmachine,\n                                          String srcfile, String destfile,\n                                          boolean append) {\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf = new byte[1000000];\n\n        //logger.info(\"CmdService: Copying \" + srcfile + \" to \" + destfile);\n        //logger.info(\"CmdService: Copying from \" + srcmachine + \" to \" + destmachine);\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                destfilep.writeBytes(buf, 0 , buf.length);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile + \" to \" + destmachine + \":\" +\n                          destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     *\n     * The hostInterfaces Properties object stores mappings of machine name\n     * in the benchmark configuration to the corresponding interface of the\n     * master machine used to connect to that machine.\n     *\n     * @return Properties - the hostInterfaces oject.\n     */\n    public Properties getHostInterfaces() {\n        return hostInterfaces;\n    }\n\n    /**\n     * Set the Log level for Agents\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","lineNo":750}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdService.java,v 1.32 2008/02/28 02:24:51 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.common.RegistryLocator;\nimport com.sun.faban.harness.agent.*;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.FileHelper;\nimport com.sun.faban.harness.util.CmdMap;\nimport com.sun.faban.harness.util.InterfaceProbe;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.FabanHostUnknownException;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.text.SimpleDateFormat;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    public static final int SEQUENTIAL = 1;\t/* Sequential flag in FG mode*/\n    public static final int PARALLEL = 2;\t/* parallel flag in FG mode*/\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp;\n    private ArrayList<FileAgent> filep;\n    private ArrayList<String> machinesList;\t// list of all machines\n    private Properties hostInterfaces;\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private String jvmOptions;\n    private HashMap<String, String> binMap = new HashMap<String, String>();\n    private Map<String, String> ifMap;\n\n    private String rsh, agent;\n\n\n    private CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n\n        init();\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        if(cmds == null)\n            cmds = new CmdService();\n        return cmds;\n    }\n\n    /**\n     *\n     * @return master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList = new ArrayList<String>();\n        cmdp = new ArrayList<CmdAgent>();\n        filep = new ArrayList<FileAgent>();\n        hostInterfaces = new Properties();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines\n     * This method can be called multiple times to initialize multiple\n     * classes of machines\n     * @param hosts String[][] of machines\n     * @return true if successful, false if setup failed\n     *\n     */\n    public boolean setup(String benchName, String[][] hosts,\n                         String home, String options) {\n\n        javaHome = home;\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n        jvmOptions = \"-Dfaban.home=\" + escapedHome +\n                \" -Djava.security.policy=\" + escapedHome + \"config\" + fs +\n                \"faban.policy -Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties -Dfaban.registry.port=\" +\n                Config.RMI_PORT + ' ' + \"-Dfaban.logging.port=\" +\n                Config.LOGGING_PORT;\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if(!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                 log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))){\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                                String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch(IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer(\" -cp \");\n            for(int i = 0; i < libs.length; i++) {\n                if(libs[i].isFile())\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n            }\n\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            String cmd = javaHome + File.separator + \"bin\" + File.separator +\n                    \"java \" + jvmOptions + \" -Xms32m -Xmx1024m \" + classpath +\n                    \" com.sun.faban.common.RegistryImpl\" ;\n\n            logger.info(\"Starting Registry.\");\n            logger.fine(\"Starting using command \" + cmd);\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        jvmOptions += ' ' + options;\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch(InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch(Exception e) {\n            logger.severe(\"Unable to connect to Registry \" + e);\n            logger.log(Level.FINE,  \"Exception\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        outer:\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 ||    // localhost\n                        machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\") + ' ';\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\",e);\n        }\n\n        if (rsh == null)\n            rsh = \"rsh\";\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master))\n                return false;\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if(\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for(int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if(machinesList.contains(machines[i]))\n                    continue;\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0)\n                    return false;\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress))\n                    return false;\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++)\n            if (!getCmdAgent((String) machinesList.get(i)))\n                return false;\n        setClocks();\n        return true;\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n                             Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host: hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            }\n            catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                                retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return(false);\n            }\n\n            cmdp.add(c);\n            logger.fine(\"CmdService: Configuring \" + s);\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" + c.getHostName());\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            filep.add((FileAgent) registry.getService(s));\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \"\n                    + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n    * We use a script 'cmd' which will setup the CLASSPATH before\n    * invoking CmdAgent\n    */\n    private boolean startCmdAgent(String benchName, String mach,\n                                  String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        String cmdarray;\n\n        String agentParams = mach + ' ' + interfaceAddress + ' ' +\n                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +\n                        \" faban.benchmarkName=\" + benchName;\n        try {\n            if (mach.equals(master)) {\n                cmdarray = agent + agentParams;\n                logger.fine(\"Executing \" + cmdarray);\n                Command cmdAgent = new Command(cmdarray);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams += \" faban.download=\" + downloadURL.toString();\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    OutputStream socketOut = socket.getOutputStream();\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    socketOut.write(agentParams.getBytes());\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200 : agentStarted = true;\n                                   logger.fine(\"Found Agent(daemon)@\" + mach +\n                                               \". Registering agent.\");\n                                   break;\n                        case 500 : logger.warning(\"Agent(daemon)@\" + mach +\n                                              \": \" + response +\n                                              \" Please report the issue \" +\n                                              \"and provide logs from \" + mach +\n                                              \":FABAN_HOME/logs/agent.log\");\n                                   break;\n                        case 409 : logger.severe(\"Agent(daemon)@\" + mach +\n                                                 \": \" + response);\n                                   // We do not fall back in the conflict case.\n                                   return false;\n                        default  : logger.warning(\"Agent(daemon)@\" + mach +\n                                                  \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;\n                    logger.fine(\"Executing \" + cmdarray);\n                    Command cmdAgent = new Command(cmdarray);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                                                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<Future<Boolean>> tasks = new ArrayList<Future<Boolean>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    tasks.add(Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat)));\n                }\n                for (Future<Boolean> future : tasks)\n                    try {\n                        future.get(300, TimeUnit.SECONDS);\n                    } catch (Throwable t) {\n                        Throwable cause = t.getCause();\n                        while (cause != null) {\n                            t = cause;\n                            cause = t.getCause();\n                        }\n                        logger.log(Level.SEVERE, t.getMessage(), t);\n                    }\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                     SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws RemoteException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \"cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \"Cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100)\n                            ++nextSec; // If not, we go to the next sec.\n\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        Thread.sleep(callTime - wakeBefore -\n                                                    System.currentTimeMillis());\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0)\n            return machineName; // Cannot resolve\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        }\n        catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                          re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return execute(master, c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).execute(c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return java(master, c);\n    }\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).java(c);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c);\n        return result;\n    }\n\n    public <V extends Serializable> V\n            execute(String machine, RemoteCallable<V> callable)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable);\n    }\n\n    public <V extends Serializable> List<V>\n            execute(String[] machines, RemoteCallable<V> callable)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable));\n        return rl;\n    }\n\n\n    /**\n     * Start commands sequentially in foreground on machines\n     * The command string should include all stdin, stdout, stderr\n     * redirections (if any). Note that files referred in the command\n     * should be on the machine on which the command is run.\n     * The 'copy' method can be used to transfer files to remote machines.\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param seq flag to indicate if commands should be sequential or parallel\n     * @param priority (default or higher priority) for command\n     * @return true if all commands completed successfully, else false\n     * @see #copy (String, String, String, String, boolean)\n     */\n    public boolean start(String machines[], String cmd, int seq,\n                         int priority) throws Exception {\n\n        boolean exitcode = true;\n\n\n        for (int i = 0; i<machines.length; i++)\n            logger.fine(\"Starting command = \" + cmd +\" on machine \" + machines[i]);\n\n        if (seq == SEQUENTIAL) {\n            /* Start cmd on each m/c in foreground */\n            for (int i = 0; i < machines.length; i++) {\n                if (findCmdAgent(machines[i]).start(cmd, priority) == false)\n                    exitcode = false;\n            }\n        }\n        else if (seq == PARALLEL) {\n            /* Start cmd on each m/c in parallel, then wait for all */\n            String ident = \"Generated\";\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).start(cmd, ident, priority);\n            for (int i = 0; i < machines.length; i++)\n                if (findCmdAgent(machines[i]).wait(ident) == false)\n                    exitcode = false;\n        }\n        return(exitcode);\n    }\n\n\n    /**\n     * Start a command on a single machine\n     */\n    public boolean start(String machine, String command, int seq,\n                         int priority) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(start(m, command, seq, priority));\n    }\n\n    /**\n     * Start commands in background\n     *\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident,\n                      int priority) throws Exception {\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n            findCmdAgent(machines[i]).start(cmd, ident, priority);\n        }\n    }\n\n    /**\n     * Start command in background and wait for the\n     * specified message\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident, String msg,\n                      int priority) throws Exception {\n\n        for (int i = 0; i < machines.length; i++) {\n\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n\n            boolean ret = findCmdAgent(machines[i]).\n                    start(cmd, ident, msg, priority);\n            if(ret)\n                logger.fine(\"Started command \" + cmd + \" on machine \" + machines[i]);\n            else\n                logger.severe(\"command \" + cmd + \" on machine \" + machines[i] + \" failed\");\n        }\n    }\n\n    /**\n     * Start a command in background on a single machine\n     */\n    public void start(String machine, String command, String ident,\n                      int priority ) throws Exception {\n        String m[] = new String[1];\n        m[0] = machine;\n        start(m, command, ident, priority);\n    }\n\n\n    /**\n     * Start a  command in background and returning the first line of output.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param ident identifier to associate with this command\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String machine, String command,\n                                           String ident, int priority)\n            throws Exception {\n\n        logger.info(\"starting command = \"\n                    + command + \" on machine = \" + machine);\n        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(\n                                                command, ident, priority);\n        return retVal;\n    }\n\n\n\n    /**\n     * Start a command in foreground and returning the stdout.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param priority in which to run command\n     * @return String the standard output from the command\n     */\n    public String startAndGetStdOut (String machine, String command, int priority)\n            throws Exception {\n\n        String retVal = findCmdAgent(machine).\n                                        startAndGetStdOut(command, priority);\n        return retVal;\n    }\n\n\n\n    public void startJavaCmd(String machines[], String cmd,\n                             String ident, String env[]) throws Exception {\n\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            logger.fine(\"Starting JAVA with \" + cmd + \" on \" + machines[i]);\n            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);\n        }\n    }\n\n    /**\n     * Start the agent on a single machine\n     */\n    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     */\n    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machine on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully\n     */\n    public boolean wait(String machine, String ident) throws Exception {\n        boolean exitcode = true;\n        logger.info(\"Waiting for \" + ident + \" to complete \");\n        if (findCmdAgent(machine).wait(ident) == false)\n            exitcode = false;\n        return(exitcode);\n    }\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machines on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully on all machines\n     */\n    public boolean wait(String machines[], String ident) throws Exception {\n        boolean exitcode = true;\n        for (int i = 0; i < machines.length; i++) {\n            if(wait(machines[i], ident) == false)\n                exitcode = false;\n        }\n        return(exitcode);\n    }\n\n    /**\n     * Kill command started earlier in background\n     * This method calls kill on all the CmdAgent objects for\n     * the listed machines\n     * @param machines on which to issue kill\n     * @param ident used to identify command in 'start' call\n     */\n    public void kill(String machines[], String ident) {\n        try {\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).kill(ident);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to kill \" + ident, e);\n        }\n    }\n\n\n    /**\n\n     * Kill command started earlier in background using the killem script.\n     * This method calls killem on all the CmdAgent objects for\n     * the listed machines.\n     * @param machines on which to issue kill\n     * @param ident identifier if any if this process was previously started\n     *              through the CmdService.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem(String machines[], String ident, String processString, int sigNum) {\n        try {\n            for (int i = 0; i < machines.length; i++) {\n                findCmdAgent(machines[i]).killem(ident, processString, sigNum);\n                logger.info(\"killed \" + processString +\n                        \" on machine \" + machines[i]);\n            }\n        } catch (Exception e) { }\n    }\n\n    /**\n     * Gets a property from a given file\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n\n    /**\n     * Kill all commands currently running and cleanup\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++)\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                if (retry == 20)\n                    logger.severe(\"Registry did not terminate \" +\n                                \"after 20 termination attempts, giving up! \" +\n                                \"Subsequent runs may have problems.\");\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n                                     String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = master.getHostName();\n                String dest = cmdp.get(didx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Pushing - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent destf = filep.get(didx);\n        try {\n            FileService destfilep = destf.open(destfile, FileAgent.WRITE);\n            byte[] content = FileHelper.getContent(srcfile);\n            destfilep.write(content);\n            destfilep.close();\n        } catch (FileServiceException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, e);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copy(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n\n        if (srcfile.equals(destfile)){\n            try{\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine\n                + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                              \":\" + srcfile + \" to \" + destmachine + \":\" + destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return true;\n    }\n\n    public synchronized boolean move(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n        // First copy the file then delete\n        try {\n            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {\n                FileAgent srcf = null;\n                int sidx = machinesList.indexOf(srcmachine);\n                int didx = machinesList.indexOf(destmachine);\n                if (sidx == didx && srcfile.equals(destfile))\n                    return(true);\n                srcf = filep.get(sidx);\n                return srcf.removeFile(srcfile);\n            }\n        }\n        catch(Exception ie) {\n            logger.severe(\"CmdService: Could not move \" + srcmachine +\n                        \":\" + srcfile + \" to \" + destmachine + \":\" +\n                        destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return false;\n    }\n\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return filep.get(index);\n    }\n\n\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n                logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                        \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile, \n                                             OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyBytes(String srcmachine,\n                                          String destmachine,\n                                          String srcfile, String destfile,\n                                          boolean append) {\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf = new byte[1000000];\n\n        //logger.info(\"CmdService: Copying \" + srcfile + \" to \" + destfile);\n        //logger.info(\"CmdService: Copying from \" + srcmachine + \" to \" + destmachine);\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                destfilep.writeBytes(buf, 0 , buf.length);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile + \" to \" + destmachine + \":\" +\n                          destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     *\n     * The hostInterfaces Properties object stores mappings of machine name\n     * in the benchmark configuration to the corresponding interface of the\n     * master machine used to connect to that machine.\n     *\n     * @return Properties - the hostInterfaces oject.\n     */\n    public Properties getHostInterfaces() {\n        return hostInterfaces;\n    }\n\n    /**\n     * Set the Log level for Agents\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdService.java,v 1.33 2008/03/14 06:47:40 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport com.sun.faban.common.*;\nimport com.sun.faban.harness.FabanHostUnknownException;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.agent.CmdAgent;\nimport com.sun.faban.harness.agent.FileAgent;\nimport com.sun.faban.harness.agent.FileService;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport com.sun.faban.harness.util.InterfaceProbe;\n\nimport java.io.*;\nimport java.net.*;\nimport java.rmi.RemoteException;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * This file contains the class that implements the Command service API.\n * The Command Service object is created by the Engine at the start of\n * a run and it starts up the CmdAgent applications on all the\n * machines and connects to them via RMI. In the API implementation,\n * it identifies the particular CmdAgent and passes the call along.\n *\n * The CmdAgents take care of any error messages generated by the\n * command and automatically log them to the run's error log.\n * The CmdAgent's path will include the default faban bin\n * directories (in addition to /usr/bin, /usr/sbin, /usr/ucb), so\n * any faban executables will be found. Commands in any other\n * path should be invoked with the full pathname of the command.\n * The CmdAgent's environment will also include CLASSPATH set to\n * the faban lib directory to find any Java classes.\n *\n * Shell commands or any commands whose output must be re-directed\n * or piped (basically using shell) should be executed using syntax\n * such as :\n * \"sh -c <command> [<args>] [> out]\".\n * IMPORTANT: There should be a single CmdService object in the\n * entire framework or else multiple copies of the CmdAgent\n * application will be spawned on the target machines.\n * Therefore, this class is implemented as a Singleton.\n * No public constructors are defined and the object cannot be cloned.\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.GenericBenchmark\n */\nfinal public class CmdService { \t// The final keyword prevents clones\n\n    public static final int SEQUENTIAL = 1;\t/* Sequential flag in FG mode*/\n    public static final int PARALLEL = 2;\t/* parallel flag in FG mode*/\n\n    private static Logger logger = Logger.getLogger(CmdService.class.getName());\n    private static CmdService cmds;\n\n    private ArrayList<CmdAgent> cmdp = new ArrayList<CmdAgent>();\n    private ArrayList<FileAgent> filep = new ArrayList<FileAgent>();\n\n    /** List of all machines */\n    private ArrayList<String> machinesList = new ArrayList<String>();\t\n    private Properties hostInterfaces = new Properties();\n    private Registry registry;\n    private String master;\t// Name of faban master machine\n    private String masterAddress; // ip of faban master machine\n    private CommandHandle registryCmd;\n    private String javaHome;\n    private String jvmOptions;\n    private HashMap<String, String> binMap = new HashMap<String, String>();\n    private Map<String, String> ifMap;\n\n    private String rsh, agent;\n\n\n    private CmdService() {\n\n        try {\n            master = (InetAddress.getLocalHost()).getHostName();\n            masterAddress = (InetAddress.getLocalHost()).getHostAddress();\n            logger.config(\"InetAddress master Host = \" + master);\n            logger.config(\"InetAddress master address = \" + masterAddress);\n        } catch (Exception e) {\n            logger.severe(\"CmdService <init> failed \" + e);\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    /**\n     * This method is the only way that an external object\n     * can get a reference to the singleton CmdService.\n     * This method should not be used outside engine.\n     * @return reference to the single CmdService\n     */\n    public static CmdService getHandle() {\n        if(cmds == null)\n            cmds = new CmdService();\n        return cmds;\n    }\n\n    /**\n     *\n     * @return master machine name\n     */\n    public String getMaster() {\n        return master;\n    }\n\n\n    /**\n     * Returns the ip address of the master.\n     * @return The ip address of the master\n     */\n    public String getMasterIP() {\n        return masterAddress;\n    }\n\n    /**\n     * Returns the ip address of the master's interface best used for\n     * communicating with the target host.\n     * @param agentHost The target host\n     * @return The ip address of the master\n     */\n    public String getMasterIP(String agentHost) {\n        return ifMap.get(agentHost);\n    }\n\n    /**\n     *\n     * This method is called after every run to re-initialize the data\n     * structures that need to change from one run to another.\n     *\n     */\n    public void init() {\n        machinesList.clear();\n        cmdp.clear();\n        filep.clear();\n        hostInterfaces.clear();\n    }\n\n    /**\n     * This method initializes the CmdAgent RMI server processes\n     * on the specified set of machines\n     * This method can be called multiple times to initialize multiple\n     * classes of machines\n     * @param hosts String[][] of machines\n     * @return true if successful, false if setup failed\n     *\n     */\n    public boolean setup(String benchName, String[][] hosts,\n                         String home, String options) {\n\n        // It is common for java to be in C:\\Program Files. This has a space\n        // inside the string and can cause havoc. We need to double quote this\n        // parameter as needed.\n        if (home.indexOf(' ') == -1)\n            javaHome = home;\n        else\n            javaHome = '\"' + home + '\"';\n\n        // We need to be careful to escape properties having '\\\\' on win32\n        String escapedHome = Config.FABAN_HOME.replace(\"\\\\\", \"\\\\\\\\\");\n        String fs = File.separatorChar == '\\\\' ? \"\\\\\\\\\" : File.separator;\n\n        // Again, we ensure FABAN_HOME to be quoted if there are spaces inside.\n        if (escapedHome.indexOf(' ') != -1)\n            escapedHome = '\"' + escapedHome + '\"';\n        jvmOptions = \"-Dfaban.home=\" + escapedHome +\n                \" -Djava.security.policy=\" + escapedHome + \"config\" + fs +\n                \"faban.policy -Djava.util.logging.config.file=\" + escapedHome +\n                \"config\" + fs + \"logging.properties -Dfaban.registry.port=\" +\n                Config.RMI_PORT + ' ' + \"-Dfaban.logging.port=\" +\n                Config.LOGGING_PORT;\n\n        try {\n            // Update the logging.properties file in config dir\n            Properties log = new Properties();\n            FileInputStream in = new FileInputStream(Config.CONFIG_DIR +\n                                                    \"logging.properties\");\n            log.load(in);\n            in.close();\n\n            // Update if it has changed.\n            if(!(log.getProperty(\"java.util.logging.SocketHandler.host\").\n                    equals(master) &&\n                 log.getProperty(\"java.util.logging.SocketHandler.port\").\n                    equals(String.valueOf(Config.LOGGING_PORT)))){\n                log.setProperty(\"java.util.logging.SocketHandler.host\", master);\n                log.setProperty(\"java.util.logging.SocketHandler.port\",\n                                String.valueOf(Config.LOGGING_PORT));\n                FileOutputStream out = new FileOutputStream(\n                        new File(Config.CONFIG_DIR + \"logging.properties\"));\n                log.store(out, \"Faban logging properties\");\n                out.close();\n            }\n\n        } catch(IOException e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent \" + e, e);\n        }\n\n        // Start RMI registry and Registry\n        try {\n\n            // Create classpath with all client jars in faban/lib dir.\n            // Benchmark specific stubs will be in one of the jars.\n            File[] libs = (new File(Config.LIB_DIR)).listFiles();\n\n            StringBuffer buf = new StringBuffer(\" -cp \");\n            for(int i = 0; i < libs.length; i++) {\n                if(libs[i].isFile())\n                    buf.append(libs[i].getAbsolutePath() + File.pathSeparator);\n            }\n\n            String classpath = buf.toString();\n\n            // The registry should not consume much resources. Just don't\n            // use the driver JVM options and set it to 32m - 1024m dynamic.\n            // This should not be performance sensitive at all.\n            String cmd = javaHome + File.separator + \"bin\" + File.separator +\n                    \"java \" + jvmOptions + \" -Xms32m -Xmx1024m \" + classpath +\n                    \" com.sun.faban.common.RegistryImpl\" ;\n\n            logger.info(\"Starting Registry.\");\n            logger.fine(\"Starting using command \" + cmd);\n            Command rmiCmd = new Command(cmd);\n            rmiCmd.setSynchronous(false);\n            rmiCmd.setLogLevel(Command.STDOUT, Level.WARNING);\n            registryCmd = rmiCmd.execute();\n\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Couldn't start Registry. \" +\n                    \"Please check if its already running\", e);\n            return false;\n        }\n\n        // Now add the driver options to the JVM options. Need them after this.\n        jvmOptions += ' ' + options;\n\n        // RMI registry takes a bit of time to startup. So sleep for some time\n        try {\n            logger.fine(\"Waiting for RMI registry and Registry to startup\");\n            Thread.sleep(10000);\n        } catch(InterruptedException e) {\n        }\n\n        try {\n            registry = RegistryLocator.getRegistry(Config.RMI_PORT);\n        } catch(Exception e) {\n            logger.severe(\"Unable to connect to Registry \" + e);\n            logger.log(Level.FINE,  \"Exception\", e);\n            return false;\n        }\n\n        // an agent needs to be started on the master machine\n        // first since configuration of agents on other machines\n        // depend on a CmdAgent running on the master machine\n\n        // We need to scan the machines to ensure that they are not a different\n        // incarnation of the master's name. If they are, switch the master to\n        // use these names instead.\n\n        // Also, we use the same loop to create a non-duplicate set of remote\n        // machines. This is used later to find the interfaces to the remote\n        // machine.\n\n        InetAddress[] masterIps = null;\n        try {\n            masterIps = InetAddress.getAllByName(master);\n        } catch (UnknownHostException e) {\n            logger.log(Level.SEVERE, \"Strange! Master is unknown.\", e);\n            return false;\n        }\n\n        HashSet<String> remoteMachines = new HashSet<String>();\n        boolean isMasterSet = false;\n\n        outer:\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for (int i = 0; i < machines.length; i++) {\n\n                // Check for no localhost, we don't allow it.\n                if (machines[i].startsWith(\"localhost\")) {\n                    if (machines[i].length() == 9 ||    // localhost\n                        machines[i].charAt(9) == '.') { // localhost.domain\n                        logger.severe(\"Host names must not be localhost. \" +\n                                \"Please use real host names or IP addresses \" +\n                                \"instead. Terminating run!\");\n                        return false;\n                    }\n                }\n                try {\n                    InetAddress[] machineIps =\n                            InetAddress.getAllByName(machines[i]);\n                    if (sameHost(masterIps, machineIps)) {\n                        if (!isMasterSet) { // Set the master to the first\n                                            // found master name in the list.\n                            master = machines[i];\n                            isMasterSet = true;\n                        } else { // Set all subsequent masters to the same.\n                            machines[i] = master;\n                        }\n                    } else {     // All remote machines go into a set.\n                        remoteMachines.add(machines[i]);\n                    }\n                } catch (UnknownHostException e) {\n                    logger.log(Level.WARNING, machines[i] + \" is unknown.\", e);\n                }\n            }\n        }\n\n        // Next we use the command map to get the right\n        // rsh command based on the undelying OS.\n        try {\n            binMap = CmdMap.getCmdMap(null);\n            rsh = binMap.get(\"rsh\");\n            agent = binMap.get(\"agent\") + ' ';\n        } catch (Exception e) {\n            logger.log(Level.WARNING, \"Failed to obtain command map.\",e);\n        }\n\n        if (rsh == null)\n            rsh = \"rsh\";\n\n        //only case in which interfaceAddress is not an address but\n        //the hostname of the master machine.  used in CmdAgentImpl\n        //the cmdagent on the master machine is registered under 2\n        // names, Config.CMD_AGENT@master as well as just Config.CMD_AGENT\n        if (!machinesList.contains(master)) {\n            if (!startCmdAgent(benchName, master, master))\n                return false;\n            machinesList.add(master);\n        }\n\n        // this is necessary in case you are on a private network\n        // where the machine's private ip address is not the same as it's\n        // public ip address\n\n        // Fist check specific scripts for the arch\n        String scriptPath = Config.BIN_DIR + Config.ARCH_DIR + \"interface\";\n        File ifScript = new File(scriptPath.trim());\n\n        // Then check script for the OS. If it exists, use it.\n        // It is usually more reliable than the interface probe.\n        if (!ifScript.exists()) {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            scriptPath = Config.BIN_DIR + Config.OS_DIR + \"interface\";\n            ifScript = new File(scriptPath.trim());\n        }\n\n        ifMap = new HashMap<String, String>();\n        boolean ifMapComplete = false;\n\n        if (ifScript.exists()) {\n            ifMapComplete = getIfMap(remoteMachines, ifScript, ifMap);\n        } else {\n            logger.finer(\"Could not find interface script at \" +\n                    ifScript.getAbsolutePath());\n            ifScript = null;\n        }\n\n        // If we have no interface script or the interface script did not\n        // do a complete job, we'll resort to the probe.\n        // Most reliable when run as root, but buggy in parallel mode.\n        // Also the interface probe needs JDK1.6 or later.\n        if (!ifMapComplete) {\n            if(\"1.6\".compareTo(System.getProperty(\"java.version\")) > 0) {\n                logger.severe(\"Could not find a way to check the interface!\");\n                return false;\n            }\n\n            InterfaceProbe iProbe = null;\n            try {\n                iProbe = new InterfaceProbe(Config.THREADPOOL);\n                iProbe.getIfMap(remoteMachines, ifMap);\n            } catch (SocketException e) {\n                logger.log(Level.SEVERE,\n                        \"Could not find a way to check the interface!\", e);\n            }\n        }\n\n\n        // cycles through benchmark machines starting up agents and\n        // configuring them\n        for (int j = 0; j < hosts.length; j++) {\n            String[] machines = hosts[j];\n            for(int i = 0; i < machines.length; i++) {\n                // Do not start duplicate Cmd agent\n                if(machinesList.contains(machines[i]))\n                    continue;\n\n                String interfaceAddress = ifMap.get(machines[i]);\n\n                if (interfaceAddress == null || interfaceAddress.length() == 0)\n                    return false;\n\n                if (!startCmdAgent(benchName, machines[i], interfaceAddress))\n                    return false;\n\n                // By adding the mach to the list we prevent multiple\n                // agents being started on the same server\n                machinesList.add(machines[i]);\n            }\n        }\n        try {\n            Thread.sleep(20000);\n        } catch (InterruptedException e) {\n        }\n        for (int i = 0; i < machinesList.size(); i++)\n            if (!getCmdAgent((String) machinesList.get(i)))\n                return false;\n        setClocks();\n        return true;\n    }\n\n    private boolean getIfMap(Collection<String> hosts, File ifScript,\n                             Map<String, String> ifMap) {\n        boolean complete = true;\n\n        for (String host: hosts) {\n            String interfaceAddress = null;\n\n            String ifCommand = ifScript.getAbsolutePath() + ' ' + host;\n\n            logger.fine(\"Detecting interface: \" + ifCommand);\n            try {\n                Process p = Runtime.getRuntime().exec(ifCommand);\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n\n                interfaceAddress = bufR.readLine();\n                if (interfaceAddress != null) {\n                    interfaceAddress = interfaceAddress.trim();\n                    if (\"127.0.0.1\".equals(interfaceAddress)) {\n                        complete = false;\n                        ifMap.put(host, \"\");\n                    } else {\n                        ifMap.put(host, interfaceAddress);\n                    }\n                }\n\n                int exitValue = -1;\n\n                if (interfaceAddress != null &&\n                        interfaceAddress.length() > 0) { //Read something...\n\n                    exitValue = p.waitFor();\n                    if (exitValue != 0) {\n                        logger.warning(\"interface: Cannot reach system \" +\n                                host);\n                        complete = false;\n                        ifMap.put(host, \"\");\n                        continue;\n                    }\n                } else { // Nothing read, check stderr\n                    bufR = new BufferedReader(\n                            new InputStreamReader(p.getErrorStream()));\n                    logger.severe(bufR.readLine());\n                    ifMap.put(host, \"\");\n                    continue;\n                }\n            }\n            catch (Exception e) {\n                logger.log(Level.SEVERE,\n                        \"Error in executing the interface program: \" +\n                        ifCommand, e);\n                break;\n            }\n\n            logger.config(\"Interface Address = \" + interfaceAddress);\n        }\n        return complete;\n    }\n\n    private boolean getCmdAgent(String mach) {\n\n        try {\n            String s = Config.CMD_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            int retry = 1;\n            CmdAgent c = (CmdAgent) registry.getService(s);\n            for (; c == null && retry <= 10; retry++) {\n                Thread.sleep(10000);\n                logger.warning(\"Retry connecting to \" + s + \", count \" +\n                                retry + '.');\n                c = (CmdAgent) registry.getService(s);\n            }\n            if (c == null) {\n                logger.severe(\"Could not connect to \" + s);\n                return(false);\n            }\n\n            cmdp.add(c);\n            logger.fine(\"CmdService: Configuring \" + s);\n            // Added by Ramesh to get the real hostnames of the servers\n            logger.info(\"CmdService: Configured \" + s + \" on server \" + c.getHostName());\n            s = Config.FILE_AGENT + \"@\" + mach;\n            logger.fine(\"CmdService: Connecting to \" + s);\n            filep.add((FileAgent) registry.getService(s));\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Error accessing command agent on system \"\n                    + mach, e);\n            return (false);\n        }\n    }\n\n    /* start up the CmdAgent applications\n    * We use a script 'cmd' which will setup the CLASSPATH before\n    * invoking CmdAgent\n    */\n    private boolean startCmdAgent(String benchName, String mach,\n                                  String interfaceAddress) {\n\n        hostInterfaces.setProperty(mach, interfaceAddress);\n        String cmdarray;\n\n        String agentParams = mach + ' ' + interfaceAddress + ' ' +\n                        masterAddress + ' ' + javaHome + ' ' + jvmOptions +\n                        \" faban.benchmarkName=\" + benchName;\n        try {\n            if (mach.equals(master)) {\n                cmdarray = agent + agentParams;\n                logger.fine(\"Executing \" + cmdarray);\n                Command cmdAgent = new Command(cmdarray);\n                cmdAgent.setSynchronous(false);\n                cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                cmdAgent.execute();\n            } else { // if the machine is not the master machine, we need to\n                // do an rsh or talk to the agent daemon and pass download\n                // instructions.\n                // Many times, the FABAN_URL cannot be reached by the benchmark\n                // downloader. So it is better to change the URL to access\n                // the master via the best interface, by ip address instead of\n                // host name.\n\n                URL fabanURL = new URL(Config.FABAN_URL);\n                URL downloadURL = new URL(fabanURL.getProtocol(),\n                        interfaceAddress, fabanURL.getPort(),\n                        fabanURL.getFile());\n                agentParams += \" faban.download=\" + downloadURL.toString();\n\n                boolean agentStarted = false;\n\n                try { // See first whether we have an agent daemon.\n                    Socket socket = new Socket(mach, Config.AGENT_PORT);\n                    OutputStream socketOut = socket.getOutputStream();\n                    InputStream socketIn = socket.getInputStream();\n                    byte[] buffer = new byte[1024];\n                    socketOut.write(agentParams.getBytes());\n                    int length = socketIn.read(buffer);\n                    socketIn.close();\n                    socketOut.close();\n                    socket.close();\n                    String response = new String(buffer, 0, length);\n                    int rcode = Integer.parseInt(response.substring(0, 3));\n                    switch (rcode) {\n                        case 200 : agentStarted = true;\n                                   logger.fine(\"Found Agent(daemon)@\" + mach +\n                                               \". Registering agent.\");\n                                   break;\n                        case 500 : logger.warning(\"Agent(daemon)@\" + mach +\n                                              \": \" + response +\n                                              \" Please report the issue \" +\n                                              \"and provide logs from \" + mach +\n                                              \":FABAN_HOME/logs/agent.log\");\n                                   break;\n                        case 409 : logger.severe(\"Agent(daemon)@\" + mach +\n                                                 \": \" + response);\n                                   // We do not fall back in the conflict case.\n                                   return false;\n                        default  : logger.warning(\"Agent(daemon)@\" + mach +\n                                                  \": \" + response);\n                    }\n\n                } catch (ConnectException e) {\n                    // We should get a ConnectException if the agent was not\n                    // started in daemon mode. This should take no time.\n                    logger.log(Level.FINER, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                } catch (IOException e) {\n                    logger.log(Level.WARNING, \"Agent(daemon)@\" + mach + \": \" +\n                        e.getMessage() + \". Will try remote shell instead.\", e);\n                }\n\n                if (!agentStarted) {\n                    cmdarray = rsh + ' ' + mach + ' ' + agent + agentParams;\n                    logger.fine(\"Executing \" + cmdarray);\n                    Command cmdAgent = new Command(cmdarray);\n                    cmdAgent.setSynchronous(false);\n                    cmdAgent.setLogLevel(Command.STDOUT, Level.WARNING);\n                    cmdAgent.execute();\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Could not execute \" + agent +\n                                                    \"on machine \" + mach, e);\n            return false;\n        }\n    }\n\n    private boolean sameHost(InetAddress[] host1, InetAddress[] host2) {\n        for (int i = 0; i < host1.length; i++) {\n            for (int j = 0; j < host2.length; j++) {\n                if (host1[i].equals(host2[j]))\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    private void setClocks() {\n        SimpleDateFormat dateFormat = new SimpleDateFormat(\"MMddHHmmyyyy.ss\");\n        dateFormat.setTimeZone(new SimpleTimeZone(0, \"GMT\")); // Use GMT.\n        HashSet<String> hostSet = new HashSet<String>();\n        ArrayList<Future<Boolean>> tasks = new ArrayList<Future<Boolean>>();\n        hostSet.add(master); // Don't try to set clock for master.\n        for (Object o : cmdp) {\n            CmdAgent agent = (CmdAgent) o;\n            String hostName = null;\n            try {\n                hostName = agent.getHostName();\n                if (hostSet.add(hostName)) {\n                    tasks.add(Config.THREADPOOL.submit(\n                            new setClockTask(agent, hostName, dateFormat)));\n                }\n                for (Future<Boolean> future : tasks)\n                    try {\n                        future.get(300, TimeUnit.SECONDS);\n                    } catch (Throwable t) {\n                        Throwable cause = t.getCause();\n                        while (cause != null) {\n                            t = cause;\n                            cause = t.getCause();\n                        }\n                        logger.log(Level.SEVERE, t.getMessage(), t);\n                    }\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE,\n                        \"Cannot communicate to agent to set time.\", e);\n            }\n        }\n    }\n\n    static class setClockTask implements Callable<Boolean> {\n        public static final long ACCURACY = 10l; // plus-minus 10ms.\n        CmdAgent agent;\n        String hostName;\n        SimpleDateFormat dateFormat;\n\n        setClockTask(CmdAgent agent, String hostName,\n                     SimpleDateFormat dateFormat) {\n            this.agent = agent;\n            this.hostName = hostName;\n            this.dateFormat = dateFormat;\n        }\n\n        public Boolean call() throws RemoteException, InterruptedException {\n\n            // 1. If we're within accuracy, don't set the clock\n            long ms = System.currentTimeMillis();\n            long timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n            if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                logger.fine(\"Time difference of \" + timeDiff +\n                        \" ms already in range. No need to set clock.\");\n                return true;\n            }\n\n            logger.info(\"Time difference to host \" + hostName + \" is \" +\n                    timeDiff + \" ms. Attempting to set clock.\");\n\n            int lag = 100; // Start with 100ms latency.\n            int wakeBefore = 20;\n\n            // 2. Wait till we're latency/2 from second boundary\n            // Find next second boundary.\n            long nextSec;\n            String nextSecString = \"\";\n            long callTime;\n\n            for (int i = 0;; i++) {\n                if (i >= 20) {\n                    logger.warning(hostName + \"cannot accurately set remote \" +\n                            \"time after \" + i + \" attempts. There is still a \" +\n                            \"difference of \" + timeDiff + \" ms. Giving up.\");\n                    return false;\n                }\n                findBoundaryLoop:\n                for (int j = 0;; j++) {\n                    if (j >= 20) {\n                        logger.warning(hostName + \"Cannot scan time to set \" +\n                                \"clock after \" + j + \" retries. Giving up \" +\n                                \"setting clock. System may be overloaded or \" +\n                                \"JVM doing too much garbage collections.\");\n                        return false;\n                    }\n                    logger.finer(\"Lag time: \" + lag + \"ms\");\n                    for (;;) {\n                        ms = System.currentTimeMillis();\n                        nextSec = (long) Math.ceil(ms / 1000d);\n                        // We should be 100 ms from the boundary, at least.\n                        if (nextSec * 1000 - ms < 100)\n                            ++nextSec; // If not, we go to the next sec.\n\n                        // Convert nextSec back to millis\n                        nextSec *= 1000l;\n                        callTime = nextSec - lag;\n\n                        // DateFormat got passed to us and gets shared between\n                        // multiple threads. So we need to sync.\n                        synchronized (dateFormat) {\n                            nextSecString = dateFormat.format(\n                                    new Date(nextSec));\n                        }\n\n                        // Now, sleep and wake up 20ms before the wanted second\n                        // boundary. This is to avoid late calls as sleep may\n                        // have up to 10ms wakeup delay.\n                        long sleepTime = callTime - wakeBefore -\n                                                    System.currentTimeMillis();\n                        if (sleepTime > 0)\n                            Thread.sleep(sleepTime);\n\n                        if (System.currentTimeMillis() >= callTime - 2) {\n                            wakeBefore += wakeBefore;\n                            continue;\n                        }\n                        break;\n                    }\n\n                    // Now within 20ms from the call, wait in a tight loop.\n                    for (;;) {\n                        long currentTime = System.currentTimeMillis();\n                        if (currentTime == callTime) {\n                            break findBoundaryLoop;\n                        } else if (currentTime > callTime) {\n                            logger.finer(hostName + \"missed preset callTime \" +\n                                    \"of \" + callTime + \". Current time is \" +\n                                    currentTime + \".\");\n                            continue findBoundaryLoop; // Missed second boundary\n                        }\n                    }\n                }\n\n                // 3. Call agent to set time\n                ms = System.currentTimeMillis();\n                agent.setTime(nextSecString);\n                logger.finer(\"Actual setTime took \" +\n                        (System.currentTimeMillis() - ms) + \" ms.\");\n\n                // 4. Verify that time has been set properly.\n                ms = System.currentTimeMillis();\n                timeDiff = -agent.getTime() +\n                            ms + (System.currentTimeMillis() - ms) / 2;\n                if (timeDiff < ACCURACY && timeDiff > -ACCURACY) {\n                    logger.info(\"Setting time succeeded for \" + hostName +\n                            \" after \" + i + \" retries. Time difference is \" +\n                            timeDiff + \" ms.\");\n                    break;\n                } else {\n                    logger.finer(\"Too large time difference of \" + timeDiff +\n                            \" ms to \" + hostName + \". Only \" + ACCURACY +\n                            \" ms are allowed.\");\n                    lag += timeDiff;\n                }\n            }\n            return true;\n        }\n    }\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     */\n    public String getHostName(String machineName) {\n\n        int index = machinesList.indexOf(machineName);\n        if (index < 0)\n            return machineName; // Cannot resolve\n        String retVal = null;\n        try {\n            retVal = cmdp.get(index).getHostName();\n        }\n        catch (RemoteException re) {\n            logger.severe(\"RemoteException \" +\n                          re.getCause());\n            logger.log(Level.FINE, \"Exception\", re);\n        }\n        if (retVal == null) {\n            return machineName;\n        }\n        return retVal;\n    }\n\n    /**\n     * Executes a command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return execute(master, c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle execute(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).execute(c);\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] execute(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).execute(c);\n        return result;\n    }\n\n    /**\n     * Executes a java command from the master's command agent.\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return java(master, c);\n    }\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machine The target machine to execute the command\n     * @param c The command to be executed\n     * @return  A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle java(String machine, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        return findCmdAgent(machine).java(c);\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param machines The target machines to execute the command\n     * @param c The command to be executed\n     * @return  Handles to the command on each of the target machines\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     * @throws RemoteException If there is a communication error to the\n     *                         remote agent\n     */\n    public CommandHandle[] java(String[] machines, Command c)\n            throws IOException, InterruptedException, RemoteException {\n        CommandHandle[] result = new CommandHandle[machines.length];\n        for (int i = 0; i < machines.length; i++)\n            result[i] = findCmdAgent(machines[i]).java(c);\n        return result;\n    }\n\n    public <V extends Serializable> V\n            execute(String machine, RemoteCallable<V> callable)\n            throws Exception {\n        return findCmdAgent(machine).exec(callable);\n    }\n\n    public <V extends Serializable> List<V>\n            execute(String[] machines, RemoteCallable<V> callable)\n            throws Exception {\n\n        ArrayList<V> rl = new ArrayList<V>();\n        for (int i = 0; i < machines.length; i++)\n            rl.add(findCmdAgent(machines[i]).exec(callable));\n        return rl;\n    }\n\n\n    /**\n     * Start commands sequentially in foreground on machines\n     * The command string should include all stdin, stdout, stderr\n     * redirections (if any). Note that files referred in the command\n     * should be on the machine on which the command is run.\n     * The 'copy' method can be used to transfer files to remote machines.\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param seq flag to indicate if commands should be sequential or parallel\n     * @param priority (default or higher priority) for command\n     * @return true if all commands completed successfully, else false\n     * @see #copy (String, String, String, String, boolean)\n     */\n    public boolean start(String machines[], String cmd, int seq,\n                         int priority) throws Exception {\n\n        boolean exitcode = true;\n\n\n        for (int i = 0; i<machines.length; i++)\n            logger.fine(\"Starting command = \" + cmd +\" on machine \" + machines[i]);\n\n        if (seq == SEQUENTIAL) {\n            /* Start cmd on each m/c in foreground */\n            for (int i = 0; i < machines.length; i++) {\n                if (findCmdAgent(machines[i]).start(cmd, priority) == false)\n                    exitcode = false;\n            }\n        }\n        else if (seq == PARALLEL) {\n            /* Start cmd on each m/c in parallel, then wait for all */\n            String ident = \"Generated\";\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).start(cmd, ident, priority);\n            for (int i = 0; i < machines.length; i++)\n                if (findCmdAgent(machines[i]).wait(ident) == false)\n                    exitcode = false;\n        }\n        return(exitcode);\n    }\n\n\n    /**\n     * Start a command on a single machine\n     */\n    public boolean start(String machine, String command, int seq,\n                         int priority) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(start(m, command, seq, priority));\n    }\n\n    /**\n     * Start commands in background\n     *\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident,\n                      int priority) throws Exception {\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n            findCmdAgent(machines[i]).start(cmd, ident, priority);\n        }\n    }\n\n    /**\n     * Start command in background and wait for the\n     * specified message\n     * @param machines on which command should be started\n     * @param cmd command to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public void start(String machines[], String cmd, String ident, String msg,\n                      int priority) throws Exception {\n\n        for (int i = 0; i < machines.length; i++) {\n\n            if ((machines[i] == null) || (machines[i].equals(\"\")))\n                continue;\n\n            boolean ret = findCmdAgent(machines[i]).\n                    start(cmd, ident, msg, priority);\n            if(ret)\n                logger.fine(\"Started command \" + cmd + \" on machine \" + machines[i]);\n            else\n                logger.severe(\"command \" + cmd + \" on machine \" + machines[i] + \" failed\");\n        }\n    }\n\n    /**\n     * Start a command in background on a single machine\n     */\n    public void start(String machine, String command, String ident,\n                      int priority ) throws Exception {\n        String m[] = new String[1];\n        m[0] = machine;\n        start(m, command, ident, priority);\n    }\n\n\n    /**\n     * Start a  command in background and returning the first line of output.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param ident identifier to associate with this command\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String machine, String command,\n                                           String ident, int priority)\n            throws Exception {\n\n        logger.info(\"starting command = \"\n                    + command + \" on machine = \" + machine);\n        String retVal = findCmdAgent(machine).startAndGetOneOutputLine(\n                                                command, ident, priority);\n        return retVal;\n    }\n\n\n\n    /**\n     * Start a command in foreground and returning the stdout.\n     *\n     * @param machine name of the machine on which to start the command\n     * @param command to start\n     * @param priority in which to run command\n     * @return String the standard output from the command\n     */\n    public String startAndGetStdOut (String machine, String command, int priority)\n            throws Exception {\n\n        String retVal = findCmdAgent(machine).\n                                        startAndGetStdOut(command, priority);\n        return retVal;\n    }\n\n\n\n    public void startJavaCmd(String machines[], String cmd,\n                             String ident, String env[]) throws Exception {\n\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            logger.fine(\"Starting JAVA with \" + cmd + \" on \" + machines[i]);\n            findCmdAgent(machines[i]).startJavaCmd(cmd, ident, env);\n        }\n    }\n\n    /**\n     * Start the agent on a single machine\n     */\n    public boolean startAgent(String machine, Class agentClass, String identifier) throws Exception {\n\n        String m[] = new String[1];\n        m[0] = machine;\n\n        return(startAgent(m, agentClass, identifier));\n    }\n\n    /**\n     * Start Agent in the specified machines.\n     *\n     * @param machines on which command should be started\n     * @param agentClass Impl Class of the agent to be started\n     * @param identifier to identify this agent later\n     */\n    public boolean startAgent(String machines[], Class agentClass, String identifier) throws Exception {\n        boolean result = true;\n\n        for (int i = 0; i < machines.length; i++) {\n            if ((machines[i] == null) || (machines[i].equals(\"\"))) {\n                continue;\n            }\n            //Change the identifier to agent@host\n            result = result && findCmdAgent(machines[i]).\n                    startAgent(agentClass, identifier + \"@\" + machines[i]);\n        }\n        return result;\n    }\n\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machine on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully\n     */\n    public boolean wait(String machine, String ident) throws Exception {\n        boolean exitcode = true;\n        logger.info(\"Waiting for \" + ident + \" to complete \");\n        if (findCmdAgent(machine).wait(ident) == false)\n            exitcode = false;\n        return(exitcode);\n    }\n\n    /**\n     * Wait for command started earlier in background\n     * This method calls wait on all the CmdAgent objects for\n     * the listed machines\n     *\n     * @param machines on which to wait\n     * @param ident used to identify command in 'start' call\n     * @return true if command finished succesfully on all machines\n     */\n    public boolean wait(String machines[], String ident) throws Exception {\n        boolean exitcode = true;\n        for (int i = 0; i < machines.length; i++) {\n            if(wait(machines[i], ident) == false)\n                exitcode = false;\n        }\n        return(exitcode);\n    }\n\n    /**\n     * Kill command started earlier in background\n     * This method calls kill on all the CmdAgent objects for\n     * the listed machines\n     * @param machines on which to issue kill\n     * @param ident used to identify command in 'start' call\n     */\n    public void kill(String machines[], String ident) {\n        try {\n            for (int i = 0; i < machines.length; i++)\n                findCmdAgent(machines[i]).kill(ident);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Failed to kill \" + ident, e);\n        }\n    }\n\n\n    /**\n\n     * Kill command started earlier in background using the killem script.\n     * This method calls killem on all the CmdAgent objects for\n     * the listed machines.\n     * @param machines on which to issue kill\n     * @param ident identifier if any if this process was previously started\n     *              through the CmdService.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem(String machines[], String ident, String processString, int sigNum) {\n        try {\n            for (int i = 0; i < machines.length; i++) {\n                findCmdAgent(machines[i]).killem(ident, processString, sigNum);\n                logger.info(\"killed \" + processString +\n                        \" on machine \" + machines[i]);\n            }\n        } catch (Exception e) { }\n    }\n\n    /**\n     * Gets a property from a given file\n     * @param machine The machine name\n     * @param propFile The property file name\n     * @param propName The property key name\n     * @return The property value\n     * @throws java.io.IOException If there is an error accessing the config file\n     */\n    public String getProperty(String machine, String propFile, String propName)\n            throws IOException {\n        return findFileAgent(machine).getProperty(propFile, propName);\n    }\n\n\n    /**\n     * Kill all commands currently running and cleanup\n     * This method is called when a run must be aborted\n     * or at the end of a benchmark run.\n     */\n    public void kill() {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                logger.info(\"killing CmdAgent@\" + machinesList.get(i));\n                cmdp.get(i).kill();\n            }\n            cmdp.clear();\n            filep.clear();\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, \"Kill Failed for CmdAgent@\" +\n                    machinesList.get(i), e);\n        } finally {\n            //Exiting Registry\n            if (registryCmd != null) {\n                int retry = 0;\n                for (; retry < 20; retry++)\n                    try {\n                        registryCmd.destroy();\n                        Thread.sleep(1000);\n                        int exitValue = registryCmd.exitValue();\n                        logger.finer(\"Registry exited with exit value \" +\n                                exitValue + '.');\n                        break;\n                    } catch (InterruptedException e) {\n                        logger.log(Level.WARNING, \"Interrupted waiting for \" +\n                                \"registry to terminate. \" +\n                                \"Cannot verify termination status.\", e);\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy for Registry. \" +\n                                \"Please report bug.\", e);\n                    } catch (IllegalThreadStateException e) {\n                        logger.log(Level.FINER,\n                                \"Registry did not terminate! \", e);\n                    }\n                if (retry == 20)\n                    logger.severe(\"Registry did not terminate \" +\n                                \"after 20 termination attempts, giving up! \" +\n                                \"Subsequent runs may have problems.\");\n\n            }\n        }\n    }\n\n    /**\n     * Pushes a local file on the Faban master to the remote host.\n     * @param srcfile The source file name\n     * @param destmachine The destination machine\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean push(String srcfile,\n                                     String destmachine, String destfile) {\n        int didx = machinesList.indexOf(destmachine);\n        if (didx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + destmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = master.getHostName();\n                String dest = cmdp.get(didx).getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Pushing - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent destf = filep.get(didx);\n        FileTransfer transfer = new FileTransfer(srcfile, destfile);\n        try {\n            if (destf.push(transfer) != transfer.getSize())\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception writing file \" + destfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Pushing - \" +\n                    \"exception reading file \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n\n    /**\n     * Gets a remote file to the Faban master.\n     * @param srcmachine The source machine\n     * @param srcfile The source file name\n     * @param destfile The destination file name\n     * @return true if successful, false otherwise\n     */\n    public synchronized boolean get(String srcmachine, String srcfile,\n                                     String destfile) {\n        int sidx = machinesList.indexOf(srcmachine);\n        if (sidx == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + srcmachine + \" not found!\");\n        if (srcfile.equals(destfile)){\n            try {\n                CmdAgent master = (CmdAgent)\n                                        registry.getService(Config.CMD_AGENT);\n                String src = cmdp.get(sidx).getHostName();\n                String dest = master.getHostName();\n                if (dest.equals(src))\n                    return true;\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"CmdService: Getting - CmdAgent \" +\n                           \"getHostName exception\", e);\n                return false;\n            }\n        }\n\n        FileAgent srcf = filep.get(sidx);\n        try {\n            FileTransfer transfer = srcf.get(srcfile, destfile);\n            if (transfer.getSize() <= 0)\n                throw new IOException(\"Invalid transfer size\");\n        } catch (RemoteException e) {\n            Throwable t = e;\n            Throwable cause = t.getCause();\n            while (cause != null)\n                t = cause;\n\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading file \" + srcfile, t);\n            return false;\n        } catch (IOException e) {\n            logger.log(Level.SEVERE, \"CmdService: Getting - \" +\n                    \"exception reading \" + srcfile, e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copy(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf;\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n\n        if (srcfile.equals(destfile)){\n            try{\n                String dest = cmdp.get(didx).getHostName();\n                String src = cmdp.get(sidx).getHostName();\n                if (dest == src)\n                    return true;\n            } catch (Exception e) {\n                logger.severe(\"CmdService: Copying - CmdAgent getHostName exception\");\n                logger.log(Level.FINE, \"Exception\", e);\n            }\n        }\n        logger.fine(\"CmdService: Copying \" + srcfile + \" from \" + srcmachine\n                + \" to \" + destfile + \" in \" + destmachine);\n\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Read from src and write to dest.\n            buf = srcfilep.read();\n            destfilep.write(buf);\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                              \":\" + srcfile + \" to \" + destmachine + \":\" + destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return true;\n    }\n\n    public synchronized boolean move(String srcmachine, String destmachine,\n                                     String srcfile, String destfile,\n                                     boolean append) {\n        // First copy the file then delete\n        try {\n            if(this.copy(srcmachine, destmachine, srcfile, destfile, append)) {\n                FileAgent srcf = null;\n                int sidx = machinesList.indexOf(srcmachine);\n                int didx = machinesList.indexOf(destmachine);\n                if (sidx == didx && srcfile.equals(destfile))\n                    return(true);\n                srcf = filep.get(sidx);\n                return srcf.removeFile(srcfile);\n            }\n        }\n        catch(Exception ie) {\n            logger.severe(\"CmdService: Could not move \" + srcmachine +\n                        \":\" + srcfile + \" to \" + destmachine + \":\" +\n                        destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return false;\n    }\n\n    public String getTmpDir(String machine) {\n        try {\n            return findCmdAgent(machine).getTmpDir();\n        } catch (RemoteException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private CmdAgent findCmdAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return cmdp.get(index);\n    }\n\n    private FileAgent findFileAgent(String machine) {\n        if (machine == null || machine.length() == 0)\n            throw new IllegalArgumentException(\n                    \"Machine cannot be null or zero length\");\n        int index = machinesList.indexOf(machine);\n        if (index == -1)\n            throw new FabanHostUnknownException(\n                    \"Host \" + machine + \" not found!\");\n        return filep.get(index);\n    }\n\n\n    public synchronized boolean delete(String srcmachine, String srcfile) {\n        try {\n            return findFileAgent(srcmachine).removeFile(srcfile);\n        } catch (Exception ie) {\n                logger.severe(\"CmdService: Could not delete \" + srcmachine +\n                        \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return false;\n        }\n    }\n\n\n    /**\n     * Copy a file from one remote machine to a stream on the master.\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param srcfile - Name of source file\n     * @param stream The stream to copy the content to\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyToStream(String srcmachine, String srcfile, \n                                             OutputStream stream) {\n        FileService srcfilep = null;\n        byte[] buf = null;\n\n        FileAgent srcf = findFileAgent(srcmachine);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                stream.write(buf);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     * Copy a file from one remote machine to another\n     * This method essentially does the work of 'rcp'\n     * using the FileAgents on the machines\n     * @param srcmachine - Name of source machine\n     * @param destmachine - Name of destination machine\n     * @param srcfile - Name of source file\n     * @param destfile - Name of destination file\n     * @param append to dest file or overwrite it\n     * @return true/false if copy was successful/failed\n     */\n    public synchronized boolean copyBytes(String srcmachine,\n                                          String destmachine,\n                                          String srcfile, String destfile,\n                                          boolean append) {\n        FileAgent srcf, destf = null;\n        FileService srcfilep = null, destfilep = null;\n        int sidx = machinesList.indexOf(srcmachine);\n        int didx = machinesList.indexOf(destmachine);\n        byte[] buf = new byte[1000000];\n\n        //logger.info(\"CmdService: Copying \" + srcfile + \" to \" + destfile);\n        //logger.info(\"CmdService: Copying from \" + srcmachine + \" to \" + destmachine);\n        if (sidx == didx && srcfile.equals(destfile))\n            return(true);\n        srcf = filep.get(sidx);\n        destf = filep.get(didx);\n        try {\n            srcfilep = srcf.open(srcfile, FileAgent.READ);\n            if (append)\n                destfilep = destf.open(destfile, FileAgent.APPEND);\n            else\n                destfilep = destf.open(destfile, FileAgent.WRITE);\n\n            // Now loop, reading from src and writing to dest\n            while (true) {\n                buf = srcfilep.readBytes(1000000);\n                //\tlogger.info(\"           Read \" + buf);\n                //\tlogger.info(buf);\n                //\t\tlogger.info(buf.length);\n                destfilep.writeBytes(buf, 0 , buf.length);\n                if (buf.length < 1000000) {\n                    break;\n                }\n            }\n\n            srcfilep.close();\n            destfilep.close();\n        } catch (Exception ie) {\n            logger.severe(\"CmdService: Could not copy \" + srcmachine +\n                          \":\" + srcfile + \" to \" + destmachine + \":\" +\n                          destfile);\n            logger.log(Level.FINE, \"Exception\", ie);\n            return(false);\n        }\n        return(true);\n    }\n\n\n    /**\n     *\n     * The hostInterfaces Properties object stores mappings of machine name\n     * in the benchmark configuration to the corresponding interface of the\n     * master machine used to connect to that machine.\n     *\n     * @return Properties - the hostInterfaces oject.\n     */\n    public Properties getHostInterfaces() {\n        return hostInterfaces;\n    }\n\n    /**\n     * Set the Log level for Agents\n     * @param name Logger name\n     * @param level Log level\n     */\n    public void setLogLevel(String name, Level level) {\n        int i = 0;\n        try {\n            for (i = 0; i < cmdp.size(); i++) {\n                cmdp.get(i).setLogLevel(name, level);\n            }\n        } catch (Exception e) {\n            logger.severe(\" setLogLevel Failed for CmdAgent@\" + machinesList.get(i));\n            logger.log(Level.FINE, \"Exception\", e);\n        }\n    }\n\n    Registry getRegistry() {\n        return registry;\n    }\n\n    /**\n     * Checks whether the given remote file exists.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if exists, false otherwise.\n     */\n    public boolean doesFileExist(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).doesFileExist(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a normal file.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a normal file, false otherwise.\n     */\n    public boolean isFile(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isFile(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n\n    /**\n     * Checks whether the given remote file exists and is a directory.\n     * @param hostName The host name to check.\n     * @param fileName The file name to test.\n     * @return true if file is a directory, false otherwise.\n     */\n    public boolean isDirectory(String hostName, String fileName) {\n        try {\n            return findFileAgent(hostName).isDirectory(fileName);\n        } catch (Exception ie) {\n                logger.log(Level.SEVERE, \"CmdService: Could not check \" +\n                        hostName + \":\" + fileName, ie);\n            return false;\n        }\n    }\n}\n","lineNo":1306}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CommandHandleImpl.java,v 1.8 2008/01/29 23:18:22 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.common;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Implementation of the remote command handle.\n *\n * @author Akara Sucharitakul\n */\npublic class CommandHandleImpl implements CommandHandle {\n\n    static ThreadLocal streamReaders = new ThreadLocal() {\n\n        protected Object initialValue() {\n            ReaderThread[] readers = new ReaderThread[2];\n            for (int i = 0; i < readers.length; i++) {\n                readers[i] = new ReaderThread(i);\n            }\n            return readers;\n        }\n    };\n\n    Command command;\n\n    /**\n     * Saves the ReaderThreads of this Command in case some of the\n     * threads get abandoned.\n     */\n    ReaderThread[] readers = new ReaderThread[2];\n\n\n    /**\n     * Constructs the command handle implementation from a command.\n     * @param command The command object\n     * @throws RemoteException If the iml's stub is not available, run rmic\n     */\n    CommandHandleImpl(Command command) throws RemoteException {\n        this.command = command;\n        if (command.remote)\n            UnicastRemoteObject.exportObject(this);\n    }\n\n    /**\n     * Forfully terminates the command.\n     */\n    public void destroy() {\n        command.killed = true;\n        command.process.destroy();\n    }\n\n    /**\n     * Waits for the command to terminate.\n     *\n     * @throws InterruptedException The waiting thread got interrupted\n     */\n    public void waitFor() throws InterruptedException {\n        // Wait for the process to terminate\n        command.process.waitFor();\n        if (!command.daemon)\n            // For non-daemon, wait another max 10 secs to clear the streams\n            for (int i = 0; i < readers.length; i++)\n                readers[i].waitFor(10000);\n    }\n\n    /**\n     * Waits for the command to terminate, with a given timeout.\n     * @param timeout The time out\n     * @throws InterruptedException The waiting thread got interrupted.\n     */\n    public void waitFor(int timeout) throws InterruptedException {\n        long t = System.currentTimeMillis();\n        long dt = 0l;\n        if (!command.daemon) {\n            for (int i = 0; i < readers.length; i++) {\n                readers[i].waitFor((int) (timeout - dt));\n                dt = System.currentTimeMillis() - t;\n                if (timeout <= dt)\n                    break;\n            }\n        }\n    }\n\n\n    static byte[] readFile(String fileName) throws IOException {\n        FileChannel channel = (new FileInputStream(fileName)).getChannel();\n        long channelSize = channel.size();\n        if (channelSize >= Integer.MAX_VALUE)\n            throw new IOException(\"Cannot handle file size >= 2GB\");\n        ByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY,\n                0, channelSize);\n        byte[] content = new byte[(int) channelSize];\n        buffer.get(content);\n        return content;\n    }\n\n    /**\n     * Obtains the exit value of the command.\n     *\n     * @return The exit value of the command\n     */\n    public int exitValue() {\n        return command.process.exitValue();\n    }\n\n    /**\n     * Obtains the stdout or stderr of the command.\n     * @param streamId Command.STDOUT or Command.STDERR\n     * @return The output from stdout or stderr, or null if there is no output\n     * @throws IOException There is an error getting the output\n     */\n    public byte[] fetchOutput(int streamId) throws IOException {\n        if (command.streamHandling[streamId] == Command.TRICKLE_LOG)\n            throw new IllegalStateException(\"Output not available if \" +\n                    \"StreamHandling is TRICKLE_LOG\");\n        return readers[streamId].fetchOutput();\n    }\n\n    public void waitMatch() throws InterruptedException {\n        for (int i = 0; i < readers.length; i++)\n            readers[i].waitMatch();\n    }\n\n    void processLogs(Command command) {\n        ReaderThread[] readers = (ReaderThread[]) streamReaders.get();\n        for (int i = 0; i < readers.length; i++) {\n            while (!readers[i].read(command))\n                // Thread is abandoned if read returns false. Create new.\n                readers[i] = new ReaderThread(i);\n            // Save the references to prevent loss due to abandonment.\n            this.readers[i] = readers[i];\n        }\n    }\n\n    static class ReaderThread extends Thread {\n\n        int streamId;\n        byte[] buffer = new byte[8192];\n        byte[] matchSequence;\n        int matchSeqOffset = 0;\n        int offset = 0;\n        String outputFile = null;\n        FileOutputStream outStream = null;\n        Command command = null;\n        String cmdString;\n        boolean bufferOutput = Boolean.parseBoolean(\n                            System.getProperty(\"faban.command.buffer\", \"true\"));\n        boolean matched = true;\n        boolean abandoned = false;\n        Logger logger;\n\n        ReaderThread(int streamId) {\n            logger = Logger.getLogger(getClass().getName());\n            this.streamId = streamId;\n            setDaemon(true);\n            start();\n        }\n\n        public void run() {\n            logger.finest(Command.STREAM_NAME[streamId] +\n                    \" ReaderThread started.\");\n\n            while (!abandoned) {\n                boolean go = false;\n                synchronized (this) {\n                    if (command != null)\n                        go = true;\n                    else\n                        try {\n                            wait();\n                        } catch(InterruptedException e) {\n                        }\n                }\n                if (go)\n                    try {\n                        cmdString = command.command;\n                        logger.finest(\"Starting reading \" + Command.\n                                STREAM_NAME[streamId] + \" of \" + cmdString);\n\n                        if (command.streamMatch[streamId] != null) {\n                            matchSequence = command.streamMatch[streamId].getBytes();\n                            matched = false;\n                        } else {\n                            matchSequence = null;\n                            matched = true;\n                        }\n                        matchSeqOffset = 0;\n\n                        if (command.streamHandling[streamId] ==\n                                Command.TRICKLE_LOG) {\n                            trickleLog();\n                        } else {\n                            capture();\n                            if (command.streamHandling[streamId] ==\n                                Command.BULK_LOG) {\n                                byte[] b = fetchOutput();\n                                if (b != null)\n                                    logger.log(command.level[streamId],\n                                            cmdString + '\\n' +\n                                            Command.STREAM_NAME[streamId] +\n                                            \":\\n\" + new String(b));\n                            }\n                        }\n                    } catch (IOException e) {\n                        Level level;\n                        if (command.killed)\n                            level = Level.FINER;\n                        else\n                            level = Level.WARNING;\n\n                        logger.log(level, \"Error reading from log stream \" +\n                                \"from command \" + command.command + '.', e);\n                    } catch (Exception e) {\n                        logger.log(Level.WARNING,\n                                \"There is an error reading the log stream \" +\n                                \"from command \" + command.command + '.', e);\n                    } finally {\n                        synchronized(this) {\n                            command = null;\n                            notify();\n                        }                        \n                    }\n            }\n        }\n\n        synchronized boolean read(Command command) {\n            // If we start many things asynchronously, we may need to keep\n            // many threads. Threads that are not reusable are called\n            // abandoned threads.\n            if (this.command != null) {\n                abandoned = true;\n                logger.fine(\"Abandoning ReaderThread for \" +\n                        Command.STREAM_NAME[streamId]);\n                return false;\n            }\n\n            this.command = command;\n            notify();\n            return true;\n        }\n\n        synchronized void waitFor() throws InterruptedException {\n            while (command != null) {\n                if (command.daemon)\n                    return;\n                wait(10000);\n            }\n        }\n\n        /**\n         * Waits for the reader to timeout.\n         * @param timeOut The given timeout\n         * @throws InterruptedException\n         */\n        synchronized void waitFor(int timeOut) throws InterruptedException {\n            long dt = 0l;\n            long t = System.currentTimeMillis();\n            while (command != null && timeOut > dt) {\n                if (command.daemon)\n                    return ;\n                wait(timeOut - dt);\n                dt = System.currentTimeMillis() - t;\n            }\n            if (command != null)\n                logger.warning(\"Timed out waiting for command \" + command.command);\n        }\n\n        private void capture() throws IOException {\n            logger.finest(\"Capturing \" + Command.STREAM_NAME[streamId] +\n                          \" of \" + cmdString);\n            // Re-initialize buffer.\n            offset = 0;\n\n            // Save the outputFile name for after command no longer exists.\n            outputFile = command.outputFile[streamId];\n            outStream = null;\n            int length = command.stream[streamId].\n                    read(buffer, offset, buffer.length);\n\n            while (length != -1) {\n                match(buffer, offset, length);\n                offset += length;\n                // buffer full or not buffering, flush it\n                if (!bufferOutput || offset == buffer.length) {\n                    // Open file if not yet opened.\n                    if (outStream == null) {\n                        logger.finest(\"Writing \" + Command.STREAM_NAME[streamId]\n                                + \" to \" + outputFile);\n                        outStream = new FileOutputStream(outputFile);\n                    }\n                    outStream.write(buffer, 0, offset);\n                    offset = 0;\n                }\n                length = command.stream[streamId]\n                        .read(buffer, offset, buffer.length - offset);\n            }\n            command.stream[streamId].close();\n\n            logger.finest(Command.STREAM_NAME[streamId] + \" outputFile: \" +\n                    outputFile + \" outStream: \" + outStream + \" forceFile: \" +\n                    command.forceFile[streamId] + \" buffer size: \" + offset);\n            if (outStream == null && command.forceFile[streamId] &&\n                    offset > 0) {\n                logger.finest(\"Writing \" + Command.STREAM_NAME[streamId] +\n                        \" to \" + outputFile);\n                outStream = new FileOutputStream(outputFile);\n            }\n\n            if (outStream != null) {\n                // Flush the rest first.\n                outStream.write(buffer, 0, offset);\n                outStream.close();\n            }\n        }\n\n        private void trickleLog() throws IOException {\n            logger.finest(\"Trickeling log for \" +\n                    Command.STREAM_NAME[streamId]);\n            int length = command.stream[streamId].\n                    read(buffer, 0, buffer.length);\n\n            while (length != -1) {\n                logger.log(command.level[streamId], cmdString + '\\n' +\n                        Command.STREAM_NAME[streamId] + \":\\n\" +\n                        new String(buffer, 0, length));\n\n                match(buffer, 0, length);\n\n                length = command.stream[streamId]\n                        .read(buffer, 0, buffer.length);\n            }\n            command.stream[streamId].close();\n        }\n\n        byte[] fetchOutput() throws IOException {\n            logger.finest(\"Fetching output for \" +\n                    Command.STREAM_NAME[streamId]);\n\n            byte[] retBuffer = null;\n            if (outStream == null) { // If everything is still in memory\n                if (offset == 0) // Nothing read\n                    return null;\n                retBuffer = new byte[offset];\n                System.arraycopy(buffer, 0, retBuffer, 0, offset);\n            } else {\n                retBuffer = readFile(outputFile);\n            }\n            return retBuffer;\n        }\n\n        /**\n         * Matches the match string against the match buffer. Controls\n         * partial matches and calls the matchOld method to deal with the old\n         * buffer after missing the partial match. Calls matchNew to match\n         * the current buffer.\n         * @param b The buffer\n         * @param offset The offset into the buffer\n         * @param length The length of the part to match\n         */\n        private void match(byte[] b, int offset, int length) {\n            if (matched)\n                return;\n            if (matchSeqOffset > 0) { // A partial match\n                if (matchNew(b, offset, length)) // Do the partial match\n                    return;\n                while (matchOld())  // Scan whether there's another partial\n                    if (matchNew(b, offset, length)) // Do the other partial\n                        return;\n            }\n            matchNew(b, offset, length); // Do the full match\n        }\n\n        /**\n         * Matches the rest of the previous buffer. This method only gets\n         * called if there was a partial match. In that case, the interesting\n         * part of the previous buffer also is the match string all the way to\n         * but not including the offset. So we do not need to keep a copy of\n         * the previous buffer but just need to do a match of the match string\n         * against itself starting at offset 1 - offset 0 was already checked\n         * at previous buffer scan.\n         * @return True if there is a partial match, false otherwise\n         */\n        private boolean matchOld() {\n            mainLoop:\n            for (int i = 1; i < matchSeqOffset; i++) {\n                for (int j = 0; j < matchSequence.length; j++) {\n                    if (i + j >= matchSeqOffset) {\n                        matchSeqOffset = j;\n                        return true;\n                    }\n                    if (matchSequence[j] != matchSequence[i + j])\n                        continue mainLoop;\n                }\n            }\n            matchSeqOffset = 0;\n            return false;\n        }\n\n        /**\n         * Matches the rest of the sequence to the buffer. Note, returning\n         * true does not mean we found the match. It can also mean that we\n         * found a partial match ending the buffer.\n         * @param b The buffer\n         * @param offset Offset into the buffer\n         * @param length Length of the buffer\n         * @return Whether or not to stop matching this buffer\n         */\n        private boolean matchNew(byte[] b, int offset, int length) {\n            int endOffset = offset + length;\n            mainLoop:\n            for (int i = offset; i < endOffset; i++) {\n                for (int j = matchSeqOffset; j < matchSequence.length; j++) {\n                    if (i + j >= endOffset) {\n                        matchSeqOffset = j; // If we come to an end on this\n                        return true; // buffer, we need to stop matching it.\n                    }\n                    if (matchSequence[j] != b[i + j])\n                        continue mainLoop;\n                }\n                synchronized (this) {\n                    matched = true;\n                    notify();\n                    return true; // Stop matching if we found it.\n                }\n            }\n            return false; // Otherwise, continue checking matchOld\n        }\n\n        synchronized void waitMatch() throws InterruptedException {\n            while (!matched)\n                wait(1000);\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CommandHandleImpl.java,v 1.9 2008/03/14 06:31:33 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.common;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * Implementation of the remote command handle.\n *\n * @author Akara Sucharitakul\n */\npublic class CommandHandleImpl implements CommandHandle {\n\n    static ThreadLocal streamReaders = new ThreadLocal() {\n\n        protected Object initialValue() {\n            ReaderThread[] readers = new ReaderThread[2];\n            for (int i = 0; i < readers.length; i++) {\n                readers[i] = new ReaderThread(i);\n            }\n            return readers;\n        }\n    };\n\n    Command command;\n\n    /**\n     * Saves the ReaderThreads of this Command in case some of the\n     * threads get abandoned.\n     */\n    ReaderThread[] readers = new ReaderThread[2];\n\n\n    /**\n     * Constructs the command handle implementation from a command.\n     * @param command The command object\n     * @throws RemoteException If the iml's stub is not available, run rmic\n     */\n    CommandHandleImpl(Command command) throws RemoteException {\n        this.command = command;\n        if (command.remote)\n            UnicastRemoteObject.exportObject(this);\n    }\n\n    /**\n     * Obtains the command string this command handle represents.\n     *\n     * @return The command string executed.\n     */\n    public String getCommandString() throws RemoteException {\n        return command.command;\n    }\n\n    /**\n     * Forfully terminates the command.\n     */\n    public void destroy() {\n        command.killed = true;\n        command.process.destroy();\n    }\n\n    /**\n     * Waits for the command to terminate.\n     *\n     * @throws InterruptedException The waiting thread got interrupted\n     */\n    public void waitFor() throws InterruptedException {\n        // Wait for the process to terminate\n        command.process.waitFor();\n        if (!command.daemon)\n            // For non-daemon, wait another max 10 secs to clear the streams\n            for (int i = 0; i < readers.length; i++)\n                readers[i].waitFor(10000);\n    }\n\n    /**\n     * Waits for the command to terminate, with a given timeout.\n     * @param timeout The time out\n     * @throws InterruptedException The waiting thread got interrupted.\n     */\n    public void waitFor(int timeout) throws InterruptedException {\n        long t = System.currentTimeMillis();\n        long dt = 0l;\n        if (!command.daemon) {\n            for (int i = 0; i < readers.length; i++) {\n                readers[i].waitFor((int) (timeout - dt));\n                dt = System.currentTimeMillis() - t;\n                if (timeout <= dt)\n                    break;\n            }\n        }\n    }\n\n\n    static byte[] readFile(String fileName) throws IOException {\n        File f = new File(fileName);\n        long size = f.length();\n        if (size >= Integer.MAX_VALUE)\n            throw new IOException(\"Cannot handle file size >= 2GB\");\n\n        int readSize = (int) size;\n        FileInputStream in = new FileInputStream(f);\n        byte[] content = new byte[readSize];\n        int position = 0;\n        while (position < readSize) {\n            int c = in.read(content, position, readSize - position);\n            if (c >= 0) {\n                position += c;\n            } else { // Prematurely ran into eof\n                throw new IOException(\"Unexpected EOF reading file!\");\n            }\n        }\n        in.close();\n        return content;\n    }\n\n    /**\n     * Obtains the exit value of the command.\n     *\n     * @return The exit value of the command\n     */\n    public int exitValue() {\n        return command.process.exitValue();\n    }\n\n    /**\n     * Obtains the stdout or stderr of the command.\n     * @param streamId Command.STDOUT or Command.STDERR\n     * @return The output from stdout or stderr, or null if there is no output\n     * @throws IOException There is an error getting the output\n     */\n    public byte[] fetchOutput(int streamId) throws IOException {\n        if (command.streamHandling[streamId] == Command.TRICKLE_LOG)\n            throw new IllegalStateException(\"Output not available if \" +\n                    \"StreamHandling is TRICKLE_LOG\");\n        return readers[streamId].fetchOutput();\n    }\n\n    /**\n     * Obtains the stdout or stderr of the command and put it into file.\n     *\n     * @param streamId Command.STDOUT or Command.STDERR\n     * @param destFile The destination file on the calling system\n     * @return The FileTransfer, if called from remote system, the file is saved\n     * @throws java.io.IOException      There is an error getting the output\n     * @throws IllegalStateException    The command is not yet terminated or\n     *                                  does not record output\n     * @throws java.rmi.RemoteException A network error occurred\n     */\n    public FileTransfer fetchOutput(int streamId, String destFile) throws\n            IOException, IllegalStateException {\n        if (command.streamHandling[streamId] == Command.TRICKLE_LOG)\n            throw new IllegalStateException(\"Output not available if \" +\n                    \"StreamHandling is TRICKLE_LOG\");\n        return readers[streamId].fetchOutput(destFile);\n\n    }\n\n    public void waitMatch() throws InterruptedException {\n        for (int i = 0; i < readers.length; i++)\n            readers[i].waitMatch();\n    }\n\n    void processLogs(Command command) {\n        ReaderThread[] readers = (ReaderThread[]) streamReaders.get();\n        for (int i = 0; i < readers.length; i++) {\n            while (!readers[i].read(command))\n                // Thread is abandoned if read returns false. Create new.\n                readers[i] = new ReaderThread(i);\n            // Save the references to prevent loss due to abandonment.\n            this.readers[i] = readers[i];\n        }\n    }\n\n    static class ReaderThread extends Thread {\n\n        int streamId;\n        byte[] buffer = new byte[8192];\n        byte[] matchSequence;\n        int matchSeqOffset = 0;\n        int offset = 0;\n        String outputFile = null;\n        FileOutputStream outStream = null;\n        Command command = null;\n        String cmdString;\n        boolean bufferOutput = Boolean.parseBoolean(\n                            System.getProperty(\"faban.command.buffer\", \"true\"));\n        boolean matched = true;\n        boolean abandoned = false;\n        static Logger logger = Logger.getLogger(ReaderThread.class.getName());\n\n        ReaderThread(int streamId) {\n            this.streamId = streamId;\n            setDaemon(true);\n            start();\n        }\n\n        public void run() {\n            logger.finest(Command.STREAM_NAME[streamId] +\n                    \" ReaderThread started.\");\n\n            while (!abandoned) {\n                boolean go = false;\n                synchronized (this) {\n                    if (command != null)\n                        go = true;\n                    else\n                        try {\n                            wait();\n                        } catch(InterruptedException e) {\n                        }\n                }\n                if (go)\n                    try {\n                        cmdString = command.command;\n                        logger.finest(\"Starting reading \" + Command.\n                                STREAM_NAME[streamId] + \" of \" + cmdString);\n\n                        if (command.streamMatch[streamId] != null) {\n                            matchSequence = command.streamMatch[streamId].getBytes();\n                            matched = false;\n                        } else {\n                            matchSequence = null;\n                            matched = true;\n                        }\n                        matchSeqOffset = 0;\n\n                        if (command.streamHandling[streamId] ==\n                                Command.TRICKLE_LOG) {\n                            trickleLog();\n                        } else {\n                            capture();\n                            if (command.streamHandling[streamId] ==\n                                Command.BULK_LOG) {\n                                byte[] b = fetchOutput();\n                                if (b != null)\n                                    logger.log(command.level[streamId],\n                                            cmdString + '\\n' +\n                                            Command.STREAM_NAME[streamId] +\n                                            \":\\n\" + new String(b));\n                            }\n                        }\n                    } catch (IOException e) {\n                        Level level;\n                        if (command.killed)\n                            level = Level.FINER;\n                        else\n                            level = Level.WARNING;\n\n                        logger.log(level, \"Error reading from log stream \" +\n                                \"from command \" + command.command + '.', e);\n                    } catch (Exception e) {\n                        logger.log(Level.WARNING,\n                                \"There is an error reading the log stream \" +\n                                \"from command \" + command.command + '.', e);\n                    } finally {\n                        synchronized(this) {\n                            command = null;\n                            notify();\n                        }                        \n                    }\n            }\n        }\n\n        synchronized boolean read(Command command) {\n            // If we start many things asynchronously, we may need to keep\n            // many threads. Threads that are not reusable are called\n            // abandoned threads.\n            if (this.command != null) {\n                abandoned = true;\n                logger.fine(\"Abandoning ReaderThread for \" +\n                        Command.STREAM_NAME[streamId]);\n                return false;\n            }\n\n            this.command = command;\n            notify();\n            return true;\n        }\n\n        synchronized void waitFor() throws InterruptedException {\n            while (command != null) {\n                if (command.daemon)\n                    return;\n                wait(10000);\n            }\n        }\n\n        /**\n         * Waits for the reader to timeout.\n         * @param timeOut The given timeout\n         * @throws InterruptedException\n         */\n        synchronized void waitFor(int timeOut) throws InterruptedException {\n            long dt = 0l;\n            long t = System.currentTimeMillis();\n            while (command != null && timeOut > dt) {\n                if (command.daemon)\n                    return ;\n                wait(timeOut - dt);\n                dt = System.currentTimeMillis() - t;\n            }\n            if (command != null)\n                logger.warning(\"Timed out waiting for command \" + command.command);\n        }\n\n        private void capture() throws IOException {\n            logger.finest(\"Capturing \" + Command.STREAM_NAME[streamId] +\n                          \" of \" + cmdString);\n            // Re-initialize buffer.\n            offset = 0;\n\n            // Save the outputFile name for after command no longer exists.\n            outputFile = command.outputFile[streamId];\n            outStream = null;\n            int length = command.stream[streamId].\n                    read(buffer, offset, buffer.length);\n\n            while (length != -1) {\n                match(buffer, offset, length);\n                offset += length;\n                // buffer full or not buffering, flush it\n                if (!bufferOutput || offset == buffer.length) {\n                    // Open file if not yet opened.\n                    if (outStream == null) {\n                        logger.finest(\"Writing \" + Command.STREAM_NAME[streamId]\n                                + \" to \" + outputFile);\n                        outStream = new FileOutputStream(outputFile);\n                    }\n                    outStream.write(buffer, 0, offset);\n                    offset = 0;\n                }\n                length = command.stream[streamId]\n                        .read(buffer, offset, buffer.length - offset);\n            }\n            command.stream[streamId].close();\n\n            logger.finest(Command.STREAM_NAME[streamId] + \" outputFile: \" +\n                    outputFile + \" outStream: \" + outStream + \" forceFile: \" +\n                    command.forceFile[streamId] + \" buffer size: \" + offset);\n            if (outStream == null && command.forceFile[streamId] &&\n                    offset > 0) {\n                logger.finest(\"Writing \" + Command.STREAM_NAME[streamId] +\n                        \" to \" + outputFile);\n                outStream = new FileOutputStream(outputFile);\n            }\n\n            if (outStream != null) {\n                // Flush the rest first.\n                outStream.write(buffer, 0, offset);\n                outStream.close();\n            }\n        }\n\n        private void trickleLog() throws IOException {\n            logger.finest(\"Trickeling log for \" +\n                    Command.STREAM_NAME[streamId]);\n            int length = command.stream[streamId].\n                    read(buffer, 0, buffer.length);\n\n            while (length != -1) {\n                logger.log(command.level[streamId], cmdString + '\\n' +\n                        Command.STREAM_NAME[streamId] + \":\\n\" +\n                        new String(buffer, 0, length));\n\n                match(buffer, 0, length);\n\n                length = command.stream[streamId]\n                        .read(buffer, 0, buffer.length);\n            }\n            command.stream[streamId].close();\n        }\n\n        byte[] fetchOutput() throws IOException {\n            logger.finest(\"Fetching output for \" +\n                    Command.STREAM_NAME[streamId]);\n\n            byte[] retBuffer = null;\n            if (outStream == null) { // If everything is still in memory\n                if (offset == 0) // Nothing read\n                    return null;\n                retBuffer = new byte[offset];\n                System.arraycopy(buffer, 0, retBuffer, 0, offset);\n            } else {\n                retBuffer = readFile(outputFile);\n            }\n            return retBuffer;\n        }\n\n        FileTransfer fetchOutput(String destFile) throws IOException {\n            logger.finest(\"Fetching output for \" +\n                    Command.STREAM_NAME[streamId] + \" to \" + destFile);\n\n            FileTransfer transfer;\n            if (outStream == null) { // If everything is still in memory\n                if (offset == 0) // Nothing read\n                    return null;\n                transfer = new FileTransfer(buffer, 0, offset, destFile);\n            } else {\n                transfer = new FileTransfer(outputFile, destFile);\n            }\n            return transfer;\n        }\n\n        /**\n         * Matches the match string against the match buffer. Controls\n         * partial matches and calls the matchOld method to deal with the old\n         * buffer after missing the partial match. Calls matchNew to match\n         * the current buffer.\n         * @param b The buffer\n         * @param offset The offset into the buffer\n         * @param length The length of the part to match\n         */\n        private void match(byte[] b, int offset, int length) {\n            if (matched)\n                return;\n            if (matchSeqOffset > 0) { // A partial match\n                if (matchNew(b, offset, length)) // Do the partial match\n                    return;\n                while (matchOld())  // Scan whether there's another partial\n                    if (matchNew(b, offset, length)) // Do the other partial\n                        return;\n            }\n            matchNew(b, offset, length); // Do the full match\n        }\n\n        /**\n         * Matches the rest of the previous buffer. This method only gets\n         * called if there was a partial match. In that case, the interesting\n         * part of the previous buffer also is the match string all the way to\n         * but not including the offset. So we do not need to keep a copy of\n         * the previous buffer but just need to do a match of the match string\n         * against itself starting at offset 1 - offset 0 was already checked\n         * at previous buffer scan.\n         * @return True if there is a partial match, false otherwise\n         */\n        private boolean matchOld() {\n            mainLoop:\n            for (int i = 1; i < matchSeqOffset; i++) {\n                for (int j = 0; j < matchSequence.length; j++) {\n                    if (i + j >= matchSeqOffset) {\n                        matchSeqOffset = j;\n                        return true;\n                    }\n                    if (matchSequence[j] != matchSequence[i + j])\n                        continue mainLoop;\n                }\n            }\n            matchSeqOffset = 0;\n            return false;\n        }\n\n        /**\n         * Matches the rest of the sequence to the buffer. Note, returning\n         * true does not mean we found the match. It can also mean that we\n         * found a partial match ending the buffer.\n         * @param b The buffer\n         * @param offset Offset into the buffer\n         * @param length Length of the buffer\n         * @return Whether or not to stop matching this buffer\n         */\n        private boolean matchNew(byte[] b, int offset, int length) {\n            int endOffset = offset + length;\n            mainLoop:\n            for (int i = offset; i < endOffset; i++) {\n                for (int j = matchSeqOffset; j < matchSequence.length; j++) {\n                    if (i + j >= endOffset) {\n                        matchSeqOffset = j; // If we come to an end on this\n                        return true; // buffer, we need to stop matching it.\n                    }\n                    if (matchSequence[j] != b[i + j])\n                        continue mainLoop;\n                }\n                synchronized (this) {\n                    matched = true;\n                    notify();\n                    return true; // Stop matching if we found it.\n                }\n            }\n            return false; // Otherwise, continue checking matchOld\n        }\n\n        synchronized void waitMatch() throws InterruptedException {\n            while (!matched)\n                wait(1000);\n        }\n    }\n}\n","lineNo":129}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: InitFilter.java,v 1.2 2006/06/29 19:38:41 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n/**\n * Filter to ensure proper initialization of the Faban system on first request\n * to any Faban resource.\n *\n * @author Akara Sucharitakul\n */\npublic class InitFilter implements Filter {\n\n    ServletContext ctx;\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        ctx = filterConfig.getServletContext();\n    }\n\n    public void doFilter(ServletRequest request, ServletResponse response,\n                         FilterChain chain)\n            throws IOException, ServletException {\n        Engine.initIfNotInited(ctx, (HttpServletRequest) request);\n        chain.doFilter(request, response);\n    }\n\n    public void destroy() {\n        Engine.destroy();\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: InitFilter.java,v 1.3 2008/02/05 07:33:42 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.engine;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.util.logging.Logger;\nimport java.util.logging.Level;\n\n/**\n * Filter to ensure proper initialization of the Faban system on first request\n * to any Faban resource.\n *\n * @author Akara Sucharitakul\n */\npublic class InitFilter implements Filter {\n\n    ServletContext ctx;\n\n    public void init(FilterConfig filterConfig) throws ServletException {\n        ctx = filterConfig.getServletContext();\n    }\n\n    public void doFilter(ServletRequest request, ServletResponse response,\n                         FilterChain chain)\n            throws IOException, ServletException {\n        HttpServletResponse resp = null;\n        try {\n            resp = (HttpServletResponse) response;\n            HttpServletRequest req = (HttpServletRequest) request;\n            Engine.initIfNotInited(ctx, req);\n            chain.doFilter(request, response);\n        } catch (Throwable e) {\n            Logger.getLogger(this.getClass().getName()).\n                                        log(Level.SEVERE, e.getMessage(), e);\n            if (resp != null) {\n                resp.sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR,\n                                e.getMessage());\n                resp.flushBuffer();\n            }\n        }\n    }\n\n    public void destroy() {\n        Engine.destroy();\n    }\n}\n","lineNo":53}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdAgentImpl.java,v 1.13 2008/01/15 08:02:51 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandChecker;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * CmdAgentImpl is the class that runs remote commands for the CmdService\n * This implementation provides a robust means of running remote\n * commands. All error messages from the remote commands are logged\n * to the error log, which should help in debugging.\n * The user is encouraged not to run huge shell scripts using this\n * interface as the debugging advantages will be lost. Rather, try and\n * break up the task to running Java/native apps as far as possible\n * and use shell scripts sparingly. If the shell scripts spit out\n * periodic status messages indicating the position in its execution\n * cycle, this will aid in debugging.\n * <ul>\n * <li> It implements the CmdAgent interface; see the\n *      CmdAgent.java file for its description.\n * <li> Application-defined exceptions.\n * <\/ul>\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.CmdService\n */\npublic class CmdAgentImpl extends UnicastRemoteObject\n        implements CmdAgent, CommandChecker, Unreferenced {\n\n    private static Logger logger =\n            Logger.getLogger(CmdAgentImpl.class.getName());\n\n    // This is actually deprecated. The field is responsible for old style\n    // ident based executions.\n    private Map processMap = Collections.synchronizedMap(new HashMap());\n\n    private List<CommandHandle> handleList = Collections.synchronizedList(\n                                                new ArrayList<CommandHandle>());\n\n    private String[] baseClassPath;\n    Map<String, String> binMap;\n\n    static class CmdProcess {\n        String ident;\n        Process process;\n        String logs;\n\n        public CmdProcess() {\n        }\n\n        public CmdProcess(String ident, Process process, String logs) {\n            this.ident = ident;\n            this.process = process;\n            this.logs = logs;\n        }\n    }\n\n\n    // This class must be created only through the main method.\n    CmdAgentImpl(String benchName) throws RemoteException {\n        super();\n\n        try {\n            setBenchName(benchName);\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent.\", e);\n        }\n    }\n\n    void setBenchName(String benchName) throws Exception {\n        baseClassPath = getBaseClassPath(benchName);\n        binMap = CmdMap.getCmdMap(benchName);\n    }\n\n    // CmdAgent implementation\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     *\n     */\n    public String getHostName() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Only Other Agents should access the command agent using this method.\n     * So the access is limited to package level\n     * @return this Command Agent\n     */\n    static CmdAgent getHandle() {\n        return AgentBootstrap.cmd;\n    }\n\n    /**\n     * Obtains the tmp directory of a remote host.\n     *\n     * @return The tmp directory.\n     */\n    public String getTmpDir() {\n        return Config.TMP_DIR;\n    }\n\n    /**\n     * Set the logging level of the specified logger.\n     * @param name Name of the logger. If \"\" is passed the root logger level will be set.\n     * @param level The Log level to set\n     */\n    public void setLogLevel(String name, Level level) throws RemoteException {\n        LogManager.getLogManager().getLogger(name).setLevel(level);\n\n        //Update logging.properties file which is used by faban driver\n\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     *\n     * @param c The command to be executed\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException {\n        CommandHandle handle = c.execute(this);\n        if (!c.isSynchronous())\n            handleList.add(handle);\n        return handle;\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param c The command containing the main class\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException {\n        CommandHandle handle = c.executeJava(this);\n        if (!c.isSynchronous())\n            handleList.add(handle);\n        return handle;\n    }\n\n    /**\n     * Executes the RemoteCallable on the target instance.\n     *\n     * @param callable The callable to execute\n     * @return The type specified at creation of the callable.\n     * @throws Exception Any exception from the callable\n     */\n    public <V extends Serializable> V exec(RemoteCallable<V> callable)\n            throws Exception {\n\n        return callable.call();\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env)\n            throws Exception {\n        return startJavaCmd(cmd, identifier, env, null);\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @param classPath the class path to prepend to the base class path\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env,\n                                String[] classPath) throws Exception {\n\n        Process p;\n\n        StringBuffer buf = new StringBuffer(\" -cp \");\n        boolean falseEnding = false;\n        if (classPath != null)\n            for (int i = 0; i < classPath.length; i++) {\n                buf.append(classPath[i]);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n        for (int i = 0; i < baseClassPath.length; i++) {\n            buf.append(baseClassPath[i]);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        buf.append(' ');\n        String classpath = buf.toString();\n\n        cmd = AgentBootstrap.javaHome + File.separator + \"bin\" + File.separator + \"java \" +\n                AgentBootstrap.jvmOptions + classpath + cmd;\n        try {\n            logger.fine(\"Starting Java \" + cmd);\n            p = Runtime.getRuntime().exec(cmd, env);\n        }\n        catch (IOException e) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", e);\n            throw e;\n        }\n        processLogs(p);\n        if (p != null) {\n            processMap.put(identifier,\n                    new CmdProcess(identifier, p, processLogs(p)));\n\n            return true;\n        }\n        else\n            return false;\n    }\n\n    public boolean startAgent(Class agentClass, String identifier) throws Exception {\n        try {\n            Remote agent = (Remote)agentClass.newInstance();\n            logger.info(\"Agent class \" + agent.getClass().getName() + \" created\");\n            AgentBootstrap.registry.register(identifier, agent);\n            logger.fine(\"Agent started and Registered as \" + identifier);\n        }catch(Exception e) {\n            logger.log(Level.WARNING, \"Failed to create \" +\n                    agentClass.getName(), e);\n        }\n        return true;\n    }\n\n    /**\n     * This method is responsible for starting up the specified command\n     * in background\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd - actual command to execute\n     * @param identifier\t- String to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority to run command in\n     */\n    public boolean start (String cmd, String identifier, int priority)\n            throws Exception {\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            if(identifier != null)\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            return(true);\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Start command in background and wait for the specified message\n     * @param cmd to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public boolean start(String cmd, String ident, String msg, int priority)\n            throws Exception {\n\n        boolean ret = false;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                InputStream is = p.getInputStream();\n                BufferedReader bufR = new BufferedReader(new InputStreamReader(is));\n\n                // Just to make sure we don't wait for ever.\n                // We try for 1000 times to read before we give up\n                int attempts = 1000;\n                while(attempts-- > 0) {\n                    // make sure we don't block\n                    if(is.available() > 0) {\n                        String s = bufR.readLine();\n                        if((s !=  null) && (s.indexOf(msg) != -1)) {\n                            ret = true;\n                            break;\n                        }\n                    }\n                    else {\n                        try {\n                            Thread.sleep(100);\n                        } catch(Exception e){\n                            break;\n                        }\n                    }\n                }\n                bufR.close();\n            }\n            catch (Exception e){}\n\n            if(ident != null) {\n                processMap.put(ident,\n                        new CmdProcess(ident, p, processLogs(p)));\n            } // else we don't want to wait or kill this process later.\n        }\n        return(ret);\n    }\n    /**\n     * This method is responsible for starting the command in background\n     * and returning the first line of output.\n     * @param cmd command to start\n     * @param identifier to associate with this command, null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String cmd, String identifier, int priority)\n            throws Exception {\n\n        String retVal = null;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n                retVal = bufR.readLine();\n            }\n            catch (Exception e){}\n\n            if(identifier != null) {\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            }\n        }\n        return(retVal);\n    }\n\n    /**\n     * This method starts a command in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd : command to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean start (String cmd, int priority)\n            throws Exception {\n        boolean status = false;\n        Process p = createProcess(cmd, priority);\n\n        String errfile = processLogs(p);\n\n        /* Since this is in foreground, wait for it to complete */\n        try {\n            p.waitFor();\n        }\n        catch (InterruptedException ie) {\n            /* If we are interrupted, we were probably sent the kill signal */\n            p.destroy();\n        }\n\n        /* Now xfer logs (if any) */\n        xferLogs(errfile, cmd);\n\n        // Look at the exit value\n        if(p.exitValue() == 0)\n            status = true;\n\n        return(status);\n    }\n\n    /**\n         * This method starts a command in foreground\n         * The stdout from command is captured and returned.\n         * @param cmd : command to be started\n         * @param priority - class in which cmd should be run\n         * @return StringBuffer\n         */\n        public String startAndGetStdOut (String cmd, int priority)\n                throws Exception {\n            int readSize = 0;\n            int errReadSize = 0;\n            InputStream in,err;\n            byte[] buffer = new byte[8096];\n            StringBuffer std_out = new StringBuffer();\n            StringBuffer std_err = new StringBuffer();\n            Process p = createProcess(cmd, priority);\n\n            in = p.getInputStream();\n            err = p.getErrorStream();\n\n            // std_err.append(cmd);\n            // std_err.append(\"\\nstderr:\\n\");\n\n            boolean outClosed = false;\n            boolean errClosed = false;\n            for (;;) {\n                if (!outClosed && (readSize = in.read(buffer)) > 0)\n                    std_out.append(new String(buffer, 0, readSize));\n                if (!outClosed && readSize < 0)\n                    outClosed = true;\n                if (!errClosed && (errReadSize = err.read(buffer)) > 0)\n                    std_err.append(new String(buffer, 0, errReadSize));\n                if (!errClosed && errReadSize < 0)\n                    errClosed = true;\n                if (outClosed && errClosed)\n                    break;\n            }\n            logger.info(cmd + \"\\nstdout:\\n\" + std_out + \"\\nstderr:\\n\" + std_err);\n            /* Since this is in foreground, wait for it to complete */\n            try {\n                p.waitFor();\n                int exitValue = p.exitValue();\n                if (exitValue != 0) {\n                    logger.info(\"Warning: \" + \"Command exited with exit value - \" + exitValue );\n                }\n            } catch (InterruptedException e) {\n                /* If we are interrupted, we were probably sent the kill signal */\n                p.destroy();\n            }\n            in.close();\n            err.close();\n            return(std_out.toString());\n        }\n\n\n    /**\n     * This method runs a script in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean runScript (String cmd, int priority) throws Exception {\n        return start(cmd, priority);\n    }\n\n    /**\n     * This method is responsible for waiting for a command started\n     * earlier in background\n     * @param identifier with which this cmd was started\n     * @return true if command completed successfully\n     */\n    public boolean wait(String identifier) throws Exception {\n        boolean status;\n        CmdProcess cproc = (CmdProcess) processMap.get(identifier);\n        if (cproc == null) {\n            Exception e = new Exception(AgentBootstrap.ident + \" wait \" + identifier + \" : No such identifier\");\n            logger.throwing(AgentBootstrap.ident, \"wait\", e);\n            throw e;\n        }\n        logger.fine(\"Waiting for Command Identifier \" + identifier);\n\n        // Make sure nobody else is waiting for it.\n        synchronized (cproc) {\n            try {\n                cproc.process.waitFor();\n            }\n            catch (InterruptedException ie) {\n                cproc.process.destroy();\n            }\n            /* Now xfer logs (if any)*/\n            xferLogs(cproc.logs, cproc.ident);\n\n            if(cproc.process.exitValue() == 0)\n                status = true;\n            else\n                status = false;\n        }\n\n        /* Remove this command from our cache */\n        processMap.remove(cproc.ident);\n\n        return(status);\n    }\n\n    /**\n     * This method kills off the process specified\n     *\n     */\n    public void kill(String identifier) {\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        if (cproc == null)\n            // Such process no longer exists.\n            return;\n\n        cproc.process.destroy();\n\n        /* Now xfer logs (if any) to status and error logs*/\n        xferLogs(cproc.logs, cproc.ident);\n    }\n\n    /**\n     * This method is responsible for aborting a command using the killem\n     * script\n     * @param  identifier for the process. null if not started through\n     *               command service.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem (String identifier,\n                                     String processString, int sigNum)\n            throws RemoteException, IOException {\n\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        Object sync = cproc;\n        if (cproc == null)\n            sync = this;\n\n        // use exec to avoid creating another process\n        String s = \"exec \" + Config.BIN_DIR + \"perfkillem \" +\n                processString + \" -y -\" + sigNum;\n\n        synchronized (sync) {\n            logger.warning(\"Killing process with command \" + s);\n\n            try {\n                Process p = createProcess(s, Config.DEFAULT_PRIORITY);\n                p.waitFor();\n            }\n            catch (InterruptedException ie){\n            }\n            catch (Exception e) {\n                logger.log(Level.WARNING, \"Killem failed.\", e);\n            }\n        }\n    }\n\n    /**\n     * Kill off all processes started\n     */\n    public void kill() {\n        // Use an array of Idents as the vector gets manipulated by the kill(ident) call\n        String[] keys = new String[processMap.size()];\n        keys = (String[]) processMap.keySet().toArray(keys);\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i] != null)\n                kill(keys[i]);\n        }\n\n        // Now iterate the handle list and kill'em all.\n        for (CommandHandle handle : handleList) {\n            try {\n                handle.destroy();\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                        \"local CommandHandle destroy. \" +\n                        \"Please report bug.\", e);\n            }\n        }\n\n        for (int retries = 0; handleList.size() > 0 && retries < 20; retries++){\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                logger.log(Level.WARNING, \"Sleep Interrupted. Strange!\", e);\n            }\n\n            // We need to use iterator instead of foreach loop as we need to\n            // remove handles from the list while going through it.\n            Iterator<CommandHandle> iter = handleList.iterator();\n            while (iter.hasNext()) {\n                CommandHandle handle = iter.next();\n                boolean terminated = false;\n                try {\n                    int exitValue = handle.exitValue();\n                    logger.finer(\"Command exited with exit value \" +\n                            exitValue + '.');\n                    terminated = true;\n                } catch (RemoteException e) {\n                    logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                            \"local CommandHandle exitValue. \" +\n                            \"Please report bug.\", e);\n                } catch (IllegalThreadStateException e) {\n                    logger.log(Level.FINER, \"Registry did not terminate! \", e);\n                }\n\n                if (terminated)\n                    iter.remove();\n                else\n                    try { // kill again...\n                        handle.destroy();\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy. \" +\n                                \"Please report bug.\", e);\n                    }\n            }\n        }\n\n        int leftover = handleList.size();\n        if (leftover > 0) {\n            logger.warning(\"Process termination/cleanup unsuccessful after \" +\n                    \"20 attempts. \" + leftover + \" processes remaining. This \" +\n                    \"may affect subsequent runs.\");\n            handleList.clear();\n        }\n\n        /* Exit application */\n        try {\n            AgentBootstrap.deregisterAgents();\n        } catch (RemoteException re){\n            logger.log(Level.WARNING, re.getMessage(), re);\n        }\n\n        logger.fine(\"Killing itself\");\n\n        // *** This is to gracefully return from this method.\n        // *** The Agent will exit after 5 seconds\n        // *** If the System.exit(0) is called in this method\n        // *** the Service will get a RemoteException\n        Thread exitThread = new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(5000);\n                    AgentBootstrap.terminateAgents();\n                } catch (Exception e) {}\n            }\n        };\n        exitThread.start();\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     *\n     * @see         java.rmi.server.Unreferenced\n     *\n     */\n    public void unreferenced()\n    {\n        kill();\n    }\n\n    public static Registry getRegistry() {\n        return AgentBootstrap.registry;\n    }\n\n    public static String getHost() {\n        return AgentBootstrap.host;\n    }\n\n    public static String getMaster() {\n        return AgentBootstrap.master;\n    }\n\n    private Process createProcess(String cmd, int priority) throws Exception {\n        Process p;\n        cmd = checkCommand(cmd);\n        String args[] = new String[7];\n\n        args[0] = \"priocntl\";\n        args[1] = \"-e\";\n        args[2] = \"-c\";\n        args[3] = (priority == Config.DEFAULT_PRIORITY) ? \"TS\" : \"RT\";\n        args[4] = \"sh\";\n        args[5] = \"-c\";\n        args[6] = cmd;\n\n        try {\n            logger.fine(\"Starting Command : \" + cmd );\n            p = Runtime.getRuntime().exec(args);\n        }\n        catch (IOException ie) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", ie);\n            throw ie;\n        }\n        return p;\n    }\n\n    /**\n     * Method that handles errors from commands\n     * This method captures any messages on stderr and\n     * stdout of the given Process and logs them.\n     * @param proc Process whose stderr needs to be logged\n     * @return filename in which errors are logged\n     */\n    private String processLogs(Process proc)\n    {\n        InputStream err = proc.getErrorStream();\n        InputStream log = proc.getInputStream();\n        // Create a unique temporary log file in tmp dir\n        String errFile =\n                Config.TMP_DIR + \"cmd\" + proc.hashCode();\n        String logFile = errFile + \"-out\";\n\n        // Create Log writer for errors\n        try {\n            new LogWriter(err, errFile);\n        }\n        catch (IOException ie) {\n            logger.warning(\"Could not write to \" + errFile);\n            return(null);\n        }\n\n        // Create Log writer for stdout\n        try {\n            new LogWriter(log, logFile);\n        }\n        catch (IOException ie) {\n            try {\n                logger.warning(\"Could not write to \" + logFile);\n            }\n            catch (Exception e){}\n        }\n\n        logger.fine(\"Created Error File \" + errFile);\n        logger.fine(\"Created Log File \" + logFile);\n        return errFile;\n    }\n\n    /**\n     * This method saves messages on stderr of the given\n     * Process and logs them to the errorlog.\n     * @param errFile Filename of the stderr log\n     * @param cmd command which generated errors\n     */\n    private boolean xferLogs(String errFile, String cmd) {\n        boolean status = true;\n        // First check if file has any  error messages\n        File f = new File(errFile);\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in log identifying source of errors\n                    buf.append(cmd);\n                    buf.append(\"\\nstderr:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.warning(buf.toString());\n                    status = false;\n                }\n                in.close();\n                f.delete();\n            }\n            // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n\n        // Copy std out\n        // First check if file has any message\n        f = new File(errFile + \"-out\");\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in ststus log identifying source of messages\n                    buf.append(cmd);\n                    buf.append(\"\\nstdout:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.info(buf.toString());\n                }\n                in.close();\n                f.delete();\n            }\n                    // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n        return status;\n    }\n\n    /**\n     * Checks and completes the command, if possible.\n     * @param cmd The original command\n     * @return The completed command\n     */\n    public String checkCommand(String cmd) {\n        String bin;\n        int idx = cmd.indexOf(' ');\n        if (idx == -1)\n            bin = cmd;\n        else\n            bin = cmd.substring(0, idx);\n        if (bin.indexOf(File.separator) != -1)\n            // The path is part of the command, use it as is\n            return cmd;\n        String path = (String) binMap.get(bin);\n        if (path == null) // Don't find it, just try as is\n            return cmd;\n        if (idx == -1)\n            return path;\n        return path + cmd.substring(idx);\n    }\n\n    /**\n     * Checks and completes the java command, if possible.\n     *\n     * @param cmd The original command\n     * @return The completed java command\n     */\n    public String checkJavaCommand(String cmd) {\n\n        StringBuilder buf = new StringBuilder(AgentBootstrap.javaHome);\n        buf.append(File.separator);\n        buf.append(\"bin\");\n        buf.append(File.separator);\n        buf.append(\"java \");\n        buf.append(AgentBootstrap.jvmOptions);\n        buf.append(\" -cp \");\n\n        boolean falseEnding = false;\n        // Externally specified classpath takes precedence.\n        for (String pathElement : AgentBootstrap.extClassPath) {\n            buf.append(pathElement);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        for (String pathElement : baseClassPath) {    ;\n            buf.append(pathElement);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        buf.append(' ');\n        buf.append(cmd);\n        return buf.toString();\n    }\n\n    private static String[] getBaseClassPath(String benchName) {\n        // The benchmark-specific libs take precedence, add first to list\n        ArrayList libList = new ArrayList();\n        File libDir = new File(Config.BENCHMARK_DIR + benchName + \"/lib/\");\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        libDir = new File(Config.LIB_DIR);\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        String[] baseClassPath = new String[libList.size()];\n        baseClassPath = (String[]) libList.toArray(baseClassPath);\n        return baseClassPath;\n    }\n\n    /**\n     * This method is for measuring the latency communicating from master\n     * to client and back for setting time. The implementation should\n     * call the OS command to get the time to have some realistic latency.\n     *\n     * @param sampleArg Included arg to really measure latency.\n     */\n    public void probeLatency(String sampleArg)  {\n        Command c = new Command(\"date\");\n        c.setLogLevel(Command.STDOUT, Level.FINE);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            if (c.execute(this).exitValue() != 0)\n                logger.log(Level.WARNING, \"Error executing \\\"date\\\".\");\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error executing date.\", e);\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted executing date.\", e);\n        }\n    }\n\n    /**\n     * Sets the time on the agent host, in GMT. The time string\n     * must be in the format MMddHHmmyyyy.ss according to Unix date specs\n     * and must be in GMT time.\n     *\n     * @param gmtTimeString Time string in format\n     */\n    public void setTime(String gmtTimeString) {\n        Command c = new Command(\"date -u \" + gmtTimeString);\n        c.setLogLevel(Command.STDOUT, Level.FINE);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            if (c.execute(this).exitValue() != 0);\n                logger.log(Level.WARNING, \"Error on \\\"date\\\" command trying \" +\n                                            \"to set the date.\");\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error setting date.\", e);\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted setting date.\", e);\n        }\n    }\n\n    /**\n     * Gets the time on the agent host, in millis.\n     *\n     * @return The time on the remote system.\n     */\n    public long getTime() {\n        return System.currentTimeMillis();\n    }\n\n    // The class which spawns a thread to read the stream of the process\n    // and dumps it into the tmp file.\n    class LogWriter extends Thread {\n        BufferedReader in;\n        PrintStream out;\n\n        /**\n         * Constructor\n         * Open files and start thread\n         *\n         * @param is InputStream to read from\n         * @param logfile String filename to log to\n         */\n        public LogWriter(InputStream is, String logfile) throws IOException {\n            in = new BufferedReader(new InputStreamReader(is));\n            out = new PrintStream(new FileOutputStream(logfile));\n            this.start();\n        }\n\n        /**\n         * Run, copying input stream's contents to output until no\n         * more data in input file. Exit thread automatically.\n         */\n        public void run() {\n            try {\n                String str = in.readLine();\n                while (str != null) {\n                    out.println(str);\n                    str = in.readLine();\n                }\n            } catch (IOException ie) {\n                return;\n            }\n            return;\n        }\n    }\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: CmdAgentImpl.java,v 1.14 2008/02/01 22:53:55 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.harness.agent;\n\nimport com.sun.faban.common.Command;\nimport com.sun.faban.common.CommandChecker;\nimport com.sun.faban.common.CommandHandle;\nimport com.sun.faban.common.Registry;\nimport com.sun.faban.harness.RemoteCallable;\nimport com.sun.faban.harness.common.Config;\nimport com.sun.faban.harness.util.CmdMap;\n\nimport java.io.*;\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\nimport java.rmi.server.UnicastRemoteObject;\nimport java.rmi.server.Unreferenced;\nimport java.util.*;\nimport java.util.logging.Level;\nimport java.util.logging.LogManager;\nimport java.util.logging.Logger;\n\n/**\n * CmdAgentImpl is the class that runs remote commands for the CmdService\n * This implementation provides a robust means of running remote\n * commands. All error messages from the remote commands are logged\n * to the error log, which should help in debugging.\n * The user is encouraged not to run huge shell scripts using this\n * interface as the debugging advantages will be lost. Rather, try and\n * break up the task to running Java/native apps as far as possible\n * and use shell scripts sparingly. If the shell scripts spit out\n * periodic status messages indicating the position in its execution\n * cycle, this will aid in debugging.\n * <ul>\n * <li> It implements the CmdAgent interface; see the\n *      CmdAgent.java file for its description.\n * <li> Application-defined exceptions.\n * <\/ul>\n *\n * @author Ramesh Ramachandran\n * @see com.sun.faban.harness.agent.CmdAgent\n * @see com.sun.faban.harness.engine.CmdService\n */\npublic class CmdAgentImpl extends UnicastRemoteObject\n        implements CmdAgent, CommandChecker, Unreferenced {\n\n    private static Logger logger =\n            Logger.getLogger(CmdAgentImpl.class.getName());\n\n    // This is actually deprecated. The field is responsible for old style\n    // ident based executions.\n    private Map processMap = Collections.synchronizedMap(new HashMap());\n\n    private List<CommandHandle> handleList = Collections.synchronizedList(\n                                                new ArrayList<CommandHandle>());\n\n    private String[] baseClassPath;\n    Map<String, String> binMap;\n\n    static class CmdProcess {\n        String ident;\n        Process process;\n        String logs;\n\n        public CmdProcess() {\n        }\n\n        public CmdProcess(String ident, Process process, String logs) {\n            this.ident = ident;\n            this.process = process;\n            this.logs = logs;\n        }\n    }\n\n\n    // This class must be created only through the main method.\n    CmdAgentImpl(String benchName) throws RemoteException {\n        super();\n\n        try {\n            setBenchName(benchName);\n        } catch(Exception e) {\n            logger.log(Level.SEVERE, \"Failed to initialize CmdAgent.\", e);\n        }\n    }\n\n    void setBenchName(String benchName) throws Exception {\n        baseClassPath = getBaseClassPath(benchName);\n        binMap = CmdMap.getCmdMap(benchName);\n    }\n\n    // CmdAgent implementation\n\n    /**\n     * Return the hostname of this machine as known to this machine\n     * itself. This method is included in order to solve a Naming problem\n     * related to the names of the tpcw result files to be transferred to the\n     * the master machine.\n     *\n     */\n    public String getHostName() {\n        return AgentBootstrap.host;\n    }\n\n    /**\n     * Only Other Agents should access the command agent using this method.\n     * So the access is limited to package level\n     * @return this Command Agent\n     */\n    static CmdAgent getHandle() {\n        return AgentBootstrap.cmd;\n    }\n\n    /**\n     * Obtains the tmp directory of a remote host.\n     *\n     * @return The tmp directory.\n     */\n    public String getTmpDir() {\n        return Config.TMP_DIR;\n    }\n\n    /**\n     * Set the logging level of the specified logger.\n     * @param name Name of the logger. If \"\" is passed the root logger level will be set.\n     * @param level The Log level to set\n     */\n    public void setLogLevel(String name, Level level) throws RemoteException {\n        LogManager.getLogManager().getLogger(name).setLevel(level);\n\n        //Update logging.properties file which is used by faban driver\n\n    }\n\n    /**\n     * Executes a command from the remote command agent.\n     *\n     * @param c The command to be executed\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle execute(Command c)\n            throws IOException, InterruptedException {\n        CommandHandle handle = c.execute(this);\n        if (!c.isSynchronous())\n            handleList.add(handle);\n        return handle;\n    }\n\n    /**\n     * Executes a java command from the remote command agent.\n     * @param c The command containing the main class\n     * @return A handle to the command\n     * @throws IOException Error communicating with resulting process\n     * @throws InterruptedException Thread got interrupted waiting\n     */\n    public CommandHandle java(Command c)\n            throws IOException, InterruptedException {\n        CommandHandle handle = c.executeJava(this);\n        if (!c.isSynchronous())\n            handleList.add(handle);\n        return handle;\n    }\n\n    /**\n     * Executes the RemoteCallable on the target instance.\n     *\n     * @param callable The callable to execute\n     * @return The type specified at creation of the callable.\n     * @throws Exception Any exception from the callable\n     */\n    public <V extends Serializable> V exec(RemoteCallable<V> callable)\n            throws Exception {\n\n        return callable.call();\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env)\n            throws Exception {\n        return startJavaCmd(cmd, identifier, env, null);\n    }\n\n    /**\n     * This method is responsible for starting a java cmd in background\n     * @param cmd args and class to start the JVM\n     * @param identifier to associate with this command\n     * @param env in which to run command\n     * @param classPath the class path to prepend to the base class path\n     * @return \ttrue if command started successfully\n     */\n    public boolean startJavaCmd(String cmd, String identifier, String[] env,\n                                String[] classPath) throws Exception {\n\n        Process p;\n\n        StringBuffer buf = new StringBuffer(\" -cp \");\n        boolean falseEnding = false;\n        if (classPath != null)\n            for (int i = 0; i < classPath.length; i++) {\n                buf.append(classPath[i]);\n                buf.append(File.pathSeparator);\n                falseEnding = true;\n            }\n        for (int i = 0; i < baseClassPath.length; i++) {\n            buf.append(baseClassPath[i]);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        buf.append(' ');\n        String classpath = buf.toString();\n\n        cmd = AgentBootstrap.javaHome + File.separator + \"bin\" + File.separator + \"java \" +\n                AgentBootstrap.jvmOptions + classpath + cmd;\n        try {\n            logger.fine(\"Starting Java \" + cmd);\n            p = Runtime.getRuntime().exec(cmd, env);\n        }\n        catch (IOException e) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", e);\n            throw e;\n        }\n        processLogs(p);\n        if (p != null) {\n            processMap.put(identifier,\n                    new CmdProcess(identifier, p, processLogs(p)));\n\n            return true;\n        }\n        else\n            return false;\n    }\n\n    public boolean startAgent(Class agentClass, String identifier) throws Exception {\n        try {\n            Remote agent = (Remote)agentClass.newInstance();\n            logger.info(\"Agent class \" + agent.getClass().getName() + \" created\");\n            AgentBootstrap.registry.register(identifier, agent);\n            logger.fine(\"Agent started and Registered as \" + identifier);\n        }catch(Exception e) {\n            logger.log(Level.WARNING, \"Failed to create \" +\n                    agentClass.getName(), e);\n        }\n        return true;\n    }\n\n    /**\n     * This method is responsible for starting up the specified command\n     * in background\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd - actual command to execute\n     * @param identifier\t- String to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority to run command in\n     */\n    public boolean start (String cmd, String identifier, int priority)\n            throws Exception {\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            if(identifier != null)\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            return(true);\n        }\n        else\n            return false;\n    }\n\n    /**\n     * Start command in background and wait for the specified message\n     * @param cmd to be started\n     * @param ident to identify this command later null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param msg message to which wait for\n     * @param priority (default or higher priority) for command\n     */\n    public boolean start(String cmd, String ident, String msg, int priority)\n            throws Exception {\n\n        boolean ret = false;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                InputStream is = p.getInputStream();\n                BufferedReader bufR = new BufferedReader(new InputStreamReader(is));\n\n                // Just to make sure we don't wait for ever.\n                // We try for 1000 times to read before we give up\n                int attempts = 1000;\n                while(attempts-- > 0) {\n                    // make sure we don't block\n                    if(is.available() > 0) {\n                        String s = bufR.readLine();\n                        if((s !=  null) && (s.indexOf(msg) != -1)) {\n                            ret = true;\n                            break;\n                        }\n                    }\n                    else {\n                        try {\n                            Thread.sleep(100);\n                        } catch(Exception e){\n                            break;\n                        }\n                    }\n                }\n                bufR.close();\n            }\n            catch (Exception e){}\n\n            if(ident != null) {\n                processMap.put(ident,\n                        new CmdProcess(ident, p, processLogs(p)));\n            } // else we don't want to wait or kill this process later.\n        }\n        return(ret);\n    }\n    /**\n     * This method is responsible for starting the command in background\n     * and returning the first line of output.\n     * @param cmd command to start\n     * @param identifier to associate with this command, null if you don't want to do wait\n     *              or kill the process when the cmdAgent exits.\n     * @param priority in which to run command\n     * @return String the first line of output from the command\n     */\n    public String startAndGetOneOutputLine(String cmd, String identifier, int priority)\n            throws Exception {\n\n        String retVal = null;\n\n        Process p = createProcess(cmd, priority);\n        if (p != null) {\n            try {\n                BufferedReader bufR = new BufferedReader(\n                        new InputStreamReader(p.getInputStream()));\n                retVal = bufR.readLine();\n            }\n            catch (Exception e){}\n\n            if(identifier != null) {\n                processMap.put(identifier,\n                        new CmdProcess(identifier, p, processLogs(p)));\n            }\n        }\n        return(retVal);\n    }\n\n    /**\n     * This method starts a command in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd : command to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean start (String cmd, int priority)\n            throws Exception {\n        boolean status = false;\n        Process p = createProcess(cmd, priority);\n\n        String errfile = processLogs(p);\n\n        /* Since this is in foreground, wait for it to complete */\n        try {\n            p.waitFor();\n        }\n        catch (InterruptedException ie) {\n            /* If we are interrupted, we were probably sent the kill signal */\n            p.destroy();\n        }\n\n        /* Now xfer logs (if any) */\n        xferLogs(errfile, cmd);\n\n        // Look at the exit value\n        if(p.exitValue() == 0)\n            status = true;\n\n        return(status);\n    }\n\n    /**\n         * This method starts a command in foreground\n         * The stdout from command is captured and returned.\n         * @param cmd : command to be started\n         * @param priority - class in which cmd should be run\n         * @return StringBuffer\n         */\n        public String startAndGetStdOut (String cmd, int priority)\n                throws Exception {\n            int readSize = 0;\n            int errReadSize = 0;\n            InputStream in,err;\n            byte[] buffer = new byte[8096];\n            StringBuffer std_out = new StringBuffer();\n            StringBuffer std_err = new StringBuffer();\n            Process p = createProcess(cmd, priority);\n\n            in = p.getInputStream();\n            err = p.getErrorStream();\n\n            // std_err.append(cmd);\n            // std_err.append(\"\\nstderr:\\n\");\n\n            boolean outClosed = false;\n            boolean errClosed = false;\n            for (;;) {\n                if (!outClosed && (readSize = in.read(buffer)) > 0)\n                    std_out.append(new String(buffer, 0, readSize));\n                if (!outClosed && readSize < 0)\n                    outClosed = true;\n                if (!errClosed && (errReadSize = err.read(buffer)) > 0)\n                    std_err.append(new String(buffer, 0, errReadSize));\n                if (!errClosed && errReadSize < 0)\n                    errClosed = true;\n                if (outClosed && errClosed)\n                    break;\n            }\n            logger.info(cmd + \"\\nstdout:\\n\" + std_out + \"\\nstderr:\\n\" + std_err);\n            /* Since this is in foreground, wait for it to complete */\n            try {\n                p.waitFor();\n                int exitValue = p.exitValue();\n                if (exitValue != 0) {\n                    logger.info(\"Warning: \" + \"Command exited with exit value - \" + exitValue );\n                }\n            } catch (InterruptedException e) {\n                /* If we are interrupted, we were probably sent the kill signal */\n                p.destroy();\n            }\n            in.close();\n            err.close();\n            return(std_out.toString());\n        }\n\n\n    /**\n     * This method runs a script in foreground\n     * The stderr from command is captured and logged to the errorlog.\n     * @param cmd to be started\n     * @param priority - class in which cmd should be run\n     * @return boolean true if command completed successfully\n     */\n    public boolean runScript (String cmd, int priority) throws Exception {\n        return start(cmd, priority);\n    }\n\n    /**\n     * This method is responsible for waiting for a command started\n     * earlier in background\n     * @param identifier with which this cmd was started\n     * @return true if command completed successfully\n     */\n    public boolean wait(String identifier) throws Exception {\n        boolean status;\n        CmdProcess cproc = (CmdProcess) processMap.get(identifier);\n        if (cproc == null) {\n            Exception e = new Exception(AgentBootstrap.ident + \" wait \" + identifier + \" : No such identifier\");\n            logger.throwing(AgentBootstrap.ident, \"wait\", e);\n            throw e;\n        }\n        logger.fine(\"Waiting for Command Identifier \" + identifier);\n\n        // Make sure nobody else is waiting for it.\n        synchronized (cproc) {\n            try {\n                cproc.process.waitFor();\n            }\n            catch (InterruptedException ie) {\n                cproc.process.destroy();\n            }\n            /* Now xfer logs (if any)*/\n            xferLogs(cproc.logs, cproc.ident);\n\n            if(cproc.process.exitValue() == 0)\n                status = true;\n            else\n                status = false;\n        }\n\n        /* Remove this command from our cache */\n        processMap.remove(cproc.ident);\n\n        return(status);\n    }\n\n    /**\n     * This method kills off the process specified\n     *\n     */\n    public void kill(String identifier) {\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        if (cproc == null)\n            // Such process no longer exists.\n            return;\n\n        cproc.process.destroy();\n\n        /* Now xfer logs (if any) to status and error logs*/\n        xferLogs(cproc.logs, cproc.ident);\n    }\n\n    /**\n     * This method is responsible for aborting a command using the killem\n     * script\n     * @param  identifier for the process. null if not started through\n     *               command service.\n     * @param processString search string to grep the process while killing\n     *                      (same as in killem)\n     * @param sigNum the signal number to be used to kill.\n     *\n     */\n    public void killem (String identifier,\n                                     String processString, int sigNum)\n            throws RemoteException, IOException {\n\n        CmdProcess cproc = (CmdProcess) processMap.remove(identifier);\n        Object sync = cproc;\n        if (cproc == null)\n            sync = this;\n\n        // use exec to avoid creating another process\n        String s = \"exec \" + Config.BIN_DIR + \"perfkillem \" +\n                processString + \" -y -\" + sigNum;\n\n        synchronized (sync) {\n            logger.warning(\"Killing process with command \" + s);\n\n            try {\n                Process p = createProcess(s, Config.DEFAULT_PRIORITY);\n                p.waitFor();\n            }\n            catch (InterruptedException ie){\n            }\n            catch (Exception e) {\n                logger.log(Level.WARNING, \"Killem failed.\", e);\n            }\n        }\n    }\n\n    /**\n     * Kill off all processes started\n     */\n    public void kill() {\n        // Use an array of Idents as the vector gets manipulated by the kill(ident) call\n        String[] keys = new String[processMap.size()];\n        keys = (String[]) processMap.keySet().toArray(keys);\n        for (int i = 0; i < keys.length; i++) {\n            if (keys[i] != null)\n                kill(keys[i]);\n        }\n\n        // Now iterate the handle list and kill'em all.\n        for (CommandHandle handle : handleList) {\n            try {\n                handle.destroy();\n            } catch (RemoteException e) {\n                logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                        \"local CommandHandle destroy. \" +\n                        \"Please report bug.\", e);\n            }\n        }\n\n        for (int retries = 0; handleList.size() > 0 && retries < 20; retries++){\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                logger.log(Level.WARNING, \"Sleep Interrupted. Strange!\", e);\n            }\n\n            // We need to use iterator instead of foreach loop as we need to\n            // remove handles from the list while going through it.\n            Iterator<CommandHandle> iter = handleList.iterator();\n            while (iter.hasNext()) {\n                CommandHandle handle = iter.next();\n                boolean terminated = false;\n                try {\n                    int exitValue = handle.exitValue();\n                    logger.finer(\"Command exited with exit value \" +\n                            exitValue + '.');\n                    terminated = true;\n                } catch (RemoteException e) {\n                    logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                            \"local CommandHandle exitValue. \" +\n                            \"Please report bug.\", e);\n                } catch (IllegalThreadStateException e) {\n                    logger.log(Level.FINER, \"Registry did not terminate! \", e);\n                }\n\n                if (terminated)\n                    iter.remove();\n                else\n                    try { // kill again...\n                        handle.destroy();\n                    } catch (RemoteException e) {\n                        logger.log(Level.SEVERE, \"Caught RemoteException on \" +\n                                \"local CommandHandle destroy. \" +\n                                \"Please report bug.\", e);\n                    }\n            }\n        }\n\n        int leftover = handleList.size();\n        if (leftover > 0) {\n            logger.warning(\"Process termination/cleanup unsuccessful after \" +\n                    \"20 attempts. \" + leftover + \" processes remaining. This \" +\n                    \"may affect subsequent runs.\");\n            handleList.clear();\n        }\n\n        /* Exit application */\n        try {\n            AgentBootstrap.deregisterAgents();\n        } catch (RemoteException re){\n            logger.log(Level.WARNING, re.getMessage(), re);\n        }\n\n        logger.fine(\"Killing itself\");\n\n        // *** This is to gracefully return from this method.\n        // *** The Agent will exit after 5 seconds\n        // *** If the System.exit(0) is called in this method\n        // *** the Service will get a RemoteException\n        Thread exitThread = new Thread() {\n            public void run() {\n                try {\n                    Thread.sleep(5000);\n                    AgentBootstrap.terminateAgents();\n                } catch (Exception e) {}\n            }\n        };\n        exitThread.start();\n    }\n\n    /**\n     * When this instance is unreferenced the application must exit.\n     *\n     * @see         java.rmi.server.Unreferenced\n     *\n     */\n    public void unreferenced()\n    {\n        kill();\n    }\n\n    public static Registry getRegistry() {\n        return AgentBootstrap.registry;\n    }\n\n    public static String getHost() {\n        return AgentBootstrap.host;\n    }\n\n    public static String getMaster() {\n        return AgentBootstrap.master;\n    }\n\n    private Process createProcess(String cmd, int priority) throws Exception {\n        Process p;\n        cmd = checkCommand(cmd);\n        String args[] = new String[7];\n\n        args[0] = \"priocntl\";\n        args[1] = \"-e\";\n        args[2] = \"-c\";\n        args[3] = (priority == Config.DEFAULT_PRIORITY) ? \"TS\" : \"RT\";\n        args[4] = \"sh\";\n        args[5] = \"-c\";\n        args[6] = cmd;\n\n        try {\n            logger.fine(\"Starting Command : \" + cmd );\n            p = Runtime.getRuntime().exec(args);\n        }\n        catch (IOException ie) {\n            p = null;\n            logger.log(Level.WARNING, \"Command \" + cmd + \" failed.\", ie);\n            throw ie;\n        }\n        return p;\n    }\n\n    /**\n     * Method that handles errors from commands\n     * This method captures any messages on stderr and\n     * stdout of the given Process and logs them.\n     * @param proc Process whose stderr needs to be logged\n     * @return filename in which errors are logged\n     */\n    private String processLogs(Process proc)\n    {\n        InputStream err = proc.getErrorStream();\n        InputStream log = proc.getInputStream();\n        // Create a unique temporary log file in tmp dir\n        String errFile =\n                Config.TMP_DIR + \"cmd\" + proc.hashCode();\n        String logFile = errFile + \"-out\";\n\n        // Create Log writer for errors\n        try {\n            new LogWriter(err, errFile);\n        }\n        catch (IOException ie) {\n            logger.warning(\"Could not write to \" + errFile);\n            return(null);\n        }\n\n        // Create Log writer for stdout\n        try {\n            new LogWriter(log, logFile);\n        }\n        catch (IOException ie) {\n            try {\n                logger.warning(\"Could not write to \" + logFile);\n            }\n            catch (Exception e){}\n        }\n\n        logger.fine(\"Created Error File \" + errFile);\n        logger.fine(\"Created Log File \" + logFile);\n        return errFile;\n    }\n\n    /**\n     * This method saves messages on stderr of the given\n     * Process and logs them to the errorlog.\n     * @param errFile Filename of the stderr log\n     * @param cmd command which generated errors\n     */\n    private boolean xferLogs(String errFile, String cmd) {\n        boolean status = true;\n        // First check if file has any  error messages\n        File f = new File(errFile);\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in log identifying source of errors\n                    buf.append(cmd);\n                    buf.append(\"\\nstderr:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.warning(buf.toString());\n                    status = false;\n                }\n                in.close();\n                f.delete();\n            }\n            // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n\n        // Copy std out\n        // First check if file has any message\n        f = new File(errFile + \"-out\");\n        if (f.exists() && f.canRead()) {\n            try {\n                StringBuffer buf = new StringBuffer();\n                BufferedReader in = new BufferedReader(new FileReader(f));\n                String line = in.readLine();\n                if (line != null) {\n                    // Create entry in ststus log identifying source of messages\n                    buf.append(cmd);\n                    buf.append(\"\\nstdout:\\n\");\n\n                    // Loop, logging messages\n                    while (line != null) {\n                        buf.append(\"\\n          \" + line);\n                        line = in.readLine();\n                    }\n                    logger.info(buf.toString());\n                }\n                in.close();\n                f.delete();\n            }\n                    // We don't bother with exceptions as none of these should occur\n            catch (SecurityException se){}\n            catch (FileNotFoundException fe){}\n            catch (IOException ie){}\n        }\n        return status;\n    }\n\n    /**\n     * Checks and completes the command, if possible.\n     * @param cmd The original command\n     * @return The completed command\n     */\n    public String checkCommand(String cmd) {\n        String bin;\n        int idx = cmd.indexOf(' ');\n        if (idx == -1)\n            bin = cmd;\n        else\n            bin = cmd.substring(0, idx);\n        if (bin.indexOf(File.separator) != -1)\n            // The path is part of the command, use it as is\n            return cmd;\n        String path = (String) binMap.get(bin);\n        if (path == null) // Don't find it, just try as is\n            return cmd;\n        if (idx == -1)\n            return path;\n        return path + cmd.substring(idx);\n    }\n\n    /**\n     * Checks and completes the java command, if possible.\n     *\n     * @param cmd The original command\n     * @return The completed java command\n     */\n    public String checkJavaCommand(String cmd) {\n\n        StringBuilder buf = new StringBuilder(AgentBootstrap.javaHome);\n        buf.append(File.separator);\n        buf.append(\"bin\");\n        buf.append(File.separator);\n        buf.append(\"java \");\n        buf.append(AgentBootstrap.jvmOptions);\n        buf.append(\" -cp \");\n\n        boolean falseEnding = false;\n        // Externally specified classpath takes precedence.\n        for (String pathElement : AgentBootstrap.extClassPath) {\n            buf.append(pathElement);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        for (String pathElement : baseClassPath) {    ;\n            buf.append(pathElement);\n            buf.append(File.pathSeparator);\n            falseEnding = true;\n        }\n        if (falseEnding)\n            buf.setLength(buf.length() - File.pathSeparator.length());\n\n        buf.append(' ');\n        buf.append(cmd);\n        return buf.toString();\n    }\n\n    private static String[] getBaseClassPath(String benchName) {\n        // The benchmark-specific libs take precedence, add first to list\n        ArrayList libList = new ArrayList();\n        File libDir = new File(Config.BENCHMARK_DIR + benchName + \"/lib/\");\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        libDir = new File(Config.LIB_DIR);\n        if (libDir.exists() && libDir.isDirectory()) {\n            File[] libFiles = libDir.listFiles();\n            for (int i = 0; i < libFiles.length; i++)\n                if (libFiles[i].isFile())\n                    libList.add(libFiles[i].getAbsolutePath());\n        }\n        String[] baseClassPath = new String[libList.size()];\n        baseClassPath = (String[]) libList.toArray(baseClassPath);\n        return baseClassPath;\n    }\n\n    /**\n     * Sets the time on the agent host, in GMT. The time string\n     * must be in the format MMddHHmmyyyy.ss according to Unix date specs\n     * and must be in GMT time.\n     *\n     * @param gmtTimeString Time string in format\n     */\n    public void setTime(String gmtTimeString) {\n        String cmdLine = \"date -u \" + gmtTimeString;\n        Command c = new Command(cmdLine);\n        c.setLogLevel(Command.STDOUT, Level.FINER);\n        c.setLogLevel(Command.STDERR, Level.WARNING);\n        try {\n            int exitValue = c.execute(this).exitValue();\n            if (exitValue != 0)\n                logger.log(Level.WARNING, \"Error on \\\"\" + cmdLine +\n                        \"\\\" command trying to set the date. Exit value: \" +\n                        exitValue);\n        } catch (IOException e) {\n            logger.log(Level.WARNING, \"Error setting date.\", e);\n        } catch (InterruptedException e) {\n            logger.log(Level.WARNING, \"Interrupted setting date.\", e);\n        }\n    }\n\n    /**\n     * Gets the time on the agent host, in millis.\n     *\n     * @return The time on the remote system.\n     */\n    public long getTime() {\n        return System.currentTimeMillis();\n    }\n\n    // The class which spawns a thread to read the stream of the process\n    // and dumps it into the tmp file.\n    class LogWriter extends Thread {\n        BufferedReader in;\n        PrintStream out;\n\n        /**\n         * Constructor\n         * Open files and start thread\n         *\n         * @param is InputStream to read from\n         * @param logfile String filename to log to\n         */\n        public LogWriter(InputStream is, String logfile) throws IOException {\n            in = new BufferedReader(new InputStreamReader(is));\n            out = new PrintStream(new FileOutputStream(logfile));\n            this.start();\n        }\n\n        /**\n         * Run, copying input stream's contents to output until no\n         * more data in input file. Exit thread automatically.\n         */\n        public void run() {\n            try {\n                String str = in.readLine();\n                while (str != null) {\n                    out.println(str);\n                    str = in.readLine();\n                }\n            } catch (IOException ie) {\n                return;\n            }\n            return;\n        }\n    }\n}\n","lineNo":915}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: RegistryLocator.java,v 1.2 2006/06/29 19:38:35 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.common;\n\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The registry locator is the single access point for clients to locate\n * and access the Faban registry either on the local or remote system.<p>\n *\n * Although the Registry implementation uses rmi underneath, the rmi registry\n * is fully encapsulated inside the Registry and RegistryLocator to avoid any\n * confusion in the agent programs and other programs accessing the registry.\n *\n * @author Akara Sucharitakul\n */\npublic class RegistryLocator {\n\n    static Logger logger = Logger.getLogger(RegistryLocator.class.getName());\n\n    /**\n     * The default registry port for Faban - 9998.\n     */\n    public static final int DEFAULT_PORT = 9998;\n\n    /**\n     * The rmi registry bind name used to find the registry - FabanRegistry.\n     */\n    static final String BIND_NAME = \"FabanRegistry\";\n\n    private static int getPort() {\n        int port = DEFAULT_PORT;\n        String portString = System.getProperty(\"faban.registry.port\");\n        if (portString != null)\n            try {\n                port = Integer.parseInt(portString);\n            } catch (NumberFormatException e) {\n                logger.log(Level.SEVERE, \"Property faban.registry.port \" +\n                        e.getMessage(), e);\n                throw e;\n            }\n        return port;\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * system property faban.registry.port as the port.\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry()\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(getPort());\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * system property faban.registry.port as the port.\n     * @param master The master host name\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master)\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, getPort());\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * port specified.\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry(int port)\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * port specified.\n     * @param master The master host name\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master, int port)\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: RegistryLocator.java,v 1.3 2007/10/16 09:18:14 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.common;\n\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The registry locator is the single access point for clients to locate\n * and access the Faban registry either on the local or remote system.<p>\n *\n * Although the Registry implementation uses rmi underneath, the rmi registry\n * is fully encapsulated inside the Registry and RegistryLocator to avoid any\n * confusion in the agent programs and other programs accessing the registry.\n *\n * @author Akara Sucharitakul\n */\npublic class RegistryLocator {\n\n    static Logger logger = Logger.getLogger(RegistryLocator.class.getName());\n\n    /**\n     * The default registry port for Faban - 9998.\n     */\n    public static final int DEFAULT_PORT = 9998;\n\n    /**\n     * The rmi registry bind name used to find the registry - FabanRegistry.\n     */\n    static final String BIND_NAME = \"FabanRegistry\";\n\n    private static int getPort() {\n        int port = DEFAULT_PORT;\n        String portString = System.getProperty(\"faban.registry.port\");\n        if (portString != null)\n            try {\n                port = Integer.parseInt(portString);\n            } catch (NumberFormatException e) {\n                logger.log(Level.SEVERE, \"Property faban.registry.port \" +\n                        e.getMessage(), e);\n                throw e;\n            }\n        return port;\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * system property faban.registry.port as the port.\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry()\n            throws RemoteException, NotBoundException {\n\n        int port = getPort();\n        logger.fine(\"Obtaining registry at localhost:\" + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * system property faban.registry.port as the port.\n     * @param master The master host name\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master)\n            throws RemoteException, NotBoundException {\n\n        int port = getPort();\n        logger.fine(\"Obtaining registry at \" + master + ':' + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * port specified.\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry(int port)\n            throws RemoteException, NotBoundException {\n\n        logger.fine(\"Obtaining registry at localhost:\" + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * port specified.\n     * @param master The master host name\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master, int port)\n            throws RemoteException, NotBoundException {\n\n        logger.fine(\"Obtaining registry at \" + master + ':' + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n}\n","lineNo":80}
{"Smelly Sample":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: RegistryLocator.java,v 1.2 2006/06/29 19:38:35 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.common;\n\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The registry locator is the single access point for clients to locate\n * and access the Faban registry either on the local or remote system.<p>\n *\n * Although the Registry implementation uses rmi underneath, the rmi registry\n * is fully encapsulated inside the Registry and RegistryLocator to avoid any\n * confusion in the agent programs and other programs accessing the registry.\n *\n * @author Akara Sucharitakul\n */\npublic class RegistryLocator {\n\n    static Logger logger = Logger.getLogger(RegistryLocator.class.getName());\n\n    /**\n     * The default registry port for Faban - 9998.\n     */\n    public static final int DEFAULT_PORT = 9998;\n\n    /**\n     * The rmi registry bind name used to find the registry - FabanRegistry.\n     */\n    static final String BIND_NAME = \"FabanRegistry\";\n\n    private static int getPort() {\n        int port = DEFAULT_PORT;\n        String portString = System.getProperty(\"faban.registry.port\");\n        if (portString != null)\n            try {\n                port = Integer.parseInt(portString);\n            } catch (NumberFormatException e) {\n                logger.log(Level.SEVERE, \"Property faban.registry.port \" +\n                        e.getMessage(), e);\n                throw e;\n            }\n        return port;\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * system property faban.registry.port as the port.\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry()\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(getPort());\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * system property faban.registry.port as the port.\n     * @param master The master host name\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master)\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, getPort());\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * port specified.\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry(int port)\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * port specified.\n     * @param master The master host name\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master, int port)\n            throws RemoteException, NotBoundException {\n\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n}\n","Method after Refactoring":"/* The contents of this file are subject to the terms\n * of the Common Development and Distribution License\n * (the License). You may not use this file except in\n * compliance with the License.\n *\n * You can obtain a copy of the License at\n * http://www.sun.com/cddl/cddl.html or\n * install_dir/legal/LICENSE\n * See the License for the specific language governing\n * permission and limitations under the License.\n *\n * When distributing Covered Code, include this CDDL\n * Header Notice in each file and include the License file\n * at install_dir/legal/LICENSE.\n * If applicable, add the following below the CDDL Header,\n * with the fields enclosed by brackets [] replaced by\n * your own identifying information:\n * \"Portions Copyrighted [year] [name of copyright owner]\"\n *\n * $Id: RegistryLocator.java,v 1.3 2007/10/16 09:18:14 akara Exp $\n *\n * Copyright 2005 Sun Microsystems Inc. All Rights Reserved\n */\npackage com.sun.faban.common;\n\nimport java.rmi.NotBoundException;\nimport java.rmi.RemoteException;\nimport java.rmi.registry.LocateRegistry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * The registry locator is the single access point for clients to locate\n * and access the Faban registry either on the local or remote system.<p>\n *\n * Although the Registry implementation uses rmi underneath, the rmi registry\n * is fully encapsulated inside the Registry and RegistryLocator to avoid any\n * confusion in the agent programs and other programs accessing the registry.\n *\n * @author Akara Sucharitakul\n */\npublic class RegistryLocator {\n\n    static Logger logger = Logger.getLogger(RegistryLocator.class.getName());\n\n    /**\n     * The default registry port for Faban - 9998.\n     */\n    public static final int DEFAULT_PORT = 9998;\n\n    /**\n     * The rmi registry bind name used to find the registry - FabanRegistry.\n     */\n    static final String BIND_NAME = \"FabanRegistry\";\n\n    private static int getPort() {\n        int port = DEFAULT_PORT;\n        String portString = System.getProperty(\"faban.registry.port\");\n        if (portString != null)\n            try {\n                port = Integer.parseInt(portString);\n            } catch (NumberFormatException e) {\n                logger.log(Level.SEVERE, \"Property faban.registry.port \" +\n                        e.getMessage(), e);\n                throw e;\n            }\n        return port;\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * system property faban.registry.port as the port.\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry()\n            throws RemoteException, NotBoundException {\n\n        int port = getPort();\n        logger.fine(\"Obtaining registry at localhost:\" + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * system property faban.registry.port as the port.\n     * @param master The master host name\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master)\n            throws RemoteException, NotBoundException {\n\n        int port = getPort();\n        logger.fine(\"Obtaining registry at \" + master + ':' + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the local system using the\n     * port specified.\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry.\n     * @throws NotBoundException The registry itself is not bound.\n     */\n    public static Registry getRegistry(int port)\n            throws RemoteException, NotBoundException {\n\n        logger.fine(\"Obtaining registry at localhost:\" + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n    /**\n     * Obtains a reference to the registry on the remote master system using the\n     * port specified.\n     * @param master The master host name\n     * @param port The port to connect to the registry\n     * @return A remote reference to the registry\n     * @throws RemoteException Cannot access the registry\n     * @throws NotBoundException The registry itself is not bound\n     */\n    public static Registry getRegistry(String master, int port)\n            throws RemoteException, NotBoundException {\n\n        logger.fine(\"Obtaining registry at \" + master + ':' + port);\n        java.rmi.registry.Registry rmiRegistry =\n                                LocateRegistry.getRegistry(master, port);\n        return (Registry) rmiRegistry.lookup(BIND_NAME);\n    }\n\n}\n","lineNo":98}
