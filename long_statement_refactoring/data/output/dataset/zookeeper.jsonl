{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.quorum;\n\nimport static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Properties;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.PortAssignment;\nimport org.apache.zookeeper.ZooDefs.Ids;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.admin.ZooKeeperAdmin;\nimport org.apache.zookeeper.test.ClientBase;\nimport org.apache.zookeeper.test.ReconfigTest;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\n\npublic class ReconfigLegacyTest extends QuorumPeerTestBase {\n\n    private static final int SERVER_COUNT = 3;\n\n    @BeforeEach\n    public void setup() {\n        ClientBase.setupTestEnv();\n        QuorumPeerConfig.setReconfigEnabled(true);\n        System.setProperty(\"zookeeper.DigestAuthenticationProvider.superDigest\", \"super:D/InIHSb7yEEbrWz8b9l71RjZJU=\"/* password is 'test'*/);\n    }\n\n    /**\n     * This test checks that when started with a single static config file the\n     * servers will create a valid dynamic config file. Also checks that when\n     * the static config includes a clientPort but the dynamic definition also\n     * includes it, the static definition is erased.\n     */\n    @Test\n    public void testConfigFileBackwardCompatibility() throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n        ArrayList<String> allServers = new ArrayList<>();\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            clientPorts[i] = PortAssignment.unique();\n            server = \"server.\" + i + \"=localhost:\" + PortAssignment.unique() + \":\" + PortAssignment.unique()\n                     + \":participant;localhost:\" + clientPorts[i];\n            allServers.add(server);\n            sb.append(server + \"\\n\");\n        }\n        String currentQuorumCfgSection = sb.toString();\n\n        MainThread[] mt = new MainThread[SERVER_COUNT];\n        ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];\n\n        // Start the servers with a static config file, without a dynamic\n        // config file.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, \"participant\", false);\n            // check that a dynamic configuration file doesn't exist\n            assertEquals(mt[i].getDynamicFiles().length, 0);\n            mt[i].start();\n        }\n        // Check that the servers are up, have the right config and can process operations.\n        // Check that the static config was split into static and dynamic files correctly.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(\n                ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n            zk[i] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[i]);\n            File[] dynamicFiles = mt[i].getDynamicFiles();\n\n            assertTrue(dynamicFiles.length == 1);\n            ReconfigTest.testServerHasConfig(zk[i], allServers, null);\n            // check that static config file doesn't include membership info\n            // and has a pointer to the dynamic configuration file\n            // check that static config file doesn't include peerType info\n            Properties cfg = readPropertiesFromFile(mt[i].confFile);\n            for (int j = 0; j < SERVER_COUNT; j++) {\n                assertFalse(cfg.containsKey(\"server.\" + j));\n            }\n            assertFalse(cfg.containsKey(\"peerType\"));\n            assertTrue(cfg.containsKey(\"dynamicConfigFile\"));\n            assertFalse(cfg.containsKey(\"clientPort\"));\n\n            // check that the dynamic configuration file contains the membership info\n            cfg = readPropertiesFromFile(dynamicFiles[0]);\n            for (int j = 0; j < SERVER_COUNT; j++) {\n                String serverLine = cfg.getProperty(\"server.\" + j, \"\");\n                assertEquals(allServers.get(j), \"server.\" + j + \"=\" + serverLine);\n            }\n            assertFalse(cfg.containsKey(\"dynamicConfigFile\"));\n        }\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n\n        // now shut down the servers and restart them\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            zk[i].close();\n            mt[i].shutdown();\n        }\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].start();\n        }\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(\n                ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n            zk[i] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[i]);\n            ReconfigTest.testServerHasConfig(zk[i], allServers, null);\n        }\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].shutdown();\n            zk[i].close();\n        }\n    }\n\n    /**\n     * https://issues.apache.org/jira/browse/ZOOKEEPER-1992\n     * 1. When a server starts from old style static config, without a client port in the server\n     *    specification, it should keep the client port in static config file.\n     * 2. After port reconfig, the old port should be removed from static file\n     *    and new port added to dynamic file.\n     * @throws Exception\n     */\n    @Test\n    public void testReconfigRemoveClientFromStatic() throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        final int[] quorumPorts = new int[SERVER_COUNT];\n        final int[] electionPorts = new int[SERVER_COUNT];\n\n        final int changedServerId = 0;\n        final int newClientPort = PortAssignment.unique();\n\n        StringBuilder sb = new StringBuilder();\n        ArrayList<String> allServers = new ArrayList<>();\n        ArrayList<String> newServers = new ArrayList<>();\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            clientPorts[i] = PortAssignment.unique();\n            quorumPorts[i] = PortAssignment.unique();\n            electionPorts[i] = PortAssignment.unique();\n\n            String server = \"server.\" + i + \"=localhost:\" + quorumPorts[i] + \":\" + electionPorts[i] + \":participant\";\n            allServers.add(server);\n            sb.append(server + \"\\n\");\n\n            if (i == changedServerId) {\n                newServers.add(server + \";0.0.0.0:\" + newClientPort);\n            } else {\n                newServers.add(server);\n            }\n        }\n        String quorumCfgSection = sb.toString();\n\n        MainThread[] mt = new MainThread[SERVER_COUNT];\n        ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];\n        ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];\n\n        // Start the servers with a static config file, without a dynamic config file.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection, false);\n            mt[i].start();\n        }\n\n        // Check that when a server starts from old style config, it should keep the client\n        // port in static config file.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(\n                ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n            zk[i] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[i]);\n            zkAdmin[i] = new ZooKeeperAdmin(\"127.0.0.1:\" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this);\n            zkAdmin[i].addAuthInfo(\"digest\", \"super:test\".getBytes());\n\n            ReconfigTest.testServerHasConfig(zk[i], allServers, null);\n            Properties cfg = readPropertiesFromFile(mt[i].confFile);\n\n            assertTrue(cfg.containsKey(\"dynamicConfigFile\"));\n            assertTrue(cfg.containsKey(\"clientPort\"));\n        }\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n\n        ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n\n        // Sleep since writing the config files may take time.\n        Thread.sleep(1000);\n\n        // Check that new dynamic config includes the updated client port.\n        // Check that server changedServerId erased clientPort from static config.\n        // Check that other servers still have clientPort in static config.\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            ReconfigTest.testServerHasConfig(zk[i], newServers, null);\n            Properties staticCfg = readPropertiesFromFile(mt[i].confFile);\n            if (i == changedServerId) {\n                assertFalse(staticCfg.containsKey(\"clientPort\"));\n            } else {\n                assertTrue(staticCfg.containsKey(\"clientPort\"));\n            }\n        }\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].shutdown();\n            zk[i].close();\n            zkAdmin[i].close();\n        }\n    }\n\n    public static Properties readPropertiesFromFile(File file) throws IOException {\n        Properties cfg = new Properties();\n        FileInputStream in = new FileInputStream(file);\n        try {\n            cfg.load(in);\n        } finally {\n            in.close();\n        }\n        return cfg;\n    }\n\n    /**\n     * Test case for https://issues.apache.org/jira/browse/ZOOKEEPER-2244\n     *\n     * @throws Exception\n     */\n    @Test\n    @Timeout(value = 120)\n    public void testRestartZooKeeperServer() throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            clientPorts[i] = PortAssignment.unique();\n            server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique()\n                    + \":participant;127.0.0.1:\" + clientPorts[i];\n            sb.append(server + \"\\n\");\n        }\n        String currentQuorumCfgSection = sb.toString();\n        MainThread[] mt = new MainThread[SERVER_COUNT];\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);\n            mt[i].start();\n        }\n\n        // ensure server started\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n        }\n\n        ZooKeeper zk = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[0]);\n\n        String zNodePath = \"/serverRestartTest\";\n        String data = \"originalData\";\n        zk.create(zNodePath, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        zk.close();\n\n        /**\n         * stop two servers out of three and again start them\n         */\n        mt[0].shutdown();\n        mt[1].shutdown();\n        mt[0].start();\n        mt[1].start();\n        // ensure server started\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n        }\n        zk = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[0]);\n\n        byte[] dataBytes = zk.getData(zNodePath, null, null);\n        String receivedData = new String(dataBytes);\n        assertEquals(data, receivedData);\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].shutdown();\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.quorum;\n\nimport static org.apache.zookeeper.server.quorum.QuorumPeerMainTLSTest.getClientTLSConfigs;\nimport static org.apache.zookeeper.server.quorum.QuorumPeerMainTLSTest.getServerTLSConfigs;\nimport static org.apache.zookeeper.test.ClientBase.CONNECTION_TIMEOUT;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertFalse;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.security.Security;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.Properties;\nimport org.apache.commons.io.FileUtils;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.PortAssignment;\nimport org.apache.zookeeper.ZooDefs.Ids;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.admin.ZooKeeperAdmin;\nimport org.apache.zookeeper.client.ZKClientConfig;\nimport org.apache.zookeeper.common.X509KeyType;\nimport org.apache.zookeeper.common.X509TestContext;\nimport org.apache.zookeeper.test.ClientBase;\nimport org.apache.zookeeper.test.ReconfigTest;\nimport org.bouncycastle.jce.provider.BouncyCastleProvider;\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.Timeout;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.ValueSource;\n\n\npublic class ReconfigLegacyTest extends QuorumPeerTestBase {\n\n    private static final int SERVER_COUNT = 3;\n    private static File tempDir;\n    private static X509TestContext x509TestContext = null;\n\n    @BeforeAll\n    public static void beforeAll() throws Exception {\n        Security.addProvider(new BouncyCastleProvider());\n        tempDir = ClientBase.createEmptyTestDir();\n        x509TestContext = X509TestContext.newBuilder()\n            .setTempDir(tempDir)\n            .setKeyStoreKeyType(X509KeyType.EC)\n            .setTrustStoreKeyType(X509KeyType.EC)\n            .build();\n    }\n\n    @AfterAll\n    public static void afterAll() {\n        Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME);\n        try {\n            FileUtils.deleteDirectory(tempDir);\n        } catch (IOException e) {\n            // ignore\n        }\n    }\n\n    @BeforeEach\n    public void setup() {\n        ClientBase.setupTestEnv();\n        QuorumPeerConfig.setReconfigEnabled(true);\n        System.setProperty(\"zookeeper.DigestAuthenticationProvider.superDigest\", \"super:D/InIHSb7yEEbrWz8b9l71RjZJU=\"/* password is 'test'*/);\n    }\n\n    /**\n     * This test checks that when started with a single static config file the\n     * servers will create a valid dynamic config file. Also checks that when\n     * the static config includes a clientPort but the dynamic definition also\n     * includes it, the static definition is erased.\n     */\n    @Test\n    public void testConfigFileBackwardCompatibility() throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n        ArrayList<String> allServers = new ArrayList<>();\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            clientPorts[i] = PortAssignment.unique();\n            server = \"server.\" + i + \"=localhost:\" + PortAssignment.unique() + \":\" + PortAssignment.unique()\n                + \":participant;localhost:\" + clientPorts[i];\n            allServers.add(server);\n            sb.append(server + \"\\n\");\n        }\n        String currentQuorumCfgSection = sb.toString();\n\n        MainThread[] mt = new MainThread[SERVER_COUNT];\n        ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];\n\n        // Start the servers with a static config file, without a dynamic\n        // config file.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, \"participant\", false);\n            // check that a dynamic configuration file doesn't exist\n            assertEquals(mt[i].getDynamicFiles().length, 0);\n            mt[i].start();\n        }\n        // Check that the servers are up, have the right config and can process operations.\n        // Check that the static config was split into static and dynamic files correctly.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(\n                ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n            zk[i] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[i]);\n            File[] dynamicFiles = mt[i].getDynamicFiles();\n\n            assertTrue(dynamicFiles.length == 1);\n            ReconfigTest.testServerHasConfig(zk[i], allServers, null);\n            // check that static config file doesn't include membership info\n            // and has a pointer to the dynamic configuration file\n            // check that static config file doesn't include peerType info\n            Properties cfg = readPropertiesFromFile(mt[i].confFile);\n            for (int j = 0; j < SERVER_COUNT; j++) {\n                assertFalse(cfg.containsKey(\"server.\" + j));\n            }\n            assertFalse(cfg.containsKey(\"peerType\"));\n            assertTrue(cfg.containsKey(\"dynamicConfigFile\"));\n            assertFalse(cfg.containsKey(\"clientPort\"));\n\n            // check that the dynamic configuration file contains the membership info\n            cfg = readPropertiesFromFile(dynamicFiles[0]);\n            for (int j = 0; j < SERVER_COUNT; j++) {\n                String serverLine = cfg.getProperty(\"server.\" + j, \"\");\n                assertEquals(allServers.get(j), \"server.\" + j + \"=\" + serverLine);\n            }\n            assertFalse(cfg.containsKey(\"dynamicConfigFile\"));\n        }\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n\n        // now shut down the servers and restart them\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            zk[i].close();\n            mt[i].shutdown();\n        }\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].start();\n        }\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(\n                ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n            zk[i] = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[i]);\n            ReconfigTest.testServerHasConfig(zk[i], allServers, null);\n        }\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].shutdown();\n            zk[i].close();\n        }\n    }\n\n    /**\n     * https://issues.apache.org/jira/browse/ZOOKEEPER-1992\n     * 1. When a server starts from old style static config, without a client port in the server\n     *    specification, it should keep the client port in static config file.\n     * 2. After port reconfig, the old port should be removed from static file\n     *    and new port added to dynamic file.\n     * @throws Exception\n     */\n    @ParameterizedTest\n    @ValueSource(booleans = {false, true})\n    public void testReconfigRemoveClientFromStatic(boolean isSecure) throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        final int[] secureClientPorts = new int[SERVER_COUNT];\n        final int[] adminServerPorts = new int[SERVER_COUNT];\n        final int[] quorumPorts = new int[SERVER_COUNT];\n        final int[] electionPorts = new int[SERVER_COUNT];\n\n        final int changedServerId = 0;\n        final int newClientPortOrSecureClientPort = PortAssignment.unique();\n\n        StringBuilder sb = new StringBuilder();\n        ArrayList<String> allServers = new ArrayList<>();\n        ArrayList<String> newServers = new ArrayList<>();\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            clientPorts[i] = PortAssignment.unique();\n            secureClientPorts[i] = PortAssignment.unique();\n            adminServerPorts[i] = PortAssignment.unique();\n            quorumPorts[i] = PortAssignment.unique();\n            electionPorts[i] = PortAssignment.unique();\n\n            String server = \"server.\" + i + \"=localhost:\" + quorumPorts[i] + \":\" + electionPorts[i] + \":participant\";\n            allServers.add(server);\n            sb.append(server + \"\\n\");\n\n            if (i == changedServerId) {\n                if (isSecure) {\n                    newServers.add(server + \";;0.0.0.0:\" + newClientPortOrSecureClientPort);\n                } else {\n                    newServers.add(server + \";0.0.0.0:\" + newClientPortOrSecureClientPort);\n                }\n\n            } else {\n                newServers.add(server);\n            }\n        }\n        String quorumCfgSection = sb.toString();\n\n        MainThread[] mt = new MainThread[SERVER_COUNT];\n        ZooKeeper[] zk = new ZooKeeper[SERVER_COUNT];\n        ZooKeeperAdmin[] zkAdmin = new ZooKeeperAdmin[SERVER_COUNT];\n\n        Map<String, String> configMap = getServerTLSConfigs(x509TestContext);\n        StringBuilder configBuilder = new StringBuilder();\n        for (Map.Entry<String, String> entry : configMap.entrySet()) {\n            configBuilder.append(entry.getKey()).append(\"=\").append(entry.getValue()).append(\"\\n\");\n        }\n\n        // Start the servers with a static config file, without a dynamic config file.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            if (isSecure) {\n                mt[i] = new MainThread(i, MainThread.UNSET_STATIC_CLIENTPORT, adminServerPorts[i], secureClientPorts[i], quorumCfgSection, configBuilder.toString(), null, false, null);\n            } else {\n                mt[i] = new MainThread(i, clientPorts[i], adminServerPorts[i], quorumCfgSection, null, null, false);\n            }\n            mt[i].start();\n        }\n\n\n        ZKClientConfig clientConfig;\n        if (isSecure) {\n            clientConfig = getClientTLSConfigs(x509TestContext);\n        } else {\n            clientConfig = null;\n        }\n\n        // Check that when a server starts from old style config, it should keep the client\n        // port in static config file.\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            String cnxnString = \"127.0.0.1:\" + (isSecure ? secureClientPorts[i] : clientPorts[i]);\n            assertTrue(\n                ClientBase.waitForServerUp(cnxnString, CONNECTION_TIMEOUT, isSecure, clientConfig),\n                \"waiting for server \" + i + \" being up\");\n            zk[i] = ClientBase.createZKClient(cnxnString, CONNECTION_TIMEOUT, CONNECTION_TIMEOUT, clientConfig);\n            zkAdmin[i] = new ZooKeeperAdmin(cnxnString, ClientBase.CONNECTION_TIMEOUT, this, clientConfig);\n            zkAdmin[i].addAuthInfo(\"digest\", \"super:test\".getBytes());\n\n            ReconfigTest.testServerHasConfig(zk[i], allServers, null);\n            Properties cfg = readPropertiesFromFile(mt[i].confFile);\n\n            assertTrue(cfg.containsKey(\"dynamicConfigFile\"));\n            if (isSecure) {\n                assertTrue(cfg.containsKey(\"secureClientPort\"));\n            } else {\n                assertTrue(cfg.containsKey(\"clientPort\"));\n            }\n\n        }\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n\n        ReconfigTest.reconfig(zkAdmin[1], null, null, newServers, -1);\n        ReconfigTest.testNormalOperation(zk[0], zk[1]);\n\n        // Sleep since writing the config files may take time.\n        Thread.sleep(1000);\n\n        // Check that new dynamic config includes the updated client port.\n        // Check that server changedServerId erased clientPort from static config.\n        // Check that other servers still have clientPort in static config.\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            ReconfigTest.testServerHasConfig(zk[i], newServers, null);\n            Properties staticCfg = readPropertiesFromFile(mt[i].confFile);\n            String configKey = isSecure ? \"secureClientPort\" : \"clientPort\";\n            if (i == changedServerId) {\n                assertFalse(staticCfg.containsKey(configKey));\n            } else {\n                assertTrue(staticCfg.containsKey(configKey));\n            }\n        }\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].shutdown();\n            zk[i].close();\n            zkAdmin[i].close();\n        }\n    }\n\n    public static Properties readPropertiesFromFile(File file) throws IOException {\n        Properties cfg = new Properties();\n        FileInputStream in = new FileInputStream(file);\n        try {\n            cfg.load(in);\n        } finally {\n            in.close();\n        }\n        return cfg;\n    }\n\n    /**\n     * Test case for https://issues.apache.org/jira/browse/ZOOKEEPER-2244\n     *\n     * @throws Exception\n     */\n    @Test\n    @Timeout(value = 120)\n    public void testRestartZooKeeperServer() throws Exception {\n        final int[] clientPorts = new int[SERVER_COUNT];\n        StringBuilder sb = new StringBuilder();\n        String server;\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            clientPorts[i] = PortAssignment.unique();\n            server = \"server.\" + i + \"=127.0.0.1:\" + PortAssignment.unique() + \":\" + PortAssignment.unique()\n                + \":participant;127.0.0.1:\" + clientPorts[i];\n            sb.append(server + \"\\n\");\n        }\n        String currentQuorumCfgSection = sb.toString();\n        MainThread[] mt = new MainThread[SERVER_COUNT];\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i] = new MainThread(i, clientPorts[i], currentQuorumCfgSection, false);\n            mt[i].start();\n        }\n\n        // ensure server started\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n        }\n\n        ZooKeeper zk = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[0]);\n\n        String zNodePath = \"/serverRestartTest\";\n        String data = \"originalData\";\n        zk.create(zNodePath, data.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        zk.close();\n\n        /**\n         * stop two servers out of three and again start them\n         */\n        mt[0].shutdown();\n        mt[1].shutdown();\n        mt[0].start();\n        mt[1].start();\n        // ensure server started\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            assertTrue(ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i], CONNECTION_TIMEOUT),\n                \"waiting for server \" + i + \" being up\");\n        }\n        zk = ClientBase.createZKClient(\"127.0.0.1:\" + clientPorts[0]);\n\n        byte[] dataBytes = zk.getData(zNodePath, null, null);\n        String receivedData = new String(dataBytes);\n        assertEquals(data, receivedData);\n\n        for (int i = 0; i < SERVER_COUNT; i++) {\n            mt[i].shutdown();\n        }\n    }\n\n}\n","lineNo":289}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class BinaryOutputArchive implements OutputArchive {\n    private ByteBuffer bb = ByteBuffer.allocate(1024);\n\n    private DataOutput out;\n\n    public static BinaryOutputArchive getArchive(OutputStream strm) {\n        return new BinaryOutputArchive(new DataOutputStream(strm));\n    }\n\n    /**\n     * Creates a new instance of BinaryOutputArchive.\n     */\n    public BinaryOutputArchive(DataOutput out) {\n        this.out = out;\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        out.writeByte(b);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        out.writeBoolean(b);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        out.writeInt(i);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        out.writeLong(l);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        out.writeFloat(f);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        out.writeDouble(d);\n    }\n\n    /**\n     * create our own char encoder to utf8. This is faster\n     * then string.getbytes(UTF8).\n     *\n     * @param s the string to encode into utf8\n     * @return utf8 byte sequence.\n     */\n    private ByteBuffer stringToByteBuffer(CharSequence s) {\n        bb.clear();\n        final int len = s.length();\n        for (int i = 0; i < len; i++) {\n            if (bb.remaining() < 3) {\n                ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);\n                bb.flip();\n                n.put(bb);\n                bb = n;\n            }\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                bb.put((byte) c);\n            } else if (c < 0x800) {\n                bb.put((byte) (0xc0 | (c >> 6)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            } else {\n                bb.put((byte) (0xe0 | (c >> 12)));\n                bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            }\n        }\n        bb.flip();\n        return bb;\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        if (s == null) {\n            writeInt(-1, \"len\");\n            return;\n        }\n        ByteBuffer bb = stringToByteBuffer(s);\n        writeInt(bb.remaining(), \"len\");\n        out.write(bb.array(), bb.position(), bb.limit());\n    }\n\n    public void writeBuffer(byte[] barr, String tag)\n            throws IOException {\n        if (barr == null) {\n            out.writeInt(-1);\n            return;\n        }\n        out.writeInt(barr.length);\n        out.write(barr);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        if (v == null) {\n            writeInt(-1, tag);\n            return;\n        }\n        writeInt(v.size(), tag);\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        writeInt(v.size(), tag);\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class BinaryOutputArchive implements OutputArchive {\n    private ByteBuffer bb = ByteBuffer.allocate(1024);\n\n    private DataOutput out;\n\n    private long dataSize;\n\n    public static BinaryOutputArchive getArchive(OutputStream strm) {\n        return new BinaryOutputArchive(new DataOutputStream(strm));\n    }\n\n    /**\n     * Creates a new instance of BinaryOutputArchive.\n     */\n    public BinaryOutputArchive(DataOutput out) {\n        this.out = out;\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        out.writeByte(b);\n        dataSize += 1;\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        out.writeBoolean(b);\n        dataSize += 1;\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        out.writeInt(i);\n        dataSize += 4;\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        out.writeLong(l);\n        dataSize += 8;\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        out.writeFloat(f);\n        dataSize += 4;\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        out.writeDouble(d);\n        dataSize += 8;\n    }\n\n    /**\n     * create our own char encoder to utf8. This is faster\n     * then string.getbytes(UTF8).\n     *\n     * @param s the string to encode into utf8\n     * @return utf8 byte sequence.\n     */\n    private ByteBuffer stringToByteBuffer(CharSequence s) {\n        bb.clear();\n        final int len = s.length();\n        for (int i = 0; i < len; i++) {\n            if (bb.remaining() < 3) {\n                ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);\n                bb.flip();\n                n.put(bb);\n                bb = n;\n            }\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                bb.put((byte) c);\n            } else if (c < 0x800) {\n                bb.put((byte) (0xc0 | (c >> 6)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            } else {\n                bb.put((byte) (0xe0 | (c >> 12)));\n                bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            }\n        }\n        bb.flip();\n        return bb;\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        if (s == null) {\n            writeInt(-1, \"len\");\n            return;\n        }\n        ByteBuffer bb = stringToByteBuffer(s);\n        int strLen = bb.remaining();\n        writeInt(strLen, \"len\");\n        out.write(bb.array(), bb.position(), bb.limit());\n        dataSize += strLen;\n    }\n\n    public void writeBuffer(byte[] barr, String tag)\n            throws IOException {\n        if (barr == null) {\n            writeInt(-1, \"len\");\n            return;\n        }\n        int len = barr.length;\n        writeInt(len, \"len\");\n        out.write(barr);\n        dataSize += len;\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        if (v == null) {\n            writeInt(-1, tag);\n            return;\n        }\n        writeInt(v.size(), tag);\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        writeInt(v.size(), tag);\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n    }\n\n    @Override\n    public long getDataSize() {\n        return dataSize;\n    }\n\n}\n","lineNo":119}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class BinaryOutputArchive implements OutputArchive {\n    private ByteBuffer bb = ByteBuffer.allocate(1024);\n\n    private DataOutput out;\n\n    public static BinaryOutputArchive getArchive(OutputStream strm) {\n        return new BinaryOutputArchive(new DataOutputStream(strm));\n    }\n\n    /**\n     * Creates a new instance of BinaryOutputArchive.\n     */\n    public BinaryOutputArchive(DataOutput out) {\n        this.out = out;\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        out.writeByte(b);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        out.writeBoolean(b);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        out.writeInt(i);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        out.writeLong(l);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        out.writeFloat(f);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        out.writeDouble(d);\n    }\n\n    /**\n     * create our own char encoder to utf8. This is faster\n     * then string.getbytes(UTF8).\n     *\n     * @param s the string to encode into utf8\n     * @return utf8 byte sequence.\n     */\n    private ByteBuffer stringToByteBuffer(CharSequence s) {\n        bb.clear();\n        final int len = s.length();\n        for (int i = 0; i < len; i++) {\n            if (bb.remaining() < 3) {\n                ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);\n                bb.flip();\n                n.put(bb);\n                bb = n;\n            }\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                bb.put((byte) c);\n            } else if (c < 0x800) {\n                bb.put((byte) (0xc0 | (c >> 6)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            } else {\n                bb.put((byte) (0xe0 | (c >> 12)));\n                bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            }\n        }\n        bb.flip();\n        return bb;\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        if (s == null) {\n            writeInt(-1, \"len\");\n            return;\n        }\n        ByteBuffer bb = stringToByteBuffer(s);\n        writeInt(bb.remaining(), \"len\");\n        out.write(bb.array(), bb.position(), bb.limit());\n    }\n\n    public void writeBuffer(byte[] barr, String tag)\n            throws IOException {\n        if (barr == null) {\n            out.writeInt(-1);\n            return;\n        }\n        out.writeInt(barr.length);\n        out.write(barr);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        if (v == null) {\n            writeInt(-1, tag);\n            return;\n        }\n        writeInt(v.size(), tag);\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        writeInt(v.size(), tag);\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.DataOutput;\nimport java.io.DataOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class BinaryOutputArchive implements OutputArchive {\n    private ByteBuffer bb = ByteBuffer.allocate(1024);\n\n    private DataOutput out;\n\n    private long dataSize;\n\n    public static BinaryOutputArchive getArchive(OutputStream strm) {\n        return new BinaryOutputArchive(new DataOutputStream(strm));\n    }\n\n    /**\n     * Creates a new instance of BinaryOutputArchive.\n     */\n    public BinaryOutputArchive(DataOutput out) {\n        this.out = out;\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        out.writeByte(b);\n        dataSize += 1;\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        out.writeBoolean(b);\n        dataSize += 1;\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        out.writeInt(i);\n        dataSize += 4;\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        out.writeLong(l);\n        dataSize += 8;\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        out.writeFloat(f);\n        dataSize += 4;\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        out.writeDouble(d);\n        dataSize += 8;\n    }\n\n    /**\n     * create our own char encoder to utf8. This is faster\n     * then string.getbytes(UTF8).\n     *\n     * @param s the string to encode into utf8\n     * @return utf8 byte sequence.\n     */\n    private ByteBuffer stringToByteBuffer(CharSequence s) {\n        bb.clear();\n        final int len = s.length();\n        for (int i = 0; i < len; i++) {\n            if (bb.remaining() < 3) {\n                ByteBuffer n = ByteBuffer.allocate(bb.capacity() << 1);\n                bb.flip();\n                n.put(bb);\n                bb = n;\n            }\n            char c = s.charAt(i);\n            if (c < 0x80) {\n                bb.put((byte) c);\n            } else if (c < 0x800) {\n                bb.put((byte) (0xc0 | (c >> 6)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            } else {\n                bb.put((byte) (0xe0 | (c >> 12)));\n                bb.put((byte) (0x80 | ((c >> 6) & 0x3f)));\n                bb.put((byte) (0x80 | (c & 0x3f)));\n            }\n        }\n        bb.flip();\n        return bb;\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        if (s == null) {\n            writeInt(-1, \"len\");\n            return;\n        }\n        ByteBuffer bb = stringToByteBuffer(s);\n        int strLen = bb.remaining();\n        writeInt(strLen, \"len\");\n        out.write(bb.array(), bb.position(), bb.limit());\n        dataSize += strLen;\n    }\n\n    public void writeBuffer(byte[] barr, String tag)\n            throws IOException {\n        if (barr == null) {\n            writeInt(-1, \"len\");\n            return;\n        }\n        int len = barr.length;\n        writeInt(len, \"len\");\n        out.write(barr);\n        dataSize += len;\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        if (v == null) {\n            writeInt(-1, tag);\n            return;\n        }\n        writeInt(v.size(), tag);\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        writeInt(v.size(), tag);\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n    }\n\n    @Override\n    public long getDataSize() {\n        return dataSize;\n    }\n\n}\n","lineNo":131}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(l);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(d);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeString(s));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeBuffer(buf));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n    private long dataSize;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n            dataSize += 1;\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        dataSize += 1;\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(l);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(d);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeString(s);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeBuffer(buf);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            dataSize += 2;\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            dataSize += 1;\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            dataSize += 1;\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    @Override\n    public long getDataSize() {\n        return dataSize;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","lineNo":76}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(l);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(d);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeString(s));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeBuffer(buf));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n    private long dataSize;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n            dataSize += 1;\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        dataSize += 1;\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(l);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(d);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeString(s);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeBuffer(buf);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            dataSize += 2;\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            dataSize += 1;\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            dataSize += 1;\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    @Override\n    public long getDataSize() {\n        return dataSize;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","lineNo":88}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(l);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(d);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeString(s));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeBuffer(buf));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n    private long dataSize;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n            dataSize += 1;\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        dataSize += 1;\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(l);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(d);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeString(s);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeBuffer(buf);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            dataSize += 2;\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            dataSize += 1;\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            dataSize += 1;\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    @Override\n    public long getDataSize() {\n        return dataSize;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","lineNo":96}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(l);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(d);\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeString(s));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        stream.print(escapeBuffer(buf));\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        isFirst = false;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.jute;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.UnsupportedEncodingException;\nimport java.util.List;\nimport java.util.TreeMap;\n\n/**\n *\n */\npublic class ToStringOutputArchive implements OutputArchive {\n\n    private PrintStream stream;\n    private boolean isFirst = true;\n    private long dataSize;\n\n    private void throwExceptionOnError(String tag) throws IOException {\n        if (stream.checkError()) {\n            throw new IOException(\"Error serializing \" + tag);\n        }\n    }\n\n    private void printCommaUnlessFirst() {\n        if (!isFirst) {\n            stream.print(\",\");\n            dataSize += 1;\n        }\n        isFirst = false;\n    }\n\n    /**\n     * Creates a new instance of ToStringOutputArchive.\n     */\n    public ToStringOutputArchive(OutputStream out) throws UnsupportedEncodingException {\n        stream = new PrintStream(out, true, \"UTF-8\");\n    }\n\n    public void writeByte(byte b, String tag) throws IOException {\n        writeLong((long) b, tag);\n    }\n\n    public void writeBool(boolean b, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String val = b ? \"T\" : \"F\";\n        stream.print(val);\n        dataSize += 1;\n        throwExceptionOnError(tag);\n    }\n\n    public void writeInt(int i, String tag) throws IOException {\n        writeLong((long) i, tag);\n    }\n\n    public void writeLong(long l, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(l);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeFloat(float f, String tag) throws IOException {\n        writeDouble((double) f, tag);\n    }\n\n    public void writeDouble(double d, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = String.valueOf(d);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeString(String s, String tag) throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeString(s);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeBuffer(byte[] buf, String tag)\n            throws IOException {\n        printCommaUnlessFirst();\n        String strValue = escapeBuffer(buf);\n        stream.print(strValue);\n        dataSize += strValue.length();\n        throwExceptionOnError(tag);\n    }\n\n    public void writeRecord(Record r, String tag) throws IOException {\n        if (r == null) {\n            return;\n        }\n        r.serialize(this, tag);\n    }\n\n    public void startRecord(Record r, String tag) throws IOException {\n        if (tag != null && !\"\".equals(tag)) {\n            printCommaUnlessFirst();\n            stream.print(\"s{\");\n            dataSize += 2;\n            isFirst = true;\n        }\n    }\n\n    public void endRecord(Record r, String tag) throws IOException {\n        if (tag == null || \"\".equals(tag)) {\n            stream.print(\"\\n\");\n            dataSize += 1;\n            isFirst = true;\n        } else {\n            stream.print(\"}\");\n            dataSize += 1;\n            isFirst = false;\n        }\n    }\n\n    public void startVector(List<?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"v{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endVector(List<?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    public void startMap(TreeMap<?, ?> v, String tag) throws IOException {\n        printCommaUnlessFirst();\n        stream.print(\"m{\");\n        dataSize += 2;\n        isFirst = true;\n    }\n\n    public void endMap(TreeMap<?, ?> v, String tag) throws IOException {\n        stream.print(\"}\");\n        dataSize += 1;\n        isFirst = false;\n    }\n\n    @Override\n    public long getDataSize() {\n        return dataSize;\n    }\n\n    private static String escapeString(String s) {\n        if (s == null) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(s.length() + 1);\n        sb.append('\\'');\n        int len = s.length();\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case '\\0':\n                    sb.append(\"%00\");\n                    break;\n                case '\\n':\n                    sb.append(\"%0A\");\n                    break;\n                case '\\r':\n                    sb.append(\"%0D\");\n                    break;\n                case ',':\n                    sb.append(\"%2C\");\n                    break;\n                case '}':\n                    sb.append(\"%7D\");\n                    break;\n                case '%':\n                    sb.append(\"%25\");\n                    break;\n                default:\n                    sb.append(c);\n            }\n        }\n\n        return sb.toString();\n    }\n\n    private static String escapeBuffer(byte[] barr) {\n        if (barr == null || barr.length == 0) {\n            return \"\";\n        }\n\n        StringBuilder sb = new StringBuilder(barr.length + 1);\n        sb.append('#');\n\n        for (byte b : barr) {\n            sb.append(Integer.toHexString(b));\n        }\n\n        return sb.toString();\n    }\n}\n","lineNo":105}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.jute.InputArchive;\nimport org.apache.jute.OutputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.proto.CheckVersionRequest;\nimport org.apache.zookeeper.proto.CreateRequest;\nimport org.apache.zookeeper.proto.CreateTTLRequest;\nimport org.apache.zookeeper.proto.DeleteRequest;\nimport org.apache.zookeeper.proto.GetChildrenRequest;\nimport org.apache.zookeeper.proto.GetDataRequest;\nimport org.apache.zookeeper.proto.MultiHeader;\nimport org.apache.zookeeper.proto.SetDataRequest;\n\n/**\n * Encodes a composite operation.  In the wire format, each operation\n * consists of a single MultiHeader followed by the appropriate request.\n * Each of these MultiHeaders has a type which indicates\n * the type of the following operation or a negative number if no more operations\n * are included.\n * All of the operations must be from the same OpKind.\n */\npublic class MultiOperationRecord implements Record, Iterable<Op> {\n\n    private List<Op> ops = new ArrayList<>();\n    private Op.OpKind opKind = null;\n\n    public MultiOperationRecord() {\n    }\n\n    public MultiOperationRecord(Iterable<Op> ops) throws IllegalArgumentException {\n        for (Op op : ops) {\n            setOrCheckOpKind(op.getKind());\n            add(op);\n        }\n    }\n\n    @Override\n    public Iterator<Op> iterator() {\n        return ops.iterator();\n    }\n\n    public void add(Op op) throws IllegalArgumentException {\n        setOrCheckOpKind(op.getKind());\n        ops.add(op);\n    }\n\n    public int size() {\n        return ops.size();\n    }\n\n    /**\n     * Returns the kind of the operations contained by the record.\n     * @return The OpKind value of all the elements in the record.\n     */\n    public Op.OpKind getOpKind() {\n        return opKind;\n    }\n\n    private void setOrCheckOpKind(Op.OpKind ok) throws IllegalArgumentException {\n        if (opKind == null) {\n            opKind = ok;\n        } else if (ok != opKind) {\n            throw new IllegalArgumentException(\"Mixing read and write operations (transactions)\"\n                                               + \" is not allowed in a multi request.\");\n        }\n    }\n\n    @Override\n    public void serialize(OutputArchive archive, String tag) throws IOException {\n        archive.startRecord(this, tag);\n        for (Op op : ops) {\n            MultiHeader h = new MultiHeader(op.getType(), false, -1);\n            h.serialize(archive, tag);\n            switch (op.getType()) {\n            case ZooDefs.OpCode.create:\n            case ZooDefs.OpCode.create2:\n            case ZooDefs.OpCode.createTTL:\n            case ZooDefs.OpCode.createContainer:\n            case ZooDefs.OpCode.delete:\n            case ZooDefs.OpCode.setData:\n            case ZooDefs.OpCode.check:\n            case ZooDefs.OpCode.getChildren:\n            case ZooDefs.OpCode.getData:\n                op.toRequestRecord().serialize(archive, tag);\n                break;\n            default:\n                throw new IOException(\"Invalid type of op\");\n            }\n        }\n        new MultiHeader(-1, true, -1).serialize(archive, tag);\n        archive.endRecord(this, tag);\n    }\n\n    @Override\n    public void deserialize(InputArchive archive, String tag) throws IOException {\n        archive.startRecord(tag);\n        MultiHeader h = new MultiHeader();\n        h.deserialize(archive, tag);\n        try {\n            while (!h.getDone()) {\n                switch (h.getType()) {\n                case ZooDefs.OpCode.create:\n                case ZooDefs.OpCode.create2:\n                case ZooDefs.OpCode.createContainer:\n                    CreateRequest cr = new CreateRequest();\n                    cr.deserialize(archive, tag);\n                    add(Op.create(cr.getPath(), cr.getData(), cr.getAcl(), cr.getFlags()));\n                    break;\n                case ZooDefs.OpCode.createTTL:\n                    CreateTTLRequest crTtl = new CreateTTLRequest();\n                    crTtl.deserialize(archive, tag);\n                    add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));\n                    break;\n                case ZooDefs.OpCode.delete:\n                    DeleteRequest dr = new DeleteRequest();\n                    dr.deserialize(archive, tag);\n                    add(Op.delete(dr.getPath(), dr.getVersion()));\n                    break;\n                case ZooDefs.OpCode.setData:\n                    SetDataRequest sdr = new SetDataRequest();\n                    sdr.deserialize(archive, tag);\n                    add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));\n                    break;\n                case ZooDefs.OpCode.check:\n                    CheckVersionRequest cvr = new CheckVersionRequest();\n                    cvr.deserialize(archive, tag);\n                    add(Op.check(cvr.getPath(), cvr.getVersion()));\n                    break;\n                case ZooDefs.OpCode.getChildren:\n                    GetChildrenRequest gcr = new GetChildrenRequest();\n                    gcr.deserialize(archive, tag);\n                    add(Op.getChildren(gcr.getPath()));\n                    break;\n                case ZooDefs.OpCode.getData:\n                    GetDataRequest gdr = new GetDataRequest();\n                    gdr.deserialize(archive, tag);\n                    add(Op.getData(gdr.getPath()));\n                    break;\n                default:\n                    throw new IOException(\"Invalid type of op\");\n                }\n                h.deserialize(archive, tag);\n            }\n        } catch (IllegalArgumentException e) {\n            throw new IOException(\"Mixing different kind of ops\");\n        }\n        archive.endRecord(tag);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof MultiOperationRecord)) {\n            return false;\n        }\n\n        MultiOperationRecord that = (MultiOperationRecord) o;\n\n        if (ops != null) {\n            Iterator<Op> other = that.ops.iterator();\n            for (Op op : ops) {\n                boolean hasMoreData = other.hasNext();\n                if (!hasMoreData) {\n                    return false;\n                }\n                Op otherOp = other.next();\n                if (!op.equals(otherOp)) {\n                    return false;\n                }\n            }\n            return !other.hasNext();\n        } else {\n            return that.ops == null;\n        }\n\n    }\n\n    @Override\n    public int hashCode() {\n        int h = 1023;\n        for (Op op : ops) {\n            h = h * 25 + op.hashCode();\n        }\n        return h;\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport org.apache.jute.InputArchive;\nimport org.apache.jute.OutputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.proto.CheckVersionRequest;\nimport org.apache.zookeeper.proto.CreateRequest;\nimport org.apache.zookeeper.proto.CreateTTLRequest;\nimport org.apache.zookeeper.proto.DeleteRequest;\nimport org.apache.zookeeper.proto.GetChildrenRequest;\nimport org.apache.zookeeper.proto.GetDataRequest;\nimport org.apache.zookeeper.proto.MultiHeader;\nimport org.apache.zookeeper.proto.SetDataRequest;\n\n/**\n * Encodes a composite operation.  In the wire format, each operation\n * consists of a single MultiHeader followed by the appropriate request.\n * Each of these MultiHeaders has a type which indicates\n * the type of the following operation or a negative number if no more operations\n * are included.\n * All of the operations must be from the same OpKind.\n */\npublic class MultiOperationRecord implements Record, Iterable<Op> {\n\n    private List<Op> ops = new ArrayList<>();\n    private Op.OpKind opKind = null;\n\n    public MultiOperationRecord() {\n    }\n\n    public MultiOperationRecord(Iterable<Op> ops) throws IllegalArgumentException {\n        for (Op op : ops) {\n            setOrCheckOpKind(op.getKind());\n            add(op);\n        }\n    }\n\n    @Override\n    public Iterator<Op> iterator() {\n        return ops.iterator();\n    }\n\n    public void add(Op op) throws IllegalArgumentException {\n        setOrCheckOpKind(op.getKind());\n        ops.add(op);\n    }\n\n    public int size() {\n        return ops.size();\n    }\n\n    /**\n     * Returns the kind of the operations contained by the record.\n     * @return The OpKind value of all the elements in the record.\n     */\n    public Op.OpKind getOpKind() {\n        return opKind;\n    }\n\n    private void setOrCheckOpKind(Op.OpKind ok) throws IllegalArgumentException {\n        if (opKind == null) {\n            opKind = ok;\n        } else if (ok != opKind) {\n            throw new IllegalArgumentException(\"Mixing read and write operations (transactions)\"\n                                               + \" is not allowed in a multi request.\");\n        }\n    }\n\n    @Override\n    public void serialize(OutputArchive archive, String tag) throws IOException {\n        archive.startRecord(this, tag);\n        for (Op op : ops) {\n            MultiHeader h = new MultiHeader(op.getType(), false, -1);\n            h.serialize(archive, tag);\n            switch (op.getType()) {\n            case ZooDefs.OpCode.create:\n            case ZooDefs.OpCode.create2:\n            case ZooDefs.OpCode.createTTL:\n            case ZooDefs.OpCode.createContainer:\n            case ZooDefs.OpCode.delete:\n            case ZooDefs.OpCode.setData:\n            case ZooDefs.OpCode.check:\n            case ZooDefs.OpCode.getChildren:\n            case ZooDefs.OpCode.getData:\n                op.toRequestRecord().serialize(archive, tag);\n                break;\n            default:\n                throw new IOException(\"Invalid type of op\");\n            }\n        }\n        new MultiHeader(-1, true, -1).serialize(archive, tag);\n        archive.endRecord(this, tag);\n    }\n\n    @Override\n    public void deserialize(InputArchive archive, String tag) throws IOException {\n        archive.startRecord(tag);\n        MultiHeader h = new MultiHeader();\n        h.deserialize(archive, tag);\n        try {\n            while (!h.getDone()) {\n                switch (h.getType()) {\n                case ZooDefs.OpCode.create:\n                case ZooDefs.OpCode.create2:\n                case ZooDefs.OpCode.createContainer:\n                    CreateRequest cr = new CreateRequest();\n                    cr.deserialize(archive, tag);\n                    CreateMode createMode = CreateMode.fromFlag(cr.getFlags(), null);\n                    if (createMode == null) {\n                        throw new IOException(\"invalid flag \" + cr.getFlags() + \" for create mode\");\n                    }\n                    CreateOptions options = CreateOptions.newBuilder(cr.getAcl(), createMode).build();\n                    add(Op.create(cr.getPath(), cr.getData(), options, h.getType()));\n                    break;\n                case ZooDefs.OpCode.createTTL:\n                    CreateTTLRequest crTtl = new CreateTTLRequest();\n                    crTtl.deserialize(archive, tag);\n                    add(Op.create(crTtl.getPath(), crTtl.getData(), crTtl.getAcl(), crTtl.getFlags(), crTtl.getTtl()));\n                    break;\n                case ZooDefs.OpCode.delete:\n                    DeleteRequest dr = new DeleteRequest();\n                    dr.deserialize(archive, tag);\n                    add(Op.delete(dr.getPath(), dr.getVersion()));\n                    break;\n                case ZooDefs.OpCode.setData:\n                    SetDataRequest sdr = new SetDataRequest();\n                    sdr.deserialize(archive, tag);\n                    add(Op.setData(sdr.getPath(), sdr.getData(), sdr.getVersion()));\n                    break;\n                case ZooDefs.OpCode.check:\n                    CheckVersionRequest cvr = new CheckVersionRequest();\n                    cvr.deserialize(archive, tag);\n                    add(Op.check(cvr.getPath(), cvr.getVersion()));\n                    break;\n                case ZooDefs.OpCode.getChildren:\n                    GetChildrenRequest gcr = new GetChildrenRequest();\n                    gcr.deserialize(archive, tag);\n                    add(Op.getChildren(gcr.getPath()));\n                    break;\n                case ZooDefs.OpCode.getData:\n                    GetDataRequest gdr = new GetDataRequest();\n                    gdr.deserialize(archive, tag);\n                    add(Op.getData(gdr.getPath()));\n                    break;\n                default:\n                    throw new IOException(\"Invalid type of op\");\n                }\n                h.deserialize(archive, tag);\n            }\n        } catch (IllegalArgumentException e) {\n            throw new IOException(\"Mixing different kind of ops\");\n        }\n        archive.endRecord(tag);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof MultiOperationRecord)) {\n            return false;\n        }\n\n        MultiOperationRecord that = (MultiOperationRecord) o;\n\n        if (ops != null) {\n            Iterator<Op> other = that.ops.iterator();\n            for (Op op : ops) {\n                boolean hasMoreData = other.hasNext();\n                if (!hasMoreData) {\n                    return false;\n                }\n                Op otherOp = other.next();\n                if (!op.equals(otherOp)) {\n                    return false;\n                }\n            }\n            return !other.hasNext();\n        } else {\n            return that.ops == null;\n        }\n\n    }\n\n    @Override\n    public int hashCode() {\n        int h = 1023;\n        for (Op op : ops) {\n            h = h * 25 + op.hashCode();\n        }\n        return h;\n    }\n\n}\n","lineNo":133}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.common;\n\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\n\n/**\n * This class contains common utilities for netstuff. Like printing IPv6 literals correctly\n */\npublic class NetUtils {\n\n    public static String formatInetAddr(InetSocketAddress addr) {\n        InetAddress ia = addr.getAddress();\n\n        if (ia == null) {\n            return String.format(\"%s:%s\", addr.getHostString(), addr.getPort());\n        }\n\n        if (ia instanceof Inet6Address) {\n            return String.format(\"[%s]:%s\", ia.getHostAddress(), addr.getPort());\n        } else {\n            return String.format(\"%s:%s\", ia.getHostAddress(), addr.getPort());\n        }\n    }\n\n    /**\n     * Separates host and port from given host port string if host port string is enclosed\n     * within square bracket.\n     *\n     * @param hostPort host port string\n     * @return String[]{host, port} if host port string is host:port\n     * or String[] {host, port:port} if host port string is host:port:port\n     * or String[] {host} if host port string is host\n     * or String[]{} if not a ipv6 host port string.\n     */\n    public static String[] getIPV6HostAndPort(String hostPort) {\n        if (hostPort.startsWith(\"[\")) {\n            int i = hostPort.lastIndexOf(']');\n            if (i < 0) {\n                throw new IllegalArgumentException(\n                    hostPort + \" starts with '[' but has no matching ']'\");\n            }\n            String host = hostPort.substring(1, i);\n            if (host.isEmpty()) {\n                throw new IllegalArgumentException(host + \" is empty.\");\n            }\n            if (hostPort.length() > i + 1) {\n                return getHostPort(hostPort, i, host);\n            }\n            return new String[] { host };\n        } else {\n            //Not an IPV6 host port string\n            return new String[] {};\n        }\n    }\n\n    private static String[] getHostPort(String hostPort, int indexOfClosingBracket, String host) {\n        // [127::1]:2181 , check separator : exits\n        if (hostPort.charAt(indexOfClosingBracket + 1) != ':') {\n            throw new IllegalArgumentException(hostPort + \" does not have : after ]\");\n        }\n        // [127::1]: scenario\n        if (indexOfClosingBracket + 2 == hostPort.length()) {\n            throw new IllegalArgumentException(hostPort + \" doesn't have a port after colon.\");\n        }\n        //do not include\n        String port = hostPort.substring(indexOfClosingBracket + 2);\n        return new String[] { host, port };\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.common;\n\nimport java.net.Inet6Address;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\n\n/**\n * This class contains common utilities for netstuff. Like printing IPv6 literals correctly\n */\npublic class NetUtils {\n\n    /**\n     * Prefer using the hostname for formatting, but without requesting reverse DNS lookup.\n     * Fall back to IP address if hostname is unavailable and use [] brackets for IPv6 literal.\n     */\n    public static String formatInetAddr(InetSocketAddress addr) {\n        String hostString = addr.getHostString();\n        InetAddress ia = addr.getAddress();\n\n        if (ia instanceof Inet6Address && hostString.contains(\":\")) {\n            return String.format(\"[%s]:%s\", hostString, addr.getPort());\n        } else {\n            return String.format(\"%s:%s\", hostString, addr.getPort());\n        }\n    }\n\n    /**\n     * Separates host and port from given host port string if host port string is enclosed\n     * within square bracket.\n     *\n     * @param hostPort host port string\n     * @return String[]{host, port} if host port string is host:port\n     * or String[] {host, port:port} if host port string is host:port:port\n     * or String[] {host} if host port string is host\n     * or String[]{} if not a ipv6 host port string.\n     */\n    public static String[] getIPV6HostAndPort(String hostPort) {\n        if (hostPort.startsWith(\"[\")) {\n            int i = hostPort.lastIndexOf(']');\n            if (i < 0) {\n                throw new IllegalArgumentException(\n                    hostPort + \" starts with '[' but has no matching ']'\");\n            }\n            String host = hostPort.substring(1, i);\n            if (host.isEmpty()) {\n                throw new IllegalArgumentException(host + \" is empty.\");\n            }\n            if (hostPort.length() > i + 1) {\n                return getHostPort(hostPort, i, host);\n            }\n            return new String[] { host };\n        } else {\n            //Not an IPV6 host port string\n            return new String[] {};\n        }\n    }\n\n    private static String[] getHostPort(String hostPort, int indexOfClosingBracket, String host) {\n        // [127::1]:2181 , check separator : exits\n        if (hostPort.charAt(indexOfClosingBracket + 1) != ':') {\n            throw new IllegalArgumentException(hostPort + \" does not have : after ]\");\n        }\n        // [127::1]: scenario\n        if (indexOfClosingBracket + 2 == hostPort.length()) {\n            throw new IllegalArgumentException(hostPort + \" doesn't have a port after colon.\");\n        }\n        //do not include\n        String port = hostPort.substring(indexOfClosingBracket + 2);\n        return new String[] { host, port };\n    }\n}\n","lineNo":35}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.watch;\n\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.Watcher;\nimport org.apache.zookeeper.Watcher.Event.EventType;\nimport org.apache.zookeeper.Watcher.Event.KeeperState;\nimport org.apache.zookeeper.server.ServerCnxn;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ZooTrace;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class manages watches. It allows watches to be associated with a string\n * and removes watchers and their watches in addition to managing triggers.\n */\npublic class WatchManager implements IWatchManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(WatchManager.class);\n\n    private final Map<String, Set<Watcher>> watchTable = new HashMap<>();\n\n    private final Map<Watcher, Set<String>> watch2Paths = new HashMap<>();\n\n    private final WatcherModeManager watcherModeManager = new WatcherModeManager();\n\n    @Override\n    public synchronized int size() {\n        int result = 0;\n        for (Set<Watcher> watches : watchTable.values()) {\n            result += watches.size();\n        }\n        return result;\n    }\n\n    private boolean isDeadWatcher(Watcher watcher) {\n        return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();\n    }\n\n    @Override\n    public boolean addWatch(String path, Watcher watcher) {\n        return addWatch(path, watcher, WatcherMode.DEFAULT_WATCHER_MODE);\n    }\n\n    @Override\n    public synchronized boolean addWatch(String path, Watcher watcher, WatcherMode watcherMode) {\n        if (isDeadWatcher(watcher)) {\n            LOG.debug(\"Ignoring addWatch with closed cnxn\");\n            return false;\n        }\n\n        Set<Watcher> list = watchTable.get(path);\n        if (list == null) {\n            // don't waste memory if there are few watches on a node\n            // rehash when the 4th entry is added, doubling size thereafter\n            // seems like a good compromise\n            list = new HashSet<>(4);\n            watchTable.put(path, list);\n        }\n        list.add(watcher);\n\n        Set<String> paths = watch2Paths.get(watcher);\n        if (paths == null) {\n            // cnxns typically have many watches, so use default cap here\n            paths = new HashSet<>();\n            watch2Paths.put(watcher, paths);\n        }\n\n        watcherModeManager.setWatcherMode(watcher, path, watcherMode);\n\n        return paths.add(path);\n    }\n\n    @Override\n    public synchronized void removeWatcher(Watcher watcher) {\n        Set<String> paths = watch2Paths.remove(watcher);\n        if (paths == null) {\n            return;\n        }\n        for (String p : paths) {\n            Set<Watcher> list = watchTable.get(p);\n            if (list != null) {\n                list.remove(watcher);\n                if (list.isEmpty()) {\n                    watchTable.remove(p);\n                }\n            }\n            watcherModeManager.removeWatcher(watcher, p);\n        }\n    }\n\n    @Override\n    public WatcherOrBitSet triggerWatch(String path, EventType type) {\n        return triggerWatch(path, type, null);\n    }\n\n    @Override\n    public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet supress) {\n        WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);\n        Set<Watcher> watchers = new HashSet<>();\n        PathParentIterator pathParentIterator = getPathParentIterator(path);\n        synchronized (this) {\n            for (String localPath : pathParentIterator.asIterable()) {\n                Set<Watcher> thisWatchers = watchTable.get(localPath);\n                if (thisWatchers == null || thisWatchers.isEmpty()) {\n                    continue;\n                }\n                Iterator<Watcher> iterator = thisWatchers.iterator();\n                while (iterator.hasNext()) {\n                    Watcher watcher = iterator.next();\n                    WatcherMode watcherMode = watcherModeManager.getWatcherMode(watcher, localPath);\n                    if (watcherMode.isRecursive()) {\n                        if (type != EventType.NodeChildrenChanged) {\n                            watchers.add(watcher);\n                        }\n                    } else if (!pathParentIterator.atParentPath()) {\n                        watchers.add(watcher);\n                        if (!watcherMode.isPersistent()) {\n                            iterator.remove();\n                            Set<String> paths = watch2Paths.get(watcher);\n                            if (paths != null) {\n                                paths.remove(localPath);\n                            }\n                        }\n                    }\n                }\n                if (thisWatchers.isEmpty()) {\n                    watchTable.remove(localPath);\n                }\n            }\n        }\n        if (watchers.isEmpty()) {\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, \"No watchers for \" + path);\n            }\n            return null;\n        }\n\n        for (Watcher w : watchers) {\n            if (supress != null && supress.contains(w)) {\n                continue;\n            }\n            w.process(e);\n        }\n\n        switch (type) {\n            case NodeCreated:\n                ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(watchers.size());\n                break;\n\n            case NodeDeleted:\n                ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(watchers.size());\n                break;\n\n            case NodeDataChanged:\n                ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(watchers.size());\n                break;\n\n            case NodeChildrenChanged:\n                ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(watchers.size());\n                break;\n            default:\n                // Other types not logged.\n                break;\n        }\n\n        return new WatcherOrBitSet(watchers);\n    }\n\n    @Override\n    public synchronized String toString() {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(watch2Paths.size()).append(\" connections watching \").append(watchTable.size()).append(\" paths\\n\");\n\n        int total = 0;\n        for (Set<String> paths : watch2Paths.values()) {\n            total += paths.size();\n        }\n        sb.append(\"Total watches:\").append(total);\n\n        return sb.toString();\n    }\n\n    @Override\n    public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath) {\n        if (byPath) {\n            for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {\n                pwriter.println(e.getKey());\n                for (Watcher w : e.getValue()) {\n                    pwriter.print(\"\\t0x\");\n                    pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));\n                    pwriter.print(\"\\n\");\n                }\n            }\n        } else {\n            for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {\n                pwriter.print(\"0x\");\n                pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));\n                for (String path : e.getValue()) {\n                    pwriter.print(\"\\t\");\n                    pwriter.println(path);\n                }\n            }\n        }\n    }\n\n    @Override\n    public synchronized boolean containsWatcher(String path, Watcher watcher) {\n        WatcherMode watcherMode = watcherModeManager.getWatcherMode(watcher, path);\n        PathParentIterator pathParentIterator = getPathParentIterator(path);\n        for (String localPath : pathParentIterator.asIterable()) {\n            Set<Watcher> watchers = watchTable.get(localPath);\n            if (!pathParentIterator.atParentPath()) {\n                if (watchers != null) {\n                    return true;    // at the leaf node, all watcher types match\n                }\n            }\n            if (watcherMode.isRecursive()) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    @Override\n    public synchronized boolean removeWatcher(String path, Watcher watcher) {\n        Set<String> paths = watch2Paths.get(watcher);\n        if (paths == null || !paths.remove(path)) {\n            return false;\n        }\n\n        Set<Watcher> list = watchTable.get(path);\n        if (list == null || !list.remove(watcher)) {\n            return false;\n        }\n\n        if (list.isEmpty()) {\n            watchTable.remove(path);\n        }\n\n        watcherModeManager.removeWatcher(watcher, path);\n\n        return true;\n    }\n\n    @Override\n    public synchronized WatchesReport getWatches() {\n        Map<Long, Set<String>> id2paths = new HashMap<>();\n        for (Entry<Watcher, Set<String>> e : watch2Paths.entrySet()) {\n            Long id = ((ServerCnxn) e.getKey()).getSessionId();\n            Set<String> paths = new HashSet<>(e.getValue());\n            id2paths.put(id, paths);\n        }\n        return new WatchesReport(id2paths);\n    }\n\n    @Override\n    public synchronized WatchesPathReport getWatchesByPath() {\n        Map<String, Set<Long>> path2ids = new HashMap<>();\n        for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {\n            Set<Long> ids = new HashSet<>(e.getValue().size());\n            path2ids.put(e.getKey(), ids);\n            for (Watcher watcher : e.getValue()) {\n                ids.add(((ServerCnxn) watcher).getSessionId());\n            }\n        }\n        return new WatchesPathReport(path2ids);\n    }\n\n    @Override\n    public synchronized WatchesSummary getWatchesSummary() {\n        int totalWatches = 0;\n        for (Set<String> paths : watch2Paths.values()) {\n            totalWatches += paths.size();\n        }\n        return new WatchesSummary(watch2Paths.size(), watchTable.size(), totalWatches);\n    }\n\n    @Override\n    public void shutdown() { /* do nothing */ }\n\n    @Override\n    public int getRecursiveWatchQty() {\n        return watcherModeManager.getRecursiveQty();\n    }\n\n    private PathParentIterator getPathParentIterator(String path) {\n        if (watcherModeManager.getRecursiveQty() == 0) {\n            return PathParentIterator.forPathOnly(path);\n        }\n        return PathParentIterator.forAll(path);\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.watch;\n\nimport java.io.PrintWriter;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.Watcher;\nimport org.apache.zookeeper.Watcher.Event.EventType;\nimport org.apache.zookeeper.Watcher.Event.KeeperState;\nimport org.apache.zookeeper.server.ServerCnxn;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ZooTrace;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class manages watches. It allows watches to be associated with a string\n * and removes watchers and their watches in addition to managing triggers.\n */\npublic class WatchManager implements IWatchManager {\n\n    private static final Logger LOG = LoggerFactory.getLogger(WatchManager.class);\n\n    private final Map<String, Set<Watcher>> watchTable = new HashMap<>();\n\n    private final Map<Watcher, Map<String, WatchStats>> watch2Paths = new HashMap<>();\n\n    private int recursiveWatchQty = 0;\n\n    @Override\n    public synchronized int size() {\n        int result = 0;\n        for (Set<Watcher> watches : watchTable.values()) {\n            result += watches.size();\n        }\n        return result;\n    }\n\n    private boolean isDeadWatcher(Watcher watcher) {\n        return watcher instanceof ServerCnxn && ((ServerCnxn) watcher).isStale();\n    }\n\n    @Override\n    public boolean addWatch(String path, Watcher watcher) {\n        return addWatch(path, watcher, WatcherMode.DEFAULT_WATCHER_MODE);\n    }\n\n    @Override\n    public synchronized boolean addWatch(String path, Watcher watcher, WatcherMode watcherMode) {\n        if (isDeadWatcher(watcher)) {\n            LOG.debug(\"Ignoring addWatch with closed cnxn\");\n            return false;\n        }\n\n        Set<Watcher> list = watchTable.get(path);\n        if (list == null) {\n            // don't waste memory if there are few watches on a node\n            // rehash when the 4th entry is added, doubling size thereafter\n            // seems like a good compromise\n            list = new HashSet<>(4);\n            watchTable.put(path, list);\n        }\n        list.add(watcher);\n\n        Map<String, WatchStats> paths = watch2Paths.get(watcher);\n        if (paths == null) {\n            // cnxns typically have many watches, so use default cap here\n            paths = new HashMap<>();\n            watch2Paths.put(watcher, paths);\n        }\n\n        WatchStats stats = paths.getOrDefault(path, WatchStats.NONE);\n        WatchStats newStats = stats.addMode(watcherMode);\n\n        if (newStats != stats) {\n            paths.put(path, newStats);\n            if (watcherMode.isRecursive()) {\n                ++recursiveWatchQty;\n            }\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public synchronized void removeWatcher(Watcher watcher) {\n        Map<String, WatchStats> paths = watch2Paths.remove(watcher);\n        if (paths == null) {\n            return;\n        }\n        for (String p : paths.keySet()) {\n            Set<Watcher> list = watchTable.get(p);\n            if (list != null) {\n                list.remove(watcher);\n                if (list.isEmpty()) {\n                    watchTable.remove(p);\n                }\n            }\n        }\n        for (WatchStats stats : paths.values()) {\n            if (stats.hasMode(WatcherMode.PERSISTENT_RECURSIVE)) {\n                --recursiveWatchQty;\n            }\n        }\n    }\n\n    @Override\n    public WatcherOrBitSet triggerWatch(String path, EventType type) {\n        return triggerWatch(path, type, null);\n    }\n\n    @Override\n    public WatcherOrBitSet triggerWatch(String path, EventType type, WatcherOrBitSet supress) {\n        WatchedEvent e = new WatchedEvent(type, KeeperState.SyncConnected, path);\n        Set<Watcher> watchers = new HashSet<>();\n        synchronized (this) {\n            PathParentIterator pathParentIterator = getPathParentIterator(path);\n            for (String localPath : pathParentIterator.asIterable()) {\n                Set<Watcher> thisWatchers = watchTable.get(localPath);\n                if (thisWatchers == null || thisWatchers.isEmpty()) {\n                    continue;\n                }\n                Iterator<Watcher> iterator = thisWatchers.iterator();\n                while (iterator.hasNext()) {\n                    Watcher watcher = iterator.next();\n                    Map<String, WatchStats> paths = watch2Paths.getOrDefault(watcher, Collections.emptyMap());\n                    WatchStats stats = paths.get(localPath);\n                    if (stats == null) {\n                        LOG.warn(\"inconsistent watch table for watcher {}, {} not in path list\", watcher, localPath);\n                        continue;\n                    }\n                    if (!pathParentIterator.atParentPath()) {\n                        watchers.add(watcher);\n                        WatchStats newStats = stats.removeMode(WatcherMode.STANDARD);\n                        if (newStats == WatchStats.NONE) {\n                            iterator.remove();\n                            paths.remove(localPath);\n                        } else if (newStats != stats) {\n                            paths.put(localPath, newStats);\n                        }\n                    } else if (stats.hasMode(WatcherMode.PERSISTENT_RECURSIVE)) {\n                        watchers.add(watcher);\n                    }\n                }\n                if (thisWatchers.isEmpty()) {\n                    watchTable.remove(localPath);\n                }\n            }\n        }\n        if (watchers.isEmpty()) {\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, \"No watchers for \" + path);\n            }\n            return null;\n        }\n\n        for (Watcher w : watchers) {\n            if (supress != null && supress.contains(w)) {\n                continue;\n            }\n            w.process(e);\n        }\n\n        switch (type) {\n            case NodeCreated:\n                ServerMetrics.getMetrics().NODE_CREATED_WATCHER.add(watchers.size());\n                break;\n\n            case NodeDeleted:\n                ServerMetrics.getMetrics().NODE_DELETED_WATCHER.add(watchers.size());\n                break;\n\n            case NodeDataChanged:\n                ServerMetrics.getMetrics().NODE_CHANGED_WATCHER.add(watchers.size());\n                break;\n\n            case NodeChildrenChanged:\n                ServerMetrics.getMetrics().NODE_CHILDREN_WATCHER.add(watchers.size());\n                break;\n            default:\n                // Other types not logged.\n                break;\n        }\n\n        return new WatcherOrBitSet(watchers);\n    }\n\n    @Override\n    public synchronized String toString() {\n        StringBuilder sb = new StringBuilder();\n\n        sb.append(watch2Paths.size()).append(\" connections watching \").append(watchTable.size()).append(\" paths\\n\");\n\n        int total = 0;\n        for (Map<String, WatchStats> paths : watch2Paths.values()) {\n            total += paths.size();\n        }\n        sb.append(\"Total watches:\").append(total);\n\n        return sb.toString();\n    }\n\n    @Override\n    public synchronized void dumpWatches(PrintWriter pwriter, boolean byPath) {\n        if (byPath) {\n            for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {\n                pwriter.println(e.getKey());\n                for (Watcher w : e.getValue()) {\n                    pwriter.print(\"\\t0x\");\n                    pwriter.print(Long.toHexString(((ServerCnxn) w).getSessionId()));\n                    pwriter.print(\"\\n\");\n                }\n            }\n        } else {\n            for (Entry<Watcher, Map<String, WatchStats>> e : watch2Paths.entrySet()) {\n                pwriter.print(\"0x\");\n                pwriter.println(Long.toHexString(((ServerCnxn) e.getKey()).getSessionId()));\n                for (String path : e.getValue().keySet()) {\n                    pwriter.print(\"\\t\");\n                    pwriter.println(path);\n                }\n            }\n        }\n    }\n\n    @Override\n    public synchronized boolean containsWatcher(String path, Watcher watcher) {\n        Set<Watcher> list = watchTable.get(path);\n        return list != null && list.contains(watcher);\n    }\n\n    @Override\n    public synchronized boolean removeWatcher(String path, Watcher watcher) {\n        Map<String, WatchStats> paths = watch2Paths.get(watcher);\n        if (paths == null) {\n            return false;\n        }\n\n        WatchStats stats = paths.remove(path);\n        if (stats == null) {\n            return false;\n        }\n        if (stats.hasMode(WatcherMode.PERSISTENT_RECURSIVE)) {\n            --recursiveWatchQty;\n        }\n\n        Set<Watcher> list = watchTable.get(path);\n        if (list == null || !list.remove(watcher)) {\n            LOG.warn(\"inconsistent watch table for path {}, {} not in watcher list\", path, watcher);\n            return false;\n        }\n\n        if (list.isEmpty()) {\n            watchTable.remove(path);\n        }\n\n        return true;\n    }\n\n    // VisibleForTesting\n    Map<Watcher, Map<String, WatchStats>> getWatch2Paths() {\n        return watch2Paths;\n    }\n\n    @Override\n    public synchronized WatchesReport getWatches() {\n        Map<Long, Set<String>> id2paths = new HashMap<>();\n        for (Entry<Watcher, Map<String, WatchStats>> e : watch2Paths.entrySet()) {\n            Long id = ((ServerCnxn) e.getKey()).getSessionId();\n            Set<String> paths = new HashSet<>(e.getValue().keySet());\n            id2paths.put(id, paths);\n        }\n        return new WatchesReport(id2paths);\n    }\n\n    @Override\n    public synchronized WatchesPathReport getWatchesByPath() {\n        Map<String, Set<Long>> path2ids = new HashMap<>();\n        for (Entry<String, Set<Watcher>> e : watchTable.entrySet()) {\n            Set<Long> ids = new HashSet<>(e.getValue().size());\n            path2ids.put(e.getKey(), ids);\n            for (Watcher watcher : e.getValue()) {\n                ids.add(((ServerCnxn) watcher).getSessionId());\n            }\n        }\n        return new WatchesPathReport(path2ids);\n    }\n\n    @Override\n    public synchronized WatchesSummary getWatchesSummary() {\n        int totalWatches = 0;\n        for (Map<String, WatchStats> paths : watch2Paths.values()) {\n            totalWatches += paths.size();\n        }\n        return new WatchesSummary(watch2Paths.size(), watchTable.size(), totalWatches);\n    }\n\n    @Override\n    public void shutdown() { /* do nothing */ }\n\n    // VisibleForTesting\n    synchronized int getRecursiveWatchQty() {\n        return recursiveWatchQty;\n    }\n\n    private PathParentIterator getPathParentIterator(String path) {\n        if (getRecursiveWatchQty() == 0) {\n            return PathParentIterator.forPathOnly(path);\n        }\n        return PathParentIterator.forAll(path);\n    }\n}\n","lineNo":263}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.admin;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.apache.zookeeper.metrics.MetricsUtils;\nimport org.apache.zookeeper.server.ServerCnxnFactory;\nimport org.apache.zookeeper.server.ServerStats;\nimport org.apache.zookeeper.server.ZKDatabase;\nimport org.apache.zookeeper.server.ZooKeeperServer;\nimport org.apache.zookeeper.server.quorum.BufferStats;\nimport org.apache.zookeeper.test.ClientBase;\nimport org.junit.jupiter.api.Test;\n\npublic class CommandsTest extends ClientBase {\n\n    /**\n     * Checks that running a given Command returns the expected Map. Asserts\n     * that all specified keys are present with values of the specified types\n     * and that there are no extra entries.\n     *\n     * @param cmdName\n     *            - the primary name of the command\n     * @param kwargs\n     *            - keyword arguments to the command\n     * @param fields\n     *            - the fields that are expected in the returned Map\n     * @throws IOException\n     * @throws InterruptedException\n     */\n    public void testCommand(String cmdName, Map<String, String> kwargs, Field... fields) throws IOException, InterruptedException {\n        ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n        Map<String, Object> result = Commands.runCommand(cmdName, zks, kwargs).toMap();\n\n        assertTrue(result.containsKey(\"command\"));\n        // This is only true because we're setting cmdName to the primary name\n        assertEquals(cmdName, result.remove(\"command\"));\n        assertTrue(result.containsKey(\"error\"));\n        assertNull(result.remove(\"error\"), \"error: \" + result.get(\"error\"));\n\n        for (Field field : fields) {\n            String k = field.key;\n            assertTrue(result.containsKey(k),\n                    \"Result from command \" + cmdName + \" missing field \\\"\" + k + \"\\\"\" + \"\\n\" + result);\n            Class<?> t = field.type;\n            Object v = result.remove(k);\n            assertTrue(t.isAssignableFrom(v.getClass()),\n                    \"\\\"\" + k + \"\\\" field from command \" + cmdName\n                            + \" should be of type \" + t + \", is actually of type \" + v.getClass());\n        }\n\n        assertTrue(result.isEmpty(), \"Result from command \" + cmdName + \" contains extra fields: \" + result);\n    }\n\n    public void testCommand(String cmdName, Field... fields) throws IOException, InterruptedException {\n        testCommand(cmdName, new HashMap<String, String>(), fields);\n    }\n\n    private static class Field {\n\n        String key;\n        Class<?> type;\n        Field(String key, Class<?> type) {\n            this.key = key;\n            this.type = type;\n        }\n\n    }\n\n    @Test\n    public void testConfiguration() throws IOException, InterruptedException {\n        testCommand(\"configuration\", new Field(\"client_port\", Integer.class), new Field(\"data_dir\", String.class), new Field(\"data_log_dir\", String.class), new Field(\"tick_time\", Integer.class), new Field(\"max_client_cnxns\", Integer.class), new Field(\"min_session_timeout\", Integer.class), new Field(\"max_session_timeout\", Integer.class), new Field(\"server_id\", Long.class), new Field(\"client_port_listen_backlog\", Integer.class));\n    }\n\n    @Test\n    public void testConnections() throws IOException, InterruptedException {\n        testCommand(\"connections\", new Field(\"connections\", Iterable.class), new Field(\"secure_connections\", Iterable.class));\n    }\n\n    @Test\n    public void testObservers() throws IOException, InterruptedException {\n        testCommand(\"observers\", new Field(\"synced_observers\", Integer.class), new Field(\"observers\", Iterable.class));\n    }\n\n    @Test\n    public void testObserverConnectionStatReset() throws IOException, InterruptedException {\n        testCommand(\"observer_connection_stat_reset\");\n    }\n\n    @Test\n    public void testConnectionStatReset() throws IOException, InterruptedException {\n        testCommand(\"connection_stat_reset\");\n    }\n\n    @Test\n    public void testDump() throws IOException, InterruptedException {\n        testCommand(\"dump\", new Field(\"expiry_time_to_session_ids\", Map.class), new Field(\"session_id_to_ephemeral_paths\", Map.class));\n    }\n\n    @Test\n    public void testEnvironment() throws IOException, InterruptedException {\n        testCommand(\"environment\", new Field(\"zookeeper.version\", String.class), new Field(\"host.name\", String.class), new Field(\"java.version\", String.class), new Field(\"java.vendor\", String.class), new Field(\"java.home\", String.class), new Field(\"java.class.path\", String.class), new Field(\"java.library.path\", String.class), new Field(\"java.io.tmpdir\", String.class), new Field(\"java.compiler\", String.class), new Field(\"os.name\", String.class), new Field(\"os.arch\", String.class), new Field(\"os.version\", String.class), new Field(\"user.name\", String.class), new Field(\"user.home\", String.class), new Field(\"user.dir\", String.class), new Field(\"os.memory.free\", String.class), new Field(\"os.memory.max\", String.class), new Field(\"os.memory.total\", String.class));\n    }\n\n    @Test\n    public void testGetTraceMask() throws IOException, InterruptedException {\n        testCommand(\"get_trace_mask\", new Field(\"tracemask\", Long.class));\n    }\n\n    @Test\n    public void testIsReadOnly() throws IOException, InterruptedException {\n        testCommand(\"is_read_only\", new Field(\"read_only\", Boolean.class));\n    }\n\n    @Test\n    public void testLastSnapshot() throws IOException, InterruptedException {\n        testCommand(\"last_snapshot\", new Field(\"zxid\", String.class), new Field(\"timestamp\", Long.class));\n    }\n\n    @Test\n    public void testMonitor() throws IOException, InterruptedException {\n        ArrayList<Field> fields = new ArrayList<>(Arrays.asList(\n                new Field(\"version\", String.class),\n                new Field(\"avg_latency\", Double.class),\n                new Field(\"max_latency\", Long.class),\n                new Field(\"min_latency\", Long.class),\n                new Field(\"packets_received\", Long.class),\n                new Field(\"packets_sent\", Long.class),\n                new Field(\"num_alive_connections\", Integer.class),\n                new Field(\"outstanding_requests\", Long.class),\n                new Field(\"server_state\", String.class),\n                new Field(\"znode_count\", Integer.class),\n                new Field(\"watch_count\", Integer.class),\n                new Field(\"ephemerals_count\", Integer.class),\n                new Field(\"approximate_data_size\", Long.class),\n                new Field(\"open_file_descriptor_count\", Long.class),\n                new Field(\"max_file_descriptor_count\", Long.class),\n                new Field(\"last_client_response_size\", Integer.class),\n                new Field(\"max_client_response_size\", Integer.class),\n                new Field(\"min_client_response_size\", Integer.class),\n                new Field(\"auth_failed_count\", Long.class),\n                new Field(\"non_mtls_remote_conn_count\", Long.class),\n                new Field(\"non_mtls_local_conn_count\", Long.class),\n                new Field(\"uptime\", Long.class),\n                new Field(\"global_sessions\", Long.class),\n                new Field(\"local_sessions\", Long.class),\n                new Field(\"connection_drop_probability\", Double.class),\n                new Field(\"outstanding_tls_handshake\", Integer.class)\n        ));\n        Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n\n        for (String metric : metrics.keySet()) {\n            boolean alreadyDefined = fields.stream().anyMatch(f -> {\n                return f.key.equals(metric);\n            });\n            if (alreadyDefined) {\n                // known metrics are defined statically in the block above\n                continue;\n            }\n            if (metric.startsWith(\"avg_\")) {\n                fields.add(new Field(metric, Double.class));\n            } else {\n                fields.add(new Field(metric, Long.class));\n            }\n        }\n        Field[] fieldsArray = fields.toArray(new Field[0]);\n        testCommand(\"monitor\", fieldsArray);\n    }\n\n    @Test\n    public void testRuok() throws IOException, InterruptedException {\n        testCommand(\"ruok\");\n    }\n\n    @Test\n    public void testServerStats() throws IOException, InterruptedException {\n        testCommand(\"server_stats\", new Field(\"version\", String.class), new Field(\"read_only\", Boolean.class), new Field(\"server_stats\", ServerStats.class), new Field(\"node_count\", Integer.class), new Field(\"client_response\", BufferStats.class));\n    }\n\n    @Test\n    public void testSetTraceMask() throws IOException, InterruptedException {\n        Map<String, String> kwargs = new HashMap<String, String>();\n        kwargs.put(\"traceMask\", \"1\");\n        testCommand(\"set_trace_mask\", kwargs, new Field(\"tracemask\", Long.class));\n    }\n\n    @Test\n    public void testStat() throws IOException, InterruptedException {\n        testCommand(\"stats\",\n                    new Field(\"version\", String.class),\n                    new Field(\"read_only\", Boolean.class),\n                    new Field(\"server_stats\", ServerStats.class),\n                    new Field(\"node_count\", Integer.class),\n                    new Field(\"connections\", Iterable.class),\n                    new Field(\"secure_connections\", Iterable.class),\n                    new Field(\"client_response\", BufferStats.class));\n    }\n\n    @Test\n    public void testStatReset() throws IOException, InterruptedException {\n        testCommand(\"stat_reset\");\n    }\n\n    @Test\n    public void testWatches() throws IOException, InterruptedException {\n        testCommand(\"watches\", new Field(\"session_id_to_watched_paths\", Map.class));\n    }\n\n    @Test\n    public void testWatchesByPath() throws IOException, InterruptedException {\n        testCommand(\"watches_by_path\", new Field(\"path_to_session_ids\", Map.class));\n    }\n\n    @Test\n    public void testWatchSummary() throws IOException, InterruptedException {\n        testCommand(\"watch_summary\", new Field(\"num_connections\", Integer.class), new Field(\"num_paths\", Integer.class), new Field(\"num_total_watches\", Integer.class));\n    }\n\n    @Test\n    public void testVotingViewCommand() throws IOException, InterruptedException {\n        testCommand(\"voting_view\",\n                    new Field(\"current_config\", Map.class));\n    }\n\n    @Test\n    public void testConsCommandSecureOnly() {\n        // Arrange\n        Commands.ConsCommand cmd = new Commands.ConsCommand();\n        ZooKeeperServer zkServer = mock(ZooKeeperServer.class);\n        ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);\n        when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);\n\n        // Act\n        CommandResponse response = cmd.run(zkServer, null);\n\n        // Assert\n        assertThat(response.toMap().containsKey(\"connections\"), is(true));\n        assertThat(response.toMap().containsKey(\"secure_connections\"), is(true));\n    }\n\n    /**\n     * testing Stat command, when only SecureClientPort is defined by the user and there is no\n     * regular (non-SSL port) open. In this case zkServer.getServerCnxnFactory === null\n     * see: ZOOKEEPER-3633\n     */\n    @Test\n    public void testStatCommandSecureOnly() {\n        Commands.StatCommand cmd = new Commands.StatCommand();\n        ZooKeeperServer zkServer = mock(ZooKeeperServer.class);\n        ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);\n        ServerStats serverStats = mock(ServerStats.class);\n        ZKDatabase zkDatabase = mock(ZKDatabase.class);\n        when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);\n        when(zkServer.serverStats()).thenReturn(serverStats);\n        when(zkServer.getZKDatabase()).thenReturn(zkDatabase);\n        when(zkDatabase.getNodeCount()).thenReturn(0);\n\n        CommandResponse response = cmd.run(zkServer, null);\n\n        assertThat(response.toMap().containsKey(\"connections\"), is(true));\n        assertThat(response.toMap().containsKey(\"secure_connections\"), is(true));\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.admin;\n\nimport static org.apache.zookeeper.server.ZooKeeperServer.ZOOKEEPER_SERIALIZE_LAST_PROCESSED_ZXID_ENABLED;\nimport static org.apache.zookeeper.server.admin.Commands.SnapshotCommand.ADMIN_SNAPSHOT_ENABLED;\nimport static org.apache.zookeeper.server.admin.Commands.SnapshotCommand.ADMIN_SNAPSHOT_INTERVAL;\nimport static org.apache.zookeeper.server.admin.Commands.SnapshotCommand.REQUEST_QUERY_PARAM_STREAMING;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.servlet.http.HttpServletResponse;\nimport org.apache.zookeeper.metrics.MetricsUtils;\nimport org.apache.zookeeper.server.ServerCnxnFactory;\nimport org.apache.zookeeper.server.ServerStats;\nimport org.apache.zookeeper.server.ZKDatabase;\nimport org.apache.zookeeper.server.ZooKeeperServer;\nimport org.apache.zookeeper.server.quorum.BufferStats;\nimport org.apache.zookeeper.test.ClientBase;\nimport org.junit.jupiter.api.Test;\n\npublic class CommandsTest extends ClientBase {\n\n    /**\n     * Checks that running a given Command returns the expected Map. Asserts\n     * that all specified keys are present with values of the specified types\n     * and that there are no extra entries.\n     *\n     * @param cmdName\n     *            - the primary name of the command\n     * @param kwargs\n     *            - keyword arguments to the command\n     * @param expectedHeaders\n     *            - expected HTTP response headers\n     * @param expectedStatusCode\n     *            - expected HTTP status code\n     * @param fields\n     *            - the fields that are expected in the returned Map\n     * @throws IOException\n     * @throws InterruptedException\n     */\n    private void testCommand(String cmdName, Map<String, String> kwargs,\n                             Map<String, String> expectedHeaders, int expectedStatusCode,\n                             Field... fields) throws IOException, InterruptedException {\n        ZooKeeperServer zks = serverFactory.getZooKeeperServer();\n        final CommandResponse commandResponse = Commands.runCommand(cmdName, zks, kwargs);\n        assertNotNull(commandResponse);\n        assertEquals(expectedStatusCode, commandResponse.getStatusCode());\n        try (final InputStream responseStream = commandResponse.getInputStream()) {\n            if (Boolean.parseBoolean(kwargs.getOrDefault(REQUEST_QUERY_PARAM_STREAMING, \"false\"))) {\n                assertNotNull(responseStream, \"InputStream in the response of command \" + cmdName + \" should not be null\");\n            } else {\n                Map<String, Object> result = commandResponse.toMap();\n                assertTrue(result.containsKey(\"command\"));\n                // This is only true because we're setting cmdName to the primary name\n                assertEquals(cmdName, result.remove(\"command\"));\n                assertTrue(result.containsKey(\"error\"));\n                assertNull(result.remove(\"error\"), \"error: \" + result.get(\"error\"));\n\n                for (Field field : fields) {\n                    String k = field.key;\n                    assertTrue(result.containsKey(k),\n                            \"Result from command \" + cmdName + \" missing field \\\"\" + k + \"\\\"\" + \"\\n\" + result);\n                    Class<?> t = field.type;\n                    Object v = result.remove(k);\n                    assertTrue(t.isAssignableFrom(v.getClass()),\n                            \"\\\"\" + k + \"\\\" field from command \" + cmdName\n                                    + \" should be of type \" + t + \", is actually of type \" + v.getClass());\n                }\n\n                assertTrue(result.isEmpty(), \"Result from command \" + cmdName + \" contains extra fields: \" + result);\n            }\n        }\n        assertEquals(expectedHeaders, commandResponse.getHeaders());\n    }\n\n    public void testCommand(String cmdName, Field... fields) throws IOException, InterruptedException {\n        testCommand(cmdName, new HashMap<String, String>(), new HashMap<>(), HttpServletResponse.SC_OK, fields);\n    }\n\n    private static class Field {\n\n        String key;\n        Class<?> type;\n        Field(String key, Class<?> type) {\n            this.key = key;\n            this.type = type;\n        }\n    }\n\n    @Test\n    public void testSnapshot_streaming() throws IOException, InterruptedException {\n        testSnapshot(true);\n    }\n\n    @Test\n    public void testSnapshot_nonStreaming() throws IOException, InterruptedException {\n        testSnapshot(false);\n    }\n\n    @Test\n    public void testConfiguration() throws IOException, InterruptedException {\n        testCommand(\"configuration\", new Field(\"client_port\", Integer.class), new Field(\"data_dir\", String.class), new Field(\"data_log_dir\", String.class), new Field(\"tick_time\", Integer.class), new Field(\"max_client_cnxns\", Integer.class), new Field(\"min_session_timeout\", Integer.class), new Field(\"max_session_timeout\", Integer.class), new Field(\"server_id\", Long.class), new Field(\"client_port_listen_backlog\", Integer.class));\n    }\n\n    @Test\n    public void testConnections() throws IOException, InterruptedException {\n        testCommand(\"connections\", new Field(\"connections\", Iterable.class), new Field(\"secure_connections\", Iterable.class));\n    }\n\n    @Test\n    public void testObservers() throws IOException, InterruptedException {\n        testCommand(\"observers\", new Field(\"synced_observers\", Integer.class), new Field(\"observers\", Iterable.class));\n    }\n\n    @Test\n    public void testObserverConnectionStatReset() throws IOException, InterruptedException {\n        testCommand(\"observer_connection_stat_reset\");\n    }\n\n    @Test\n    public void testConnectionStatReset() throws IOException, InterruptedException {\n        testCommand(\"connection_stat_reset\");\n    }\n\n    @Test\n    public void testDump() throws IOException, InterruptedException {\n        testCommand(\"dump\", new Field(\"expiry_time_to_session_ids\", Map.class), new Field(\"session_id_to_ephemeral_paths\", Map.class));\n    }\n\n    @Test\n    public void testEnvironment() throws IOException, InterruptedException {\n        testCommand(\"environment\", new Field(\"zookeeper.version\", String.class), new Field(\"host.name\", String.class), new Field(\"java.version\", String.class), new Field(\"java.vendor\", String.class), new Field(\"java.home\", String.class), new Field(\"java.class.path\", String.class), new Field(\"java.library.path\", String.class), new Field(\"java.io.tmpdir\", String.class), new Field(\"java.compiler\", String.class), new Field(\"os.name\", String.class), new Field(\"os.arch\", String.class), new Field(\"os.version\", String.class), new Field(\"user.name\", String.class), new Field(\"user.home\", String.class), new Field(\"user.dir\", String.class), new Field(\"os.memory.free\", String.class), new Field(\"os.memory.max\", String.class), new Field(\"os.memory.total\", String.class));\n    }\n\n    @Test\n    public void testGetTraceMask() throws IOException, InterruptedException {\n        testCommand(\"get_trace_mask\", new Field(\"tracemask\", Long.class));\n    }\n\n    @Test\n    public void testIsReadOnly() throws IOException, InterruptedException {\n        testCommand(\"is_read_only\", new Field(\"read_only\", Boolean.class));\n    }\n\n    @Test\n    public void testLastSnapshot() throws IOException, InterruptedException {\n        testCommand(\"last_snapshot\", new Field(\"zxid\", String.class), new Field(\"timestamp\", Long.class));\n    }\n\n    @Test\n    public void testMonitor() throws IOException, InterruptedException {\n        ArrayList<Field> fields = new ArrayList<>(Arrays.asList(\n                new Field(\"version\", String.class),\n                new Field(\"avg_latency\", Double.class),\n                new Field(\"max_latency\", Long.class),\n                new Field(\"min_latency\", Long.class),\n                new Field(\"packets_received\", Long.class),\n                new Field(\"packets_sent\", Long.class),\n                new Field(\"num_alive_connections\", Integer.class),\n                new Field(\"outstanding_requests\", Long.class),\n                new Field(\"server_state\", String.class),\n                new Field(\"znode_count\", Integer.class),\n                new Field(\"watch_count\", Integer.class),\n                new Field(\"ephemerals_count\", Integer.class),\n                new Field(\"approximate_data_size\", Long.class),\n                new Field(\"open_file_descriptor_count\", Long.class),\n                new Field(\"max_file_descriptor_count\", Long.class),\n                new Field(\"last_client_response_size\", Integer.class),\n                new Field(\"max_client_response_size\", Integer.class),\n                new Field(\"min_client_response_size\", Integer.class),\n                new Field(\"auth_failed_count\", Long.class),\n                new Field(\"non_mtls_remote_conn_count\", Long.class),\n                new Field(\"non_mtls_local_conn_count\", Long.class),\n                new Field(\"uptime\", Long.class),\n                new Field(\"global_sessions\", Long.class),\n                new Field(\"local_sessions\", Long.class),\n                new Field(\"connection_drop_probability\", Double.class),\n                new Field(\"outstanding_tls_handshake\", Integer.class)\n        ));\n        Map<String, Object> metrics = MetricsUtils.currentServerMetrics();\n\n        for (String metric : metrics.keySet()) {\n            boolean alreadyDefined = fields.stream().anyMatch(f -> {\n                return f.key.equals(metric);\n            });\n            if (alreadyDefined) {\n                // known metrics are defined statically in the block above\n                continue;\n            }\n            if (metric.startsWith(\"avg_\")) {\n                fields.add(new Field(metric, Double.class));\n            } else {\n                fields.add(new Field(metric, Long.class));\n            }\n        }\n        Field[] fieldsArray = fields.toArray(new Field[0]);\n        testCommand(\"monitor\", fieldsArray);\n    }\n\n    @Test\n    public void testRuok() throws IOException, InterruptedException {\n        testCommand(\"ruok\");\n    }\n\n    @Test\n    public void testServerStats() throws IOException, InterruptedException {\n        testCommand(\"server_stats\", new Field(\"version\", String.class), new Field(\"read_only\", Boolean.class), new Field(\"server_stats\", ServerStats.class), new Field(\"node_count\", Integer.class), new Field(\"client_response\", BufferStats.class));\n    }\n\n    @Test\n    public void testSetTraceMask() throws IOException, InterruptedException {\n        Map<String, String> kwargs = new HashMap<String, String>();\n        kwargs.put(\"traceMask\", \"1\");\n        testCommand(\"set_trace_mask\", kwargs, new HashMap<>(), HttpServletResponse.SC_OK, new Field(\"tracemask\", Long.class));\n    }\n\n    @Test\n    public void testStat() throws IOException, InterruptedException {\n        testCommand(\"stats\",\n                    new Field(\"version\", String.class),\n                    new Field(\"read_only\", Boolean.class),\n                    new Field(\"server_stats\", ServerStats.class),\n                    new Field(\"node_count\", Integer.class),\n                    new Field(\"connections\", Iterable.class),\n                    new Field(\"secure_connections\", Iterable.class),\n                    new Field(\"client_response\", BufferStats.class));\n    }\n\n    @Test\n    public void testStatReset() throws IOException, InterruptedException {\n        testCommand(\"stat_reset\");\n    }\n\n    @Test\n    public void testWatches() throws IOException, InterruptedException {\n        testCommand(\"watches\", new Field(\"session_id_to_watched_paths\", Map.class));\n    }\n\n    @Test\n    public void testWatchesByPath() throws IOException, InterruptedException {\n        testCommand(\"watches_by_path\", new Field(\"path_to_session_ids\", Map.class));\n    }\n\n    @Test\n    public void testWatchSummary() throws IOException, InterruptedException {\n        testCommand(\"watch_summary\", new Field(\"num_connections\", Integer.class), new Field(\"num_paths\", Integer.class), new Field(\"num_total_watches\", Integer.class));\n    }\n\n    @Test\n    public void testVotingViewCommand() throws IOException, InterruptedException {\n        testCommand(\"voting_view\",\n                    new Field(\"current_config\", Map.class));\n    }\n\n    @Test\n    public void testConsCommandSecureOnly() {\n        // Arrange\n        Commands.ConsCommand cmd = new Commands.ConsCommand();\n        ZooKeeperServer zkServer = mock(ZooKeeperServer.class);\n        ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);\n        when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);\n\n        // Act\n        CommandResponse response = cmd.run(zkServer, null);\n\n        // Assert\n        assertThat(response.toMap().containsKey(\"connections\"), is(true));\n        assertThat(response.toMap().containsKey(\"secure_connections\"), is(true));\n    }\n\n    /**\n     * testing Stat command, when only SecureClientPort is defined by the user and there is no\n     * regular (non-SSL port) open. In this case zkServer.getServerCnxnFactory === null\n     * see: ZOOKEEPER-3633\n     */\n    @Test\n    public void testStatCommandSecureOnly() {\n        Commands.StatCommand cmd = new Commands.StatCommand();\n        ZooKeeperServer zkServer = mock(ZooKeeperServer.class);\n        ServerCnxnFactory cnxnFactory = mock(ServerCnxnFactory.class);\n        ServerStats serverStats = mock(ServerStats.class);\n        ZKDatabase zkDatabase = mock(ZKDatabase.class);\n        when(zkServer.getSecureServerCnxnFactory()).thenReturn(cnxnFactory);\n        when(zkServer.serverStats()).thenReturn(serverStats);\n        when(zkServer.getZKDatabase()).thenReturn(zkDatabase);\n        when(zkDatabase.getNodeCount()).thenReturn(0);\n\n        CommandResponse response = cmd.run(zkServer, null);\n\n        assertThat(response.toMap().containsKey(\"connections\"), is(true));\n        assertThat(response.toMap().containsKey(\"secure_connections\"), is(true));\n    }\n\n    private void testSnapshot(final boolean streaming) throws IOException, InterruptedException {\n        System.setProperty(ADMIN_SNAPSHOT_ENABLED, \"true\");\n        System.setProperty(ADMIN_SNAPSHOT_INTERVAL, \"0\");\n        System.setProperty(ZOOKEEPER_SERIALIZE_LAST_PROCESSED_ZXID_ENABLED, \"true\");\n        try {\n            final Map<String, String> kwargs = new HashMap<>();\n            kwargs.put(REQUEST_QUERY_PARAM_STREAMING, String.valueOf(streaming));\n            final Map<String, String> expectedHeaders = new HashMap<>();\n            expectedHeaders.put(Commands.SnapshotCommand.RESPONSE_HEADER_LAST_ZXID, \"0x0\");\n            expectedHeaders.put(Commands.SnapshotCommand.RESPONSE_HEADER_SNAPSHOT_SIZE, \"478\");\n            testCommand(\"snapshot\", kwargs, expectedHeaders, HttpServletResponse.SC_OK);\n        } finally {\n            System.clearProperty(ADMIN_SNAPSHOT_ENABLED);\n            System.clearProperty(ADMIN_SNAPSHOT_INTERVAL);\n            System.clearProperty(ZOOKEEPER_SERIALIZE_LAST_PROCESSED_ZXID_ENABLED);\n        }\n    }\n\n}\n","lineNo":73}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.CancelledKeyException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.security.cert.Certificate;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class handles communication with clients using NIO. There is one per\n * client, but only one thread doing the communication.\n */\npublic class NIOServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxn.class);\n\n    private final NIOServerCnxnFactory factory;\n\n    private final SocketChannel sock;\n\n    private final SelectorThread selectorThread;\n\n    private final SelectionKey sk;\n\n    private boolean initialized;\n\n    private final ByteBuffer lenBuffer = ByteBuffer.allocate(4);\n\n    protected ByteBuffer incomingBuffer = lenBuffer;\n\n    private final Queue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();\n\n    private int sessionTimeout;\n\n    /**\n     * This is the id that uniquely identifies the session of a client. Once\n     * this session is no longer active, the ephemeral nodes will go away.\n     */\n    private long sessionId;\n\n    /**\n     * Client socket option for TCP keepalive\n     */\n    private final boolean clientTcpKeepAlive = Boolean.getBoolean(\"zookeeper.clientTcpKeepAlive\");\n\n    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock, SelectionKey sk, NIOServerCnxnFactory factory, SelectorThread selectorThread) throws IOException {\n        super(zk);\n        this.sock = sock;\n        this.sk = sk;\n        this.factory = factory;\n        this.selectorThread = selectorThread;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        sock.socket().setTcpNoDelay(true);\n        /* set socket linger to false, so that socket close does not block */\n        sock.socket().setSoLinger(false, -1);\n        sock.socket().setKeepAlive(clientTcpKeepAlive);\n        InetAddress addr = ((InetSocketAddress) sock.socket().getRemoteSocketAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n        this.sessionTimeout = factory.sessionlessCnxnTimeout;\n    }\n\n    /* Send close connection packet to the client, doIO will eventually\n     * close the underlying machinery (like socket, selectorkey, etc...)\n     */\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    /**\n     * send buffer without using the asynchronous\n     * calls to selector and then close the socket\n     * @param bb\n     */\n    void sendBufferSync(ByteBuffer bb) {\n        try {\n            /* configure socket to be blocking\n             * so that we dont have to do write in\n             * a tight while loop\n             */\n            if (bb != ServerCnxnFactory.closeConn) {\n                if (sock.isOpen()) {\n                    sock.configureBlocking(true);\n                    sock.write(bb);\n                }\n                packetSent();\n            }\n        } catch (IOException ie) {\n            LOG.error(\"Error sending data synchronously \", ie);\n        }\n    }\n\n    /**\n     * sendBuffer pushes a byte buffer onto the outgoing buffer queue for\n     * asynchronous writes.\n     */\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Add a buffer to outgoingBuffers, sk {} is valid: {}\", sk, sk.isValid());\n        }\n\n        synchronized (outgoingBuffers) {\n            for (ByteBuffer buffer : buffers) {\n                outgoingBuffers.add(buffer);\n            }\n            outgoingBuffers.add(packetSentinel);\n        }\n        requestInterestOpsUpdate();\n    }\n\n    /**\n     * When read on socket failed, this is typically because client closed the\n     * connection. In most cases, the client does this when the server doesn't\n     * respond within 2/3 of session timeout. This possibly indicates server\n     * health/performance issue, so we need to log and keep track of stat\n     *\n     * @throws EndOfStreamException\n     */\n    private void handleFailedRead() throws EndOfStreamException {\n        setStale();\n        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n        throw new EndOfStreamException(\"Unable to read additional data from client,\"\n                                       + \" it probably closed the socket:\"\n                                       + \" address = \" + sock.socket().getRemoteSocketAddress() + \",\"\n                                       + \" session = 0x\" + Long.toHexString(sessionId),\n                                       DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);\n    }\n\n    /** Read the request payload (everything following the length prefix) */\n    private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException {\n        if (incomingBuffer.remaining() != 0) { // have we read length bytes?\n            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok\n            if (rc < 0) {\n                handleFailedRead();\n            }\n        }\n\n        if (incomingBuffer.remaining() == 0) { // have we read length bytes?\n            incomingBuffer.flip();\n            packetReceived(4 + incomingBuffer.remaining());\n            if (!initialized) {\n                readConnectRequest();\n            } else {\n                readRequest();\n            }\n            lenBuffer.clear();\n            incomingBuffer = lenBuffer;\n        }\n    }\n\n    /**\n     * This boolean tracks whether the connection is ready for selection or\n     * not. A connection is marked as not ready for selection while it is\n     * processing an IO request. The flag is used to gatekeep pushing interest\n     * op updates onto the selector.\n     */\n    private final AtomicBoolean selectable = new AtomicBoolean(true);\n\n    public boolean isSelectable() {\n        return sk.isValid() && selectable.get();\n    }\n\n    public void disableSelectable() {\n        selectable.set(false);\n    }\n\n    public void enableSelectable() {\n        selectable.set(true);\n    }\n\n    private void requestInterestOpsUpdate() {\n        if (isSelectable()) {\n            selectorThread.addInterestOpsUpdateRequest(sk);\n        }\n    }\n\n    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {\n                    /*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n\n            int sent = sock.write(directBuffer);\n\n            ByteBuffer bb;\n\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {\n                    /*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }\n                /* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n\n    /**\n     * Only used in order to allow testing\n     */\n    protected boolean isSocketOpen() {\n        return sock.isOpen();\n    }\n\n    /**\n     * Handles read/write IO on connection.\n     */\n    void doIO(SelectionKey k) throws InterruptedException {\n        try {\n            if (!isSocketOpen()) {\n                LOG.warn(\"trying to do i/o on a null socket for session: 0x{}\", Long.toHexString(sessionId));\n\n                return;\n            }\n            if (k.isReadable()) {\n                int rc = sock.read(incomingBuffer);\n                if (rc < 0) {\n                    try {\n                        handleFailedRead();\n                    } catch (EndOfStreamException e) {\n                        // no stacktrace. this case is very common, and it is usually not a problem.\n                        LOG.info(\"{}\", e.getMessage());\n                        // expecting close to log session closure\n                        close(e.getReason());\n                        return;\n                    }\n                }\n                if (incomingBuffer.remaining() == 0) {\n                    boolean isPayload;\n                    if (incomingBuffer == lenBuffer) { // start of next request\n                        incomingBuffer.flip();\n                        isPayload = readLength(k);\n                        incomingBuffer.clear();\n                    } else {\n                        // continuation\n                        isPayload = true;\n                    }\n                    if (isPayload) { // not the case for 4letterword\n                        readPayload();\n                    } else {\n                        // four letter words take care\n                        // need not do anything else\n                        return;\n                    }\n                }\n            }\n            if (k.isWritable()) {\n                handleWrite(k);\n\n                if (!initialized && !getReadInterest() && !getWriteInterest()) {\n                    throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n                }\n            }\n        } catch (CancelledKeyException e) {\n            LOG.warn(\"CancelledKeyException causing close of session: 0x{}\", Long.toHexString(sessionId));\n\n            LOG.debug(\"CancelledKeyException stack trace\", e);\n\n            close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n        } catch (CloseRequestException e) {\n            // expecting close to log session closure\n            close();\n        } catch (EndOfStreamException e) {\n            LOG.warn(\"Unexpected exception\", e);\n            // expecting close to log session closure\n            close(e.getReason());\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n            LOG.warn(\"Closing session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.CLIENT_CNX_LIMIT);\n        } catch (IOException e) {\n            LOG.warn(\"Close of session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        }\n    }\n\n    protected void readRequest() throws IOException {\n        zkServer.processPacket(this, incomingBuffer);\n    }\n\n    // returns whether we are interested in writing, which is determined\n    // by whether we have any pending buffers on the output queue or not\n    private boolean getWriteInterest() {\n        return !outgoingBuffers.isEmpty();\n    }\n\n    // returns whether we are interested in taking new requests, which is\n    // determined by whether we are currently throttled or not\n    private boolean getReadInterest() {\n        return !throttled.get();\n    }\n\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n\n    // Throttle acceptance of new requests. If this entailed a state change,\n    // register an interest op update request with the selector.\n    //\n    // Don't support wait disable receive in NIO, ignore the parameter\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    // Disable throttling and resume acceptance of new requests. If this\n    // entailed a state change, register an interest op update request with\n    // the selector.\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    private void readConnectRequest() throws IOException, InterruptedException, ClientCnxnLimitException {\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        zkServer.processConnectRequest(this, incomingBuffer);\n        initialized = true;\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n        packetReceived(4);\n\n        /** cancel the selection key to remove the socket handling\n         * from selector. This is to prevent netcat problem wherein\n         * netcat immediately closes the sending side after sending the\n         * commands and still keeps the receiving channel open.\n         * The idea is to remove the selectionkey from the selector\n         * so that the selector does not notice the closed read on the\n         * socket channel and keep the socket alive to write the data to\n         * and makes sure to close the socket after its done writing the data\n         */\n        if (k != null) {\n            try {\n                k.cancel();\n            } catch (Exception e) {\n                LOG.error(\"Error cancelling command selection key\", e);\n            }\n        }\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, sock.socket().getRemoteSocketAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            incomingBuffer = ByteBuffer.allocate(8);\n            int rc = sock.read(incomingBuffer);\n            if (rc < 0) {\n                throw new IOException(\"Read error\");\n            }\n            incomingBuffer.flip();\n            long traceMask = incomingBuffer.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /** Reads the first 4 bytes of lenBuffer, which could be true length or\n     *  four letter word.\n     *\n     * @param k selection key\n     * @return true if length read, otw false (wasn't really the length)\n     * @throws IOException if buffer size exceeds maxBuffer size\n     */\n    private boolean readLength(SelectionKey k) throws IOException {\n        // Read the length, now get the buffer\n        int len = lenBuffer.getInt();\n        if (!initialized && checkFourLetterWord(sk, len)) {\n            return false;\n        }\n        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n            throw new IOException(\"Len error. \"\n                    + \"A message from \" +  this.getRemoteSocketAddress() + \" with advertised length of \" + len\n                    + \" is either a malformed message or too large to process\"\n                    + \" (length is greater than jute.maxbuffer=\" + BinaryInputArchive.maxBuffer + \")\");\n        }\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        // checkRequestSize will throw IOException if request is rejected\n        zkServer.checkRequestSizeWhenReceivingMessage(len);\n        incomingBuffer = ByteBuffer.allocate(len);\n        return true;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n     */\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    /**\n     * Used by \"dump\" 4-letter command to list all connection in\n     * cnxnExpiryMap\n     */\n    @Override\n    public String toString() {\n        return \"ip: \" + sock.socket().getRemoteSocketAddress() + \" sessionId: 0x\" + Long.toHexString(sessionId);\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    private void close() {\n        setStale();\n        if (!factory.removeCnxn(this)) {\n            return;\n        }\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (sk != null) {\n            try {\n                // need to cancel this selection key from the selector\n                sk.cancel();\n            } catch (Exception e) {\n                LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n            }\n        }\n\n        closeSock();\n    }\n\n    /**\n     * Close resources associated with the sock of this cnxn.\n     */\n    private void closeSock() {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        String logMsg = String.format(\n            \"Closed socket connection for client %s %s\",\n            sock.socket().getRemoteSocketAddress(),\n            sessionId != 0\n                ? \"which had sessionid 0x\" + Long.toHexString(sessionId)\n                : \"(no session established for client)\"\n            );\n        LOG.debug(logMsg);\n\n        closeSock(sock);\n    }\n\n    /**\n     * Close resources associated with a sock.\n     */\n    public static void closeSock(SocketChannel sock) {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        try {\n            /*\n             * The following sequence of code is stupid! You would think that\n             * only sock.close() is needed, but alas, it doesn't work that way.\n             * If you just do sock.close() there are cases where the socket\n             * doesn't actually close...\n             */\n            sock.socket().shutdownOutput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during output shutdown\", e);\n        }\n        try {\n            sock.socket().shutdownInput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during input shutdown\", e);\n        }\n        try {\n            sock.socket().close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socketchannel close\", e);\n        }\n    }\n\n    private static final ByteBuffer packetSentinel = ByteBuffer.allocate(0);\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat, int opCode) {\n        int responseSize = 0;\n        try {\n            ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n            responseSize = bb[0].getInt();\n            bb[0].rewind();\n            sendBuffer(bb);\n            decrOutstandingAndCheckThrottle(h);\n        } catch (Exception e) {\n            LOG.warn(\"Unexpected exception. Destruction averted.\", e);\n        }\n        return responseSize;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)\n     */\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        // The last parameter OpCode here is used to select the response cache.\n        // Passing OpCode.error (with a value of -1) means we don't care, as we don't need\n        // response cache on delivering watcher events.\n        int responseSize = sendResponse(h, e, \"notification\", null, null, ZooDefs.OpCode.error);\n        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()\n     */\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n        factory.touchCnxn(this);\n    }\n\n    @Override\n    public int getInterestOps() {\n        if (!isSelectable()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (getReadInterest()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (getWriteInterest()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();\n    }\n\n    public InetAddress getSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return sock.socket().getInetAddress();\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return false;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.CancelledKeyException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.security.cert.Certificate;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ConnectRequest;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class handles communication with clients using NIO. There is one per\n * client, but only one thread doing the communication.\n */\npublic class NIOServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxn.class);\n\n    private final NIOServerCnxnFactory factory;\n\n    private final SocketChannel sock;\n\n    private final SelectorThread selectorThread;\n\n    private final SelectionKey sk;\n\n    private boolean initialized;\n\n    private final ByteBuffer lenBuffer = ByteBuffer.allocate(4);\n\n    protected ByteBuffer incomingBuffer = lenBuffer;\n\n    private final Queue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();\n\n    private int sessionTimeout;\n\n    /**\n     * This is the id that uniquely identifies the session of a client. Once\n     * this session is no longer active, the ephemeral nodes will go away.\n     */\n    private long sessionId;\n\n    /**\n     * Client socket option for TCP keepalive\n     */\n    private final boolean clientTcpKeepAlive = Boolean.getBoolean(\"zookeeper.clientTcpKeepAlive\");\n\n    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock, SelectionKey sk, NIOServerCnxnFactory factory, SelectorThread selectorThread) throws IOException {\n        super(zk);\n        this.sock = sock;\n        this.sk = sk;\n        this.factory = factory;\n        this.selectorThread = selectorThread;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        sock.socket().setTcpNoDelay(true);\n        /* set socket linger to false, so that socket close does not block */\n        sock.socket().setSoLinger(false, -1);\n        sock.socket().setKeepAlive(clientTcpKeepAlive);\n        InetAddress addr = ((InetSocketAddress) sock.socket().getRemoteSocketAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n        this.sessionTimeout = factory.sessionlessCnxnTimeout;\n    }\n\n    /* Send close connection packet to the client, doIO will eventually\n     * close the underlying machinery (like socket, selectorkey, etc...)\n     */\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    /**\n     * send buffer without using the asynchronous\n     * calls to selector and then close the socket\n     * @param bb\n     */\n    void sendBufferSync(ByteBuffer bb) {\n        try {\n            /* configure socket to be blocking\n             * so that we dont have to do write in\n             * a tight while loop\n             */\n            if (bb != ServerCnxnFactory.closeConn) {\n                if (sock.isOpen()) {\n                    sock.configureBlocking(true);\n                    sock.write(bb);\n                }\n                packetSent();\n            }\n        } catch (IOException ie) {\n            LOG.error(\"Error sending data synchronously \", ie);\n        }\n    }\n\n    /**\n     * sendBuffer pushes a byte buffer onto the outgoing buffer queue for\n     * asynchronous writes.\n     */\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Add a buffer to outgoingBuffers, sk {} is valid: {}\", sk, sk.isValid());\n        }\n\n        synchronized (outgoingBuffers) {\n            for (ByteBuffer buffer : buffers) {\n                outgoingBuffers.add(buffer);\n            }\n            outgoingBuffers.add(packetSentinel);\n        }\n        requestInterestOpsUpdate();\n    }\n\n    /**\n     * When read on socket failed, this is typically because client closed the\n     * connection. In most cases, the client does this when the server doesn't\n     * respond within 2/3 of session timeout. This possibly indicates server\n     * health/performance issue, so we need to log and keep track of stat\n     *\n     * @throws EndOfStreamException\n     */\n    private void handleFailedRead() throws EndOfStreamException {\n        setStale();\n        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n        throw new EndOfStreamException(\"Unable to read additional data from client,\"\n                                       + \" it probably closed the socket:\"\n                                       + \" address = \" + sock.socket().getRemoteSocketAddress() + \",\"\n                                       + \" session = 0x\" + Long.toHexString(sessionId),\n                                       DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);\n    }\n\n    /** Read the request payload (everything following the length prefix) */\n    private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException {\n        if (incomingBuffer.remaining() != 0) { // have we read length bytes?\n            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok\n            if (rc < 0) {\n                handleFailedRead();\n            }\n        }\n\n        if (incomingBuffer.remaining() == 0) { // have we read length bytes?\n            incomingBuffer.flip();\n            packetReceived(4 + incomingBuffer.remaining());\n            if (!initialized) {\n                readConnectRequest();\n            } else {\n                readRequest();\n            }\n            lenBuffer.clear();\n            incomingBuffer = lenBuffer;\n        }\n    }\n\n    /**\n     * This boolean tracks whether the connection is ready for selection or\n     * not. A connection is marked as not ready for selection while it is\n     * processing an IO request. The flag is used to gatekeep pushing interest\n     * op updates onto the selector.\n     */\n    private final AtomicBoolean selectable = new AtomicBoolean(true);\n\n    public boolean isSelectable() {\n        return sk.isValid() && selectable.get();\n    }\n\n    public void disableSelectable() {\n        selectable.set(false);\n    }\n\n    public void enableSelectable() {\n        selectable.set(true);\n    }\n\n    private void requestInterestOpsUpdate() {\n        if (isSelectable()) {\n            selectorThread.addInterestOpsUpdateRequest(sk);\n        }\n    }\n\n    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {\n                    /*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n\n            int sent = sock.write(directBuffer);\n\n            ByteBuffer bb;\n\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {\n                    /*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }\n                /* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n\n    /**\n     * Only used in order to allow testing\n     */\n    protected boolean isSocketOpen() {\n        return sock.isOpen();\n    }\n\n    /**\n     * Handles read/write IO on connection.\n     */\n    void doIO(SelectionKey k) throws InterruptedException {\n        try {\n            if (!isSocketOpen()) {\n                LOG.warn(\"trying to do i/o on a null socket for session: 0x{}\", Long.toHexString(sessionId));\n\n                return;\n            }\n            if (k.isReadable()) {\n                int rc = sock.read(incomingBuffer);\n                if (rc < 0) {\n                    try {\n                        handleFailedRead();\n                    } catch (EndOfStreamException e) {\n                        // no stacktrace. this case is very common, and it is usually not a problem.\n                        LOG.info(\"{}\", e.getMessage());\n                        // expecting close to log session closure\n                        close(e.getReason());\n                        return;\n                    }\n                }\n                if (incomingBuffer.remaining() == 0) {\n                    boolean isPayload;\n                    if (incomingBuffer == lenBuffer) { // start of next request\n                        incomingBuffer.flip();\n                        isPayload = readLength(k);\n                        incomingBuffer.clear();\n                    } else {\n                        // continuation\n                        isPayload = true;\n                    }\n                    if (isPayload) { // not the case for 4letterword\n                        readPayload();\n                    } else {\n                        // four letter words take care\n                        // need not do anything else\n                        return;\n                    }\n                }\n            }\n            if (k.isWritable()) {\n                handleWrite(k);\n\n                if (!initialized && !getReadInterest() && !getWriteInterest()) {\n                    throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n                }\n            }\n        } catch (CancelledKeyException e) {\n            LOG.warn(\"CancelledKeyException causing close of session: 0x{}\", Long.toHexString(sessionId));\n\n            LOG.debug(\"CancelledKeyException stack trace\", e);\n\n            close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n        } catch (CloseRequestException e) {\n            // expecting close to log session closure\n            close();\n        } catch (EndOfStreamException e) {\n            LOG.warn(\"Unexpected exception\", e);\n            // expecting close to log session closure\n            close(e.getReason());\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n            LOG.warn(\"Closing session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.CLIENT_CNX_LIMIT);\n        } catch (IOException e) {\n            LOG.warn(\"Close of session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        }\n    }\n\n    protected void readRequest() throws IOException {\n        zkServer.processPacket(this, incomingBuffer);\n    }\n\n    // returns whether we are interested in writing, which is determined\n    // by whether we have any pending buffers on the output queue or not\n    private boolean getWriteInterest() {\n        return !outgoingBuffers.isEmpty();\n    }\n\n    // returns whether we are interested in taking new requests, which is\n    // determined by whether we are currently throttled or not\n    private boolean getReadInterest() {\n        return !throttled.get();\n    }\n\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n\n    // Throttle acceptance of new requests. If this entailed a state change,\n    // register an interest op update request with the selector.\n    //\n    // Don't support wait disable receive in NIO, ignore the parameter\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    // Disable throttling and resume acceptance of new requests. If this\n    // entailed a state change, register an interest op update request with\n    // the selector.\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    private void readConnectRequest() throws IOException, ClientCnxnLimitException {\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));\n        ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n        zkServer.processConnectRequest(this, request);\n        initialized = true;\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n        packetReceived(4);\n\n        /** cancel the selection key to remove the socket handling\n         * from selector. This is to prevent netcat problem wherein\n         * netcat immediately closes the sending side after sending the\n         * commands and still keeps the receiving channel open.\n         * The idea is to remove the selectionkey from the selector\n         * so that the selector does not notice the closed read on the\n         * socket channel and keep the socket alive to write the data to\n         * and makes sure to close the socket after its done writing the data\n         */\n        if (k != null) {\n            try {\n                k.cancel();\n            } catch (Exception e) {\n                LOG.error(\"Error cancelling command selection key\", e);\n            }\n        }\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, sock.socket().getRemoteSocketAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            incomingBuffer = ByteBuffer.allocate(8);\n            int rc = sock.read(incomingBuffer);\n            if (rc < 0) {\n                throw new IOException(\"Read error\");\n            }\n            incomingBuffer.flip();\n            long traceMask = incomingBuffer.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /** Reads the first 4 bytes of lenBuffer, which could be true length or\n     *  four letter word.\n     *\n     * @param k selection key\n     * @return true if length read, otw false (wasn't really the length)\n     * @throws IOException if buffer size exceeds maxBuffer size\n     */\n    private boolean readLength(SelectionKey k) throws IOException {\n        // Read the length, now get the buffer\n        int len = lenBuffer.getInt();\n        if (!initialized && checkFourLetterWord(sk, len)) {\n            return false;\n        }\n        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n            throw new IOException(\"Len error. \"\n                    + \"A message from \" +  this.getRemoteSocketAddress() + \" with advertised length of \" + len\n                    + \" is either a malformed message or too large to process\"\n                    + \" (length is greater than jute.maxbuffer=\" + BinaryInputArchive.maxBuffer + \")\");\n        }\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        // checkRequestSize will throw IOException if request is rejected\n        zkServer.checkRequestSizeWhenReceivingMessage(len);\n        incomingBuffer = ByteBuffer.allocate(len);\n        return true;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n     */\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    /**\n     * Used by \"dump\" 4-letter command to list all connection in\n     * cnxnExpiryMap\n     */\n    @Override\n    public String toString() {\n        return \"ip: \" + sock.socket().getRemoteSocketAddress() + \" sessionId: 0x\" + Long.toHexString(sessionId);\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    private void close() {\n        setStale();\n        if (!factory.removeCnxn(this)) {\n            return;\n        }\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (sk != null) {\n            try {\n                // need to cancel this selection key from the selector\n                sk.cancel();\n            } catch (Exception e) {\n                LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n            }\n        }\n\n        closeSock();\n    }\n\n    /**\n     * Close resources associated with the sock of this cnxn.\n     */\n    private void closeSock() {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        String logMsg = String.format(\n            \"Closed socket connection for client %s %s\",\n            sock.socket().getRemoteSocketAddress(),\n            sessionId != 0\n                ? \"which had sessionid 0x\" + Long.toHexString(sessionId)\n                : \"(no session established for client)\"\n            );\n        LOG.debug(logMsg);\n\n        closeSock(sock);\n    }\n\n    /**\n     * Close resources associated with a sock.\n     */\n    public static void closeSock(SocketChannel sock) {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        try {\n            /*\n             * The following sequence of code is stupid! You would think that\n             * only sock.close() is needed, but alas, it doesn't work that way.\n             * If you just do sock.close() there are cases where the socket\n             * doesn't actually close...\n             */\n            sock.socket().shutdownOutput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during output shutdown\", e);\n        }\n        try {\n            sock.socket().shutdownInput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during input shutdown\", e);\n        }\n        try {\n            sock.socket().close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socketchannel close\", e);\n        }\n    }\n\n    private static final ByteBuffer packetSentinel = ByteBuffer.allocate(0);\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat, int opCode) {\n        int responseSize = 0;\n        try {\n            ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n            responseSize = bb[0].getInt();\n            bb[0].rewind();\n            sendBuffer(bb);\n            decrOutstandingAndCheckThrottle(h);\n        } catch (Exception e) {\n            LOG.warn(\"Unexpected exception. Destruction averted.\", e);\n        }\n        return responseSize;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)\n     */\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        // The last parameter OpCode here is used to select the response cache.\n        // Passing OpCode.error (with a value of -1) means we don't care, as we don't need\n        // response cache on delivering watcher events.\n        int responseSize = sendResponse(h, e, \"notification\", null, null, ZooDefs.OpCode.error);\n        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()\n     */\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n        factory.touchCnxn(this);\n    }\n\n    @Override\n    public int getInterestOps() {\n        if (!isSelectable()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (getReadInterest()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (getWriteInterest()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();\n    }\n\n    public InetAddress getSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return sock.socket().getInetAddress();\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return false;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n}\n","lineNo":435}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.CancelledKeyException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.security.cert.Certificate;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class handles communication with clients using NIO. There is one per\n * client, but only one thread doing the communication.\n */\npublic class NIOServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxn.class);\n\n    private final NIOServerCnxnFactory factory;\n\n    private final SocketChannel sock;\n\n    private final SelectorThread selectorThread;\n\n    private final SelectionKey sk;\n\n    private boolean initialized;\n\n    private final ByteBuffer lenBuffer = ByteBuffer.allocate(4);\n\n    protected ByteBuffer incomingBuffer = lenBuffer;\n\n    private final Queue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();\n\n    private int sessionTimeout;\n\n    /**\n     * This is the id that uniquely identifies the session of a client. Once\n     * this session is no longer active, the ephemeral nodes will go away.\n     */\n    private long sessionId;\n\n    /**\n     * Client socket option for TCP keepalive\n     */\n    private final boolean clientTcpKeepAlive = Boolean.getBoolean(\"zookeeper.clientTcpKeepAlive\");\n\n    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock, SelectionKey sk, NIOServerCnxnFactory factory, SelectorThread selectorThread) throws IOException {\n        super(zk);\n        this.sock = sock;\n        this.sk = sk;\n        this.factory = factory;\n        this.selectorThread = selectorThread;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        sock.socket().setTcpNoDelay(true);\n        /* set socket linger to false, so that socket close does not block */\n        sock.socket().setSoLinger(false, -1);\n        sock.socket().setKeepAlive(clientTcpKeepAlive);\n        InetAddress addr = ((InetSocketAddress) sock.socket().getRemoteSocketAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n        this.sessionTimeout = factory.sessionlessCnxnTimeout;\n    }\n\n    /* Send close connection packet to the client, doIO will eventually\n     * close the underlying machinery (like socket, selectorkey, etc...)\n     */\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    /**\n     * send buffer without using the asynchronous\n     * calls to selector and then close the socket\n     * @param bb\n     */\n    void sendBufferSync(ByteBuffer bb) {\n        try {\n            /* configure socket to be blocking\n             * so that we dont have to do write in\n             * a tight while loop\n             */\n            if (bb != ServerCnxnFactory.closeConn) {\n                if (sock.isOpen()) {\n                    sock.configureBlocking(true);\n                    sock.write(bb);\n                }\n                packetSent();\n            }\n        } catch (IOException ie) {\n            LOG.error(\"Error sending data synchronously \", ie);\n        }\n    }\n\n    /**\n     * sendBuffer pushes a byte buffer onto the outgoing buffer queue for\n     * asynchronous writes.\n     */\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Add a buffer to outgoingBuffers, sk {} is valid: {}\", sk, sk.isValid());\n        }\n\n        synchronized (outgoingBuffers) {\n            for (ByteBuffer buffer : buffers) {\n                outgoingBuffers.add(buffer);\n            }\n            outgoingBuffers.add(packetSentinel);\n        }\n        requestInterestOpsUpdate();\n    }\n\n    /**\n     * When read on socket failed, this is typically because client closed the\n     * connection. In most cases, the client does this when the server doesn't\n     * respond within 2/3 of session timeout. This possibly indicates server\n     * health/performance issue, so we need to log and keep track of stat\n     *\n     * @throws EndOfStreamException\n     */\n    private void handleFailedRead() throws EndOfStreamException {\n        setStale();\n        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n        throw new EndOfStreamException(\"Unable to read additional data from client,\"\n                                       + \" it probably closed the socket:\"\n                                       + \" address = \" + sock.socket().getRemoteSocketAddress() + \",\"\n                                       + \" session = 0x\" + Long.toHexString(sessionId),\n                                       DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);\n    }\n\n    /** Read the request payload (everything following the length prefix) */\n    private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException {\n        if (incomingBuffer.remaining() != 0) { // have we read length bytes?\n            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok\n            if (rc < 0) {\n                handleFailedRead();\n            }\n        }\n\n        if (incomingBuffer.remaining() == 0) { // have we read length bytes?\n            incomingBuffer.flip();\n            packetReceived(4 + incomingBuffer.remaining());\n            if (!initialized) {\n                readConnectRequest();\n            } else {\n                readRequest();\n            }\n            lenBuffer.clear();\n            incomingBuffer = lenBuffer;\n        }\n    }\n\n    /**\n     * This boolean tracks whether the connection is ready for selection or\n     * not. A connection is marked as not ready for selection while it is\n     * processing an IO request. The flag is used to gatekeep pushing interest\n     * op updates onto the selector.\n     */\n    private final AtomicBoolean selectable = new AtomicBoolean(true);\n\n    public boolean isSelectable() {\n        return sk.isValid() && selectable.get();\n    }\n\n    public void disableSelectable() {\n        selectable.set(false);\n    }\n\n    public void enableSelectable() {\n        selectable.set(true);\n    }\n\n    private void requestInterestOpsUpdate() {\n        if (isSelectable()) {\n            selectorThread.addInterestOpsUpdateRequest(sk);\n        }\n    }\n\n    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {\n                    /*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n\n            int sent = sock.write(directBuffer);\n\n            ByteBuffer bb;\n\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {\n                    /*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }\n                /* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n\n    /**\n     * Only used in order to allow testing\n     */\n    protected boolean isSocketOpen() {\n        return sock.isOpen();\n    }\n\n    /**\n     * Handles read/write IO on connection.\n     */\n    void doIO(SelectionKey k) throws InterruptedException {\n        try {\n            if (!isSocketOpen()) {\n                LOG.warn(\"trying to do i/o on a null socket for session: 0x{}\", Long.toHexString(sessionId));\n\n                return;\n            }\n            if (k.isReadable()) {\n                int rc = sock.read(incomingBuffer);\n                if (rc < 0) {\n                    try {\n                        handleFailedRead();\n                    } catch (EndOfStreamException e) {\n                        // no stacktrace. this case is very common, and it is usually not a problem.\n                        LOG.info(\"{}\", e.getMessage());\n                        // expecting close to log session closure\n                        close(e.getReason());\n                        return;\n                    }\n                }\n                if (incomingBuffer.remaining() == 0) {\n                    boolean isPayload;\n                    if (incomingBuffer == lenBuffer) { // start of next request\n                        incomingBuffer.flip();\n                        isPayload = readLength(k);\n                        incomingBuffer.clear();\n                    } else {\n                        // continuation\n                        isPayload = true;\n                    }\n                    if (isPayload) { // not the case for 4letterword\n                        readPayload();\n                    } else {\n                        // four letter words take care\n                        // need not do anything else\n                        return;\n                    }\n                }\n            }\n            if (k.isWritable()) {\n                handleWrite(k);\n\n                if (!initialized && !getReadInterest() && !getWriteInterest()) {\n                    throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n                }\n            }\n        } catch (CancelledKeyException e) {\n            LOG.warn(\"CancelledKeyException causing close of session: 0x{}\", Long.toHexString(sessionId));\n\n            LOG.debug(\"CancelledKeyException stack trace\", e);\n\n            close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n        } catch (CloseRequestException e) {\n            // expecting close to log session closure\n            close();\n        } catch (EndOfStreamException e) {\n            LOG.warn(\"Unexpected exception\", e);\n            // expecting close to log session closure\n            close(e.getReason());\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n            LOG.warn(\"Closing session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.CLIENT_CNX_LIMIT);\n        } catch (IOException e) {\n            LOG.warn(\"Close of session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        }\n    }\n\n    protected void readRequest() throws IOException {\n        zkServer.processPacket(this, incomingBuffer);\n    }\n\n    // returns whether we are interested in writing, which is determined\n    // by whether we have any pending buffers on the output queue or not\n    private boolean getWriteInterest() {\n        return !outgoingBuffers.isEmpty();\n    }\n\n    // returns whether we are interested in taking new requests, which is\n    // determined by whether we are currently throttled or not\n    private boolean getReadInterest() {\n        return !throttled.get();\n    }\n\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n\n    // Throttle acceptance of new requests. If this entailed a state change,\n    // register an interest op update request with the selector.\n    //\n    // Don't support wait disable receive in NIO, ignore the parameter\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    // Disable throttling and resume acceptance of new requests. If this\n    // entailed a state change, register an interest op update request with\n    // the selector.\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    private void readConnectRequest() throws IOException, InterruptedException, ClientCnxnLimitException {\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        zkServer.processConnectRequest(this, incomingBuffer);\n        initialized = true;\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n        packetReceived(4);\n\n        /** cancel the selection key to remove the socket handling\n         * from selector. This is to prevent netcat problem wherein\n         * netcat immediately closes the sending side after sending the\n         * commands and still keeps the receiving channel open.\n         * The idea is to remove the selectionkey from the selector\n         * so that the selector does not notice the closed read on the\n         * socket channel and keep the socket alive to write the data to\n         * and makes sure to close the socket after its done writing the data\n         */\n        if (k != null) {\n            try {\n                k.cancel();\n            } catch (Exception e) {\n                LOG.error(\"Error cancelling command selection key\", e);\n            }\n        }\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, sock.socket().getRemoteSocketAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            incomingBuffer = ByteBuffer.allocate(8);\n            int rc = sock.read(incomingBuffer);\n            if (rc < 0) {\n                throw new IOException(\"Read error\");\n            }\n            incomingBuffer.flip();\n            long traceMask = incomingBuffer.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /** Reads the first 4 bytes of lenBuffer, which could be true length or\n     *  four letter word.\n     *\n     * @param k selection key\n     * @return true if length read, otw false (wasn't really the length)\n     * @throws IOException if buffer size exceeds maxBuffer size\n     */\n    private boolean readLength(SelectionKey k) throws IOException {\n        // Read the length, now get the buffer\n        int len = lenBuffer.getInt();\n        if (!initialized && checkFourLetterWord(sk, len)) {\n            return false;\n        }\n        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n            throw new IOException(\"Len error. \"\n                    + \"A message from \" +  this.getRemoteSocketAddress() + \" with advertised length of \" + len\n                    + \" is either a malformed message or too large to process\"\n                    + \" (length is greater than jute.maxbuffer=\" + BinaryInputArchive.maxBuffer + \")\");\n        }\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        // checkRequestSize will throw IOException if request is rejected\n        zkServer.checkRequestSizeWhenReceivingMessage(len);\n        incomingBuffer = ByteBuffer.allocate(len);\n        return true;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n     */\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    /**\n     * Used by \"dump\" 4-letter command to list all connection in\n     * cnxnExpiryMap\n     */\n    @Override\n    public String toString() {\n        return \"ip: \" + sock.socket().getRemoteSocketAddress() + \" sessionId: 0x\" + Long.toHexString(sessionId);\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    private void close() {\n        setStale();\n        if (!factory.removeCnxn(this)) {\n            return;\n        }\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (sk != null) {\n            try {\n                // need to cancel this selection key from the selector\n                sk.cancel();\n            } catch (Exception e) {\n                LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n            }\n        }\n\n        closeSock();\n    }\n\n    /**\n     * Close resources associated with the sock of this cnxn.\n     */\n    private void closeSock() {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        String logMsg = String.format(\n            \"Closed socket connection for client %s %s\",\n            sock.socket().getRemoteSocketAddress(),\n            sessionId != 0\n                ? \"which had sessionid 0x\" + Long.toHexString(sessionId)\n                : \"(no session established for client)\"\n            );\n        LOG.debug(logMsg);\n\n        closeSock(sock);\n    }\n\n    /**\n     * Close resources associated with a sock.\n     */\n    public static void closeSock(SocketChannel sock) {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        try {\n            /*\n             * The following sequence of code is stupid! You would think that\n             * only sock.close() is needed, but alas, it doesn't work that way.\n             * If you just do sock.close() there are cases where the socket\n             * doesn't actually close...\n             */\n            sock.socket().shutdownOutput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during output shutdown\", e);\n        }\n        try {\n            sock.socket().shutdownInput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during input shutdown\", e);\n        }\n        try {\n            sock.socket().close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socketchannel close\", e);\n        }\n    }\n\n    private static final ByteBuffer packetSentinel = ByteBuffer.allocate(0);\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat, int opCode) {\n        int responseSize = 0;\n        try {\n            ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n            responseSize = bb[0].getInt();\n            bb[0].rewind();\n            sendBuffer(bb);\n            decrOutstandingAndCheckThrottle(h);\n        } catch (Exception e) {\n            LOG.warn(\"Unexpected exception. Destruction averted.\", e);\n        }\n        return responseSize;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)\n     */\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        // The last parameter OpCode here is used to select the response cache.\n        // Passing OpCode.error (with a value of -1) means we don't care, as we don't need\n        // response cache on delivering watcher events.\n        int responseSize = sendResponse(h, e, \"notification\", null, null, ZooDefs.OpCode.error);\n        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()\n     */\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n        factory.touchCnxn(this);\n    }\n\n    @Override\n    public int getInterestOps() {\n        if (!isSelectable()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (getReadInterest()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (getWriteInterest()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();\n    }\n\n    public InetAddress getSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return sock.socket().getInetAddress();\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return false;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.CancelledKeyException;\nimport java.nio.channels.SelectionKey;\nimport java.nio.channels.SocketChannel;\nimport java.security.cert.Certificate;\nimport java.util.Queue;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ConnectRequest;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.NIOServerCnxnFactory.SelectorThread;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class handles communication with clients using NIO. There is one per\n * client, but only one thread doing the communication.\n */\npublic class NIOServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NIOServerCnxn.class);\n\n    private final NIOServerCnxnFactory factory;\n\n    private final SocketChannel sock;\n\n    private final SelectorThread selectorThread;\n\n    private final SelectionKey sk;\n\n    private boolean initialized;\n\n    private final ByteBuffer lenBuffer = ByteBuffer.allocate(4);\n\n    protected ByteBuffer incomingBuffer = lenBuffer;\n\n    private final Queue<ByteBuffer> outgoingBuffers = new LinkedBlockingQueue<ByteBuffer>();\n\n    private int sessionTimeout;\n\n    /**\n     * This is the id that uniquely identifies the session of a client. Once\n     * this session is no longer active, the ephemeral nodes will go away.\n     */\n    private long sessionId;\n\n    /**\n     * Client socket option for TCP keepalive\n     */\n    private final boolean clientTcpKeepAlive = Boolean.getBoolean(\"zookeeper.clientTcpKeepAlive\");\n\n    public NIOServerCnxn(ZooKeeperServer zk, SocketChannel sock, SelectionKey sk, NIOServerCnxnFactory factory, SelectorThread selectorThread) throws IOException {\n        super(zk);\n        this.sock = sock;\n        this.sk = sk;\n        this.factory = factory;\n        this.selectorThread = selectorThread;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        sock.socket().setTcpNoDelay(true);\n        /* set socket linger to false, so that socket close does not block */\n        sock.socket().setSoLinger(false, -1);\n        sock.socket().setKeepAlive(clientTcpKeepAlive);\n        InetAddress addr = ((InetSocketAddress) sock.socket().getRemoteSocketAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n        this.sessionTimeout = factory.sessionlessCnxnTimeout;\n    }\n\n    /* Send close connection packet to the client, doIO will eventually\n     * close the underlying machinery (like socket, selectorkey, etc...)\n     */\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    /**\n     * send buffer without using the asynchronous\n     * calls to selector and then close the socket\n     * @param bb\n     */\n    void sendBufferSync(ByteBuffer bb) {\n        try {\n            /* configure socket to be blocking\n             * so that we dont have to do write in\n             * a tight while loop\n             */\n            if (bb != ServerCnxnFactory.closeConn) {\n                if (sock.isOpen()) {\n                    sock.configureBlocking(true);\n                    sock.write(bb);\n                }\n                packetSent();\n            }\n        } catch (IOException ie) {\n            LOG.error(\"Error sending data synchronously \", ie);\n        }\n    }\n\n    /**\n     * sendBuffer pushes a byte buffer onto the outgoing buffer queue for\n     * asynchronous writes.\n     */\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"Add a buffer to outgoingBuffers, sk {} is valid: {}\", sk, sk.isValid());\n        }\n\n        synchronized (outgoingBuffers) {\n            for (ByteBuffer buffer : buffers) {\n                outgoingBuffers.add(buffer);\n            }\n            outgoingBuffers.add(packetSentinel);\n        }\n        requestInterestOpsUpdate();\n    }\n\n    /**\n     * When read on socket failed, this is typically because client closed the\n     * connection. In most cases, the client does this when the server doesn't\n     * respond within 2/3 of session timeout. This possibly indicates server\n     * health/performance issue, so we need to log and keep track of stat\n     *\n     * @throws EndOfStreamException\n     */\n    private void handleFailedRead() throws EndOfStreamException {\n        setStale();\n        ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n        throw new EndOfStreamException(\"Unable to read additional data from client,\"\n                                       + \" it probably closed the socket:\"\n                                       + \" address = \" + sock.socket().getRemoteSocketAddress() + \",\"\n                                       + \" session = 0x\" + Long.toHexString(sessionId),\n                                       DisconnectReason.UNABLE_TO_READ_FROM_CLIENT);\n    }\n\n    /** Read the request payload (everything following the length prefix) */\n    private void readPayload() throws IOException, InterruptedException, ClientCnxnLimitException {\n        if (incomingBuffer.remaining() != 0) { // have we read length bytes?\n            int rc = sock.read(incomingBuffer); // sock is non-blocking, so ok\n            if (rc < 0) {\n                handleFailedRead();\n            }\n        }\n\n        if (incomingBuffer.remaining() == 0) { // have we read length bytes?\n            incomingBuffer.flip();\n            packetReceived(4 + incomingBuffer.remaining());\n            if (!initialized) {\n                readConnectRequest();\n            } else {\n                readRequest();\n            }\n            lenBuffer.clear();\n            incomingBuffer = lenBuffer;\n        }\n    }\n\n    /**\n     * This boolean tracks whether the connection is ready for selection or\n     * not. A connection is marked as not ready for selection while it is\n     * processing an IO request. The flag is used to gatekeep pushing interest\n     * op updates onto the selector.\n     */\n    private final AtomicBoolean selectable = new AtomicBoolean(true);\n\n    public boolean isSelectable() {\n        return sk.isValid() && selectable.get();\n    }\n\n    public void disableSelectable() {\n        selectable.set(false);\n    }\n\n    public void enableSelectable() {\n        selectable.set(true);\n    }\n\n    private void requestInterestOpsUpdate() {\n        if (isSelectable()) {\n            selectorThread.addInterestOpsUpdateRequest(sk);\n        }\n    }\n\n    void handleWrite(SelectionKey k) throws IOException {\n        if (outgoingBuffers.isEmpty()) {\n            return;\n        }\n\n        /*\n         * This is going to reset the buffer position to 0 and the\n         * limit to the size of the buffer, so that we can fill it\n         * with data from the non-direct buffers that we need to\n         * send.\n         */\n        ByteBuffer directBuffer = NIOServerCnxnFactory.getDirectBuffer();\n        if (directBuffer == null) {\n            ByteBuffer[] bufferList = new ByteBuffer[outgoingBuffers.size()];\n            // Use gathered write call. This updates the positions of the\n            // byte buffers to reflect the bytes that were written out.\n            sock.write(outgoingBuffers.toArray(bufferList));\n\n            // Remove the buffers that we have sent\n            ByteBuffer bb;\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (bb.remaining() > 0) {\n                    break;\n                }\n                outgoingBuffers.remove();\n            }\n        } else {\n            directBuffer.clear();\n\n            for (ByteBuffer b : outgoingBuffers) {\n                if (directBuffer.remaining() < b.remaining()) {\n                    /*\n                     * When we call put later, if the directBuffer is to\n                     * small to hold everything, nothing will be copied,\n                     * so we've got to slice the buffer if it's too big.\n                     */\n                    b = (ByteBuffer) b.slice().limit(directBuffer.remaining());\n                }\n                /*\n                 * put() is going to modify the positions of both\n                 * buffers, put we don't want to change the position of\n                 * the source buffers (we'll do that after the send, if\n                 * needed), so we save and reset the position after the\n                 * copy\n                 */\n                int p = b.position();\n                directBuffer.put(b);\n                b.position(p);\n                if (directBuffer.remaining() == 0) {\n                    break;\n                }\n            }\n            /*\n             * Do the flip: limit becomes position, position gets set to\n             * 0. This sets us up for the write.\n             */\n            directBuffer.flip();\n\n            int sent = sock.write(directBuffer);\n\n            ByteBuffer bb;\n\n            // Remove the buffers that we have sent\n            while ((bb = outgoingBuffers.peek()) != null) {\n                if (bb == ServerCnxnFactory.closeConn) {\n                    throw new CloseRequestException(\"close requested\", DisconnectReason.CLIENT_CLOSED_CONNECTION);\n                }\n                if (bb == packetSentinel) {\n                    packetSent();\n                }\n                if (sent < bb.remaining()) {\n                    /*\n                     * We only partially sent this buffer, so we update\n                     * the position and exit the loop.\n                     */\n                    bb.position(bb.position() + sent);\n                    break;\n                }\n                /* We've sent the whole buffer, so drop the buffer */\n                sent -= bb.remaining();\n                outgoingBuffers.remove();\n            }\n        }\n    }\n\n    /**\n     * Only used in order to allow testing\n     */\n    protected boolean isSocketOpen() {\n        return sock.isOpen();\n    }\n\n    /**\n     * Handles read/write IO on connection.\n     */\n    void doIO(SelectionKey k) throws InterruptedException {\n        try {\n            if (!isSocketOpen()) {\n                LOG.warn(\"trying to do i/o on a null socket for session: 0x{}\", Long.toHexString(sessionId));\n\n                return;\n            }\n            if (k.isReadable()) {\n                int rc = sock.read(incomingBuffer);\n                if (rc < 0) {\n                    try {\n                        handleFailedRead();\n                    } catch (EndOfStreamException e) {\n                        // no stacktrace. this case is very common, and it is usually not a problem.\n                        LOG.info(\"{}\", e.getMessage());\n                        // expecting close to log session closure\n                        close(e.getReason());\n                        return;\n                    }\n                }\n                if (incomingBuffer.remaining() == 0) {\n                    boolean isPayload;\n                    if (incomingBuffer == lenBuffer) { // start of next request\n                        incomingBuffer.flip();\n                        isPayload = readLength(k);\n                        incomingBuffer.clear();\n                    } else {\n                        // continuation\n                        isPayload = true;\n                    }\n                    if (isPayload) { // not the case for 4letterword\n                        readPayload();\n                    } else {\n                        // four letter words take care\n                        // need not do anything else\n                        return;\n                    }\n                }\n            }\n            if (k.isWritable()) {\n                handleWrite(k);\n\n                if (!initialized && !getReadInterest() && !getWriteInterest()) {\n                    throw new CloseRequestException(\"responded to info probe\", DisconnectReason.INFO_PROBE);\n                }\n            }\n        } catch (CancelledKeyException e) {\n            LOG.warn(\"CancelledKeyException causing close of session: 0x{}\", Long.toHexString(sessionId));\n\n            LOG.debug(\"CancelledKeyException stack trace\", e);\n\n            close(DisconnectReason.CANCELLED_KEY_EXCEPTION);\n        } catch (CloseRequestException e) {\n            // expecting close to log session closure\n            close();\n        } catch (EndOfStreamException e) {\n            LOG.warn(\"Unexpected exception\", e);\n            // expecting close to log session closure\n            close(e.getReason());\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n            LOG.warn(\"Closing session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.CLIENT_CNX_LIMIT);\n        } catch (IOException e) {\n            LOG.warn(\"Close of session 0x{}\", Long.toHexString(sessionId), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        }\n    }\n\n    protected void readRequest() throws IOException {\n        zkServer.processPacket(this, incomingBuffer);\n    }\n\n    // returns whether we are interested in writing, which is determined\n    // by whether we have any pending buffers on the output queue or not\n    private boolean getWriteInterest() {\n        return !outgoingBuffers.isEmpty();\n    }\n\n    // returns whether we are interested in taking new requests, which is\n    // determined by whether we are currently throttled or not\n    private boolean getReadInterest() {\n        return !throttled.get();\n    }\n\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n\n    // Throttle acceptance of new requests. If this entailed a state change,\n    // register an interest op update request with the selector.\n    //\n    // Don't support wait disable receive in NIO, ignore the parameter\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    // Disable throttling and resume acceptance of new requests. If this\n    // entailed a state change, register an interest op update request with\n    // the selector.\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            requestInterestOpsUpdate();\n        }\n    }\n\n    private void readConnectRequest() throws IOException, ClientCnxnLimitException {\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(incomingBuffer));\n        ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n        zkServer.processConnectRequest(this, request);\n        initialized = true;\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBufferSync(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final SelectionKey k, final int len) throws IOException {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n        packetReceived(4);\n\n        /** cancel the selection key to remove the socket handling\n         * from selector. This is to prevent netcat problem wherein\n         * netcat immediately closes the sending side after sending the\n         * commands and still keeps the receiving channel open.\n         * The idea is to remove the selectionkey from the selector\n         * so that the selector does not notice the closed read on the\n         * socket channel and keep the socket alive to write the data to\n         * and makes sure to close the socket after its done writing the data\n         */\n        if (k != null) {\n            try {\n                k.cancel();\n            } catch (Exception e) {\n                LOG.error(\"Error cancelling command selection key\", e);\n            }\n        }\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, sock.socket().getRemoteSocketAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            incomingBuffer = ByteBuffer.allocate(8);\n            int rc = sock.read(incomingBuffer);\n            if (rc < 0) {\n                throw new IOException(\"Read error\");\n            }\n            incomingBuffer.flip();\n            long traceMask = incomingBuffer.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /** Reads the first 4 bytes of lenBuffer, which could be true length or\n     *  four letter word.\n     *\n     * @param k selection key\n     * @return true if length read, otw false (wasn't really the length)\n     * @throws IOException if buffer size exceeds maxBuffer size\n     */\n    private boolean readLength(SelectionKey k) throws IOException {\n        // Read the length, now get the buffer\n        int len = lenBuffer.getInt();\n        if (!initialized && checkFourLetterWord(sk, len)) {\n            return false;\n        }\n        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n            throw new IOException(\"Len error. \"\n                    + \"A message from \" +  this.getRemoteSocketAddress() + \" with advertised length of \" + len\n                    + \" is either a malformed message or too large to process\"\n                    + \" (length is greater than jute.maxbuffer=\" + BinaryInputArchive.maxBuffer + \")\");\n        }\n        if (!isZKServerRunning()) {\n            throw new IOException(\"ZooKeeperServer not running\");\n        }\n        // checkRequestSize will throw IOException if request is rejected\n        zkServer.checkRequestSizeWhenReceivingMessage(len);\n        incomingBuffer = ByteBuffer.allocate(len);\n        return true;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionTimeout()\n     */\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    /**\n     * Used by \"dump\" 4-letter command to list all connection in\n     * cnxnExpiryMap\n     */\n    @Override\n    public String toString() {\n        return \"ip: \" + sock.socket().getRemoteSocketAddress() + \" sessionId: 0x\" + Long.toHexString(sessionId);\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    private void close() {\n        setStale();\n        if (!factory.removeCnxn(this)) {\n            return;\n        }\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (sk != null) {\n            try {\n                // need to cancel this selection key from the selector\n                sk.cancel();\n            } catch (Exception e) {\n                LOG.debug(\"ignoring exception during selectionkey cancel\", e);\n            }\n        }\n\n        closeSock();\n    }\n\n    /**\n     * Close resources associated with the sock of this cnxn.\n     */\n    private void closeSock() {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        String logMsg = String.format(\n            \"Closed socket connection for client %s %s\",\n            sock.socket().getRemoteSocketAddress(),\n            sessionId != 0\n                ? \"which had sessionid 0x\" + Long.toHexString(sessionId)\n                : \"(no session established for client)\"\n            );\n        LOG.debug(logMsg);\n\n        closeSock(sock);\n    }\n\n    /**\n     * Close resources associated with a sock.\n     */\n    public static void closeSock(SocketChannel sock) {\n        if (!sock.isOpen()) {\n            return;\n        }\n\n        try {\n            /*\n             * The following sequence of code is stupid! You would think that\n             * only sock.close() is needed, but alas, it doesn't work that way.\n             * If you just do sock.close() there are cases where the socket\n             * doesn't actually close...\n             */\n            sock.socket().shutdownOutput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during output shutdown\", e);\n        }\n        try {\n            sock.socket().shutdownInput();\n        } catch (IOException e) {\n            // This is a relatively common exception that we can't avoid\n            LOG.debug(\"ignoring exception during input shutdown\", e);\n        }\n        try {\n            sock.socket().close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socket close\", e);\n        }\n        try {\n            sock.close();\n        } catch (IOException e) {\n            LOG.debug(\"ignoring exception during socketchannel close\", e);\n        }\n    }\n\n    private static final ByteBuffer packetSentinel = ByteBuffer.allocate(0);\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag, String cacheKey, Stat stat, int opCode) {\n        int responseSize = 0;\n        try {\n            ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n            responseSize = bb[0].getInt();\n            bb[0].rewind();\n            sendBuffer(bb);\n            decrOutstandingAndCheckThrottle(h);\n        } catch (Exception e) {\n            LOG.warn(\"Unexpected exception. Destruction averted.\", e);\n        }\n        return responseSize;\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#process(org.apache.zookeeper.proto.WatcherEvent)\n     */\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        // The last parameter OpCode here is used to select the response cache.\n        // Passing OpCode.error (with a value of -1) means we don't care, as we don't need\n        // response cache on delivering watcher events.\n        int responseSize = sendResponse(h, e, \"notification\", null, null, ZooDefs.OpCode.error);\n        ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n    }\n\n    /*\n     * (non-Javadoc)\n     *\n     * @see org.apache.zookeeper.server.ServerCnxnIface#getSessionId()\n     */\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n        factory.touchCnxn(this);\n    }\n\n    @Override\n    public int getInterestOps() {\n        if (!isSelectable()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (getReadInterest()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (getWriteInterest()) {\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return (InetSocketAddress) sock.socket().getRemoteSocketAddress();\n    }\n\n    public InetAddress getSocketAddress() {\n        if (!sock.isOpen()) {\n            return null;\n        }\n        return sock.socket().getInetAddress();\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return false;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        throw new UnsupportedOperationException(\"SSL is unsupported in NIOServerCnxn\");\n    }\n\n}\n","lineNo":436}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);\n    private final Channel channel;\n    private CompositeByteBuf queuedBuffer;\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n    private ByteBuffer bb;\n    private final ByteBuffer bbLen = ByteBuffer.allocate(4);\n    private long sessionId;\n    private int sessionTimeout;\n    private Certificate[] clientChain;\n    private volatile boolean closingChannel;\n\n    private final NettyServerCnxnFactory factory;\n    private boolean initialized;\n\n    public int readIssuedAfterReadComplete;\n\n    private volatile HandshakeState handshakeState = HandshakeState.NONE;\n\n    public enum HandshakeState {\n        NONE,\n        STARTED,\n        FINISHED\n    }\n\n    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {\n        super(zks);\n        this.channel = channel;\n        this.closingChannel = false;\n        this.factory = factory;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    public void close() {\n        closingChannel = true;\n\n        LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n\n        setStale();\n\n        // ZOOKEEPER-2743:\n        // Always unregister connection upon close to prevent\n        // connection bean leak under certain race conditions.\n        factory.unregisterConnection(this);\n\n        // if this is not in cnxns then it's already closed\n        if (!factory.cnxns.remove(this)) {\n            LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n            if (channel.isOpen()) {\n                channel.close();\n            }\n            return;\n        }\n\n        LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n\n        factory.removeCnxnFromSessionMap(this);\n\n        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (channel.isOpen()) {\n            // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n            // that all writes have been completed before closing the channel or we risk data loss\n            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    future.channel().close().addListener(f -> releaseQueuedBuffer());\n                }\n            });\n        } else {\n            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n            channel.eventLoop().execute(this::releaseQueuedBuffer);\n        }\n    }\n\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        try {\n            int responseSize = sendResponse(h, e, \"notification\");\n            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n        } catch (IOException e1) {\n            LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n            close();\n        }\n    }\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag,\n                             String cacheKey, Stat stat, int opCode) throws IOException {\n        // cacheKey and stat are used in caching, which is not\n        // implemented here. Implementation example can be found in NIOServerCnxn.\n        if (closingChannel || !channel.isOpen()) {\n            return 0;\n        }\n        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n        int responseSize = bb[0].getInt();\n        bb[0].rewind();\n        sendBuffer(bb);\n        decrOutstandingAndCheckThrottle(h);\n        return responseSize;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    // Use a single listener instance to reduce GC\n    private final GenericFutureListener<Future<Void>> onSendBufferDoneListener = f -> {\n        if (f.isSuccess()) {\n            packetSent();\n        }\n    };\n\n    @Override\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {\n            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            return;\n        }\n        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n\n        // Stops automatic reads of incoming data on this channel. We don't\n        // expect any more traffic from the client when processing a 4LW\n        // so this shouldn't break anything.\n        channel.config().setAutoRead(false);\n        packetReceived(4);\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(8);\n            message.readBytes(mask);\n            mask.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /**\n     * Helper that throws an IllegalStateException if the current thread is not\n     * executing in the channel's event loop thread.\n     * @param callerMethodName the name of the calling method to add to the exception message.\n     */\n    private void checkIsInEventLoop(String callerMethodName) {\n        if (!channel.eventLoop().inEventLoop()) {\n            throw new IllegalStateException(callerMethodName + \"() called from non-EventLoop thread\");\n        }\n    }\n\n    /**\n     * Appends <code>buf<\/code> to <code>queuedBuffer<\/code>. Does not duplicate <code>buf<\/code>\n     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that <code>buf<\/code>\n     * is not owned by anyone else, as this call transfers ownership of <code>buf<\/code> to the\n     * <code>queuedBuffer<\/code>.\n     *\n     * This method should only be called from the event loop thread.\n     * @param buf the buffer to append to the queue.\n     */\n    private void appendToQueuedBuffer(ByteBuf buf) {\n        checkIsInEventLoop(\"appendToQueuedBuffer\");\n        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {\n            // queuedBuffer has reached its component limit, so combine the existing components.\n            queuedBuffer.consolidate();\n        }\n        queuedBuffer.addComponent(true, buf);\n        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());\n    }\n\n    /**\n     * Process incoming message. This should only be called from the event\n     * loop thread.\n     * Note that this method does not call <code>buf.release()<\/code>. The caller\n     * is responsible for making sure the buf is released after this method\n     * returns.\n     * @param buf the message bytes to process.\n     */\n    void processMessage(ByteBuf buf) {\n        checkIsInEventLoop(\"processMessage\");\n        LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n        }\n\n        if (throttled.get()) {\n            LOG.debug(\"Received message while throttled\");\n            // we are throttled, so we need to queue\n            if (queuedBuffer == null) {\n                LOG.debug(\"allocating queue\");\n                queuedBuffer = channel.alloc().compositeBuffer();\n            }\n            appendToQueuedBuffer(buf.retainedDuplicate());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n        } else {\n            LOG.debug(\"not throttled\");\n            if (queuedBuffer != null) {\n                appendToQueuedBuffer(buf.retainedDuplicate());\n                processQueuedBuffer();\n            } else {\n                receiveMessage(buf);\n                // Have to check !closingChannel, because an error in\n                // receiveMessage() could have led to close() being called.\n                if (!closingChannel && buf.isReadable()) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Before copy {}\", buf);\n                    }\n\n                    if (queuedBuffer == null) {\n                        queuedBuffer = channel.alloc().compositeBuffer();\n                    }\n                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Copy is {}\", queuedBuffer);\n                        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to process previously queued message. This should only be called\n     * from the event loop thread.\n     */\n    void processQueuedBuffer() {\n        checkIsInEventLoop(\"processQueuedBuffer\");\n        if (queuedBuffer != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n            receiveMessage(queuedBuffer);\n            if (closingChannel) {\n                // close() could have been called if receiveMessage() failed\n                LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n            } else if (!queuedBuffer.isReadable()) {\n                LOG.debug(\"Processed queue - no bytes remaining\");\n                releaseQueuedBuffer();\n            } else {\n                LOG.debug(\"Processed queue - bytes remaining\");\n                // Try to reduce memory consumption by freeing up buffer space\n                // which is no longer needed.\n                queuedBuffer.discardReadComponents();\n            }\n        } else {\n            LOG.debug(\"queue empty\");\n        }\n    }\n\n    /**\n     * Clean up queued buffer once it's no longer needed. This should only be\n     * called from the event loop thread.\n     */\n    private void releaseQueuedBuffer() {\n        checkIsInEventLoop(\"releaseQueuedBuffer\");\n        if (queuedBuffer != null) {\n            queuedBuffer.release();\n            queuedBuffer = null;\n        }\n    }\n\n    /**\n     * Receive a message, which can come from the queued buffer or from a new\n     * buffer coming in over the channel. This should only be called from the\n     * event loop thread.\n     * Note that this method does not call <code>message.release()<\/code>. The\n     * caller is responsible for making sure the message is released after this\n     * method returns.\n     * @param message the message bytes to process.\n     */\n    private void receiveMessage(ByteBuf message) {\n        checkIsInEventLoop(\"receiveMessage\");\n        try {\n            while (message.isReadable() && !throttled.get()) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes 0x{} bb {}\",\n                                  Long.toHexString(sessionId),\n                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        bb.flip();\n                        packetReceived(4 + bb.remaining());\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],\n                            // we could implement zero-copy queueing.\n                            zks.processPacket(this, bb);\n                        } else {\n                            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n                            zks.processConnectRequest(this, bb);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            LOG.info(\"Closing connection to {} because the server is not ready\",\n                                    getRemoteSocketAddress());\n                            close(DisconnectReason.IO_EXCEPTION);\n                            return;\n                        }\n                        // checkRequestSize will throw IOException if request is rejected\n                        zks.checkRequestSizeWhenReceivingMessage(len);\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n\n            LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.CLIENT_RATE_LIMIT);\n        }\n    }\n\n    /**\n     * An event that triggers a change in the channel's read setting.\n     * Used for throttling. By using an enum we can treat the two values as\n     * singletons and compare with ==.\n     */\n    enum ReadEvent {\n        DISABLE,\n        ENABLE\n    }\n\n    /**\n     * Note that the netty implementation ignores the <code>waitDisableRecv<\/code>\n     * parameter and is always asynchronous.\n     * @param waitDisableRecv ignored by this implementation.\n     */\n    @Override\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            LOG.debug(\"Throttling - disabling recv {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n        }\n    }\n\n    @Override\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            LOG.debug(\"Sending unthrottle event {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n        }\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    @Override\n    public int getInterestOps() {\n        // This might not be 100% right, but it's only used for printing\n        // connection info in the netty implementation so it's probably ok.\n        if (channel == null || !channel.isOpen()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (!throttled.get()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (!channel.isWritable()) {\n            // OP_READ means \"can read\", but OP_WRITE means \"cannot write\",\n            // it's weird.\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress) channel.remoteAddress();\n    }\n\n    /** Send close connection packet to the client.\n     */\n    @Override\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return factory.secure;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        if (clientChain == null) {\n            return null;\n        }\n        return Arrays.copyOf(clientChain, clientChain.length);\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        if (chain == null) {\n            clientChain = null;\n        } else {\n            clientChain = Arrays.copyOf(chain, chain.length);\n        }\n    }\n\n    // For tests and NettyServerCnxnFactory only, thus package-private.\n    Channel getChannel() {\n        return channel;\n    }\n\n    public int getQueuedReadableBytes() {\n        checkIsInEventLoop(\"getQueuedReadableBytes\");\n        if (queuedBuffer != null) {\n            return queuedBuffer.readableBytes();\n        }\n        return 0;\n    }\n\n    public void setHandshakeState(HandshakeState state) {\n        this.handshakeState = state;\n    }\n\n    public HandshakeState getHandshakeState() {\n        return this.handshakeState;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ConnectRequest;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);\n    private final Channel channel;\n    private CompositeByteBuf queuedBuffer;\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n    private ByteBuffer bb;\n    private final ByteBuffer bbLen = ByteBuffer.allocate(4);\n    private long sessionId;\n    private int sessionTimeout;\n    private Certificate[] clientChain;\n    private volatile boolean closingChannel;\n\n    private final NettyServerCnxnFactory factory;\n    private boolean initialized;\n\n    public int readIssuedAfterReadComplete;\n\n    private volatile HandshakeState handshakeState = HandshakeState.NONE;\n\n    public enum HandshakeState {\n        NONE,\n        STARTED,\n        FINISHED\n    }\n\n    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {\n        super(zks);\n        this.channel = channel;\n        this.closingChannel = false;\n        this.factory = factory;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    public void close() {\n        closingChannel = true;\n\n        LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n\n        setStale();\n\n        // ZOOKEEPER-2743:\n        // Always unregister connection upon close to prevent\n        // connection bean leak under certain race conditions.\n        factory.unregisterConnection(this);\n\n        // if this is not in cnxns then it's already closed\n        if (!factory.cnxns.remove(this)) {\n            LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n            if (channel.isOpen()) {\n                channel.close();\n            }\n            return;\n        }\n\n        LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n\n        factory.removeCnxnFromSessionMap(this);\n\n        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (channel.isOpen()) {\n            // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n            // that all writes have been completed before closing the channel or we risk data loss\n            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    future.channel().close().addListener(f -> releaseQueuedBuffer());\n                }\n            });\n        } else {\n            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n            channel.eventLoop().execute(this::releaseQueuedBuffer);\n        }\n    }\n\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        try {\n            int responseSize = sendResponse(h, e, \"notification\");\n            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n        } catch (IOException e1) {\n            LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n            close();\n        }\n    }\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag,\n                             String cacheKey, Stat stat, int opCode) throws IOException {\n        // cacheKey and stat are used in caching, which is not\n        // implemented here. Implementation example can be found in NIOServerCnxn.\n        if (closingChannel || !channel.isOpen()) {\n            return 0;\n        }\n        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n        int responseSize = bb[0].getInt();\n        bb[0].rewind();\n        sendBuffer(bb);\n        decrOutstandingAndCheckThrottle(h);\n        return responseSize;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    // Use a single listener instance to reduce GC\n    private final GenericFutureListener<Future<Void>> onSendBufferDoneListener = f -> {\n        if (f.isSuccess()) {\n            packetSent();\n        }\n    };\n\n    @Override\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {\n            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            return;\n        }\n        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n\n        // Stops automatic reads of incoming data on this channel. We don't\n        // expect any more traffic from the client when processing a 4LW\n        // so this shouldn't break anything.\n        channel.config().setAutoRead(false);\n        packetReceived(4);\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(8);\n            message.readBytes(mask);\n            mask.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /**\n     * Helper that throws an IllegalStateException if the current thread is not\n     * executing in the channel's event loop thread.\n     * @param callerMethodName the name of the calling method to add to the exception message.\n     */\n    private void checkIsInEventLoop(String callerMethodName) {\n        if (!channel.eventLoop().inEventLoop()) {\n            throw new IllegalStateException(callerMethodName + \"() called from non-EventLoop thread\");\n        }\n    }\n\n    /**\n     * Appends <code>buf<\/code> to <code>queuedBuffer<\/code>. Does not duplicate <code>buf<\/code>\n     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that <code>buf<\/code>\n     * is not owned by anyone else, as this call transfers ownership of <code>buf<\/code> to the\n     * <code>queuedBuffer<\/code>.\n     *\n     * This method should only be called from the event loop thread.\n     * @param buf the buffer to append to the queue.\n     */\n    private void appendToQueuedBuffer(ByteBuf buf) {\n        checkIsInEventLoop(\"appendToQueuedBuffer\");\n        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {\n            // queuedBuffer has reached its component limit, so combine the existing components.\n            queuedBuffer.consolidate();\n        }\n        queuedBuffer.addComponent(true, buf);\n        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());\n    }\n\n    /**\n     * Process incoming message. This should only be called from the event\n     * loop thread.\n     * Note that this method does not call <code>buf.release()<\/code>. The caller\n     * is responsible for making sure the buf is released after this method\n     * returns.\n     * @param buf the message bytes to process.\n     */\n    void processMessage(ByteBuf buf) {\n        checkIsInEventLoop(\"processMessage\");\n        LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n        }\n\n        if (throttled.get()) {\n            LOG.debug(\"Received message while throttled\");\n            // we are throttled, so we need to queue\n            if (queuedBuffer == null) {\n                LOG.debug(\"allocating queue\");\n                queuedBuffer = channel.alloc().compositeBuffer();\n            }\n            appendToQueuedBuffer(buf.retainedDuplicate());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n        } else {\n            LOG.debug(\"not throttled\");\n            if (queuedBuffer != null) {\n                appendToQueuedBuffer(buf.retainedDuplicate());\n                processQueuedBuffer();\n            } else {\n                receiveMessage(buf);\n                // Have to check !closingChannel, because an error in\n                // receiveMessage() could have led to close() being called.\n                if (!closingChannel && buf.isReadable()) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Before copy {}\", buf);\n                    }\n\n                    if (queuedBuffer == null) {\n                        queuedBuffer = channel.alloc().compositeBuffer();\n                    }\n                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Copy is {}\", queuedBuffer);\n                        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to process previously queued message. This should only be called\n     * from the event loop thread.\n     */\n    void processQueuedBuffer() {\n        checkIsInEventLoop(\"processQueuedBuffer\");\n        if (queuedBuffer != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n            receiveMessage(queuedBuffer);\n            if (closingChannel) {\n                // close() could have been called if receiveMessage() failed\n                LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n            } else if (!queuedBuffer.isReadable()) {\n                LOG.debug(\"Processed queue - no bytes remaining\");\n                releaseQueuedBuffer();\n            } else {\n                LOG.debug(\"Processed queue - bytes remaining\");\n                // Try to reduce memory consumption by freeing up buffer space\n                // which is no longer needed.\n                queuedBuffer.discardReadComponents();\n            }\n        } else {\n            LOG.debug(\"queue empty\");\n        }\n    }\n\n    /**\n     * Clean up queued buffer once it's no longer needed. This should only be\n     * called from the event loop thread.\n     */\n    private void releaseQueuedBuffer() {\n        checkIsInEventLoop(\"releaseQueuedBuffer\");\n        if (queuedBuffer != null) {\n            queuedBuffer.release();\n            queuedBuffer = null;\n        }\n    }\n\n    /**\n     * Receive a message, which can come from the queued buffer or from a new\n     * buffer coming in over the channel. This should only be called from the\n     * event loop thread.\n     * Note that this method does not call <code>message.release()<\/code>. The\n     * caller is responsible for making sure the message is released after this\n     * method returns.\n     * @param message the message bytes to process.\n     */\n    private void receiveMessage(ByteBuf message) {\n        checkIsInEventLoop(\"receiveMessage\");\n        try {\n            while (message.isReadable() && !throttled.get()) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes 0x{} bb {}\",\n                                  Long.toHexString(sessionId),\n                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        bb.flip();\n                        packetReceived(4 + bb.remaining());\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],\n                            // we could implement zero-copy queueing.\n                            zks.processPacket(this, bb);\n                        } else {\n                            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n                            BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n                            ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n                            zks.processConnectRequest(this, request);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            LOG.info(\"Closing connection to {} because the server is not ready\",\n                                    getRemoteSocketAddress());\n                            close(DisconnectReason.IO_EXCEPTION);\n                            return;\n                        }\n                        // checkRequestSize will throw IOException if request is rejected\n                        zks.checkRequestSizeWhenReceivingMessage(len);\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n\n            LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.CLIENT_RATE_LIMIT);\n        }\n    }\n\n    /**\n     * An event that triggers a change in the channel's read setting.\n     * Used for throttling. By using an enum we can treat the two values as\n     * singletons and compare with ==.\n     */\n    enum ReadEvent {\n        DISABLE,\n        ENABLE\n    }\n\n    /**\n     * Note that the netty implementation ignores the <code>waitDisableRecv<\/code>\n     * parameter and is always asynchronous.\n     * @param waitDisableRecv ignored by this implementation.\n     */\n    @Override\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            LOG.debug(\"Throttling - disabling recv {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n        }\n    }\n\n    @Override\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            LOG.debug(\"Sending unthrottle event {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n        }\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    @Override\n    public int getInterestOps() {\n        // This might not be 100% right, but it's only used for printing\n        // connection info in the netty implementation so it's probably ok.\n        if (channel == null || !channel.isOpen()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (!throttled.get()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (!channel.isWritable()) {\n            // OP_READ means \"can read\", but OP_WRITE means \"cannot write\",\n            // it's weird.\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress) channel.remoteAddress();\n    }\n\n    /** Send close connection packet to the client.\n     */\n    @Override\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return factory.secure;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        if (clientChain == null) {\n            return null;\n        }\n        return Arrays.copyOf(clientChain, clientChain.length);\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        if (chain == null) {\n            clientChain = null;\n        } else {\n            clientChain = Arrays.copyOf(chain, chain.length);\n        }\n    }\n\n    // For tests and NettyServerCnxnFactory only, thus package-private.\n    Channel getChannel() {\n        return channel;\n    }\n\n    public int getQueuedReadableBytes() {\n        checkIsInEventLoop(\"getQueuedReadableBytes\");\n        if (queuedBuffer != null) {\n            return queuedBuffer.readableBytes();\n        }\n        return 0;\n    }\n\n    public void setHandshakeState(HandshakeState state) {\n        this.handshakeState = state;\n    }\n\n    public HandshakeState getHandshakeState() {\n        return this.handshakeState;\n    }\n}\n","lineNo":486}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);\n    private final Channel channel;\n    private CompositeByteBuf queuedBuffer;\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n    private ByteBuffer bb;\n    private final ByteBuffer bbLen = ByteBuffer.allocate(4);\n    private long sessionId;\n    private int sessionTimeout;\n    private Certificate[] clientChain;\n    private volatile boolean closingChannel;\n\n    private final NettyServerCnxnFactory factory;\n    private boolean initialized;\n\n    public int readIssuedAfterReadComplete;\n\n    private volatile HandshakeState handshakeState = HandshakeState.NONE;\n\n    public enum HandshakeState {\n        NONE,\n        STARTED,\n        FINISHED\n    }\n\n    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {\n        super(zks);\n        this.channel = channel;\n        this.closingChannel = false;\n        this.factory = factory;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    public void close() {\n        closingChannel = true;\n\n        LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n\n        setStale();\n\n        // ZOOKEEPER-2743:\n        // Always unregister connection upon close to prevent\n        // connection bean leak under certain race conditions.\n        factory.unregisterConnection(this);\n\n        // if this is not in cnxns then it's already closed\n        if (!factory.cnxns.remove(this)) {\n            LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n            if (channel.isOpen()) {\n                channel.close();\n            }\n            return;\n        }\n\n        LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n\n        factory.removeCnxnFromSessionMap(this);\n\n        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (channel.isOpen()) {\n            // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n            // that all writes have been completed before closing the channel or we risk data loss\n            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    future.channel().close().addListener(f -> releaseQueuedBuffer());\n                }\n            });\n        } else {\n            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n            channel.eventLoop().execute(this::releaseQueuedBuffer);\n        }\n    }\n\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        try {\n            int responseSize = sendResponse(h, e, \"notification\");\n            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n        } catch (IOException e1) {\n            LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n            close();\n        }\n    }\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag,\n                             String cacheKey, Stat stat, int opCode) throws IOException {\n        // cacheKey and stat are used in caching, which is not\n        // implemented here. Implementation example can be found in NIOServerCnxn.\n        if (closingChannel || !channel.isOpen()) {\n            return 0;\n        }\n        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n        int responseSize = bb[0].getInt();\n        bb[0].rewind();\n        sendBuffer(bb);\n        decrOutstandingAndCheckThrottle(h);\n        return responseSize;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    // Use a single listener instance to reduce GC\n    private final GenericFutureListener<Future<Void>> onSendBufferDoneListener = f -> {\n        if (f.isSuccess()) {\n            packetSent();\n        }\n    };\n\n    @Override\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {\n            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            return;\n        }\n        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n\n        // Stops automatic reads of incoming data on this channel. We don't\n        // expect any more traffic from the client when processing a 4LW\n        // so this shouldn't break anything.\n        channel.config().setAutoRead(false);\n        packetReceived(4);\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(8);\n            message.readBytes(mask);\n            mask.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /**\n     * Helper that throws an IllegalStateException if the current thread is not\n     * executing in the channel's event loop thread.\n     * @param callerMethodName the name of the calling method to add to the exception message.\n     */\n    private void checkIsInEventLoop(String callerMethodName) {\n        if (!channel.eventLoop().inEventLoop()) {\n            throw new IllegalStateException(callerMethodName + \"() called from non-EventLoop thread\");\n        }\n    }\n\n    /**\n     * Appends <code>buf<\/code> to <code>queuedBuffer<\/code>. Does not duplicate <code>buf<\/code>\n     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that <code>buf<\/code>\n     * is not owned by anyone else, as this call transfers ownership of <code>buf<\/code> to the\n     * <code>queuedBuffer<\/code>.\n     *\n     * This method should only be called from the event loop thread.\n     * @param buf the buffer to append to the queue.\n     */\n    private void appendToQueuedBuffer(ByteBuf buf) {\n        checkIsInEventLoop(\"appendToQueuedBuffer\");\n        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {\n            // queuedBuffer has reached its component limit, so combine the existing components.\n            queuedBuffer.consolidate();\n        }\n        queuedBuffer.addComponent(true, buf);\n        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());\n    }\n\n    /**\n     * Process incoming message. This should only be called from the event\n     * loop thread.\n     * Note that this method does not call <code>buf.release()<\/code>. The caller\n     * is responsible for making sure the buf is released after this method\n     * returns.\n     * @param buf the message bytes to process.\n     */\n    void processMessage(ByteBuf buf) {\n        checkIsInEventLoop(\"processMessage\");\n        LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n        }\n\n        if (throttled.get()) {\n            LOG.debug(\"Received message while throttled\");\n            // we are throttled, so we need to queue\n            if (queuedBuffer == null) {\n                LOG.debug(\"allocating queue\");\n                queuedBuffer = channel.alloc().compositeBuffer();\n            }\n            appendToQueuedBuffer(buf.retainedDuplicate());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n        } else {\n            LOG.debug(\"not throttled\");\n            if (queuedBuffer != null) {\n                appendToQueuedBuffer(buf.retainedDuplicate());\n                processQueuedBuffer();\n            } else {\n                receiveMessage(buf);\n                // Have to check !closingChannel, because an error in\n                // receiveMessage() could have led to close() being called.\n                if (!closingChannel && buf.isReadable()) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Before copy {}\", buf);\n                    }\n\n                    if (queuedBuffer == null) {\n                        queuedBuffer = channel.alloc().compositeBuffer();\n                    }\n                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Copy is {}\", queuedBuffer);\n                        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to process previously queued message. This should only be called\n     * from the event loop thread.\n     */\n    void processQueuedBuffer() {\n        checkIsInEventLoop(\"processQueuedBuffer\");\n        if (queuedBuffer != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n            receiveMessage(queuedBuffer);\n            if (closingChannel) {\n                // close() could have been called if receiveMessage() failed\n                LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n            } else if (!queuedBuffer.isReadable()) {\n                LOG.debug(\"Processed queue - no bytes remaining\");\n                releaseQueuedBuffer();\n            } else {\n                LOG.debug(\"Processed queue - bytes remaining\");\n                // Try to reduce memory consumption by freeing up buffer space\n                // which is no longer needed.\n                queuedBuffer.discardReadComponents();\n            }\n        } else {\n            LOG.debug(\"queue empty\");\n        }\n    }\n\n    /**\n     * Clean up queued buffer once it's no longer needed. This should only be\n     * called from the event loop thread.\n     */\n    private void releaseQueuedBuffer() {\n        checkIsInEventLoop(\"releaseQueuedBuffer\");\n        if (queuedBuffer != null) {\n            queuedBuffer.release();\n            queuedBuffer = null;\n        }\n    }\n\n    /**\n     * Receive a message, which can come from the queued buffer or from a new\n     * buffer coming in over the channel. This should only be called from the\n     * event loop thread.\n     * Note that this method does not call <code>message.release()<\/code>. The\n     * caller is responsible for making sure the message is released after this\n     * method returns.\n     * @param message the message bytes to process.\n     */\n    private void receiveMessage(ByteBuf message) {\n        checkIsInEventLoop(\"receiveMessage\");\n        try {\n            while (message.isReadable() && !throttled.get()) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes 0x{} bb {}\",\n                                  Long.toHexString(sessionId),\n                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        bb.flip();\n                        packetReceived(4 + bb.remaining());\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],\n                            // we could implement zero-copy queueing.\n                            zks.processPacket(this, bb);\n                        } else {\n                            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n                            zks.processConnectRequest(this, bb);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            LOG.info(\"Closing connection to {} because the server is not ready\",\n                                    getRemoteSocketAddress());\n                            close(DisconnectReason.IO_EXCEPTION);\n                            return;\n                        }\n                        // checkRequestSize will throw IOException if request is rejected\n                        zks.checkRequestSizeWhenReceivingMessage(len);\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n\n            LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.CLIENT_RATE_LIMIT);\n        }\n    }\n\n    /**\n     * An event that triggers a change in the channel's read setting.\n     * Used for throttling. By using an enum we can treat the two values as\n     * singletons and compare with ==.\n     */\n    enum ReadEvent {\n        DISABLE,\n        ENABLE\n    }\n\n    /**\n     * Note that the netty implementation ignores the <code>waitDisableRecv<\/code>\n     * parameter and is always asynchronous.\n     * @param waitDisableRecv ignored by this implementation.\n     */\n    @Override\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            LOG.debug(\"Throttling - disabling recv {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n        }\n    }\n\n    @Override\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            LOG.debug(\"Sending unthrottle event {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n        }\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    @Override\n    public int getInterestOps() {\n        // This might not be 100% right, but it's only used for printing\n        // connection info in the netty implementation so it's probably ok.\n        if (channel == null || !channel.isOpen()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (!throttled.get()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (!channel.isWritable()) {\n            // OP_READ means \"can read\", but OP_WRITE means \"cannot write\",\n            // it's weird.\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress) channel.remoteAddress();\n    }\n\n    /** Send close connection packet to the client.\n     */\n    @Override\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return factory.secure;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        if (clientChain == null) {\n            return null;\n        }\n        return Arrays.copyOf(clientChain, clientChain.length);\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        if (chain == null) {\n            clientChain = null;\n        } else {\n            clientChain = Arrays.copyOf(chain, chain.length);\n        }\n    }\n\n    // For tests and NettyServerCnxnFactory only, thus package-private.\n    Channel getChannel() {\n        return channel;\n    }\n\n    public int getQueuedReadableBytes() {\n        checkIsInEventLoop(\"getQueuedReadableBytes\");\n        if (queuedBuffer != null) {\n            return queuedBuffer.readableBytes();\n        }\n        return 0;\n    }\n\n    public void setHandshakeState(HandshakeState state) {\n        this.handshakeState = state;\n    }\n\n    public HandshakeState getHandshakeState() {\n        return this.handshakeState;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ConnectRequest;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);\n    private final Channel channel;\n    private CompositeByteBuf queuedBuffer;\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n    private ByteBuffer bb;\n    private final ByteBuffer bbLen = ByteBuffer.allocate(4);\n    private long sessionId;\n    private int sessionTimeout;\n    private Certificate[] clientChain;\n    private volatile boolean closingChannel;\n\n    private final NettyServerCnxnFactory factory;\n    private boolean initialized;\n\n    public int readIssuedAfterReadComplete;\n\n    private volatile HandshakeState handshakeState = HandshakeState.NONE;\n\n    public enum HandshakeState {\n        NONE,\n        STARTED,\n        FINISHED\n    }\n\n    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {\n        super(zks);\n        this.channel = channel;\n        this.closingChannel = false;\n        this.factory = factory;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    public void close() {\n        closingChannel = true;\n\n        LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n\n        setStale();\n\n        // ZOOKEEPER-2743:\n        // Always unregister connection upon close to prevent\n        // connection bean leak under certain race conditions.\n        factory.unregisterConnection(this);\n\n        // if this is not in cnxns then it's already closed\n        if (!factory.cnxns.remove(this)) {\n            LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n            if (channel.isOpen()) {\n                channel.close();\n            }\n            return;\n        }\n\n        LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n\n        factory.removeCnxnFromSessionMap(this);\n\n        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (channel.isOpen()) {\n            // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n            // that all writes have been completed before closing the channel or we risk data loss\n            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    future.channel().close().addListener(f -> releaseQueuedBuffer());\n                }\n            });\n        } else {\n            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n            channel.eventLoop().execute(this::releaseQueuedBuffer);\n        }\n    }\n\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        try {\n            int responseSize = sendResponse(h, e, \"notification\");\n            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n        } catch (IOException e1) {\n            LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n            close();\n        }\n    }\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag,\n                             String cacheKey, Stat stat, int opCode) throws IOException {\n        // cacheKey and stat are used in caching, which is not\n        // implemented here. Implementation example can be found in NIOServerCnxn.\n        if (closingChannel || !channel.isOpen()) {\n            return 0;\n        }\n        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n        int responseSize = bb[0].getInt();\n        bb[0].rewind();\n        sendBuffer(bb);\n        decrOutstandingAndCheckThrottle(h);\n        return responseSize;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    // Use a single listener instance to reduce GC\n    private final GenericFutureListener<Future<Void>> onSendBufferDoneListener = f -> {\n        if (f.isSuccess()) {\n            packetSent();\n        }\n    };\n\n    @Override\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {\n            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            return;\n        }\n        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n\n        // Stops automatic reads of incoming data on this channel. We don't\n        // expect any more traffic from the client when processing a 4LW\n        // so this shouldn't break anything.\n        channel.config().setAutoRead(false);\n        packetReceived(4);\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(8);\n            message.readBytes(mask);\n            mask.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /**\n     * Helper that throws an IllegalStateException if the current thread is not\n     * executing in the channel's event loop thread.\n     * @param callerMethodName the name of the calling method to add to the exception message.\n     */\n    private void checkIsInEventLoop(String callerMethodName) {\n        if (!channel.eventLoop().inEventLoop()) {\n            throw new IllegalStateException(callerMethodName + \"() called from non-EventLoop thread\");\n        }\n    }\n\n    /**\n     * Appends <code>buf<\/code> to <code>queuedBuffer<\/code>. Does not duplicate <code>buf<\/code>\n     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that <code>buf<\/code>\n     * is not owned by anyone else, as this call transfers ownership of <code>buf<\/code> to the\n     * <code>queuedBuffer<\/code>.\n     *\n     * This method should only be called from the event loop thread.\n     * @param buf the buffer to append to the queue.\n     */\n    private void appendToQueuedBuffer(ByteBuf buf) {\n        checkIsInEventLoop(\"appendToQueuedBuffer\");\n        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {\n            // queuedBuffer has reached its component limit, so combine the existing components.\n            queuedBuffer.consolidate();\n        }\n        queuedBuffer.addComponent(true, buf);\n        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());\n    }\n\n    /**\n     * Process incoming message. This should only be called from the event\n     * loop thread.\n     * Note that this method does not call <code>buf.release()<\/code>. The caller\n     * is responsible for making sure the buf is released after this method\n     * returns.\n     * @param buf the message bytes to process.\n     */\n    void processMessage(ByteBuf buf) {\n        checkIsInEventLoop(\"processMessage\");\n        LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n        }\n\n        if (throttled.get()) {\n            LOG.debug(\"Received message while throttled\");\n            // we are throttled, so we need to queue\n            if (queuedBuffer == null) {\n                LOG.debug(\"allocating queue\");\n                queuedBuffer = channel.alloc().compositeBuffer();\n            }\n            appendToQueuedBuffer(buf.retainedDuplicate());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n        } else {\n            LOG.debug(\"not throttled\");\n            if (queuedBuffer != null) {\n                appendToQueuedBuffer(buf.retainedDuplicate());\n                processQueuedBuffer();\n            } else {\n                receiveMessage(buf);\n                // Have to check !closingChannel, because an error in\n                // receiveMessage() could have led to close() being called.\n                if (!closingChannel && buf.isReadable()) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Before copy {}\", buf);\n                    }\n\n                    if (queuedBuffer == null) {\n                        queuedBuffer = channel.alloc().compositeBuffer();\n                    }\n                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Copy is {}\", queuedBuffer);\n                        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to process previously queued message. This should only be called\n     * from the event loop thread.\n     */\n    void processQueuedBuffer() {\n        checkIsInEventLoop(\"processQueuedBuffer\");\n        if (queuedBuffer != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n            receiveMessage(queuedBuffer);\n            if (closingChannel) {\n                // close() could have been called if receiveMessage() failed\n                LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n            } else if (!queuedBuffer.isReadable()) {\n                LOG.debug(\"Processed queue - no bytes remaining\");\n                releaseQueuedBuffer();\n            } else {\n                LOG.debug(\"Processed queue - bytes remaining\");\n                // Try to reduce memory consumption by freeing up buffer space\n                // which is no longer needed.\n                queuedBuffer.discardReadComponents();\n            }\n        } else {\n            LOG.debug(\"queue empty\");\n        }\n    }\n\n    /**\n     * Clean up queued buffer once it's no longer needed. This should only be\n     * called from the event loop thread.\n     */\n    private void releaseQueuedBuffer() {\n        checkIsInEventLoop(\"releaseQueuedBuffer\");\n        if (queuedBuffer != null) {\n            queuedBuffer.release();\n            queuedBuffer = null;\n        }\n    }\n\n    /**\n     * Receive a message, which can come from the queued buffer or from a new\n     * buffer coming in over the channel. This should only be called from the\n     * event loop thread.\n     * Note that this method does not call <code>message.release()<\/code>. The\n     * caller is responsible for making sure the message is released after this\n     * method returns.\n     * @param message the message bytes to process.\n     */\n    private void receiveMessage(ByteBuf message) {\n        checkIsInEventLoop(\"receiveMessage\");\n        try {\n            while (message.isReadable() && !throttled.get()) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes 0x{} bb {}\",\n                                  Long.toHexString(sessionId),\n                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        bb.flip();\n                        packetReceived(4 + bb.remaining());\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],\n                            // we could implement zero-copy queueing.\n                            zks.processPacket(this, bb);\n                        } else {\n                            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n                            BinaryInputArchive bia = BinaryInputArchive.getArchive(new ByteBufferInputStream(bb));\n                            ConnectRequest request = protocolManager.deserializeConnectRequest(bia);\n                            zks.processConnectRequest(this, request);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            LOG.info(\"Closing connection to {} because the server is not ready\",\n                                    getRemoteSocketAddress());\n                            close(DisconnectReason.IO_EXCEPTION);\n                            return;\n                        }\n                        // checkRequestSize will throw IOException if request is rejected\n                        zks.checkRequestSizeWhenReceivingMessage(len);\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n\n            LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.CLIENT_RATE_LIMIT);\n        }\n    }\n\n    /**\n     * An event that triggers a change in the channel's read setting.\n     * Used for throttling. By using an enum we can treat the two values as\n     * singletons and compare with ==.\n     */\n    enum ReadEvent {\n        DISABLE,\n        ENABLE\n    }\n\n    /**\n     * Note that the netty implementation ignores the <code>waitDisableRecv<\/code>\n     * parameter and is always asynchronous.\n     * @param waitDisableRecv ignored by this implementation.\n     */\n    @Override\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            LOG.debug(\"Throttling - disabling recv {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n        }\n    }\n\n    @Override\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            LOG.debug(\"Sending unthrottle event {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n        }\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    @Override\n    public int getInterestOps() {\n        // This might not be 100% right, but it's only used for printing\n        // connection info in the netty implementation so it's probably ok.\n        if (channel == null || !channel.isOpen()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (!throttled.get()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (!channel.isWritable()) {\n            // OP_READ means \"can read\", but OP_WRITE means \"cannot write\",\n            // it's weird.\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress) channel.remoteAddress();\n    }\n\n    /** Send close connection packet to the client.\n     */\n    @Override\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return factory.secure;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        if (clientChain == null) {\n            return null;\n        }\n        return Arrays.copyOf(clientChain, clientChain.length);\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        if (chain == null) {\n            clientChain = null;\n        } else {\n            clientChain = Arrays.copyOf(chain, chain.length);\n        }\n    }\n\n    // For tests and NettyServerCnxnFactory only, thus package-private.\n    Channel getChannel() {\n        return channel;\n    }\n\n    public int getQueuedReadableBytes() {\n        checkIsInEventLoop(\"getQueuedReadableBytes\");\n        if (queuedBuffer != null) {\n            return queuedBuffer.readableBytes();\n        }\n        return 0;\n    }\n\n    public void setHandshakeState(HandshakeState state) {\n        this.handshakeState = state;\n    }\n\n    public HandshakeState getHandshakeState() {\n        return this.handshakeState;\n    }\n}\n","lineNo":487}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.util;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport org.apache.zookeeper.server.ExitCode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utilities for service management.\n */\npublic abstract class ServiceUtils {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ServiceUtils.class);\n\n    private ServiceUtils() {\n    }\n\n    /**\n     * Default strategy for shutting down the JVM.\n     */\n    @SuppressFBWarnings(\"DM_EXIT\")\n    public static final Consumer<Integer> SYSTEM_EXIT = (code) -> {\n        LOG.error(\"Exiting JVM with code {}\", code);\n        System.exit(code);\n    };\n\n    /**\n     * No-op strategy, useful for tests.\n     */\n    public static final Consumer<Integer> LOG_ONLY = (code) -> {\n        LOG.error(\"Fatal error, JVM should exit with code {}. \"\n                + \"Actually System.exit is disabled\", code);\n    };\n\n    private static volatile Consumer<Integer> systemExitProcedure = SYSTEM_EXIT;\n\n    /**\n     * Override system callback. Useful for preventing the JVM to exit in tests\n     * or in applications that are running an in-process ZooKeeper server.\n     *\n     * @param systemExitProcedure\n     */\n    public static void setSystemExitProcedure(Consumer<Integer> systemExitProcedure) {\n        Objects.requireNonNull(systemExitProcedure);\n        ServiceUtils.systemExitProcedure = systemExitProcedure;\n    }\n\n    /**\n     * Force shutdown of the JVM using System.exit.\n     *\n     * @param code the exit code\n     * @see ExitCode\n     */\n    public static void requestSystemExit(int code) {\n        systemExitProcedure.accept(code);\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.util;\n\nimport edu.umd.cs.findbugs.annotations.SuppressFBWarnings;\nimport java.util.Objects;\nimport java.util.function.Consumer;\nimport org.apache.zookeeper.server.ExitCode;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * Utilities for service management.\n */\npublic abstract class ServiceUtils {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ServiceUtils.class);\n\n    private ServiceUtils() {\n    }\n\n    /**\n     * Default strategy for shutting down the JVM.\n     */\n    @SuppressFBWarnings(\"DM_EXIT\")\n    public static final Consumer<Integer> SYSTEM_EXIT = (code) -> {\n        String msg = \"Exiting JVM with code {}\";\n        if (code == 0) {\n            // JVM exits normally\n            LOG.info(msg, code);\n        } else {\n            // JVM exits with error\n            LOG.error(msg, code);\n        }\n        System.exit(code);\n    };\n\n    /**\n     * No-op strategy, useful for tests.\n     */\n    public static final Consumer<Integer> LOG_ONLY = (code) -> {\n        if (code != 0) {\n            LOG.error(\"Fatal error, JVM should exit with code {}. \"\n                + \"Actually System.exit is disabled\", code);\n        } else {\n            LOG.info(\"JVM should exit with code {}. Actually System.exit is disabled\", code);\n        }\n    };\n\n    private static volatile Consumer<Integer> systemExitProcedure = SYSTEM_EXIT;\n\n    /**\n     * Override system callback. Useful for preventing the JVM to exit in tests\n     * or in applications that are running an in-process ZooKeeper server.\n     *\n     * @param systemExitProcedure\n     */\n    public static void setSystemExitProcedure(Consumer<Integer> systemExitProcedure) {\n        Objects.requireNonNull(systemExitProcedure);\n        ServiceUtils.systemExitProcedure = systemExitProcedure;\n    }\n\n    /**\n     * Force shutdown of the JVM using System.exit.\n     *\n     * @param code the exit code\n     * @see ExitCode\n     */\n    public static void requestSystemExit(int code) {\n        systemExitProcedure.accept(code);\n    }\n\n}\n","lineNo":42}
{"Smelly Sample":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.inspector.manager;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.inspector.logger.LoggerFactory;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.TimeUnit;\n\npublic class NodesCache {\n\n    public static final int CACHE_SIZE = 40000;\n\n    public static final int EXPIRATION_TIME = 100;\n\n    private final LoadingCache<String, List<String>> nodes;\n\n    private ZooKeeper zooKeeper;\n\n    public NodesCache(ZooKeeper zooKeeper) {\n        this.zooKeeper = zooKeeper;\n        this.nodes = CacheBuilder.newBuilder()\n                .maximumSize(CACHE_SIZE)\n                .expireAfterWrite(EXPIRATION_TIME, TimeUnit.MILLISECONDS)\n                .build(\n                        new CacheLoader<String, List<String>>() {\n                            @Override\n                            public List<String> load(String nodePath) throws Exception {\n                                return getChildren(nodePath);\n                            }\n                        }\n                );\n    }\n\n    public List<String> getChildren(String nodePath) {\n        try {\n            Stat s = zooKeeper.exists(nodePath, false);\n            if (s != null) {\n                List<String> children = this.zooKeeper.getChildren(nodePath, false);\n                Collections.sort(children);\n                return children;\n            }\n        } catch (Exception e) {\n            LoggerFactory.getLogger().error(\n                    \"Error occurred retrieving child of node: \" + nodePath, e\n            );\n        }\n        return null;\n    }\n\n    public String getNodeChild(String nodePath, int index) {\n        List<String> childNodes = null;\n        try {\n            childNodes = nodes.get(nodePath);\n            return childNodes.get(index);\n        } catch (ExecutionException e) {\n            LoggerFactory.getLogger().error(\n                    \"Error occurred retrieving child \" + index + \"of node: \" + nodePath, e\n            );\n        }\n        return null;\n    }\n\n}\n","Method after Refactoring":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.inspector.manager;\n\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.CacheLoader;\nimport com.google.common.cache.LoadingCache;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.inspector.logger.LoggerFactory;\n\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * A local cache of ZNodes in front of the Zookeeper server(s) to help cut down on network calls.  This class will\n * return results from the cache first, if available, and then fetch results remotely from Zookeeper if not.\n */\npublic class NodesCache {\n\n    public static final int CACHE_SIZE = 40000;\n\n    public static final int ENTRY_EXPIRATION_TIME_MILLIS = 10000;\n\n    private final LoadingCache<String, List<String>> nodes;\n\n    private ZooKeeper zooKeeper;\n\n    public NodesCache(ZooKeeper zooKeeper) {\n        this.zooKeeper = zooKeeper;\n        this.nodes = CacheBuilder.newBuilder()\n                .maximumSize(CACHE_SIZE)\n                .expireAfterWrite(ENTRY_EXPIRATION_TIME_MILLIS, TimeUnit.MILLISECONDS)\n                .build(new CacheLoader<String, List<String>>() {\n                           @Override\n                           public List<String> load(String nodePath) {\n                               return getChildrenRemote(nodePath);\n                           }\n                       }\n                );\n    }\n\n    /**\n     * Whereas getChildren hits the cache first, getChildrenRemote goes straight (over the network) to Zookeeper to\n     * get the answer.  This is the function used by the cache to insert entries that are requested, but don't exist\n     * in the cache yet.\n     *\n     * @param nodePath The full path to the parent whose children are to be fetched.\n     * @return The list of children of the given node as a list of full ZNode path strings or null if an\n     * error occurred.\n     */\n    private List<String> getChildrenRemote(String nodePath) {\n        try {\n            Stat s = zooKeeper.exists(nodePath, false);\n            if (s != null) {\n                List<String> children = this.zooKeeper.getChildren(nodePath, false);\n                Collections.sort(children);\n                return children;\n            }\n        } catch (Exception e) {\n            LoggerFactory.getLogger().error(\n                    \"Error occurred retrieving children of node: \" + nodePath, e\n            );\n        }\n        return null;\n    }\n\n    /**\n     * Fetch the children of the given node from the cache.\n     *\n     * @param nodePath The full path to the parent whose children are to be fetched.\n     * @return The list of children of the given node as a list of full ZNode path strings or null if an\n     * error occurred.\n     */\n    public List<String> getChildren(String nodePath) {\n        try {\n            return nodes.get(nodePath);\n        } catch (Exception e) {\n            LoggerFactory.getLogger().error(\"Error occurred retrieving children of node: \" + nodePath, e);\n        }\n        return null;\n    }\n}\n","lineNo":72}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport java.io.IOException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport javax.management.JMException;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.zookeeper.audit.ZKAuditProvider;\nimport org.apache.zookeeper.jmx.ManagedUtil;\nimport org.apache.zookeeper.metrics.MetricsProvider;\nimport org.apache.zookeeper.metrics.MetricsProviderLifeCycleException;\nimport org.apache.zookeeper.metrics.impl.MetricsProviderBootstrap;\nimport org.apache.zookeeper.server.admin.AdminServer;\nimport org.apache.zookeeper.server.admin.AdminServer.AdminServerException;\nimport org.apache.zookeeper.server.admin.AdminServerFactory;\nimport org.apache.zookeeper.server.auth.ProviderRegistry;\nimport org.apache.zookeeper.server.persistence.FileTxnSnapLog;\nimport org.apache.zookeeper.server.persistence.FileTxnSnapLog.DatadirException;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;\nimport org.apache.zookeeper.server.util.JvmPauseMonitor;\nimport org.apache.zookeeper.util.ServiceUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class starts and runs a standalone ZooKeeperServer.\n */\n@InterfaceAudience.Public\npublic class ZooKeeperServerMain {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperServerMain.class);\n\n    private static final String USAGE = \"Usage: ZooKeeperServerMain configfile | port datadir [ticktime] [maxcnxns]\";\n\n    // ZooKeeper server supports two kinds of connection: unencrypted and encrypted.\n    private ServerCnxnFactory cnxnFactory;\n    private ServerCnxnFactory secureCnxnFactory;\n    private ContainerManager containerManager;\n    private MetricsProvider metricsProvider;\n    private AdminServer adminServer;\n\n    /*\n     * Start up the ZooKeeper server.\n     *\n     * @param args the configfile or the port datadir [ticktime]\n     */\n    public static void main(String[] args) {\n        ZooKeeperServerMain main = new ZooKeeperServerMain();\n        try {\n            main.initializeAndRun(args);\n        } catch (IllegalArgumentException e) {\n            LOG.error(\"Invalid arguments, exiting abnormally\", e);\n            LOG.info(USAGE);\n            System.err.println(USAGE);\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n        } catch (ConfigException e) {\n            LOG.error(\"Invalid config, exiting abnormally\", e);\n            System.err.println(\"Invalid config, exiting abnormally\");\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n        } catch (DatadirException e) {\n            LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n            System.err.println(\"Unable to access datadir, exiting abnormally\");\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n        } catch (AdminServerException e) {\n            LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n            System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n        } catch (Exception e) {\n            LOG.error(\"Unexpected exception, exiting abnormally\", e);\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n        }\n        LOG.info(\"Exiting normally\");\n        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n    }\n\n    protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException {\n        try {\n            ManagedUtil.registerLog4jMBeans();\n        } catch (JMException e) {\n            LOG.warn(\"Unable to register log4j JMX control\", e);\n        }\n\n        ServerConfig config = new ServerConfig();\n        if (args.length == 1) {\n            config.parse(args[0]);\n        } else {\n            config.parse(args);\n        }\n\n        runFromConfig(config);\n    }\n\n    /**\n     * Run from a ServerConfig.\n     * @param config ServerConfig to use.\n     * @throws IOException\n     * @throws AdminServerException\n     */\n    public void runFromConfig(ServerConfig config) throws IOException, AdminServerException {\n        LOG.info(\"Starting server\");\n        FileTxnSnapLog txnLog = null;\n        try {\n            try {\n                metricsProvider = MetricsProviderBootstrap.startMetricsProvider(\n                    config.getMetricsProviderClassName(),\n                    config.getMetricsProviderConfiguration());\n            } catch (MetricsProviderLifeCycleException error) {\n                throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n            }\n            ServerMetrics.metricsProviderInitialized(metricsProvider);\n            ProviderRegistry.initialize();\n            // Note that this thread isn't going to be doing anything else,\n            // so rather than spawning another thread, we will just call\n            // run() in this thread.\n            // create a file logger url from the command line args\n            txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);\n            JvmPauseMonitor jvmPauseMonitor = null;\n            if (config.jvmPauseMonitorToRun) {\n                jvmPauseMonitor = new JvmPauseMonitor(config);\n            }\n            final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);\n            txnLog.setServerStats(zkServer.serverStats());\n\n            // Registers shutdown handler which will be used to know the\n            // server error or shutdown state changes.\n            final CountDownLatch shutdownLatch = new CountDownLatch(1);\n            zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));\n\n            // Start Admin server\n            adminServer = AdminServerFactory.createAdminServer();\n            adminServer.setZooKeeperServer(zkServer);\n            adminServer.start();\n\n            boolean needStartZKServer = true;\n            if (config.getClientPortAddress() != null) {\n                cnxnFactory = ServerCnxnFactory.createFactory();\n                cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n                cnxnFactory.startup(zkServer);\n                // zkServer has been started. So we don't need to start it again in secureCnxnFactory.\n                needStartZKServer = false;\n            }\n            if (config.getSecureClientPortAddress() != null) {\n                secureCnxnFactory = ServerCnxnFactory.createFactory();\n                secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n                secureCnxnFactory.startup(zkServer, needStartZKServer);\n            }\n\n            containerManager = new ContainerManager(\n                zkServer.getZKDatabase(),\n                zkServer.firstProcessor,\n                Integer.getInteger(\"znode.container.checkIntervalMs\", (int) TimeUnit.MINUTES.toMillis(1)),\n                Integer.getInteger(\"znode.container.maxPerMinute\", 10000),\n                Long.getLong(\"znode.container.maxNeverUsedIntervalMs\", 0)\n            );\n            containerManager.start();\n            ZKAuditProvider.addZKStartStopAuditLog();\n\n            // Watch status of ZooKeeper server. It will do a graceful shutdown\n            // if the server is not running or hits an internal error.\n            shutdownLatch.await();\n\n            shutdown();\n\n            if (cnxnFactory != null) {\n                cnxnFactory.join();\n            }\n            if (secureCnxnFactory != null) {\n                secureCnxnFactory.join();\n            }\n            if (zkServer.canShutdown()) {\n                zkServer.shutdown(true);\n            }\n        } catch (InterruptedException e) {\n            // warn, but generally this is ok\n            LOG.warn(\"Server interrupted\", e);\n        } finally {\n            if (txnLog != null) {\n                txnLog.close();\n            }\n            if (metricsProvider != null) {\n                try {\n                    metricsProvider.stop();\n                } catch (Throwable error) {\n                    LOG.warn(\"Error while stopping metrics\", error);\n                }\n            }\n        }\n    }\n\n    /**\n     * Shutdown the serving instance\n     */\n    protected void shutdown() {\n        if (containerManager != null) {\n            containerManager.stop();\n        }\n        if (cnxnFactory != null) {\n            cnxnFactory.shutdown();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.shutdown();\n        }\n        try {\n            if (adminServer != null) {\n                adminServer.shutdown();\n            }\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem stopping AdminServer\", e);\n        }\n    }\n\n    // VisibleForTesting\n    ServerCnxnFactory getCnxnFactory() {\n        return cnxnFactory;\n    }\n\n    // VisibleForTesting\n    ServerCnxnFactory getSecureCnxnFactory() {\n        return secureCnxnFactory;\n    }\n\n    /**\n     * Shutdowns properly the service, this method is not a public API.\n     */\n    public void close() {\n        ServerCnxnFactory primaryCnxnFactory = this.cnxnFactory;\n        if (primaryCnxnFactory == null) {\n            // in case of pure TLS we can hook into secureCnxnFactory\n            primaryCnxnFactory = secureCnxnFactory;\n        }\n        if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {\n            return;\n        }\n        ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();\n        zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);\n        try {\n            // ServerCnxnFactory will call the shutdown\n            primaryCnxnFactory.join();\n        } catch (InterruptedException ex) {\n            Thread.currentThread().interrupt();\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport java.io.IOException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport javax.management.JMException;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.zookeeper.audit.ZKAuditProvider;\nimport org.apache.zookeeper.jmx.ManagedUtil;\nimport org.apache.zookeeper.metrics.MetricsProvider;\nimport org.apache.zookeeper.metrics.MetricsProviderLifeCycleException;\nimport org.apache.zookeeper.metrics.impl.MetricsProviderBootstrap;\nimport org.apache.zookeeper.server.admin.AdminServer;\nimport org.apache.zookeeper.server.admin.AdminServer.AdminServerException;\nimport org.apache.zookeeper.server.admin.AdminServerFactory;\nimport org.apache.zookeeper.server.auth.ProviderRegistry;\nimport org.apache.zookeeper.server.persistence.FileTxnSnapLog;\nimport org.apache.zookeeper.server.persistence.FileTxnSnapLog.DatadirException;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;\nimport org.apache.zookeeper.server.util.JvmPauseMonitor;\nimport org.apache.zookeeper.util.ServiceUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class starts and runs a standalone ZooKeeperServer.\n */\n@InterfaceAudience.Public\npublic class ZooKeeperServerMain {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperServerMain.class);\n\n    private static final String USAGE = \"Usage: ZooKeeperServerMain configfile | port datadir [ticktime] [maxcnxns]\";\n\n    // ZooKeeper server supports two kinds of connection: unencrypted and encrypted.\n    private ServerCnxnFactory cnxnFactory;\n    private ServerCnxnFactory secureCnxnFactory;\n    private ContainerManager containerManager;\n    private MetricsProvider metricsProvider;\n    private AdminServer adminServer;\n\n    /*\n     * Start up the ZooKeeper server.\n     *\n     * @param args the configfile or the port datadir [ticktime]\n     */\n    public static void main(String[] args) {\n        ZooKeeperServerMain main = new ZooKeeperServerMain();\n        try {\n            main.initializeAndRun(args);\n        } catch (IllegalArgumentException e) {\n            LOG.error(\"Invalid arguments, exiting abnormally\", e);\n            LOG.info(USAGE);\n            System.err.println(USAGE);\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n        } catch (ConfigException e) {\n            LOG.error(\"Invalid config, exiting abnormally\", e);\n            System.err.println(\"Invalid config, exiting abnormally\");\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n        } catch (DatadirException e) {\n            LOG.error(\"Unable to access datadir, exiting abnormally\", e);\n            System.err.println(\"Unable to access datadir, exiting abnormally\");\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.UNABLE_TO_ACCESS_DATADIR.getValue());\n        } catch (AdminServerException e) {\n            LOG.error(\"Unable to start AdminServer, exiting abnormally\", e);\n            System.err.println(\"Unable to start AdminServer, exiting abnormally\");\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.ERROR_STARTING_ADMIN_SERVER.getValue());\n        } catch (Exception e) {\n            LOG.error(\"Unexpected exception, exiting abnormally\", e);\n            ZKAuditProvider.addServerStartFailureAuditLog();\n            ServiceUtils.requestSystemExit(ExitCode.UNEXPECTED_ERROR.getValue());\n        }\n        LOG.info(\"Exiting normally\");\n        ServiceUtils.requestSystemExit(ExitCode.EXECUTION_FINISHED.getValue());\n    }\n\n    protected void initializeAndRun(String[] args) throws ConfigException, IOException, AdminServerException {\n        try {\n            ManagedUtil.registerLog4jMBeans();\n        } catch (JMException e) {\n            LOG.warn(\"Unable to register log4j JMX control\", e);\n        }\n\n        ServerConfig config = new ServerConfig();\n        if (args.length == 1) {\n            config.parse(args[0]);\n        } else {\n            config.parse(args);\n        }\n\n        runFromConfig(config);\n    }\n\n    /**\n     * Run from a ServerConfig.\n     * @param config ServerConfig to use.\n     * @throws IOException\n     * @throws AdminServerException\n     */\n    public void runFromConfig(ServerConfig config) throws IOException, AdminServerException {\n        LOG.info(\"Starting server\");\n        FileTxnSnapLog txnLog = null;\n        try {\n            try {\n                metricsProvider = MetricsProviderBootstrap.startMetricsProvider(\n                    config.getMetricsProviderClassName(),\n                    config.getMetricsProviderConfiguration());\n            } catch (MetricsProviderLifeCycleException error) {\n                throw new IOException(\"Cannot boot MetricsProvider \" + config.getMetricsProviderClassName(), error);\n            }\n            ServerMetrics.metricsProviderInitialized(metricsProvider);\n            ProviderRegistry.initialize();\n            // Note that this thread isn't going to be doing anything else,\n            // so rather than spawning another thread, we will just call\n            // run() in this thread.\n            // create a file logger url from the command line args\n            txnLog = new FileTxnSnapLog(config.dataLogDir, config.dataDir);\n            JvmPauseMonitor jvmPauseMonitor = null;\n            if (config.jvmPauseMonitorToRun) {\n                jvmPauseMonitor = new JvmPauseMonitor(config);\n            }\n            final ZooKeeperServer zkServer = new ZooKeeperServer(jvmPauseMonitor, txnLog, config.tickTime, config.minSessionTimeout, config.maxSessionTimeout, config.listenBacklog, null, config.initialConfig);\n            txnLog.setServerStats(zkServer.serverStats());\n\n            // Registers shutdown handler which will be used to know the\n            // server error or shutdown state changes.\n            final CountDownLatch shutdownLatch = new CountDownLatch(1);\n            zkServer.registerServerShutdownHandler(new ZooKeeperServerShutdownHandler(shutdownLatch));\n\n            // Start Admin server\n            adminServer = AdminServerFactory.createAdminServer();\n            adminServer.setZooKeeperServer(zkServer);\n            adminServer.start();\n\n            boolean needStartZKServer = true;\n            if (config.getClientPortAddress() != null) {\n                cnxnFactory = ServerCnxnFactory.createFactory();\n                cnxnFactory.configure(config.getClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), false);\n                cnxnFactory.startup(zkServer);\n                // zkServer has been started. So we don't need to start it again in secureCnxnFactory.\n                needStartZKServer = false;\n            }\n            if (config.getSecureClientPortAddress() != null) {\n                secureCnxnFactory = ServerCnxnFactory.createFactory();\n                secureCnxnFactory.configure(config.getSecureClientPortAddress(), config.getMaxClientCnxns(), config.getClientPortListenBacklog(), true);\n                secureCnxnFactory.startup(zkServer, needStartZKServer);\n            }\n\n            containerManager = new ContainerManager(\n                zkServer.getZKDatabase(),\n                zkServer.firstProcessor,\n                Integer.getInteger(\"znode.container.checkIntervalMs\", (int) TimeUnit.MINUTES.toMillis(1)),\n                Integer.getInteger(\"znode.container.maxPerMinute\", 10000),\n                Long.getLong(\"znode.container.maxNeverUsedIntervalMs\", 0)\n            );\n            containerManager.start();\n            ZKAuditProvider.addZKStartStopAuditLog();\n\n            serverStarted();\n\n            // Watch status of ZooKeeper server. It will do a graceful shutdown\n            // if the server is not running or hits an internal error.\n            shutdownLatch.await();\n\n            shutdown();\n\n            if (cnxnFactory != null) {\n                cnxnFactory.join();\n            }\n            if (secureCnxnFactory != null) {\n                secureCnxnFactory.join();\n            }\n            if (zkServer.canShutdown()) {\n                zkServer.shutdown(true);\n            }\n        } catch (InterruptedException e) {\n            // warn, but generally this is ok\n            LOG.warn(\"Server interrupted\", e);\n        } finally {\n            if (txnLog != null) {\n                txnLog.close();\n            }\n            if (metricsProvider != null) {\n                try {\n                    metricsProvider.stop();\n                } catch (Throwable error) {\n                    LOG.warn(\"Error while stopping metrics\", error);\n                }\n            }\n        }\n    }\n\n    /**\n     * Shutdown the serving instance\n     */\n    protected void shutdown() {\n        if (containerManager != null) {\n            containerManager.stop();\n        }\n        if (cnxnFactory != null) {\n            cnxnFactory.shutdown();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.shutdown();\n        }\n        try {\n            if (adminServer != null) {\n                adminServer.shutdown();\n            }\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem stopping AdminServer\", e);\n        }\n    }\n\n    // VisibleForTesting\n    ServerCnxnFactory getCnxnFactory() {\n        return cnxnFactory;\n    }\n\n    // VisibleForTesting\n    ServerCnxnFactory getSecureCnxnFactory() {\n        return secureCnxnFactory;\n    }\n\n    /**\n     * Shutdowns properly the service, this method is not a public API.\n     */\n    public void close() {\n        ServerCnxnFactory primaryCnxnFactory = this.cnxnFactory;\n        ServerCnxnFactory secondaryCnxnFactory = this.secureCnxnFactory;\n        try {\n            if (primaryCnxnFactory == null) {\n                // in case of pure TLS we can hook into secureCnxnFactory\n                primaryCnxnFactory = secondaryCnxnFactory;\n            }\n            if (primaryCnxnFactory == null || primaryCnxnFactory.getZooKeeperServer() == null) {\n                LOG.info(\"Connection factory did not start\");\n                return;\n            }\n            ZooKeeperServerShutdownHandler zkShutdownHandler = primaryCnxnFactory.getZooKeeperServer().getZkShutdownHandler();\n            zkShutdownHandler.handle(ZooKeeperServer.State.SHUTDOWN);\n            try {\n                // ServerCnxnFactory will call the shutdown\n                primaryCnxnFactory.join();\n            } catch (InterruptedException ex) {\n                Thread.currentThread().interrupt();\n            }\n        } finally {\n            // ensure that we are closing the sockets\n            if (primaryCnxnFactory != null) {\n                primaryCnxnFactory.shutdown();\n            }\n            if (secondaryCnxnFactory != null) {\n                secondaryCnxnFactory.shutdown();\n            }\n        }\n    }\n\n    protected void serverStarted() {\n    }\n}\n","lineNo":252}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);\n    private final Channel channel;\n    private CompositeByteBuf queuedBuffer;\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n    private ByteBuffer bb;\n    private final ByteBuffer bbLen = ByteBuffer.allocate(4);\n    private long sessionId;\n    private int sessionTimeout;\n    private Certificate[] clientChain;\n    private volatile boolean closingChannel;\n\n    private final NettyServerCnxnFactory factory;\n    private boolean initialized;\n\n    public int readIssuedAfterReadComplete;\n\n    private volatile HandshakeState handshakeState = HandshakeState.NONE;\n\n    public enum HandshakeState {\n        NONE,\n        STARTED,\n        FINISHED\n    }\n\n    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {\n        super(zks);\n        this.channel = channel;\n        this.closingChannel = false;\n        this.factory = factory;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    public void close() {\n        closingChannel = true;\n\n        LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n\n        setStale();\n\n        // ZOOKEEPER-2743:\n        // Always unregister connection upon close to prevent\n        // connection bean leak under certain race conditions.\n        factory.unregisterConnection(this);\n\n        // if this is not in cnxns then it's already closed\n        if (!factory.cnxns.remove(this)) {\n            LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n            if (channel.isOpen()) {\n                channel.close();\n            }\n            return;\n        }\n\n        LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n\n        factory.removeCnxnFromSessionMap(this);\n\n        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (channel.isOpen()) {\n            // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n            // that all writes have been completed before closing the channel or we risk data loss\n            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    future.channel().close().addListener(f -> releaseQueuedBuffer());\n                }\n            });\n        } else {\n            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n            channel.eventLoop().execute(this::releaseQueuedBuffer);\n        }\n    }\n\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        try {\n            int responseSize = sendResponse(h, e, \"notification\");\n            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n        } catch (IOException e1) {\n            LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n            close();\n        }\n    }\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag,\n                             String cacheKey, Stat stat, int opCode) throws IOException {\n        // cacheKey and stat are used in caching, which is not\n        // implemented here. Implementation example can be found in NIOServerCnxn.\n        if (closingChannel || !channel.isOpen()) {\n            return 0;\n        }\n        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n        int responseSize = bb[0].getInt();\n        bb[0].rewind();\n        sendBuffer(bb);\n        decrOutstandingAndCheckThrottle(h);\n        return responseSize;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    // Use a single listener instance to reduce GC\n    private final GenericFutureListener<Future<Void>> onSendBufferDoneListener = f -> {\n        if (f.isSuccess()) {\n            packetSent();\n        }\n    };\n\n    @Override\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {\n            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            return;\n        }\n        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n\n        // Stops automatic reads of incoming data on this channel. We don't\n        // expect any more traffic from the client when processing a 4LW\n        // so this shouldn't break anything.\n        channel.config().setAutoRead(false);\n        packetReceived(4);\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(8);\n            message.readBytes(mask);\n            mask.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /**\n     * Helper that throws an IllegalStateException if the current thread is not\n     * executing in the channel's event loop thread.\n     * @param callerMethodName the name of the calling method to add to the exception message.\n     */\n    private void checkIsInEventLoop(String callerMethodName) {\n        if (!channel.eventLoop().inEventLoop()) {\n            throw new IllegalStateException(callerMethodName + \"() called from non-EventLoop thread\");\n        }\n    }\n\n    /**\n     * Appends <code>buf<\/code> to <code>queuedBuffer<\/code>. Does not duplicate <code>buf<\/code>\n     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that <code>buf<\/code>\n     * is not owned by anyone else, as this call transfers ownership of <code>buf<\/code> to the\n     * <code>queuedBuffer<\/code>.\n     *\n     * This method should only be called from the event loop thread.\n     * @param buf the buffer to append to the queue.\n     */\n    private void appendToQueuedBuffer(ByteBuf buf) {\n        checkIsInEventLoop(\"appendToQueuedBuffer\");\n        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {\n            // queuedBuffer has reached its component limit, so combine the existing components.\n            queuedBuffer.consolidate();\n        }\n        queuedBuffer.addComponent(true, buf);\n        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());\n    }\n\n    /**\n     * Process incoming message. This should only be called from the event\n     * loop thread.\n     * Note that this method does not call <code>buf.release()<\/code>. The caller\n     * is responsible for making sure the buf is released after this method\n     * returns.\n     * @param buf the message bytes to process.\n     */\n    void processMessage(ByteBuf buf) {\n        checkIsInEventLoop(\"processMessage\");\n        LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n        }\n\n        if (throttled.get()) {\n            LOG.debug(\"Received message while throttled\");\n            // we are throttled, so we need to queue\n            if (queuedBuffer == null) {\n                LOG.debug(\"allocating queue\");\n                queuedBuffer = channel.alloc().compositeBuffer();\n            }\n            appendToQueuedBuffer(buf.retainedDuplicate());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n        } else {\n            LOG.debug(\"not throttled\");\n            if (queuedBuffer != null) {\n                appendToQueuedBuffer(buf.retainedDuplicate());\n                processQueuedBuffer();\n            } else {\n                receiveMessage(buf);\n                // Have to check !closingChannel, because an error in\n                // receiveMessage() could have led to close() being called.\n                if (!closingChannel && buf.isReadable()) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Before copy {}\", buf);\n                    }\n\n                    if (queuedBuffer == null) {\n                        queuedBuffer = channel.alloc().compositeBuffer();\n                    }\n                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Copy is {}\", queuedBuffer);\n                        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to process previously queued message. This should only be called\n     * from the event loop thread.\n     */\n    void processQueuedBuffer() {\n        checkIsInEventLoop(\"processQueuedBuffer\");\n        if (queuedBuffer != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n            receiveMessage(queuedBuffer);\n            if (closingChannel) {\n                // close() could have been called if receiveMessage() failed\n                LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n            } else if (!queuedBuffer.isReadable()) {\n                LOG.debug(\"Processed queue - no bytes remaining\");\n                releaseQueuedBuffer();\n            } else {\n                LOG.debug(\"Processed queue - bytes remaining\");\n                // Try to reduce memory consumption by freeing up buffer space\n                // which is no longer needed.\n                queuedBuffer.discardReadComponents();\n            }\n        } else {\n            LOG.debug(\"queue empty\");\n        }\n    }\n\n    /**\n     * Clean up queued buffer once it's no longer needed. This should only be\n     * called from the event loop thread.\n     */\n    private void releaseQueuedBuffer() {\n        checkIsInEventLoop(\"releaseQueuedBuffer\");\n        if (queuedBuffer != null) {\n            queuedBuffer.release();\n            queuedBuffer = null;\n        }\n    }\n\n    /**\n     * Receive a message, which can come from the queued buffer or from a new\n     * buffer coming in over the channel. This should only be called from the\n     * event loop thread.\n     * Note that this method does not call <code>message.release()<\/code>. The\n     * caller is responsible for making sure the message is released after this\n     * method returns.\n     * @param message the message bytes to process.\n     */\n    private void receiveMessage(ByteBuf message) {\n        checkIsInEventLoop(\"receiveMessage\");\n        try {\n            while (message.isReadable() && !throttled.get()) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes 0x{} bb {}\",\n                                  Long.toHexString(sessionId),\n                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        bb.flip();\n                        packetReceived(4 + bb.remaining());\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],\n                            // we could implement zero-copy queueing.\n                            zks.processPacket(this, bb);\n                        } else {\n                            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n                            zks.processConnectRequest(this, bb);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        // checkRequestSize will throw IOException if request is rejected\n                        zkServer.checkRequestSizeWhenReceivingMessage(len);\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n\n            LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.CLIENT_RATE_LIMIT);\n        }\n    }\n\n    /**\n     * An event that triggers a change in the channel's read setting.\n     * Used for throttling. By using an enum we can treat the two values as\n     * singletons and compare with ==.\n     */\n    enum ReadEvent {\n        DISABLE,\n        ENABLE\n    }\n\n    /**\n     * Note that the netty implementation ignores the <code>waitDisableRecv<\/code>\n     * parameter and is always asynchronous.\n     * @param waitDisableRecv ignored by this implementation.\n     */\n    @Override\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            LOG.debug(\"Throttling - disabling recv {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n        }\n    }\n\n    @Override\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            LOG.debug(\"Sending unthrottle event {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n        }\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    @Override\n    public int getInterestOps() {\n        // This might not be 100% right, but it's only used for printing\n        // connection info in the netty implementation so it's probably ok.\n        if (channel == null || !channel.isOpen()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (!throttled.get()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (!channel.isWritable()) {\n            // OP_READ means \"can read\", but OP_WRITE means \"cannot write\",\n            // it's weird.\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress) channel.remoteAddress();\n    }\n\n    /** Send close connection packet to the client.\n     */\n    @Override\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return factory.secure;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        if (clientChain == null) {\n            return null;\n        }\n        return Arrays.copyOf(clientChain, clientChain.length);\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        if (chain == null) {\n            clientChain = null;\n        } else {\n            clientChain = Arrays.copyOf(chain, chain.length);\n        }\n    }\n\n    // For tests and NettyServerCnxnFactory only, thus package-private.\n    Channel getChannel() {\n        return channel;\n    }\n\n    public int getQueuedReadableBytes() {\n        checkIsInEventLoop(\"getQueuedReadableBytes\");\n        if (queuedBuffer != null) {\n            return queuedBuffer.readableBytes();\n        }\n        return 0;\n    }\n\n    public void setHandshakeState(HandshakeState state) {\n        this.handshakeState = state;\n    }\n\n    public HandshakeState getHandshakeState() {\n        return this.handshakeState;\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufUtil;\nimport io.netty.buffer.CompositeByteBuf;\nimport io.netty.buffer.Unpooled;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelFutureListener;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.SelectionKey;\nimport java.security.cert.Certificate;\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport org.apache.jute.BinaryInputArchive;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.ClientCnxn;\nimport org.apache.zookeeper.WatchedEvent;\nimport org.apache.zookeeper.data.Id;\nimport org.apache.zookeeper.data.Stat;\nimport org.apache.zookeeper.proto.ReplyHeader;\nimport org.apache.zookeeper.proto.WatcherEvent;\nimport org.apache.zookeeper.server.command.CommandExecutor;\nimport org.apache.zookeeper.server.command.FourLetterCommands;\nimport org.apache.zookeeper.server.command.NopCommand;\nimport org.apache.zookeeper.server.command.SetTraceMaskCommand;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxn extends ServerCnxn {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxn.class);\n    private final Channel channel;\n    private CompositeByteBuf queuedBuffer;\n    private final AtomicBoolean throttled = new AtomicBoolean(false);\n    private ByteBuffer bb;\n    private final ByteBuffer bbLen = ByteBuffer.allocate(4);\n    private long sessionId;\n    private int sessionTimeout;\n    private Certificate[] clientChain;\n    private volatile boolean closingChannel;\n\n    private final NettyServerCnxnFactory factory;\n    private boolean initialized;\n\n    public int readIssuedAfterReadComplete;\n\n    private volatile HandshakeState handshakeState = HandshakeState.NONE;\n\n    public enum HandshakeState {\n        NONE,\n        STARTED,\n        FINISHED\n    }\n\n    NettyServerCnxn(Channel channel, ZooKeeperServer zks, NettyServerCnxnFactory factory) {\n        super(zks);\n        this.channel = channel;\n        this.closingChannel = false;\n        this.factory = factory;\n        if (this.factory.login != null) {\n            this.zooKeeperSaslServer = new ZooKeeperSaslServer(factory.login);\n        }\n        InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n        addAuthInfo(new Id(\"ip\", addr.getHostAddress()));\n    }\n\n    /**\n     * Close the cnxn and remove it from the factory cnxns list.\n     */\n    @Override\n    public void close(DisconnectReason reason) {\n        disconnectReason = reason;\n        close();\n    }\n\n    public void close() {\n        closingChannel = true;\n\n        LOG.debug(\"close called for session id: 0x{}\", Long.toHexString(sessionId));\n\n        setStale();\n\n        // ZOOKEEPER-2743:\n        // Always unregister connection upon close to prevent\n        // connection bean leak under certain race conditions.\n        factory.unregisterConnection(this);\n\n        // if this is not in cnxns then it's already closed\n        if (!factory.cnxns.remove(this)) {\n            LOG.debug(\"cnxns size:{}\", factory.cnxns.size());\n            if (channel.isOpen()) {\n                channel.close();\n            }\n            return;\n        }\n\n        LOG.debug(\"close in progress for session id: 0x{}\", Long.toHexString(sessionId));\n\n        factory.removeCnxnFromSessionMap(this);\n\n        factory.removeCnxnFromIpMap(this, ((InetSocketAddress) channel.remoteAddress()).getAddress());\n\n        if (zkServer != null) {\n            zkServer.removeCnxn(this);\n        }\n\n        if (channel.isOpen()) {\n            // Since we don't check on the futures created by write calls to the channel complete we need to make sure\n            // that all writes have been completed before closing the channel or we risk data loss\n            // See: http://lists.jboss.org/pipermail/netty-users/2009-August/001122.html\n            channel.writeAndFlush(Unpooled.EMPTY_BUFFER).addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) {\n                    future.channel().close().addListener(f -> releaseQueuedBuffer());\n                }\n            });\n        } else {\n            ServerMetrics.getMetrics().CONNECTION_DROP_COUNT.add(1);\n            channel.eventLoop().execute(this::releaseQueuedBuffer);\n        }\n    }\n\n    @Override\n    public long getSessionId() {\n        return sessionId;\n    }\n\n    @Override\n    public int getSessionTimeout() {\n        return sessionTimeout;\n    }\n\n    @Override\n    public void process(WatchedEvent event) {\n        ReplyHeader h = new ReplyHeader(ClientCnxn.NOTIFICATION_XID, -1L, 0);\n        if (LOG.isTraceEnabled()) {\n            ZooTrace.logTraceMessage(\n                LOG,\n                ZooTrace.EVENT_DELIVERY_TRACE_MASK,\n                \"Deliver event \" + event + \" to 0x\" + Long.toHexString(this.sessionId) + \" through \" + this);\n        }\n\n        // Convert WatchedEvent to a type that can be sent over the wire\n        WatcherEvent e = event.getWrapper();\n\n        try {\n            int responseSize = sendResponse(h, e, \"notification\");\n            ServerMetrics.getMetrics().WATCH_BYTES.add(responseSize);\n        } catch (IOException e1) {\n            LOG.debug(\"Problem sending to {}\", getRemoteSocketAddress(), e1);\n            close();\n        }\n    }\n\n    @Override\n    public int sendResponse(ReplyHeader h, Record r, String tag,\n                             String cacheKey, Stat stat, int opCode) throws IOException {\n        // cacheKey and stat are used in caching, which is not\n        // implemented here. Implementation example can be found in NIOServerCnxn.\n        if (closingChannel || !channel.isOpen()) {\n            return 0;\n        }\n        ByteBuffer[] bb = serialize(h, r, tag, cacheKey, stat, opCode);\n        int responseSize = bb[0].getInt();\n        bb[0].rewind();\n        sendBuffer(bb);\n        decrOutstandingAndCheckThrottle(h);\n        return responseSize;\n    }\n\n    @Override\n    public void setSessionId(long sessionId) {\n        this.sessionId = sessionId;\n        factory.addSession(sessionId, this);\n    }\n\n    // Use a single listener instance to reduce GC\n    private final GenericFutureListener<Future<Void>> onSendBufferDoneListener = f -> {\n        if (f.isSuccess()) {\n            packetSent();\n        }\n    };\n\n    @Override\n    public void sendBuffer(ByteBuffer... buffers) {\n        if (buffers.length == 1 && buffers[0] == ServerCnxnFactory.closeConn) {\n            close(DisconnectReason.CLIENT_CLOSED_CONNECTION);\n            return;\n        }\n        channel.writeAndFlush(Unpooled.wrappedBuffer(buffers)).addListener(onSendBufferDoneListener);\n    }\n\n    /**\n     * This class wraps the sendBuffer method of NIOServerCnxn. It is\n     * responsible for chunking up the response to a client. Rather\n     * than cons'ing up a response fully in memory, which may be large\n     * for some commands, this class chunks up the result.\n     */\n    private class SendBufferWriter extends Writer {\n\n        private StringBuffer sb = new StringBuffer();\n\n        /**\n         * Check if we are ready to send another chunk.\n         * @param force force sending, even if not a full chunk\n         */\n        private void checkFlush(boolean force) {\n            if ((force && sb.length() > 0) || sb.length() > 2048) {\n                sendBuffer(ByteBuffer.wrap(sb.toString().getBytes(UTF_8)));\n                // clear our internal buffer\n                sb.setLength(0);\n            }\n        }\n\n        @Override\n        public void close() throws IOException {\n            if (sb == null) {\n                return;\n            }\n            checkFlush(true);\n            sb = null; // clear out the ref to ensure no reuse\n        }\n\n        @Override\n        public void flush() throws IOException {\n            checkFlush(true);\n        }\n\n        @Override\n        public void write(char[] cbuf, int off, int len) throws IOException {\n            sb.append(cbuf, off, len);\n            checkFlush(false);\n        }\n\n    }\n\n    /** Return if four letter word found and responded to, otw false **/\n    private boolean checkFourLetterWord(final Channel channel, ByteBuf message, final int len) {\n        // We take advantage of the limited size of the length to look\n        // for cmds. They are all 4-bytes which fits inside of an int\n        if (!FourLetterCommands.isKnown(len)) {\n            return false;\n        }\n\n        String cmd = FourLetterCommands.getCommandString(len);\n\n        // Stops automatic reads of incoming data on this channel. We don't\n        // expect any more traffic from the client when processing a 4LW\n        // so this shouldn't break anything.\n        channel.config().setAutoRead(false);\n        packetReceived(4);\n\n        final PrintWriter pwriter = new PrintWriter(new BufferedWriter(new SendBufferWriter()));\n\n        // ZOOKEEPER-2693: don't execute 4lw if it's not enabled.\n        if (!FourLetterCommands.isEnabled(cmd)) {\n            LOG.debug(\"Command {} is not executed because it is not in the whitelist.\", cmd);\n            NopCommand nopCmd = new NopCommand(\n                pwriter,\n                this,\n                cmd + \" is not executed because it is not in the whitelist.\");\n            nopCmd.start();\n            return true;\n        }\n\n        LOG.info(\"Processing {} command from {}\", cmd, channel.remoteAddress());\n\n        if (len == FourLetterCommands.setTraceMaskCmd) {\n            ByteBuffer mask = ByteBuffer.allocate(8);\n            message.readBytes(mask);\n            mask.flip();\n            long traceMask = mask.getLong();\n            ZooTrace.setTextTraceLevel(traceMask);\n            SetTraceMaskCommand setMask = new SetTraceMaskCommand(pwriter, this, traceMask);\n            setMask.start();\n            return true;\n        } else {\n            CommandExecutor commandExecutor = new CommandExecutor();\n            return commandExecutor.execute(this, pwriter, len, zkServer, factory);\n        }\n    }\n\n    /**\n     * Helper that throws an IllegalStateException if the current thread is not\n     * executing in the channel's event loop thread.\n     * @param callerMethodName the name of the calling method to add to the exception message.\n     */\n    private void checkIsInEventLoop(String callerMethodName) {\n        if (!channel.eventLoop().inEventLoop()) {\n            throw new IllegalStateException(callerMethodName + \"() called from non-EventLoop thread\");\n        }\n    }\n\n    /**\n     * Appends <code>buf<\/code> to <code>queuedBuffer<\/code>. Does not duplicate <code>buf<\/code>\n     * or call any flavor of {@link ByteBuf#retain()}. Caller must ensure that <code>buf<\/code>\n     * is not owned by anyone else, as this call transfers ownership of <code>buf<\/code> to the\n     * <code>queuedBuffer<\/code>.\n     *\n     * This method should only be called from the event loop thread.\n     * @param buf the buffer to append to the queue.\n     */\n    private void appendToQueuedBuffer(ByteBuf buf) {\n        checkIsInEventLoop(\"appendToQueuedBuffer\");\n        if (queuedBuffer.numComponents() == queuedBuffer.maxNumComponents()) {\n            // queuedBuffer has reached its component limit, so combine the existing components.\n            queuedBuffer.consolidate();\n        }\n        queuedBuffer.addComponent(true, buf);\n        ServerMetrics.getMetrics().NETTY_QUEUED_BUFFER.add(queuedBuffer.capacity());\n    }\n\n    /**\n     * Process incoming message. This should only be called from the event\n     * loop thread.\n     * Note that this method does not call <code>buf.release()<\/code>. The caller\n     * is responsible for making sure the buf is released after this method\n     * returns.\n     * @param buf the message bytes to process.\n     */\n    void processMessage(ByteBuf buf) {\n        checkIsInEventLoop(\"processMessage\");\n        LOG.debug(\"0x{} queuedBuffer: {}\", Long.toHexString(sessionId), queuedBuffer);\n\n        if (LOG.isTraceEnabled()) {\n            LOG.trace(\"0x{} buf {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf));\n        }\n\n        if (throttled.get()) {\n            LOG.debug(\"Received message while throttled\");\n            // we are throttled, so we need to queue\n            if (queuedBuffer == null) {\n                LOG.debug(\"allocating queue\");\n                queuedBuffer = channel.alloc().compositeBuffer();\n            }\n            appendToQueuedBuffer(buf.retainedDuplicate());\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n        } else {\n            LOG.debug(\"not throttled\");\n            if (queuedBuffer != null) {\n                appendToQueuedBuffer(buf.retainedDuplicate());\n                processQueuedBuffer();\n            } else {\n                receiveMessage(buf);\n                // Have to check !closingChannel, because an error in\n                // receiveMessage() could have led to close() being called.\n                if (!closingChannel && buf.isReadable()) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Before copy {}\", buf);\n                    }\n\n                    if (queuedBuffer == null) {\n                        queuedBuffer = channel.alloc().compositeBuffer();\n                    }\n                    appendToQueuedBuffer(buf.retainedSlice(buf.readerIndex(), buf.readableBytes()));\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"Copy is {}\", queuedBuffer);\n                        LOG.trace(\"0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Try to process previously queued message. This should only be called\n     * from the event loop thread.\n     */\n    void processQueuedBuffer() {\n        checkIsInEventLoop(\"processQueuedBuffer\");\n        if (queuedBuffer != null) {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"processing queue 0x{} queuedBuffer {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(queuedBuffer));\n            }\n            receiveMessage(queuedBuffer);\n            if (closingChannel) {\n                // close() could have been called if receiveMessage() failed\n                LOG.debug(\"Processed queue - channel closed, dropping remaining bytes\");\n            } else if (!queuedBuffer.isReadable()) {\n                LOG.debug(\"Processed queue - no bytes remaining\");\n                releaseQueuedBuffer();\n            } else {\n                LOG.debug(\"Processed queue - bytes remaining\");\n                // Try to reduce memory consumption by freeing up buffer space\n                // which is no longer needed.\n                queuedBuffer.discardReadComponents();\n            }\n        } else {\n            LOG.debug(\"queue empty\");\n        }\n    }\n\n    /**\n     * Clean up queued buffer once it's no longer needed. This should only be\n     * called from the event loop thread.\n     */\n    private void releaseQueuedBuffer() {\n        checkIsInEventLoop(\"releaseQueuedBuffer\");\n        if (queuedBuffer != null) {\n            queuedBuffer.release();\n            queuedBuffer = null;\n        }\n    }\n\n    /**\n     * Receive a message, which can come from the queued buffer or from a new\n     * buffer coming in over the channel. This should only be called from the\n     * event loop thread.\n     * Note that this method does not call <code>message.release()<\/code>. The\n     * caller is responsible for making sure the message is released after this\n     * method returns.\n     * @param message the message bytes to process.\n     */\n    private void receiveMessage(ByteBuf message) {\n        checkIsInEventLoop(\"receiveMessage\");\n        try {\n            while (message.isReadable() && !throttled.get()) {\n                if (bb != null) {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bb {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (bb.remaining() > message.readableBytes()) {\n                        int newLimit = bb.position() + message.readableBytes();\n                        bb.limit(newLimit);\n                    }\n                    message.readBytes(bb);\n                    bb.limit(bb.capacity());\n\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"after readBytes message readable {} bb len {} {}\", message.readableBytes(), bb.remaining(), bb);\n                        ByteBuffer dat = bb.duplicate();\n                        dat.flip();\n                        LOG.trace(\"after readbytes 0x{} bb {}\",\n                                  Long.toHexString(sessionId),\n                                  ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n                    if (bb.remaining() == 0) {\n                        bb.flip();\n                        packetReceived(4 + bb.remaining());\n\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        if (initialized) {\n                            // TODO: if zks.processPacket() is changed to take a ByteBuffer[],\n                            // we could implement zero-copy queueing.\n                            zks.processPacket(this, bb);\n                        } else {\n                            LOG.debug(\"got conn req request from {}\", getRemoteSocketAddress());\n                            zks.processConnectRequest(this, bb);\n                            initialized = true;\n                        }\n                        bb = null;\n                    }\n                } else {\n                    if (LOG.isTraceEnabled()) {\n                        LOG.trace(\"message readable {} bblenrem {}\", message.readableBytes(), bbLen.remaining());\n                        ByteBuffer dat = bbLen.duplicate();\n                        dat.flip();\n                        LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(dat)));\n                    }\n\n                    if (message.readableBytes() < bbLen.remaining()) {\n                        bbLen.limit(bbLen.position() + message.readableBytes());\n                    }\n                    message.readBytes(bbLen);\n                    bbLen.limit(bbLen.capacity());\n                    if (bbLen.remaining() == 0) {\n                        bbLen.flip();\n\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen {}\", Long.toHexString(sessionId), ByteBufUtil.hexDump(Unpooled.wrappedBuffer(bbLen)));\n                        }\n                        int len = bbLen.getInt();\n                        if (LOG.isTraceEnabled()) {\n                            LOG.trace(\"0x{} bbLen len is {}\", Long.toHexString(sessionId), len);\n                        }\n\n                        bbLen.clear();\n                        if (!initialized) {\n                            if (checkFourLetterWord(channel, message, len)) {\n                                return;\n                            }\n                        }\n                        if (len < 0 || len > BinaryInputArchive.maxBuffer) {\n                            throw new IOException(\"Len error \" + len);\n                        }\n                        ZooKeeperServer zks = this.zkServer;\n                        if (zks == null || !zks.isRunning()) {\n                            throw new IOException(\"ZK down\");\n                        }\n                        // checkRequestSize will throw IOException if request is rejected\n                        zks.checkRequestSizeWhenReceivingMessage(len);\n                        bb = ByteBuffer.allocate(len);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            LOG.warn(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.IO_EXCEPTION);\n        } catch (ClientCnxnLimitException e) {\n            // Common case exception, print at debug level\n            ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n\n            LOG.debug(\"Closing connection to {}\", getRemoteSocketAddress(), e);\n            close(DisconnectReason.CLIENT_RATE_LIMIT);\n        }\n    }\n\n    /**\n     * An event that triggers a change in the channel's read setting.\n     * Used for throttling. By using an enum we can treat the two values as\n     * singletons and compare with ==.\n     */\n    enum ReadEvent {\n        DISABLE,\n        ENABLE\n    }\n\n    /**\n     * Note that the netty implementation ignores the <code>waitDisableRecv<\/code>\n     * parameter and is always asynchronous.\n     * @param waitDisableRecv ignored by this implementation.\n     */\n    @Override\n    public void disableRecv(boolean waitDisableRecv) {\n        if (throttled.compareAndSet(false, true)) {\n            LOG.debug(\"Throttling - disabling recv {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.DISABLE);\n        }\n    }\n\n    @Override\n    public void enableRecv() {\n        if (throttled.compareAndSet(true, false)) {\n            LOG.debug(\"Sending unthrottle event {}\", this);\n            channel.pipeline().fireUserEventTriggered(ReadEvent.ENABLE);\n        }\n    }\n\n    @Override\n    public void setSessionTimeout(int sessionTimeout) {\n        this.sessionTimeout = sessionTimeout;\n    }\n\n    @Override\n    public int getInterestOps() {\n        // This might not be 100% right, but it's only used for printing\n        // connection info in the netty implementation so it's probably ok.\n        if (channel == null || !channel.isOpen()) {\n            return 0;\n        }\n        int interestOps = 0;\n        if (!throttled.get()) {\n            interestOps |= SelectionKey.OP_READ;\n        }\n        if (!channel.isWritable()) {\n            // OP_READ means \"can read\", but OP_WRITE means \"cannot write\",\n            // it's weird.\n            interestOps |= SelectionKey.OP_WRITE;\n        }\n        return interestOps;\n    }\n\n    @Override\n    public InetSocketAddress getRemoteSocketAddress() {\n        return (InetSocketAddress) channel.remoteAddress();\n    }\n\n    /** Send close connection packet to the client.\n     */\n    @Override\n    public void sendCloseSession() {\n        sendBuffer(ServerCnxnFactory.closeConn);\n    }\n\n    @Override\n    protected ServerStats serverStats() {\n        if (zkServer == null) {\n            return null;\n        }\n        return zkServer.serverStats();\n    }\n\n    @Override\n    public boolean isSecure() {\n        return factory.secure;\n    }\n\n    @Override\n    public Certificate[] getClientCertificateChain() {\n        if (clientChain == null) {\n            return null;\n        }\n        return Arrays.copyOf(clientChain, clientChain.length);\n    }\n\n    @Override\n    public void setClientCertificateChain(Certificate[] chain) {\n        if (chain == null) {\n            clientChain = null;\n        } else {\n            clientChain = Arrays.copyOf(chain, chain.length);\n        }\n    }\n\n    // For tests and NettyServerCnxnFactory only, thus package-private.\n    Channel getChannel() {\n        return channel;\n    }\n\n    public int getQueuedReadableBytes() {\n        checkIsInEventLoop(\"getQueuedReadableBytes\");\n        if (queuedBuffer != null) {\n            return queuedBuffer.readableBytes();\n        }\n        return 0;\n    }\n\n    public void setHandshakeState(HandshakeState state) {\n        this.handshakeState = state;\n    }\n\n    public HandshakeState getHandshakeState() {\n        return this.handshakeState;\n    }\n}\n","lineNo":523}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.zookeeper.admin.ZooKeeperAdmin;\nimport org.apache.zookeeper.cli.CliCommand;\nimport org.apache.zookeeper.cli.CliException;\nimport org.apache.zookeeper.cli.CommandFactory;\nimport org.apache.zookeeper.cli.CommandNotFoundException;\nimport org.apache.zookeeper.cli.MalformedCommandException;\nimport org.apache.zookeeper.client.ZKClientConfig;\nimport org.apache.zookeeper.server.ExitCode;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig;\nimport org.apache.zookeeper.util.ServiceUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The command line client to ZooKeeper.\n *\n */\n@InterfaceAudience.Public\npublic class ZooKeeperMain {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperMain.class);\n    static final Map<String, String> commandMap = new HashMap<String, String>();\n    static final Map<String, CliCommand> commandMapCli = new HashMap<String, CliCommand>();\n\n    protected MyCommandOptions cl = new MyCommandOptions();\n    protected HashMap<Integer, String> history = new HashMap<Integer, String>();\n    protected int commandCount = 0;\n    protected boolean printWatches = true;\n    protected int exitCode = ExitCode.EXECUTION_FINISHED.getValue();\n\n    protected ZooKeeper zk;\n    protected String host = \"\";\n\n    public boolean getPrintWatches() {\n        return printWatches;\n    }\n\n    static {\n        commandMap.put(\"connect\", \"host:port\");\n        commandMap.put(\"history\", \"\");\n        commandMap.put(\"redo\", \"cmdno\");\n        commandMap.put(\"printwatches\", \"on|off\");\n        commandMap.put(\"quit\", \"\");\n        Stream.of(CommandFactory.Command.values())\n            .map(command -> CommandFactory.getInstance(command))\n            // add all commands to commandMapCli and commandMap\n            .forEach(cliCommand ->{\n                cliCommand.addToMap(commandMapCli);\n                commandMap.put(\n                        cliCommand.getCmdStr(),\n                        cliCommand.getOptionStr());\n            });\n    }\n\n    static void usage() {\n        System.err.println(\"ZooKeeper -server host:port -client-configuration properties-file cmd args\");\n        List<String> cmdList = new ArrayList<String>(commandMap.keySet());\n        Collections.sort(cmdList);\n        for (String cmd : cmdList) {\n            System.err.println(\"\\t\" + cmd + \" \" + commandMap.get(cmd));\n        }\n    }\n\n    private class MyWatcher implements Watcher {\n\n        public void process(WatchedEvent event) {\n            if (getPrintWatches()) {\n                ZooKeeperMain.printMessage(\"WATCHER::\");\n                ZooKeeperMain.printMessage(event.toString());\n            }\n        }\n\n    }\n\n    /**\n     * A storage class for both command line options and shell commands.\n     *\n     */\n    static class MyCommandOptions {\n\n        private Map<String, String> options = new HashMap<String, String>();\n        private List<String> cmdArgs = null;\n        private String command = null;\n        public static final Pattern ARGS_PATTERN = Pattern.compile(\"\\\\s*([^\\\"\\']\\\\S*|\\\"[^\\\"]*\\\"|'[^']*')\\\\s*\");\n        public static final Pattern QUOTED_PATTERN = Pattern.compile(\"^([\\'\\\"])(.*)(\\\\1)$\");\n\n        public MyCommandOptions() {\n            options.put(\"server\", \"localhost:2181\");\n            options.put(\"timeout\", \"30000\");\n        }\n\n        public String getOption(String opt) {\n            return options.get(opt);\n        }\n\n        public String getCommand() {\n            return command;\n        }\n\n        public String getCmdArgument(int index) {\n            return cmdArgs.get(index);\n        }\n\n        public int getNumArguments() {\n            return cmdArgs.size();\n        }\n\n        public String[] getArgArray() {\n            return cmdArgs.toArray(new String[0]);\n        }\n\n        /**\n         * Parses a command line that may contain one or more flags\n         * before an optional command string\n         * @param args command line arguments\n         * @return true if parsing succeeded, false otherwise.\n         */\n        public boolean parseOptions(String[] args) {\n            List<String> argList = Arrays.asList(args);\n            Iterator<String> it = argList.iterator();\n\n            while (it.hasNext()) {\n                String opt = it.next();\n                try {\n                    if (opt.equals(\"-server\")) {\n                        options.put(\"server\", it.next());\n                    } else if (opt.equals(\"-timeout\")) {\n                        options.put(\"timeout\", it.next());\n                    } else if (opt.equals(\"-r\")) {\n                        options.put(\"readonly\", \"true\");\n                    } else if (opt.equals(\"-client-configuration\")) {\n                        options.put(\"client-configuration\", it.next());\n                    }\n                } catch (NoSuchElementException e) {\n                    System.err.println(\"Error: no argument found for option \" + opt);\n                    return false;\n                }\n\n                if (!opt.startsWith(\"-\")) {\n                    command = opt;\n                    cmdArgs = new ArrayList<String>();\n                    cmdArgs.add(command);\n                    while (it.hasNext()) {\n                        cmdArgs.add(it.next());\n                    }\n                    return true;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Breaks a string into command + arguments.\n         * @param cmdstring string of form \"cmd arg1 arg2..etc\"\n         * @return true if parsing succeeded.\n         */\n        public boolean parseCommand(String cmdstring) {\n            Matcher matcher = ARGS_PATTERN.matcher(cmdstring);\n\n            List<String> args = new LinkedList<String>();\n            while (matcher.find()) {\n                String value = matcher.group(1);\n                if (QUOTED_PATTERN.matcher(value).matches()) {\n                    // Strip off the surrounding quotes\n                    value = value.substring(1, value.length() - 1);\n                }\n                args.add(value);\n            }\n            if (args.isEmpty()) {\n                return false;\n            }\n            command = args.get(0);\n            cmdArgs = args;\n            return true;\n        }\n\n    }\n\n    /**\n     * Makes a list of possible completions, either for commands\n     * or for zk nodes if the token to complete begins with /\n     *\n     */\n\n    protected void addToHistory(int i, String cmd) {\n        history.put(i, cmd);\n    }\n\n    public static List<String> getCommands() {\n        List<String> cmdList = new ArrayList<String>(commandMap.keySet());\n        Collections.sort(cmdList);\n        return cmdList;\n    }\n\n    protected String getPrompt() {\n        return \"[zk: \" + host + \"(\" + zk.getState() + \")\" + \" \" + commandCount + \"] \";\n    }\n\n    public static void printMessage(String msg) {\n        System.out.println(\"\\n\" + msg);\n    }\n\n    protected void connectToZK(String newHost) throws InterruptedException, IOException {\n        if (zk != null && zk.getState().isAlive()) {\n            zk.close();\n        }\n\n        host = newHost;\n        boolean readOnly = cl.getOption(\"readonly\") != null;\n        if (cl.getOption(\"secure\") != null) {\n            System.setProperty(ZKClientConfig.SECURE_CLIENT, \"true\");\n            System.out.println(\"Secure connection is enabled\");\n        }\n\n        ZKClientConfig clientConfig = null;\n\n        if (cl.getOption(\"client-configuration\") != null) {\n            try {\n                clientConfig = new ZKClientConfig(cl.getOption(\"client-configuration\"));\n            } catch (QuorumPeerConfig.ConfigException e) {\n                e.printStackTrace();\n                ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n            }\n        }\n\n        zk = new ZooKeeperAdmin(host, Integer.parseInt(cl.getOption(\"timeout\")), new MyWatcher(), readOnly, clientConfig);\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        ZooKeeperMain main = new ZooKeeperMain(args);\n        main.run();\n    }\n\n    public ZooKeeperMain(String[] args) throws IOException, InterruptedException {\n        cl.parseOptions(args);\n        System.out.println(\"Connecting to \" + cl.getOption(\"server\"));\n        connectToZK(cl.getOption(\"server\"));\n    }\n\n    public ZooKeeperMain(ZooKeeper zk) {\n        this.zk = zk;\n    }\n\n    void run() throws IOException, InterruptedException {\n        if (cl.getCommand() == null) {\n            System.out.println(\"Welcome to ZooKeeper!\");\n\n            boolean jlinemissing = false;\n            // only use jline if it's in the classpath\n            try {\n                Class<?> consoleC = Class.forName(\"jline.console.ConsoleReader\");\n                Class<?> completorC = Class.forName(\"org.apache.zookeeper.JLineZNodeCompleter\");\n\n                System.out.println(\"JLine support is enabled\");\n\n                Object console = consoleC.getConstructor().newInstance();\n\n                Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);\n                Method addCompletor = consoleC.getMethod(\"addCompleter\", Class.forName(\"jline.console.completer.Completer\"));\n                addCompletor.invoke(console, completor);\n\n                String line;\n                Method readLine = consoleC.getMethod(\"readLine\", String.class);\n                while ((line = (String) readLine.invoke(console, getPrompt())) != null) {\n                    executeLine(line);\n                }\n            } catch (ClassNotFoundException\n                | NoSuchMethodException\n                | InvocationTargetException\n                | IllegalAccessException\n                | InstantiationException e\n            ) {\n                LOG.debug(\"Unable to start jline\", e);\n                jlinemissing = true;\n            }\n\n            if (jlinemissing) {\n                System.out.println(\"JLine support is disabled\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n                String line;\n                while ((line = br.readLine()) != null) {\n                    executeLine(line);\n                }\n            }\n        } else {\n            // Command line args non-null.  Run what was passed.\n            processCmd(cl);\n        }\n        ServiceUtils.requestSystemExit(exitCode);\n    }\n\n    public void executeLine(String line) throws InterruptedException, IOException {\n        if (!line.equals(\"\")) {\n            cl.parseCommand(line);\n            addToHistory(commandCount, line);\n            processCmd(cl);\n            commandCount++;\n        }\n    }\n\n    protected boolean processCmd(MyCommandOptions co) throws IOException, InterruptedException {\n        boolean watch = false;\n        try {\n            watch = processZKCmd(co);\n            exitCode = ExitCode.EXECUTION_FINISHED.getValue();\n        } catch (CliException ex) {\n            exitCode = ex.getExitCode();\n            System.err.println(ex.getMessage());\n        }\n        return watch;\n    }\n\n    protected boolean processZKCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException {\n        String[] args = co.getArgArray();\n        String cmd = co.getCommand();\n        if (args.length < 1) {\n            usage();\n            throw new MalformedCommandException(\"No command entered\");\n        }\n\n        if (!commandMap.containsKey(cmd)) {\n            usage();\n            throw new CommandNotFoundException(\"Command not found \" + cmd);\n        }\n\n        boolean watch = false;\n\n        LOG.debug(\"Processing {}\", cmd);\n\n        if (cmd.equals(\"quit\")) {\n            zk.close();\n            ServiceUtils.requestSystemExit(exitCode);\n        } else if (cmd.equals(\"redo\") && args.length >= 2) {\n            Integer i = Integer.decode(args[1]);\n            if (commandCount <= i || i < 0) { // don't allow redoing this redo\n                throw new MalformedCommandException(\"Command index out of range\");\n            }\n            cl.parseCommand(history.get(i));\n            if (cl.getCommand().equals(\"redo\")) {\n                throw new MalformedCommandException(\"No redoing redos\");\n            }\n            history.put(commandCount, history.get(i));\n            processCmd(cl);\n        } else if (cmd.equals(\"history\")) {\n            for (int i = commandCount - 10; i <= commandCount; ++i) {\n                if (i < 0) {\n                    continue;\n                }\n                System.out.println(i + \" - \" + history.get(i));\n            }\n        } else if (cmd.equals(\"printwatches\")) {\n            if (args.length == 1) {\n                System.out.println(\"printwatches is \" + (printWatches ? \"on\" : \"off\"));\n            } else {\n                printWatches = args[1].equals(\"on\");\n            }\n        } else if (cmd.equals(\"connect\")) {\n            if (args.length >= 2) {\n                connectToZK(args[1]);\n            } else {\n                connectToZK(host);\n            }\n        }\n\n        // Below commands all need a live connection\n        if (zk == null || !zk.getState().isAlive()) {\n            System.out.println(\"Not connected\");\n            return false;\n        }\n\n        // execute from commandMap\n        CliCommand cliCmd = commandMapCli.get(cmd);\n        if (cliCmd != null) {\n            cliCmd.setZk(zk);\n            watch = cliCmd.parse(args).exec();\n        } else if (!commandMap.containsKey(cmd)) {\n            usage();\n        }\n        return watch;\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.NoSuchElementException;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.zookeeper.admin.ZooKeeperAdmin;\nimport org.apache.zookeeper.cli.CliCommand;\nimport org.apache.zookeeper.cli.CliException;\nimport org.apache.zookeeper.cli.CommandFactory;\nimport org.apache.zookeeper.cli.CommandNotFoundException;\nimport org.apache.zookeeper.cli.MalformedCommandException;\nimport org.apache.zookeeper.client.ZKClientConfig;\nimport org.apache.zookeeper.server.ExitCode;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig;\nimport org.apache.zookeeper.util.ServiceUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * The command line client to ZooKeeper.\n *\n */\n@InterfaceAudience.Public\npublic class ZooKeeperMain {\n\n    private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperMain.class);\n    static final Map<String, String> commandMap = new HashMap<String, String>();\n    static final Map<String, CliCommand> commandMapCli = new HashMap<String, CliCommand>();\n\n    protected MyCommandOptions cl = new MyCommandOptions();\n    protected HashMap<Integer, String> history = new HashMap<Integer, String>();\n    protected int commandCount = 0;\n    protected boolean printWatches = true;\n    protected int exitCode = ExitCode.EXECUTION_FINISHED.getValue();\n\n    protected ZooKeeper zk;\n    protected String host = \"\";\n    private CountDownLatch connectLatch = null;\n\n    public boolean getPrintWatches() {\n        return printWatches;\n    }\n\n    static {\n        commandMap.put(\"connect\", \"host:port\");\n        commandMap.put(\"history\", \"\");\n        commandMap.put(\"redo\", \"cmdno\");\n        commandMap.put(\"printwatches\", \"on|off\");\n        commandMap.put(\"quit\", \"\");\n        Stream.of(CommandFactory.Command.values())\n            .map(command -> CommandFactory.getInstance(command))\n            // add all commands to commandMapCli and commandMap\n            .forEach(cliCommand ->{\n                cliCommand.addToMap(commandMapCli);\n                commandMap.put(\n                        cliCommand.getCmdStr(),\n                        cliCommand.getOptionStr());\n            });\n    }\n\n    static void usage() {\n        System.err.println(\"ZooKeeper -server host:port -client-configuration properties-file cmd args\");\n        List<String> cmdList = new ArrayList<String>(commandMap.keySet());\n        Collections.sort(cmdList);\n        for (String cmd : cmdList) {\n            System.err.println(\"\\t\" + cmd + \" \" + commandMap.get(cmd));\n        }\n    }\n\n    private class MyWatcher implements Watcher {\n\n        public void process(WatchedEvent event) {\n            if (getPrintWatches()) {\n                ZooKeeperMain.printMessage(\"WATCHER::\");\n                ZooKeeperMain.printMessage(event.toString());\n            }\n            if (connectLatch != null) {\n                // connection success\n                if (event.getType() == Event.EventType.None\n                    && event.getState() == Event.KeeperState.SyncConnected) {\n                    connectLatch.countDown();\n                }\n            }\n        }\n\n    }\n\n    /**\n     * A storage class for both command line options and shell commands.\n     *\n     */\n    static class MyCommandOptions {\n\n        private Map<String, String> options = new HashMap<String, String>();\n        private List<String> cmdArgs = null;\n        private String command = null;\n        public static final Pattern ARGS_PATTERN = Pattern.compile(\"\\\\s*([^\\\"\\']\\\\S*|\\\"[^\\\"]*\\\"|'[^']*')\\\\s*\");\n        public static final Pattern QUOTED_PATTERN = Pattern.compile(\"^([\\'\\\"])(.*)(\\\\1)$\");\n\n        public MyCommandOptions() {\n            options.put(\"server\", \"localhost:2181\");\n            options.put(\"timeout\", \"30000\");\n        }\n\n        public String getOption(String opt) {\n            return options.get(opt);\n        }\n\n        public String getCommand() {\n            return command;\n        }\n\n        public String getCmdArgument(int index) {\n            return cmdArgs.get(index);\n        }\n\n        public int getNumArguments() {\n            return cmdArgs.size();\n        }\n\n        public String[] getArgArray() {\n            return cmdArgs.toArray(new String[0]);\n        }\n\n        /**\n         * Parses a command line that may contain one or more flags\n         * before an optional command string\n         * @param args command line arguments\n         * @return true if parsing succeeded, false otherwise.\n         */\n        public boolean parseOptions(String[] args) {\n            List<String> argList = Arrays.asList(args);\n            Iterator<String> it = argList.iterator();\n\n            while (it.hasNext()) {\n                String opt = it.next();\n                try {\n                    if (opt.equals(\"-server\")) {\n                        options.put(\"server\", it.next());\n                    } else if (opt.equals(\"-timeout\")) {\n                        options.put(\"timeout\", it.next());\n                    } else if (opt.equals(\"-r\")) {\n                        options.put(\"readonly\", \"true\");\n                    } else if (opt.equals(\"-client-configuration\")) {\n                        options.put(\"client-configuration\", it.next());\n                    } else if (opt.equals(\"-waitforconnection\")) {\n                        options.put(\"waitforconnection\", \"true\");\n                    }\n                } catch (NoSuchElementException e) {\n                    System.err.println(\"Error: no argument found for option \" + opt);\n                    return false;\n                }\n\n                if (!opt.startsWith(\"-\")) {\n                    command = opt;\n                    cmdArgs = new ArrayList<String>();\n                    cmdArgs.add(command);\n                    while (it.hasNext()) {\n                        cmdArgs.add(it.next());\n                    }\n                    return true;\n                }\n            }\n            return true;\n        }\n\n        /**\n         * Breaks a string into command + arguments.\n         * @param cmdstring string of form \"cmd arg1 arg2..etc\"\n         * @return true if parsing succeeded.\n         */\n        public boolean parseCommand(String cmdstring) {\n            Matcher matcher = ARGS_PATTERN.matcher(cmdstring);\n\n            List<String> args = new LinkedList<String>();\n            while (matcher.find()) {\n                String value = matcher.group(1);\n                if (QUOTED_PATTERN.matcher(value).matches()) {\n                    // Strip off the surrounding quotes\n                    value = value.substring(1, value.length() - 1);\n                }\n                args.add(value);\n            }\n            if (args.isEmpty()) {\n                return false;\n            }\n            command = args.get(0);\n            cmdArgs = args;\n            return true;\n        }\n\n    }\n\n    /**\n     * Makes a list of possible completions, either for commands\n     * or for zk nodes if the token to complete begins with /\n     *\n     */\n\n    protected void addToHistory(int i, String cmd) {\n        history.put(i, cmd);\n    }\n\n    public static List<String> getCommands() {\n        List<String> cmdList = new ArrayList<String>(commandMap.keySet());\n        Collections.sort(cmdList);\n        return cmdList;\n    }\n\n    protected String getPrompt() {\n        return \"[zk: \" + host + \"(\" + zk.getState() + \")\" + \" \" + commandCount + \"] \";\n    }\n\n    public static void printMessage(String msg) {\n        System.out.println(\"\\n\" + msg);\n    }\n\n    protected void connectToZK(String newHost) throws InterruptedException, IOException {\n        if (zk != null && zk.getState().isAlive()) {\n            zk.close();\n        }\n\n        host = newHost;\n        boolean readOnly = cl.getOption(\"readonly\") != null;\n        if (cl.getOption(\"secure\") != null) {\n            System.setProperty(ZKClientConfig.SECURE_CLIENT, \"true\");\n            System.out.println(\"Secure connection is enabled\");\n        }\n\n        ZKClientConfig clientConfig = null;\n\n        if (cl.getOption(\"client-configuration\") != null) {\n            try {\n                clientConfig = new ZKClientConfig(cl.getOption(\"client-configuration\"));\n            } catch (QuorumPeerConfig.ConfigException e) {\n                e.printStackTrace();\n                ServiceUtils.requestSystemExit(ExitCode.INVALID_INVOCATION.getValue());\n            }\n        }\n\n        if (cl.getOption(\"waitforconnection\") != null) {\n            connectLatch = new CountDownLatch(1);\n        }\n\n        int timeout = Integer.parseInt(cl.getOption(\"timeout\"));\n        zk = new ZooKeeperAdmin(host, timeout, new MyWatcher(), readOnly, clientConfig);\n        if (connectLatch != null) {\n            if (!connectLatch.await(timeout, TimeUnit.MILLISECONDS)) {\n                zk.close();\n                throw new IOException(KeeperException.create(KeeperException.Code.CONNECTIONLOSS));\n            }\n        }\n\n    }\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        ZooKeeperMain main = new ZooKeeperMain(args);\n        main.run();\n    }\n\n    public ZooKeeperMain(String[] args) throws IOException, InterruptedException {\n        cl.parseOptions(args);\n        System.out.println(\"Connecting to \" + cl.getOption(\"server\"));\n        connectToZK(cl.getOption(\"server\"));\n    }\n\n    public ZooKeeperMain(ZooKeeper zk) {\n        this.zk = zk;\n    }\n\n    void run() throws IOException, InterruptedException {\n        if (cl.getCommand() == null) {\n            System.out.println(\"Welcome to ZooKeeper!\");\n\n            boolean jlinemissing = false;\n            // only use jline if it's in the classpath\n            try {\n                Class<?> consoleC = Class.forName(\"jline.console.ConsoleReader\");\n                Class<?> completorC = Class.forName(\"org.apache.zookeeper.JLineZNodeCompleter\");\n\n                System.out.println(\"JLine support is enabled\");\n\n                Object console = consoleC.getConstructor().newInstance();\n\n                Object completor = completorC.getConstructor(ZooKeeper.class).newInstance(zk);\n                Method addCompletor = consoleC.getMethod(\"addCompleter\", Class.forName(\"jline.console.completer.Completer\"));\n                addCompletor.invoke(console, completor);\n\n                String line;\n                Method readLine = consoleC.getMethod(\"readLine\", String.class);\n                while ((line = (String) readLine.invoke(console, getPrompt())) != null) {\n                    executeLine(line);\n                }\n            } catch (ClassNotFoundException\n                | NoSuchMethodException\n                | InvocationTargetException\n                | IllegalAccessException\n                | InstantiationException e\n            ) {\n                LOG.debug(\"Unable to start jline\", e);\n                jlinemissing = true;\n            }\n\n            if (jlinemissing) {\n                System.out.println(\"JLine support is disabled\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n                String line;\n                while ((line = br.readLine()) != null) {\n                    executeLine(line);\n                }\n            }\n        } else {\n            // Command line args non-null.  Run what was passed.\n            processCmd(cl);\n        }\n        ServiceUtils.requestSystemExit(exitCode);\n    }\n\n    public void executeLine(String line) throws InterruptedException, IOException {\n        if (!line.equals(\"\")) {\n            cl.parseCommand(line);\n            addToHistory(commandCount, line);\n            processCmd(cl);\n            commandCount++;\n        }\n    }\n\n    protected boolean processCmd(MyCommandOptions co) throws IOException, InterruptedException {\n        boolean watch = false;\n        try {\n            watch = processZKCmd(co);\n            exitCode = ExitCode.EXECUTION_FINISHED.getValue();\n        } catch (CliException ex) {\n            exitCode = ex.getExitCode();\n            System.err.println(ex.getMessage());\n        }\n        return watch;\n    }\n\n    protected boolean processZKCmd(MyCommandOptions co) throws CliException, IOException, InterruptedException {\n        String[] args = co.getArgArray();\n        String cmd = co.getCommand();\n        if (args.length < 1) {\n            usage();\n            throw new MalformedCommandException(\"No command entered\");\n        }\n\n        if (!commandMap.containsKey(cmd)) {\n            usage();\n            throw new CommandNotFoundException(\"Command not found \" + cmd);\n        }\n\n        boolean watch = false;\n\n        LOG.debug(\"Processing {}\", cmd);\n\n        if (cmd.equals(\"quit\")) {\n            zk.close();\n            ServiceUtils.requestSystemExit(exitCode);\n        } else if (cmd.equals(\"redo\") && args.length >= 2) {\n            Integer i = Integer.decode(args[1]);\n            if (commandCount <= i || i < 0) { // don't allow redoing this redo\n                throw new MalformedCommandException(\"Command index out of range\");\n            }\n            cl.parseCommand(history.get(i));\n            if (cl.getCommand().equals(\"redo\")) {\n                throw new MalformedCommandException(\"No redoing redos\");\n            }\n            history.put(commandCount, history.get(i));\n            processCmd(cl);\n        } else if (cmd.equals(\"history\")) {\n            for (int i = commandCount - 10; i <= commandCount; ++i) {\n                if (i < 0) {\n                    continue;\n                }\n                System.out.println(i + \" - \" + history.get(i));\n            }\n        } else if (cmd.equals(\"printwatches\")) {\n            if (args.length == 1) {\n                System.out.println(\"printwatches is \" + (printWatches ? \"on\" : \"off\"));\n            } else {\n                printWatches = args[1].equals(\"on\");\n            }\n        } else if (cmd.equals(\"connect\")) {\n            if (args.length >= 2) {\n                connectToZK(args[1]);\n            } else {\n                connectToZK(host);\n            }\n        }\n\n        // Below commands all need a live connection\n        if (zk == null || !zk.getState().isAlive()) {\n            System.out.println(\"Not connected\");\n            return false;\n        }\n\n        // execute from commandMap\n        CliCommand cliCmd = commandMapCli.get(cmd);\n        if (cliCmd != null) {\n            cliCmd.setZk(zk);\n            watch = cliCmd.parse(args).exec();\n        } else if (!commandMap.containsKey(cmd)) {\n            usage();\n        }\n        return watch;\n    }\n\n}\n","lineNo":280}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.cli;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionGroup;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.Quotas;\nimport org.apache.zookeeper.StatsTrack;\nimport org.apache.zookeeper.ZKUtil;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.data.Stat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * setQuota command for cli\n */\npublic class SetQuotaCommand extends CliCommand {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SetQuotaCommand.class);\n    private Options options = new Options();\n    private String[] args;\n    private CommandLine cl;\n\n    public SetQuotaCommand() {\n        super(\"setquota\", \"-n|-b val path\");\n\n        OptionGroup og1 = new OptionGroup();\n        og1.addOption(new Option(\"b\", true, \"bytes quota\"));\n        og1.addOption(new Option(\"n\", true, \"num quota\"));\n        og1.setRequired(true);\n        options.addOptionGroup(og1);\n    }\n\n    @Override\n    public CliCommand parse(String[] cmdArgs) throws CliParseException {\n        DefaultParser parser = new DefaultParser();\n        try {\n            cl = parser.parse(options, cmdArgs);\n        } catch (ParseException ex) {\n            throw new CliParseException(ex);\n        }\n        args = cl.getArgs();\n        if (args.length < 2) {\n            throw new CliParseException(getUsageStr());\n        }\n\n        return this;\n    }\n\n    @Override\n    public boolean exec() throws CliException {\n        // get the args\n        String path = args[1];\n        if (path.startsWith(Quotas.quotaZookeeper)) {\n            err.println(\"cannot set a quota under the path: \" + Quotas.quotaZookeeper);\n            return false;\n        }\n\n        if (cl.hasOption(\"b\")) {\n            // we are setting the bytes quota\n            long bytes = Long.parseLong(cl.getOptionValue(\"b\"));\n            try {\n                createQuota(zk, path, bytes, -1);\n            } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {\n                throw new CliWrapperException(ex);\n            }\n        } else if (cl.hasOption(\"n\")) {\n            // we are setting the num quota\n            int numNodes = Integer.parseInt(cl.getOptionValue(\"n\"));\n            try {\n                createQuota(zk, path, -1L, numNodes);\n            } catch (KeeperException | InterruptedException | IllegalArgumentException ex) {\n                throw new CliWrapperException(ex);\n            }\n        } else {\n            throw new MalformedCommandException(getUsageStr());\n        }\n\n        return false;\n    }\n\n    public static boolean createQuota(\n        ZooKeeper zk,\n        String path,\n        long bytes,\n        int numNodes) throws KeeperException, InterruptedException, IllegalArgumentException, MalformedPathException {\n        // check if the path exists. We cannot create\n        // quota for a path that already exists in zookeeper\n        // for now.\n        Stat initStat;\n        try {\n            initStat = zk.exists(path, false);\n        } catch (IllegalArgumentException ex) {\n            throw new MalformedPathException(ex.getMessage());\n        }\n        if (initStat == null) {\n            throw new IllegalArgumentException(path + \" does not exist.\");\n        }\n        // now check if their is already existing\n        // parent or child that has quota\n\n        String quotaPath = Quotas.quotaZookeeper;\n        // check for more than 2 children --\n        // if zookeeper_stats and zookeeper_quotas\n        // are not the children then this path\n        // is an ancestor of some path that\n        // already has quota\n\n        //check if the child node has a quota.\n        checkIfChildQuota(zk, path);\n\n        //check for any parent that has been quota\n        checkIfParentQuota(zk, path);\n\n        // this is valid node for quota\n        // start creating all the parents\n        if (zk.exists(quotaPath, false) == null) {\n            try {\n                zk.create(Quotas.procZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                zk.create(Quotas.quotaZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            } catch (KeeperException.NodeExistsException ne) {\n                // do nothing\n            }\n        }\n\n        // now create the direct children\n        // and the stat and quota nodes\n        String[] splits = path.split(\"/\");\n        StringBuilder sb = new StringBuilder();\n        sb.append(quotaPath);\n        for (int i = 1; i < splits.length; i++) {\n            sb.append(\"/\").append(splits[i]);\n            quotaPath = sb.toString();\n            try {\n                zk.create(quotaPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            } catch (KeeperException.NodeExistsException ne) {\n                //do nothing\n            }\n        }\n        String statPath = quotaPath + \"/\" + Quotas.statNode;\n        quotaPath = quotaPath + \"/\" + Quotas.limitNode;\n        StatsTrack strack = new StatsTrack(null);\n        strack.setBytes(bytes);\n        strack.setCount(numNodes);\n        try {\n            zk.create(quotaPath, strack.toString().getBytes(UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            StatsTrack stats = new StatsTrack(null);\n            stats.setBytes(0L);\n            stats.setCount(0);\n            zk.create(statPath, stats.toString().getBytes(UTF_8), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n        } catch (KeeperException.NodeExistsException ne) {\n            byte[] data = zk.getData(quotaPath, false, new Stat());\n            StatsTrack strackC = new StatsTrack(new String(data, UTF_8));\n            if (bytes != -1L) {\n                strackC.setBytes(bytes);\n            }\n            if (numNodes != -1) {\n                strackC.setCount(numNodes);\n            }\n            zk.setData(quotaPath, strackC.toString().getBytes(UTF_8), -1);\n        }\n        return true;\n    }\n\n    private static void checkIfChildQuota(ZooKeeper zk, String path) throws KeeperException, InterruptedException {\n        String realPath = Quotas.quotaZookeeper + path;\n\n        try {\n            ZKUtil.visitSubTreeDFS(zk, realPath, false, (rc, quotaPath, ctx, name) -> {\n                List<String> children = new ArrayList<>();\n                try {\n                    children = zk.getChildren(quotaPath, false);\n                } catch (KeeperException.NoNodeException ne) {\n                    LOG.debug(\"child removed during quota check\", ne);\n                    return;\n                } catch (InterruptedException | KeeperException e) {\n                    e.printStackTrace();\n                }\n\n                if (children.size() == 0) {\n                    return;\n                }\n                for (String child : children) {\n                    if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n                        throw new IllegalArgumentException(path + \" has a child \" + quotaPath.substring(Quotas.quotaZookeeper.length()) + \" which has a quota\");\n                    }\n                }\n            });\n        } catch (KeeperException.NoNodeException ne) {\n            // this is fine\n        }\n    }\n\n    private static void checkIfParentQuota(ZooKeeper zk, String path) throws InterruptedException, KeeperException {\n        final String[] splits = path.split(\"/\");\n        String quotaPath = Quotas.quotaZookeeper;\n        for (String str : splits) {\n            if (str.length() == 0) {\n                // this should only be for the beginning of the path\n                // i.e. \"/...\" - split(path)[0] is empty string before first '/'\n                continue;\n            }\n            quotaPath += \"/\" + str;\n            List<String> children = null;\n            try {\n                children = zk.getChildren(quotaPath, false);\n            } catch (KeeperException.NoNodeException ne) {\n                LOG.debug(\"child removed during quota check\", ne);\n                return;\n            }\n            if (children.size() == 0) {\n                return;\n            }\n            for (String child : children) {\n                if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n                    throw new IllegalArgumentException(path + \" has a parent \" + quotaPath.substring(Quotas.quotaZookeeper.length()) + \" which has a quota\");\n                }\n            }\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.cli;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.apache.commons.cli.CommandLine;\nimport org.apache.commons.cli.DefaultParser;\nimport org.apache.commons.cli.Option;\nimport org.apache.commons.cli.OptionGroup;\nimport org.apache.commons.cli.Options;\nimport org.apache.commons.cli.ParseException;\nimport org.apache.zookeeper.CreateMode;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.Quotas;\nimport org.apache.zookeeper.StatsTrack;\nimport org.apache.zookeeper.ZKUtil;\nimport org.apache.zookeeper.ZooDefs;\nimport org.apache.zookeeper.ZooKeeper;\nimport org.apache.zookeeper.data.Stat;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * setQuota command for cli\n */\npublic class SetQuotaCommand extends CliCommand {\n\n    private static final Logger LOG = LoggerFactory.getLogger(SetQuotaCommand.class);\n    private Options options = new Options();\n    private String[] args;\n    private CommandLine cl;\n\n    public SetQuotaCommand() {\n        super(\"setquota\", \"-n|-b|-N|-B val path\");\n\n        OptionGroup og1 = new OptionGroup();\n        og1.addOption(new Option(\"n\", true, \"num soft quota\"));\n        og1.addOption(new Option(\"b\", true, \"bytes soft quota\"));\n        og1.addOption(new Option(\"N\", true, \"num hard quota\"));\n        og1.addOption(new Option(\"B\", true, \"bytes hard quota\"));\n\n        og1.setRequired(true);\n        options.addOptionGroup(og1);\n    }\n\n    @Override\n    public CliCommand parse(String[] cmdArgs) throws CliParseException {\n        DefaultParser parser = new DefaultParser();\n        try {\n            cl = parser.parse(options, cmdArgs);\n        } catch (ParseException ex) {\n            throw new CliParseException(ex);\n        }\n        args = cl.getArgs();\n        if (args.length < 2) {\n            throw new CliParseException(getUsageStr());\n        }\n\n        return this;\n    }\n\n    @Override\n    public boolean exec() throws CliException {\n        // get the args\n        String path = args[1];\n        if (path.startsWith(Quotas.quotaZookeeper)) {\n            err.println(\"cannot set a quota under the path: \" + Quotas.quotaZookeeper);\n            return false;\n        }\n\n        StatsTrack quota = new StatsTrack();\n        quota.setCount(-1);\n        quota.setBytes(-1L);\n        quota.setCountHardLimit(-1);\n        quota.setByteHardLimit(-1L);\n\n        if (!checkOptionValue(quota)) {\n            return false;\n        }\n\n        boolean flagSet = (cl.hasOption(\"n\") || cl.hasOption(\"N\")\n                || cl.hasOption(\"b\") || cl.hasOption(\"B\"));\n        if (flagSet) {\n            try {\n                createQuota(zk, path, quota);\n            } catch (IllegalArgumentException ex) {\n                throw new MalformedPathException(ex.getMessage());\n            } catch (KeeperException | InterruptedException ex) {\n                throw new CliWrapperException(ex);\n            }\n        } else {\n            err.println(getUsageStr());\n        }\n\n        return false;\n    }\n\n    private boolean checkOptionValue(StatsTrack quota) {\n\n        try {\n            if (cl.hasOption(\"n\")) {\n                // we are setting the num quota\n                int count = Integer.parseInt(cl.getOptionValue(\"n\"));\n                if (count > 0) {\n                    quota.setCount(count);\n                } else {\n                    err.println(\"the num quota must be greater than zero\");\n                    return false;\n                }\n            }\n            if (cl.hasOption(\"b\")) {\n                // we are setting the bytes quota\n                long bytes = Long.parseLong(cl.getOptionValue(\"b\"));\n                if (bytes >= 0) {\n                    quota.setBytes(bytes);\n                } else {\n                    err.println(\"the bytes quota must be greater than or equal to zero\");\n                    return false;\n                }\n            }\n            if (cl.hasOption(\"N\")) {\n                // we are setting the num hard quota\n                int count = Integer.parseInt(cl.getOptionValue(\"N\"));\n                if (count > 0) {\n                    quota.setCountHardLimit(count);\n                } else {\n                    err.println(\"the num quota must be greater than zero\");\n                    return false;\n                }\n            }\n            if (cl.hasOption(\"B\")) {\n                // we are setting the byte hard quota\n                long bytes = Long.parseLong(cl.getOptionValue(\"B\"));\n                if (bytes >= 0) {\n                    quota.setByteHardLimit(bytes);\n                } else {\n                    err.println(\"the bytes quota must be greater than or equal to zero\");\n                    return false;\n                }\n            }\n        } catch (NumberFormatException e) {\n            err.println(\"NumberFormatException happens when parsing the option value\");\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * this method creates a quota node for the path\n     * @param zk the ZooKeeper client\n     * @param path the path for which quota needs to be created\n     * @param quota the quotas\n     * @return true if its successful and false if not.\n     */\n    public static boolean createQuota(ZooKeeper zk, String path, StatsTrack quota)\n            throws KeeperException, InterruptedException, MalformedPathException {\n        // check if the path exists. We cannot create\n        // quota for a path that doesn't exist in zookeeper\n        // for now.\n        Stat initStat;\n        try {\n            initStat = zk.exists(path, false);\n        } catch (IllegalArgumentException ex) {\n            throw new MalformedPathException(ex.getMessage());\n        }\n        if (initStat == null) {\n            throw new IllegalArgumentException(path + \" does not exist.\");\n        }\n        // now check if their is already existing\n        // parent or child that has quota\n\n        String quotaPath = Quotas.quotaZookeeper;\n        // check for more than 2 children --\n        // if zookeeper_stats and zookeeper_quotas\n        // are not the children then this path\n        // is an ancestor of some path that\n        // already has quota\n\n        //check if the child node has a quota.\n        checkIfChildQuota(zk, path);\n\n        //check for any parent that has been quota\n        checkIfParentQuota(zk, path);\n\n        // this is valid node for quota\n        // start creating all the parents\n        if (zk.exists(quotaPath, false) == null) {\n            try {\n                zk.create(Quotas.procZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n                zk.create(Quotas.quotaZookeeper, null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n            } catch (KeeperException.NodeExistsException ne) {\n                // do nothing\n            }\n        }\n\n        // now create the direct children\n        // and the stat and quota nodes\n        String[] splits = path.split(\"/\");\n        StringBuilder sb = new StringBuilder();\n        sb.append(quotaPath);\n        for (int i = 1; i < splits.length; i++) {\n            sb.append(\"/\").append(splits[i]);\n            quotaPath = sb.toString();\n            if (zk.exists(quotaPath, false) == null) {\n                try {\n                    zk.create(quotaPath, null, ZooDefs.Ids.OPEN_ACL_UNSAFE,\n                            CreateMode.PERSISTENT);\n                } catch (KeeperException.NodeExistsException ne) {\n                    //do nothing\n                }\n            }\n        }\n        String statPath = quotaPath + \"/\" + Quotas.statNode;\n        quotaPath = quotaPath + \"/\" + Quotas.limitNode;\n        byte[] data;\n\n        if (zk.exists(quotaPath, false) == null) {\n            zk.create(quotaPath, quota.getStatsBytes(),\n                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            StatsTrack stats = new StatsTrack();\n            stats.setCount(0);\n            stats.setBytes(0L);\n\n            zk.create(statPath, stats.getStatsBytes(),\n                    ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n\n            data = zk.getData(quotaPath, false, new Stat());\n            StatsTrack quotaStrack = new StatsTrack(data);\n\n            data = zk.getData(statPath, false, new Stat());\n            StatsTrack statStrack = new StatsTrack(data);\n            checkQuota(quotaStrack, statStrack);\n\n        } else {\n            data = zk.getData(quotaPath, false, new Stat());\n            StatsTrack quotaStrack = new StatsTrack(data);\n\n            if (quota.getCount() > -1) {\n                quotaStrack.setCount(quota.getCount());\n            }\n            if (quota.getBytes() > -1L) {\n                quotaStrack.setBytes(quota.getBytes());\n            }\n            if (quota.getCountHardLimit() > -1) {\n                quotaStrack.setCountHardLimit(quota.getCountHardLimit());\n            }\n            if (quota.getByteHardLimit() > -1L) {\n                quotaStrack.setByteHardLimit(quota.getByteHardLimit());\n            }\n\n            data = zk.getData(statPath, false, new Stat());\n            StatsTrack statStrack = new StatsTrack(data);\n            checkQuota(quotaStrack, statStrack);\n\n            zk.setData(quotaPath, quotaStrack.getStatsBytes(), -1);\n        }\n\n        return true;\n    }\n\n    private static void checkQuota(StatsTrack quotaStrack, StatsTrack statStrack) {\n        if ((quotaStrack.getCount() > -1 && quotaStrack.getCount() < statStrack.getCount()) || (quotaStrack.getCountHardLimit() > -1\n                && quotaStrack.getCountHardLimit() < statStrack.getCount())) {\n            System.out.println(\"[Warning]: the count quota you create is less than the existing count:\" + statStrack.getCount());\n        }\n        if ((quotaStrack.getBytes() > -1 && quotaStrack.getBytes() < statStrack.getBytes()) || (quotaStrack.getByteHardLimit() > -1\n                && quotaStrack.getByteHardLimit() < statStrack.getBytes())) {\n            System.out.println(\"[Warning]: the bytes quota you create is less than the existing bytes:\" + statStrack.getBytes());\n        }\n    }\n\n    private static void checkIfChildQuota(ZooKeeper zk, String path) throws KeeperException, InterruptedException {\n        String realPath = Quotas.quotaPath(path);\n\n        try {\n            ZKUtil.visitSubTreeDFS(zk, realPath, false, (rc, quotaPath, ctx, name) -> {\n                List<String> children = new ArrayList<>();\n                try {\n                    children = zk.getChildren(quotaPath, false);\n                } catch (KeeperException.NoNodeException ne) {\n                    LOG.debug(\"child removed during quota check\", ne);\n                    return;\n                } catch (InterruptedException | KeeperException e) {\n                    e.printStackTrace();\n                }\n\n                if (children.size() == 0) {\n                    return;\n                }\n                for (String child : children) {\n                    if (!quotaPath.equals(Quotas.quotaZookeeper + path) && Quotas.limitNode.equals(child)) {\n                        throw new IllegalArgumentException(path + \" has a child \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n                    }\n                }\n            });\n        } catch (KeeperException.NoNodeException ne) {\n            // this is fine\n        }\n    }\n\n    private static void checkIfParentQuota(ZooKeeper zk, String path) throws InterruptedException, KeeperException {\n        final String[] splits = path.split(\"/\");\n        String quotaPath = Quotas.quotaZookeeper;\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(quotaPath);\n        for (int i = 1; i < splits.length - 1; i++) {\n            sb.append(\"/\");\n            sb.append(splits[i]);\n            quotaPath = sb.toString();\n            List<String> children = null;\n            try {\n                children = zk.getChildren(quotaPath, false);\n            } catch (KeeperException.NoNodeException ne) {\n                LOG.debug(\"child removed during quota check\", ne);\n                return;\n            }\n            if (children.size() == 0) {\n                return;\n            }\n            for (String child : children) {\n                if (!quotaPath.equals(Quotas.quotaPath(path)) && Quotas.limitNode.equals(child)) {\n                    throw new IllegalArgumentException(path + \" has a parent \" + Quotas.trimQuotaPath(quotaPath) + \" which has a quota\");\n                }\n            }\n        }\n    }\n}\n","lineNo":98}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.quorum;\n\nimport static org.apache.zookeeper.common.NetUtils.formatInetAddr;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport javax.security.sasl.SaslException;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.zookeeper.KeeperException.BadArgumentsException;\nimport org.apache.zookeeper.common.AtomicFileWritingIdiom;\nimport org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;\nimport org.apache.zookeeper.common.QuorumX509Util;\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.common.X509Exception;\nimport org.apache.zookeeper.jmx.MBeanRegistry;\nimport org.apache.zookeeper.jmx.ZKMBeanInfo;\nimport org.apache.zookeeper.server.ServerCnxn;\nimport org.apache.zookeeper.server.ServerCnxnFactory;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ZKDatabase;\nimport org.apache.zookeeper.server.ZooKeeperServer;\nimport org.apache.zookeeper.server.ZooKeeperThread;\nimport org.apache.zookeeper.server.admin.AdminServer;\nimport org.apache.zookeeper.server.admin.AdminServer.AdminServerException;\nimport org.apache.zookeeper.server.admin.AdminServerFactory;\nimport org.apache.zookeeper.server.persistence.FileTxnSnapLog;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;\nimport org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;\nimport org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;\nimport org.apache.zookeeper.server.quorum.auth.QuorumAuth;\nimport org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\nimport org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\nimport org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;\nimport org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;\nimport org.apache.zookeeper.server.quorum.flexible.QuorumMaj;\nimport org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\nimport org.apache.zookeeper.server.util.ConfigUtils;\nimport org.apache.zookeeper.server.util.JvmPauseMonitor;\nimport org.apache.zookeeper.server.util.ZxidUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class manages the quorum protocol. There are three states this server\n * can be in:\n * <ol>\n * <li>Leader election - each server will elect a leader (proposing itself as a\n * leader initially).<\/li>\n * <li>Follower - the server will synchronize with the leader and replicate any\n * transactions.<\/li>\n * <li>Leader - the server will process requests and forward them to followers.\n * A majority of followers must log the request before it can be accepted.\n * <\/ol>\n *\n * This class will setup a datagram socket that will always respond with its\n * view of the current leader. The response will take the form of:\n *\n * <pre>\n * int xid;\n *\n * long myid;\n *\n * long leader_id;\n *\n * long leader_zxid;\n * <\/pre>\n *\n * The request for the current leader will consist solely of an xid: int xid;\n */\npublic class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {\n\n    private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);\n\n    private QuorumBean jmxQuorumBean;\n    LocalPeerBean jmxLocalPeerBean;\n    private Map<Long, RemotePeerBean> jmxRemotePeerBean;\n    LeaderElectionBean jmxLeaderElectionBean;\n\n    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility\n    // of updates; see the implementation comment at setLastSeenQuorumVerifier().\n    private AtomicReference<QuorumCnxManager> qcmRef = new AtomicReference<>();\n\n    QuorumAuthServer authServer;\n    QuorumAuthLearner authLearner;\n\n    /**\n     * ZKDatabase is a top level member of quorumpeer\n     * which will be used in all the zookeeperservers\n     * instantiated later. Also, it is created once on\n     * bootup and only thrown away in case of a truncate\n     * message from the leader\n     */\n    private ZKDatabase zkDb;\n\n    private JvmPauseMonitor jvmPauseMonitor;\n\n    public static final class AddressTuple {\n\n        public final MultipleAddresses quorumAddr;\n        public final MultipleAddresses electionAddr;\n        public final InetSocketAddress clientAddr;\n\n        public AddressTuple(MultipleAddresses quorumAddr, MultipleAddresses electionAddr, InetSocketAddress clientAddr) {\n            this.quorumAddr = quorumAddr;\n            this.electionAddr = electionAddr;\n            this.clientAddr = clientAddr;\n        }\n\n    }\n\n    private int observerMasterPort;\n\n    public int getObserverMasterPort() {\n        return observerMasterPort;\n    }\n\n    public void setObserverMasterPort(int observerMasterPort) {\n        this.observerMasterPort = observerMasterPort;\n    }\n\n    public static final String CONFIG_KEY_MULTI_ADDRESS_ENABLED = \"zookeeper.multiAddress.enabled\";\n    public static final String CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED = \"false\";\n\n    private boolean multiAddressEnabled = true;\n    public boolean isMultiAddressEnabled() {\n        return multiAddressEnabled;\n    }\n\n    public void setMultiAddressEnabled(boolean multiAddressEnabled) {\n        this.multiAddressEnabled = multiAddressEnabled;\n        LOG.info(\"multiAddress.enabled set to {}\", multiAddressEnabled);\n    }\n\n    public static final String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_TIMEOUT_MS = \"zookeeper.multiAddress.reachabilityCheckTimeoutMs\";\n\n    private int multiAddressReachabilityCheckTimeoutMs = (int) MultipleAddresses.DEFAULT_TIMEOUT.toMillis();\n    public int getMultiAddressReachabilityCheckTimeoutMs() {\n        return multiAddressReachabilityCheckTimeoutMs;\n    }\n\n    public void setMultiAddressReachabilityCheckTimeoutMs(int multiAddressReachabilityCheckTimeoutMs) {\n        this.multiAddressReachabilityCheckTimeoutMs = multiAddressReachabilityCheckTimeoutMs;\n        LOG.info(\"multiAddress.reachabilityCheckTimeoutMs set to {}\", multiAddressReachabilityCheckTimeoutMs);\n    }\n\n    public static final String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_ENABLED = \"zookeeper.multiAddress.reachabilityCheckEnabled\";\n\n    private boolean multiAddressReachabilityCheckEnabled = true;\n\n    public boolean isMultiAddressReachabilityCheckEnabled() {\n        return multiAddressReachabilityCheckEnabled;\n    }\n\n    public void setMultiAddressReachabilityCheckEnabled(boolean multiAddressReachabilityCheckEnabled) {\n        this.multiAddressReachabilityCheckEnabled = multiAddressReachabilityCheckEnabled;\n        LOG.info(\"multiAddress.reachabilityCheckEnabled set to {}\", multiAddressReachabilityCheckEnabled);\n    }\n\n    public static class QuorumServer {\n\n        public MultipleAddresses addr = new MultipleAddresses();\n\n        public MultipleAddresses electionAddr = new MultipleAddresses();\n\n        public InetSocketAddress clientAddr = null;\n\n        public long id;\n\n        public String hostname;\n\n        public LearnerType type = LearnerType.PARTICIPANT;\n\n        public boolean isClientAddrFromStatic = false;\n\n        private List<InetSocketAddress> myAddrs;\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr) {\n            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);\n        }\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr) {\n            this(id, addr, electionAddr, null, LearnerType.PARTICIPANT);\n        }\n\n        // VisibleForTesting\n        public QuorumServer(long id, InetSocketAddress addr) {\n            this(id, addr, null, null, LearnerType.PARTICIPANT);\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        /**\n         * Performs a DNS lookup for server address and election address.\n         *\n         * If the DNS lookup fails, this.addr and electionAddr remain\n         * unmodified.\n         */\n        public void recreateSocketAddresses() {\n            if (this.addr.isEmpty()) {\n                LOG.warn(\"Server address has not been initialized\");\n                return;\n            }\n            if (this.electionAddr.isEmpty()) {\n                LOG.warn(\"Election address has not been initialized\");\n                return;\n            }\n            this.addr.recreateSocketAddresses();\n            this.electionAddr.recreateSocketAddresses();\n        }\n\n        private LearnerType getType(String s) throws ConfigException {\n            switch (s.trim().toLowerCase()) {\n                case \"observer\":\n                    return LearnerType.OBSERVER;\n                case \"participant\":\n                    return LearnerType.PARTICIPANT;\n                default:\n                    throw new ConfigException(\"Unrecognised peertype: \" + s);\n            }\n        }\n\n        private static final String wrongFormat =\n            \" does not have the form server_config or server_config;client_config\"\n            + \" where server_config is the pipe separated list of host:port:port or host:port:port:type\"\n            + \" and client_config is port or host:port\";\n\n        public QuorumServer(long sid, String addressStr) throws ConfigException {\n            this.id = sid;\n            LearnerType newType = null;\n            String[] serverClientParts = addressStr.split(\";\");\n            String[] serverAddresses = serverClientParts[0].split(\"\\\\|\");\n\n            if (serverClientParts.length == 2) {\n                String[] clientParts = ConfigUtils.getHostAndPort(serverClientParts[1]);\n                if (clientParts.length > 2) {\n                    throw new ConfigException(addressStr + wrongFormat);\n                }\n\n                // is client_config a host:port or just a port\n                hostname = (clientParts.length == 2) ? clientParts[0] : \"0.0.0.0\";\n                try {\n                    clientAddr = new InetSocketAddress(hostname, Integer.parseInt(clientParts[clientParts.length - 1]));\n                } catch (NumberFormatException e) {\n                    throw new ConfigException(\"Address unresolved: \" + hostname + \":\" + clientParts[clientParts.length - 1]);\n                }\n            }\n\n            boolean multiAddressEnabled = Boolean.parseBoolean(\n                System.getProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, QuorumPeer.CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED));\n            if (!multiAddressEnabled && serverAddresses.length > 1) {\n                throw new ConfigException(\"Multiple address feature is disabled, but multiple addresses were specified for sid \" + sid);\n            }\n\n            for (String serverAddress : serverAddresses) {\n                String serverParts[] = ConfigUtils.getHostAndPort(serverAddress);\n                if ((serverClientParts.length > 2) || (serverParts.length < 3)\n                        || (serverParts.length > 4)) {\n                    throw new ConfigException(addressStr + wrongFormat);\n                }\n\n                // server_config should be either host:port:port or host:port:port:type\n                InetSocketAddress tempAddress;\n                InetSocketAddress tempElectionAddress;\n                try {\n                    tempAddress = new InetSocketAddress(serverParts[0], Integer.parseInt(serverParts[1]));\n                    addr.addAddress(tempAddress);\n                } catch (NumberFormatException e) {\n                    throw new ConfigException(\"Address unresolved: \" + serverParts[0] + \":\" + serverParts[1]);\n                }\n                try {\n                    tempElectionAddress = new InetSocketAddress(serverParts[0], Integer.parseInt(serverParts[2]));\n                    electionAddr.addAddress(tempElectionAddress);\n                } catch (NumberFormatException e) {\n                    throw new ConfigException(\"Address unresolved: \" + serverParts[0] + \":\" + serverParts[2]);\n                }\n\n                if (tempAddress.getPort() == tempElectionAddress.getPort()) {\n                    throw new ConfigException(\"Client and election port must be different! Please update the \"\n                            + \"configuration file on server.\" + sid);\n                }\n\n                if (serverParts.length == 4) {\n                    LearnerType tempType = getType(serverParts[3]);\n                    if (newType == null) {\n                        newType = tempType;\n                    }\n\n                    if (newType != tempType) {\n                        throw new ConfigException(\"Multiple addresses should have similar roles: \" + type + \" vs \" + tempType);\n                    }\n                }\n\n                this.hostname = serverParts[0];\n            }\n\n            if (newType != null) {\n                type = newType;\n            }\n\n            setMyAddrs();\n        }\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, LearnerType type) {\n            this(id, addr, electionAddr, null, type);\n        }\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr, LearnerType type) {\n            this.id = id;\n            if (addr != null) {\n                this.addr.addAddress(addr);\n            }\n            if (electionAddr != null) {\n                this.electionAddr.addAddress(electionAddr);\n            }\n            this.type = type;\n            this.clientAddr = clientAddr;\n\n            setMyAddrs();\n        }\n\n        private void setMyAddrs() {\n            this.myAddrs = new ArrayList<>();\n            this.myAddrs.addAll(this.addr.getAllAddresses());\n            this.myAddrs.add(this.clientAddr);\n            this.myAddrs.addAll(this.electionAddr.getAllAddresses());\n            this.myAddrs = excludedSpecialAddresses(this.myAddrs);\n        }\n\n        public static String delimitedHostString(InetSocketAddress addr) {\n            String host = addr.getHostString();\n            if (host.contains(\":\")) {\n                return \"[\" + host + \"]\";\n            } else {\n                return host;\n            }\n        }\n\n        public String toString() {\n            StringWriter sw = new StringWriter();\n\n            List<InetSocketAddress> addrList = new LinkedList<>(addr.getAllAddresses());\n            List<InetSocketAddress> electionAddrList = new LinkedList<>(electionAddr.getAllAddresses());\n\n            if (addrList.size() > 0 && electionAddrList.size() > 0) {\n                addrList.sort(Comparator.comparing(InetSocketAddress::getHostString));\n                electionAddrList.sort(Comparator.comparing(InetSocketAddress::getHostString));\n                sw.append(IntStream.range(0, addrList.size()).mapToObj(i -> String.format(\"%s:%d:%d\",\n                        delimitedHostString(addrList.get(i)), addrList.get(i).getPort(), electionAddrList.get(i).getPort()))\n                        .collect(Collectors.joining(\"|\")));\n            }\n\n            if (type == LearnerType.OBSERVER) {\n                sw.append(\":observer\");\n            } else if (type == LearnerType.PARTICIPANT) {\n                sw.append(\":participant\");\n            }\n\n            if (clientAddr != null && !isClientAddrFromStatic) {\n                sw.append(\";\");\n                sw.append(delimitedHostString(clientAddr));\n                sw.append(\":\");\n                sw.append(String.valueOf(clientAddr.getPort()));\n            }\n\n            return sw.toString();\n        }\n\n        public int hashCode() {\n            assert false : \"hashCode not designed\";\n            return 42; // any arbitrary constant will do\n        }\n\n        private boolean checkAddressesEqual(InetSocketAddress addr1, InetSocketAddress addr2) {\n            return (addr1 != null || addr2 == null)\n                   && (addr1 == null || addr2 != null)\n                   && (addr1 == null || addr2 == null || addr1.equals(addr2));\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof QuorumServer)) {\n                return false;\n            }\n            QuorumServer qs = (QuorumServer) o;\n            if ((qs.id != id) || (qs.type != type)) {\n                return false;\n            }\n            if (!addr.equals(qs.addr)) {\n                return false;\n            }\n            if (!electionAddr.equals(qs.electionAddr)) {\n                return false;\n            }\n            return checkAddressesEqual(clientAddr, qs.clientAddr);\n        }\n\n        public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException {\n            List<InetSocketAddress> otherAddrs = new ArrayList<>(s.addr.getAllAddresses());\n            otherAddrs.add(s.clientAddr);\n            otherAddrs.addAll(s.electionAddr.getAllAddresses());\n            otherAddrs = excludedSpecialAddresses(otherAddrs);\n\n            for (InetSocketAddress my : this.myAddrs) {\n\n                for (InetSocketAddress other : otherAddrs) {\n                    if (my.equals(other)) {\n                        String error = String.format(\"%s of server.%d conflicts %s of server.%d\", my, this.id, other, s.id);\n                        throw new BadArgumentsException(error);\n                    }\n                }\n            }\n        }\n\n        private List<InetSocketAddress> excludedSpecialAddresses(List<InetSocketAddress> addrs) {\n            List<InetSocketAddress> included = new ArrayList<>();\n\n            for (InetSocketAddress addr : addrs) {\n                if (addr == null) {\n                    continue;\n                }\n                InetAddress inetaddr = addr.getAddress();\n\n                if (inetaddr == null || inetaddr.isAnyLocalAddress() || // wildCard addresses (0.0.0.0 or [::])\n                    inetaddr.isLoopbackAddress()) { // loopback address(localhost/127.0.0.1)\n                    continue;\n                }\n                included.add(addr);\n            }\n            return included;\n        }\n\n    }\n\n    public enum ServerState {\n        LOOKING,\n        FOLLOWING,\n        LEADING,\n        OBSERVING\n    }\n\n    /**\n     * (Used for monitoring) shows the current phase of\n     * Zab protocol that peer is running.\n     */\n    public enum ZabState {\n        ELECTION,\n        DISCOVERY,\n        SYNCHRONIZATION,\n        BROADCAST\n    }\n\n    /**\n     * (Used for monitoring) When peer is in synchronization phase, this shows\n     * which synchronization mechanism is being used\n     */\n    public enum SyncMode {\n        NONE,\n        DIFF,\n        SNAP,\n        TRUNC\n    }\n\n    /*\n     * A peer can either be participating, which implies that it is willing to\n     * both vote in instances of consensus and to elect or become a Leader, or\n     * it may be observing in which case it isn't.\n     *\n     * We need this distinction to decide which ServerState to move to when\n     * conditions change (e.g. which state to become after LOOKING).\n     */\n    public enum LearnerType {\n        PARTICIPANT,\n        OBSERVER\n    }\n\n    /*\n     * To enable observers to have no identifier, we need a generic identifier\n     * at least for QuorumCnxManager. We use the following constant to as the\n     * value of such a generic identifier.\n     */\n\n    static final long OBSERVER_ID = Long.MAX_VALUE;\n\n    /*\n     * Record leader election time\n     */\n    public long start_fle, end_fle; // fle = fast leader election\n    public static final String FLE_TIME_UNIT = \"MS\";\n    private long unavailableStartTime;\n\n    /*\n     * Default value of peer is participant\n     */\n    private LearnerType learnerType = LearnerType.PARTICIPANT;\n\n    public LearnerType getLearnerType() {\n        return learnerType;\n    }\n\n    /**\n     * Sets the LearnerType\n     */\n    public void setLearnerType(LearnerType p) {\n        learnerType = p;\n    }\n\n    protected synchronized void setConfigFileName(String s) {\n        configFilename = s;\n    }\n\n    private String configFilename = null;\n\n    public int getQuorumSize() {\n        return getVotingView().size();\n    }\n\n    public void setJvmPauseMonitor(JvmPauseMonitor jvmPauseMonitor) {\n        this.jvmPauseMonitor = jvmPauseMonitor;\n    }\n\n    /**\n     * QuorumVerifier implementation; default (majority).\n     */\n\n    //last committed quorum verifier\n    private QuorumVerifier quorumVerifier;\n\n    //last proposed quorum verifier\n    private QuorumVerifier lastSeenQuorumVerifier = null;\n\n    // Lock object that guard access to quorumVerifier and lastSeenQuorumVerifier.\n    final Object QV_LOCK = new Object();\n\n    /**\n     * My id\n     */\n    private long myid;\n\n    /**\n     * get the id of this quorum peer.\n     */\n    public long getId() {\n        return myid;\n    }\n\n    // VisibleForTesting\n    void setId(long id) {\n        this.myid = id;\n    }\n\n    private boolean sslQuorum;\n    private boolean shouldUsePortUnification;\n\n    public boolean isSslQuorum() {\n        return sslQuorum;\n    }\n\n    public boolean shouldUsePortUnification() {\n        return shouldUsePortUnification;\n    }\n\n    private final QuorumX509Util x509Util;\n\n    QuorumX509Util getX509Util() {\n        return x509Util;\n    }\n\n    /**\n     * This is who I think the leader currently is.\n     */\n    private volatile Vote currentVote;\n\n    public synchronized Vote getCurrentVote() {\n        return currentVote;\n    }\n\n    public synchronized void setCurrentVote(Vote v) {\n        currentVote = v;\n    }\n\n    private volatile boolean running = true;\n\n    private String initialConfig;\n\n    /**\n     * The number of milliseconds of each tick\n     */\n    protected int tickTime;\n\n    /**\n     * Whether learners in this quorum should create new sessions as local.\n     * False by default to preserve existing behavior.\n     */\n    protected boolean localSessionsEnabled = false;\n\n    /**\n     * Whether learners in this quorum should upgrade local sessions to\n     * global. Only matters if local sessions are enabled.\n     */\n    protected boolean localSessionsUpgradingEnabled = true;\n\n    /**\n     * Minimum number of milliseconds to allow for session timeout.\n     * A value of -1 indicates unset, use default.\n     */\n    protected int minSessionTimeout = -1;\n\n    /**\n     * Maximum number of milliseconds to allow for session timeout.\n     * A value of -1 indicates unset, use default.\n     */\n    protected int maxSessionTimeout = -1;\n\n    /**\n     * The ZooKeeper server's socket backlog length. The number of connections\n     * that will be queued to be read before new connections are dropped. A\n     * value of one indicates the default backlog will be used.\n     */\n    protected int clientPortListenBacklog = -1;\n\n    /**\n     * The number of ticks that the initial synchronization phase can take\n     */\n    protected volatile int initLimit;\n\n    /**\n     * The number of ticks that can pass between sending a request and getting\n     * an acknowledgment\n     */\n    protected volatile int syncLimit;\n\n    /**\n     * The number of ticks that can pass before retrying to connect to learner master\n     */\n    protected volatile int connectToLearnerMasterLimit;\n\n    /**\n     * Enables/Disables sync request processor. This option is enabled\n     * by default and is to be used with observers.\n     */\n    protected boolean syncEnabled = true;\n\n    /**\n     * The current tick\n     */\n    protected AtomicInteger tick = new AtomicInteger();\n\n    /**\n     * Whether or not to listen on all IPs for the two quorum ports\n     * (broadcast and fast leader election).\n     */\n    protected boolean quorumListenOnAllIPs = false;\n\n    /**\n     * Keeps time taken for leader election in milliseconds. Sets the value to\n     * this variable only after the completion of leader election.\n     */\n    private long electionTimeTaken = -1;\n\n    /**\n     * Enable/Disables quorum authentication using sasl. Defaulting to false.\n     */\n    protected boolean quorumSaslEnableAuth;\n\n    /**\n     * If this is false, quorum peer server will accept another quorum peer client\n     * connection even if the authentication did not succeed. This can be used while\n     * upgrading ZooKeeper server. Defaulting to false (required).\n     */\n    protected boolean quorumServerSaslAuthRequired;\n\n    /**\n     * If this is false, quorum peer learner will talk to quorum peer server\n     * without authentication. This can be used while upgrading ZooKeeper\n     * server. Defaulting to false (required).\n     */\n    protected boolean quorumLearnerSaslAuthRequired;\n\n    /**\n     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.\n     */\n    protected String quorumServicePrincipal;\n\n    /**\n     * Quorum learner login context name in jaas-conf file to read the kerberos\n     * security details. Defaulting to 'QuorumLearner'.\n     */\n    protected String quorumLearnerLoginContext;\n\n    /**\n     * Quorum server login context name in jaas-conf file to read the kerberos\n     * security details. Defaulting to 'QuorumServer'.\n     */\n    protected String quorumServerLoginContext;\n\n    // TODO: need to tune the default value of thread size\n    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;\n    /**\n     * The maximum number of threads to allow in the connectionExecutors thread\n     * pool which will be used to initiate quorum server connections.\n     */\n    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;\n\n    public static final String QUORUM_CNXN_TIMEOUT_MS = \"zookeeper.quorumCnxnTimeoutMs\";\n    private static int quorumCnxnTimeoutMs;\n\n    static {\n        quorumCnxnTimeoutMs = Integer.getInteger(QUORUM_CNXN_TIMEOUT_MS, -1);\n        LOG.info(\"{}={}\", QUORUM_CNXN_TIMEOUT_MS, quorumCnxnTimeoutMs);\n    }\n\n    /**\n     * @deprecated As of release 3.4.0, this class has been deprecated, since\n     * it is used with one of the udp-based versions of leader election, which\n     * we are also deprecating.\n     *\n     * This class simply responds to requests for the current leader of this\n     * node.\n     * <p>\n     * The request contains just an xid generated by the requestor.\n     * <p>\n     * The response has the xid, the id of this server, the id of the leader,\n     * and the zxid of the leader.\n     *\n     *\n     */\n    @Deprecated\n    class ResponderThread extends ZooKeeperThread {\n\n        ResponderThread() {\n            super(\"ResponderThread\");\n        }\n\n        volatile boolean running = true;\n\n        @Override\n        public void run() {\n            try {\n                byte[] b = new byte[36];\n                ByteBuffer responseBuffer = ByteBuffer.wrap(b);\n                DatagramPacket packet = new DatagramPacket(b, b.length);\n                while (running) {\n                    udpSocket.receive(packet);\n                    if (packet.getLength() != 4) {\n                        LOG.warn(\"Got more than just an xid! Len = {}\", packet.getLength());\n                    } else {\n                        responseBuffer.clear();\n                        responseBuffer.getInt(); // Skip the xid\n                        responseBuffer.putLong(myid);\n                        Vote current = getCurrentVote();\n                        switch (getPeerState()) {\n                        case LOOKING:\n                            responseBuffer.putLong(current.getId());\n                            responseBuffer.putLong(current.getZxid());\n                            break;\n                        case LEADING:\n                            responseBuffer.putLong(myid);\n                            try {\n                                long proposed;\n                                synchronized (leader) {\n                                    proposed = leader.lastProposed;\n                                }\n                                responseBuffer.putLong(proposed);\n                            } catch (NullPointerException npe) {\n                                // This can happen in state transitions,\n                                // just ignore the request\n                            }\n                            break;\n                        case FOLLOWING:\n                            responseBuffer.putLong(current.getId());\n                            try {\n                                responseBuffer.putLong(follower.getZxid());\n                            } catch (NullPointerException npe) {\n                                // This can happen in state transitions,\n                                // just ignore the request\n                            }\n                            break;\n                        case OBSERVING:\n                            // Do nothing, Observers keep themselves to\n                            // themselves.\n                            break;\n                        }\n                        packet.setData(b);\n                        udpSocket.send(packet);\n                    }\n                    packet.setLength(b.length);\n                }\n            } catch (RuntimeException e) {\n                LOG.warn(\"Unexpected runtime exception in ResponderThread\", e);\n            } catch (IOException e) {\n                LOG.warn(\"Unexpected IO exception in ResponderThread\", e);\n            } finally {\n                LOG.warn(\"QuorumPeer responder thread exited\");\n            }\n        }\n\n    }\n\n    private ServerState state = ServerState.LOOKING;\n\n    private AtomicReference<ZabState> zabState = new AtomicReference<>(ZabState.ELECTION);\n    private AtomicReference<SyncMode> syncMode = new AtomicReference<>(SyncMode.NONE);\n    private AtomicReference<String> leaderAddress = new AtomicReference<String>(\"\");\n    private AtomicLong leaderId = new AtomicLong(-1);\n\n    private boolean reconfigFlag = false; // indicates that a reconfig just committed\n\n    public synchronized void setPeerState(ServerState newState) {\n        state = newState;\n        if (newState == ServerState.LOOKING) {\n            setLeaderAddressAndId(null, -1);\n            setZabState(ZabState.ELECTION);\n        } else {\n            LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n        }\n    }\n\n    public void setZabState(ZabState zabState) {\n        if ((zabState == ZabState.BROADCAST) && (unavailableStartTime != 0)) {\n            long unavailableTime = Time.currentElapsedTime() - unavailableStartTime;\n            ServerMetrics.getMetrics().UNAVAILABLE_TIME.add(unavailableTime);\n            if (getPeerState() == ServerState.LEADING) {\n                ServerMetrics.getMetrics().LEADER_UNAVAILABLE_TIME.add(unavailableTime);\n            }\n            unavailableStartTime = 0;\n        }\n        this.zabState.set(zabState);\n        LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n    }\n\n    public void setSyncMode(SyncMode syncMode) {\n        this.syncMode.set(syncMode);\n        LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n    }\n\n    public ZabState getZabState() {\n        return zabState.get();\n    }\n\n    public SyncMode getSyncMode() {\n        return syncMode.get();\n    }\n\n    public void setLeaderAddressAndId(MultipleAddresses addr, long newId) {\n        if (addr != null) {\n            leaderAddress.set(String.join(\"|\", addr.getAllHostStrings()));\n        } else {\n            leaderAddress.set(null);\n        }\n        leaderId.set(newId);\n    }\n\n    public String getLeaderAddress() {\n        return leaderAddress.get();\n    }\n\n    public long getLeaderId() {\n        return leaderId.get();\n    }\n\n    public String getDetailedPeerState() {\n        final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());\n        final ZabState zabState = getZabState();\n        if (!ZabState.ELECTION.equals(zabState)) {\n            sb.append(\" - \").append(zabState.toString().toLowerCase());\n        }\n        final SyncMode syncMode = getSyncMode();\n        if (!SyncMode.NONE.equals(syncMode)) {\n            sb.append(\" - \").append(syncMode.toString().toLowerCase());\n        }\n        return sb.toString();\n    }\n\n    public synchronized void reconfigFlagSet() {\n        reconfigFlag = true;\n    }\n    public synchronized void reconfigFlagClear() {\n        reconfigFlag = false;\n    }\n    public synchronized boolean isReconfigStateChange() {\n        return reconfigFlag;\n    }\n    public synchronized ServerState getPeerState() {\n        return state;\n    }\n\n    DatagramSocket udpSocket;\n\n    private final AtomicReference<AddressTuple> myAddrs = new AtomicReference<>();\n\n    /**\n     * Resolves hostname for a given server ID.\n     *\n     * This method resolves hostname for a given server ID in both quorumVerifer\n     * and lastSeenQuorumVerifier. If the server ID matches the local server ID,\n     * it also updates myAddrs.\n     */\n    public void recreateSocketAddresses(long id) {\n        QuorumVerifier qv = getQuorumVerifier();\n        if (qv != null) {\n            QuorumServer qs = qv.getAllMembers().get(id);\n            if (qs != null) {\n                qs.recreateSocketAddresses();\n                if (id == getId()) {\n                    setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n                }\n            }\n        }\n        qv = getLastSeenQuorumVerifier();\n        if (qv != null) {\n            QuorumServer qs = qv.getAllMembers().get(id);\n            if (qs != null) {\n                qs.recreateSocketAddresses();\n            }\n        }\n    }\n\n    private AddressTuple getAddrs() {\n        AddressTuple addrs = myAddrs.get();\n        if (addrs != null) {\n            return addrs;\n        }\n        try {\n            synchronized (QV_LOCK) {\n                addrs = myAddrs.get();\n                while (addrs == null) {\n                    QV_LOCK.wait();\n                    addrs = myAddrs.get();\n                }\n                return addrs;\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public MultipleAddresses getQuorumAddress() {\n        return getAddrs().quorumAddr;\n    }\n\n    public MultipleAddresses getElectionAddress() {\n        return getAddrs().electionAddr;\n    }\n\n    public InetSocketAddress getClientAddress() {\n        final AddressTuple addrs = myAddrs.get();\n        return (addrs == null) ? null : addrs.clientAddr;\n    }\n\n    private void setAddrs(MultipleAddresses quorumAddr, MultipleAddresses electionAddr, InetSocketAddress clientAddr) {\n        synchronized (QV_LOCK) {\n            myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));\n            QV_LOCK.notifyAll();\n        }\n    }\n\n    private int electionType;\n\n    Election electionAlg;\n\n    ServerCnxnFactory cnxnFactory;\n    ServerCnxnFactory secureCnxnFactory;\n\n    private FileTxnSnapLog logFactory = null;\n\n    private final QuorumStats quorumStats;\n\n    AdminServer adminServer;\n\n    private final boolean reconfigEnabled;\n\n    public static QuorumPeer testingQuorumPeer() throws SaslException {\n        return new QuorumPeer();\n    }\n\n    public QuorumPeer() throws SaslException {\n        super(\"QuorumPeer\");\n        quorumStats = new QuorumStats(this);\n        jmxRemotePeerBean = new HashMap<Long, RemotePeerBean>();\n        adminServer = AdminServerFactory.createAdminServer();\n        x509Util = createX509Util();\n        initialize();\n        reconfigEnabled = QuorumPeerConfig.isReconfigEnabled();\n    }\n\n    // VisibleForTesting\n    QuorumX509Util createX509Util() {\n        return new QuorumX509Util();\n    }\n\n    /**\n     * For backward compatibility purposes, we instantiate QuorumMaj by default.\n     */\n\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, ServerCnxnFactory cnxnFactory) throws IOException {\n        this(quorumPeers, dataDir, dataLogDir, electionType, myid, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, false, cnxnFactory, new QuorumMaj(quorumPeers));\n    }\n\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, boolean quorumListenOnAllIPs, ServerCnxnFactory cnxnFactory, QuorumVerifier quorumConfig) throws IOException {\n        this();\n        this.cnxnFactory = cnxnFactory;\n        this.electionType = electionType;\n        this.myid = myid;\n        this.tickTime = tickTime;\n        this.initLimit = initLimit;\n        this.syncLimit = syncLimit;\n        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;\n        this.quorumListenOnAllIPs = quorumListenOnAllIPs;\n        this.logFactory = new FileTxnSnapLog(dataLogDir, dataDir);\n        this.zkDb = new ZKDatabase(this.logFactory);\n        if (quorumConfig == null) {\n            quorumConfig = new QuorumMaj(quorumPeers);\n        }\n        setQuorumVerifier(quorumConfig, false);\n        adminServer = AdminServerFactory.createAdminServer();\n    }\n\n    public void initialize() throws SaslException {\n        // init quorum auth server & learner\n        if (isQuorumSaslAuthEnabled()) {\n            Set<String> authzHosts = new HashSet<String>();\n            for (QuorumServer qs : getView().values()) {\n                authzHosts.add(qs.hostname);\n            }\n            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);\n            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);\n        } else {\n            authServer = new NullQuorumAuthServer();\n            authLearner = new NullQuorumAuthLearner();\n        }\n    }\n\n    QuorumStats quorumStats() {\n        return quorumStats;\n    }\n\n    @Override\n    public synchronized void start() {\n        if (!getView().containsKey(myid)) {\n            throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n        }\n        loadDataBase();\n        startServerCnxnFactory();\n        try {\n            adminServer.start();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem starting AdminServer\", e);\n            System.out.println(e);\n        }\n        startLeaderElection();\n        startJvmPauseMonitor();\n        super.start();\n    }\n\n    private void loadDataBase() {\n        try {\n            zkDb.loadDataBase();\n\n            // load the epochs\n            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n            long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n            try {\n                currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n            } catch (FileNotFoundException e) {\n                // pick a reasonable epoch number\n                // this should only happen once when moving to a\n                // new code version\n                currentEpoch = epochOfZxid;\n                LOG.info(\n                    \"{} not found! Creating with a reasonable default of {}. \"\n                        + \"This should only happen when you are upgrading your installation\",\n                    CURRENT_EPOCH_FILENAME,\n                    currentEpoch);\n                writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n            }\n            if (epochOfZxid > currentEpoch) {\n                throw new IOException(\"The current epoch, \"\n                                      + ZxidUtils.zxidToString(currentEpoch)\n                                      + \", is older than the last zxid, \"\n                                      + lastProcessedZxid);\n            }\n            try {\n                acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n            } catch (FileNotFoundException e) {\n                // pick a reasonable epoch number\n                // this should only happen once when moving to a\n                // new code version\n                acceptedEpoch = epochOfZxid;\n                LOG.info(\n                    \"{} not found! Creating with a reasonable default of {}. \"\n                        + \"This should only happen when you are upgrading your installation\",\n                    ACCEPTED_EPOCH_FILENAME,\n                    acceptedEpoch);\n                writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n            }\n            if (acceptedEpoch < currentEpoch) {\n                throw new IOException(\"The accepted epoch, \"\n                                      + ZxidUtils.zxidToString(acceptedEpoch)\n                                      + \" is less than the current epoch, \"\n                                      + ZxidUtils.zxidToString(currentEpoch));\n            }\n        } catch (IOException ie) {\n            LOG.error(\"Unable to load database on disk\", ie);\n            throw new RuntimeException(\"Unable to run quorum server \", ie);\n        }\n    }\n\n    ResponderThread responder;\n\n    public synchronized void stopLeaderElection() {\n        responder.running = false;\n        responder.interrupt();\n    }\n    public synchronized void startLeaderElection() {\n        try {\n            if (getPeerState() == ServerState.LOOKING) {\n                currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n            }\n        } catch (IOException e) {\n            RuntimeException re = new RuntimeException(e.getMessage());\n            re.setStackTrace(e.getStackTrace());\n            throw re;\n        }\n\n        this.electionAlg = createElectionAlgorithm(electionType);\n    }\n\n    private void startJvmPauseMonitor() {\n        if (this.jvmPauseMonitor != null) {\n            this.jvmPauseMonitor.serviceStart();\n        }\n    }\n\n    /**\n     * Count the number of nodes in the map that could be followers.\n     * @param peers\n     * @return The number of followers in the map\n     */\n    protected static int countParticipants(Map<Long, QuorumServer> peers) {\n        int count = 0;\n        for (QuorumServer q : peers.values()) {\n            if (q.type == LearnerType.PARTICIPANT) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * This constructor is only used by the existing unit test code.\n     * It defaults to FileLogProvider persistence provider.\n     */\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit) throws IOException {\n        this(\n            quorumPeers,\n            snapDir,\n            logDir,\n            electionAlg,\n            myid,\n            tickTime,\n            initLimit,\n            syncLimit,\n            connectToLearnerMasterLimit,\n            false,\n            ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),\n            new QuorumMaj(quorumPeers));\n    }\n\n    /**\n     * This constructor is only used by the existing unit test code.\n     * It defaults to FileLogProvider persistence provider.\n     */\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, QuorumVerifier quorumConfig) throws IOException {\n        this(\n            quorumPeers,\n            snapDir,\n            logDir,\n            electionAlg,\n            myid,\n            tickTime,\n            initLimit,\n            syncLimit,\n            connectToLearnerMasterLimit,\n            false,\n            ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),\n            quorumConfig);\n    }\n\n    private static InetSocketAddress getClientAddress(Map<Long, QuorumServer> quorumPeers, long myid, int clientPort) throws IOException {\n        QuorumServer quorumServer = quorumPeers.get(myid);\n        if (null == quorumServer) {\n            throw new IOException(\"No QuorumServer correspoding to myid \" + myid);\n        }\n        if (null == quorumServer.clientAddr) {\n            return new InetSocketAddress(clientPort);\n        }\n        if (quorumServer.clientAddr.getPort() != clientPort) {\n            throw new IOException(\"QuorumServer port \"\n                                  + quorumServer.clientAddr.getPort()\n                                  + \" does not match with given port \"\n                                  + clientPort);\n        }\n        return quorumServer.clientAddr;\n    }\n\n    /**\n     * returns the highest zxid that this host has seen\n     *\n     * @return the highest zxid for this host\n     */\n    public long getLastLoggedZxid() {\n        if (!zkDb.isInitialized()) {\n            loadDataBase();\n        }\n        return zkDb.getDataTreeLastProcessedZxid();\n    }\n\n    public Follower follower;\n    public Leader leader;\n    public Observer observer;\n\n    protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {\n        return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));\n    }\n\n    protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception {\n        return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));\n    }\n\n    protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {\n        return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected Election createElectionAlgorithm(int electionAlgorithm) {\n        Election le = null;\n\n        //TODO: use a factory rather than a switch\n        switch (electionAlgorithm) {\n        case 1:\n            throw new UnsupportedOperationException(\"Election Algorithm 1 is not supported.\");\n        case 2:\n            throw new UnsupportedOperationException(\"Election Algorithm 2 is not supported.\");\n        case 3:\n            QuorumCnxManager qcm = createCnxnManager();\n            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);\n            if (oldQcm != null) {\n                LOG.warn(\"Clobbering already-set QuorumCnxManager (restarting leader election?)\");\n                oldQcm.halt();\n            }\n            QuorumCnxManager.Listener listener = qcm.listener;\n            if (listener != null) {\n                listener.start();\n                FastLeaderElection fle = new FastLeaderElection(this, qcm);\n                fle.start();\n                le = fle;\n            } else {\n                LOG.error(\"Null listener when initializing cnx manager\");\n            }\n            break;\n        default:\n            assert false;\n        }\n        return le;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected Election makeLEStrategy() {\n        LOG.debug(\"Initializing leader election protocol...\");\n        return electionAlg;\n    }\n\n    protected synchronized void setLeader(Leader newLeader) {\n        leader = newLeader;\n    }\n\n    protected synchronized void setFollower(Follower newFollower) {\n        follower = newFollower;\n    }\n\n    protected synchronized void setObserver(Observer newObserver) {\n        observer = newObserver;\n    }\n\n    public synchronized ZooKeeperServer getActiveServer() {\n        if (leader != null) {\n            return leader.zk;\n        } else if (follower != null) {\n            return follower.zk;\n        } else if (observer != null) {\n            return observer.zk;\n        }\n        return null;\n    }\n\n    boolean shuttingDownLE = false;\n\n    @Override\n    public void run() {\n        updateThreadName();\n\n        LOG.debug(\"Starting quorum peer\");\n        try {\n            jmxQuorumBean = new QuorumBean(this);\n            MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n            for (QuorumServer s : getView().values()) {\n                ZKMBeanInfo p;\n                if (getId() == s.id) {\n                    p = jmxLocalPeerBean = new LocalPeerBean(this);\n                    try {\n                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n                    } catch (Exception e) {\n                        LOG.warn(\"Failed to register with JMX\", e);\n                        jmxLocalPeerBean = null;\n                    }\n                } else {\n                    RemotePeerBean rBean = new RemotePeerBean(this, s);\n                    try {\n                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                        jmxRemotePeerBean.put(s.id, rBean);\n                    } catch (Exception e) {\n                        LOG.warn(\"Failed to register with JMX\", e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Failed to register with JMX\", e);\n            jmxQuorumBean = null;\n        }\n\n        try {\n            /*\n             * Main loop\n             */\n            while (running) {\n                if (unavailableStartTime == 0) {\n                    unavailableStartTime = Time.currentElapsedTime();\n                }\n\n                switch (getPeerState()) {\n                case LOOKING:\n                    LOG.info(\"LOOKING\");\n                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n\n                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n                        LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n\n                        // Create read-only server but don't start it immediately\n                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n\n                        // Instead of starting roZk immediately, wait some grace\n                        // period before we decide we're partitioned.\n                        //\n                        // Thread is used here because otherwise it would require\n                        // changes in each of election strategy classes which is\n                        // unnecessary code coupling.\n                        Thread roZkMgr = new Thread() {\n                            public void run() {\n                                try {\n                                    // lower-bound grace period to 2 secs\n                                    sleep(Math.max(2000, tickTime));\n                                    if (ServerState.LOOKING.equals(getPeerState())) {\n                                        roZk.startup();\n                                    }\n                                } catch (InterruptedException e) {\n                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n                                } catch (Exception e) {\n                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n                                }\n                            }\n                        };\n                        try {\n                            roZkMgr.start();\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        } finally {\n                            // If the thread is in the the grace period, interrupt\n                            // to come out of waiting.\n                            roZkMgr.interrupt();\n                            roZk.shutdown();\n                        }\n                    } else {\n                        try {\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        }\n                    }\n                    break;\n                case OBSERVING:\n                    try {\n                        LOG.info(\"OBSERVING\");\n                        setObserver(makeObserver(logFactory));\n                        observer.observeLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        observer.shutdown();\n                        setObserver(null);\n                        updateServerState();\n\n                        // Add delay jitter before we switch to LOOKING\n                        // state to reduce the load of ObserverMaster\n                        if (isRunning()) {\n                            Observer.waitForObserverElectionDelay();\n                        }\n                    }\n                    break;\n                case FOLLOWING:\n                    try {\n                        LOG.info(\"FOLLOWING\");\n                        setFollower(makeFollower(logFactory));\n                        follower.followLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        follower.shutdown();\n                        setFollower(null);\n                        updateServerState();\n                    }\n                    break;\n                case LEADING:\n                    LOG.info(\"LEADING\");\n                    try {\n                        setLeader(makeLeader(logFactory));\n                        leader.lead();\n                        setLeader(null);\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        if (leader != null) {\n                            leader.shutdown(\"Forcing shutdown\");\n                            setLeader(null);\n                        }\n                        updateServerState();\n                    }\n                    break;\n                }\n            }\n        } finally {\n            LOG.warn(\"QuorumPeer main thread exited\");\n            MBeanRegistry instance = MBeanRegistry.getInstance();\n            instance.unregister(jmxQuorumBean);\n            instance.unregister(jmxLocalPeerBean);\n\n            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n                instance.unregister(remotePeerBean);\n            }\n\n            jmxQuorumBean = null;\n            jmxLocalPeerBean = null;\n            jmxRemotePeerBean = null;\n        }\n    }\n\n    private synchronized void updateServerState() {\n        if (!reconfigFlag) {\n            setPeerState(ServerState.LOOKING);\n            LOG.warn(\"PeerState set to LOOKING\");\n            return;\n        }\n\n        if (getId() == getCurrentVote().getId()) {\n            setPeerState(ServerState.LEADING);\n            LOG.debug(\"PeerState set to LEADING\");\n        } else if (getLearnerType() == LearnerType.PARTICIPANT) {\n            setPeerState(ServerState.FOLLOWING);\n            LOG.debug(\"PeerState set to FOLLOWING\");\n        } else if (getLearnerType() == LearnerType.OBSERVER) {\n            setPeerState(ServerState.OBSERVING);\n            LOG.debug(\"PeerState set to OBSERVER\");\n        } else { // currently shouldn't happen since there are only 2 learner types\n            setPeerState(ServerState.LOOKING);\n            LOG.debug(\"Should not be here\");\n        }\n        reconfigFlag = false;\n    }\n\n    public void shutdown() {\n        running = false;\n        x509Util.close();\n        if (leader != null) {\n            leader.shutdown(\"quorum Peer shutdown\");\n        }\n        if (follower != null) {\n            follower.shutdown();\n        }\n        shutdownServerCnxnFactory();\n        if (udpSocket != null) {\n            udpSocket.close();\n        }\n        if (jvmPauseMonitor != null) {\n            jvmPauseMonitor.serviceStop();\n        }\n\n        try {\n            adminServer.shutdown();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem stopping AdminServer\", e);\n        }\n\n        if (getElectionAlg() != null) {\n            this.interrupt();\n            getElectionAlg().shutdown();\n        }\n        try {\n            zkDb.close();\n        } catch (IOException ie) {\n            LOG.warn(\"Error closing logs \", ie);\n        }\n    }\n\n    /**\n     * A 'view' is a node's current opinion of the membership of the entire\n     * ensemble.\n     */\n    public Map<Long, QuorumPeer.QuorumServer> getView() {\n        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());\n    }\n\n    /**\n     * Observers are not contained in this view, only nodes with\n     * PeerType=PARTICIPANT.\n     */\n    public Map<Long, QuorumPeer.QuorumServer> getVotingView() {\n        return getQuorumVerifier().getVotingMembers();\n    }\n\n    /**\n     * Returns only observers, no followers.\n     */\n    public Map<Long, QuorumPeer.QuorumServer> getObservingView() {\n        return getQuorumVerifier().getObservingMembers();\n    }\n\n    public synchronized Set<Long> getCurrentAndNextConfigVoters() {\n        Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier().getVotingMembers().keySet());\n        if (getLastSeenQuorumVerifier() != null) {\n            voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());\n        }\n        return voterIds;\n    }\n\n    /**\n     * Check if a node is in the current view. With static membership, the\n     * result of this check will never change; only when dynamic membership\n     * is introduced will this be more useful.\n     */\n    public boolean viewContains(Long sid) {\n        return this.getView().containsKey(sid);\n    }\n\n    /**\n     * Only used by QuorumStats at the moment\n     */\n    public String[] getQuorumPeers() {\n        List<String> l = new ArrayList<String>();\n        synchronized (this) {\n            if (leader != null) {\n                for (LearnerHandler fh : leader.getLearners()) {\n                    if (fh.getSocket() != null) {\n                        String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());\n                        if (leader.isLearnerSynced(fh)) {\n                            s += \"*\";\n                        }\n                        l.add(s);\n                    }\n                }\n            } else if (follower != null) {\n                l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));\n            }\n        }\n        return l.toArray(new String[0]);\n    }\n\n    public String getServerState() {\n        switch (getPeerState()) {\n        case LOOKING:\n            return QuorumStats.Provider.LOOKING_STATE;\n        case LEADING:\n            return QuorumStats.Provider.LEADING_STATE;\n        case FOLLOWING:\n            return QuorumStats.Provider.FOLLOWING_STATE;\n        case OBSERVING:\n            return QuorumStats.Provider.OBSERVING_STATE;\n        }\n        return QuorumStats.Provider.UNKNOWN_STATE;\n    }\n\n    /**\n     * set the id of this quorum peer.\n     */\n    public void setMyid(long myid) {\n        this.myid = myid;\n    }\n\n    public void setInitialConfig(String initialConfig) {\n        this.initialConfig = initialConfig;\n    }\n\n    public String getInitialConfig() {\n        return initialConfig;\n    }\n\n    /**\n     * Get the number of milliseconds of each tick\n     */\n    public int getTickTime() {\n        return tickTime;\n    }\n\n    /**\n     * Set the number of milliseconds of each tick\n     */\n    public void setTickTime(int tickTime) {\n        LOG.info(\"tickTime set to {}\", tickTime);\n        this.tickTime = tickTime;\n    }\n\n    /** Maximum number of connections allowed from particular host (ip) */\n    public int getMaxClientCnxnsPerHost() {\n        if (cnxnFactory != null) {\n            return cnxnFactory.getMaxClientCnxnsPerHost();\n        }\n        if (secureCnxnFactory != null) {\n            return secureCnxnFactory.getMaxClientCnxnsPerHost();\n        }\n        return -1;\n    }\n\n    /** Whether local sessions are enabled */\n    public boolean areLocalSessionsEnabled() {\n        return localSessionsEnabled;\n    }\n\n    /** Whether to enable local sessions */\n    public void enableLocalSessions(boolean flag) {\n        LOG.info(\"Local sessions {}\", (flag ? \"enabled\" : \"disabled\"));\n        localSessionsEnabled = flag;\n    }\n\n    /** Whether local sessions are allowed to upgrade to global sessions */\n    public boolean isLocalSessionsUpgradingEnabled() {\n        return localSessionsUpgradingEnabled;\n    }\n\n    /** Whether to allow local sessions to upgrade to global sessions */\n    public void enableLocalSessionsUpgrading(boolean flag) {\n        LOG.info(\"Local session upgrading {}\", (flag ? \"enabled\" : \"disabled\"));\n        localSessionsUpgradingEnabled = flag;\n    }\n\n    /** minimum session timeout in milliseconds */\n    public int getMinSessionTimeout() {\n        return minSessionTimeout;\n    }\n\n    /** minimum session timeout in milliseconds */\n    public void setMinSessionTimeout(int min) {\n        LOG.info(\"minSessionTimeout set to {}\", min);\n        this.minSessionTimeout = min;\n    }\n\n    /** maximum session timeout in milliseconds */\n    public int getMaxSessionTimeout() {\n        return maxSessionTimeout;\n    }\n\n    /** maximum session timeout in milliseconds */\n    public void setMaxSessionTimeout(int max) {\n        LOG.info(\"maxSessionTimeout set to {}\", max);\n        this.maxSessionTimeout = max;\n    }\n\n    /** The server socket's listen backlog length */\n    public int getClientPortListenBacklog() {\n        return this.clientPortListenBacklog;\n    }\n\n    /** Sets the server socket's listen backlog length. */\n    public void setClientPortListenBacklog(int backlog) {\n        this.clientPortListenBacklog = backlog;\n    }\n\n    /**\n     * Get the number of ticks that the initial synchronization phase can take\n     */\n    public int getInitLimit() {\n        return initLimit;\n    }\n\n    /**\n     * Set the number of ticks that the initial synchronization phase can take\n     */\n    public void setInitLimit(int initLimit) {\n        LOG.info(\"initLimit set to {}\", initLimit);\n        this.initLimit = initLimit;\n    }\n\n    /**\n     * Get the current tick\n     */\n    public int getTick() {\n        return tick.get();\n    }\n\n    public QuorumVerifier configFromString(String s) throws IOException, ConfigException {\n        Properties props = new Properties();\n        props.load(new StringReader(s));\n        return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);\n    }\n\n    /**\n     * Return QuorumVerifier object for the last committed configuration.\n     */\n    public QuorumVerifier getQuorumVerifier() {\n        synchronized (QV_LOCK) {\n            return quorumVerifier;\n        }\n    }\n\n    /**\n     * Return QuorumVerifier object for the last proposed configuration.\n     */\n    public QuorumVerifier getLastSeenQuorumVerifier() {\n        synchronized (QV_LOCK) {\n            return lastSeenQuorumVerifier;\n        }\n    }\n\n    public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW) {\n        if (qvOLD == null || !qvOLD.equals(qvNEW)) {\n            LOG.warn(\"Restarting Leader Election\");\n            getElectionAlg().shutdown();\n            shuttingDownLE = false;\n            startLeaderElection();\n        }\n    }\n\n    public String getNextDynamicConfigFilename() {\n        if (configFilename == null) {\n            LOG.warn(\"configFilename is null! This should only happen in tests.\");\n            return null;\n        }\n        return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;\n    }\n\n    // On entry to this method, qcm must be non-null and the locks on both qcm and QV_LOCK\n    // must be held.  We don't want quorumVerifier/lastSeenQuorumVerifier to change out from\n    // under us, so we have to hold QV_LOCK; and since the call to qcm.connectOne() will take\n    // the lock on qcm (and take QV_LOCK again inside that), the caller needs to have taken\n    // qcm outside QV_LOCK to avoid a deadlock against other callers of qcm.connectOne().\n    private void connectNewPeers(QuorumCnxManager qcm) {\n        if (quorumVerifier != null && lastSeenQuorumVerifier != null) {\n            Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();\n            for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {\n                if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) {\n                    qcm.connectOne(e.getKey());\n                }\n            }\n        }\n    }\n\n    public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk) {\n        if (!isReconfigEnabled()) {\n            LOG.info(\"Dynamic reconfig is disabled, we don't store the last seen config.\");\n            return;\n        }\n\n        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm\n        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't\n        // deadlock against other callers of connectOne().  If qcmRef gets set in another\n        // thread while we're inside the synchronized block, that does no harm; if we didn't\n        // take a lock on qcm (because it was null when we sampled it), we won't call\n        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility\n        // of updates that provably happen in another thread before entering this method.)\n        QuorumCnxManager qcm = qcmRef.get();\n        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;\n        synchronized (outerLockObject) {\n            synchronized (QV_LOCK) {\n                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n                    LOG.error(\"setLastSeenQuorumVerifier called with stale config \"\n                              + qv.getVersion()\n                              + \". Current version: \"\n                              + quorumVerifier.getVersion());\n                }\n                // assuming that a version uniquely identifies a configuration, so if\n                // version is the same, nothing to do here.\n                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n                    return;\n                }\n                lastSeenQuorumVerifier = qv;\n                if (qcm != null) {\n                    connectNewPeers(qcm);\n                }\n\n                if (writeToDisk) {\n                    try {\n                        String fileName = getNextDynamicConfigFilename();\n                        if (fileName != null) {\n                            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n                        }\n                    } catch (IOException e) {\n                        LOG.error(\"Error writing next dynamic config file to disk\", e);\n                    }\n                }\n            }\n        }\n    }\n\n    public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk) {\n        synchronized (QV_LOCK) {\n            if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n                // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n                // and then got the same config in UPTODATE message so its already known\n                LOG.debug(\n                    \"{} setQuorumVerifier called with known or old config {}. Current version: {}\",\n                    getId(),\n                    qv.getVersion(),\n                    quorumVerifier.getVersion());\n                return quorumVerifier;\n            }\n            QuorumVerifier prevQV = quorumVerifier;\n            quorumVerifier = qv;\n            if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {\n                lastSeenQuorumVerifier = qv;\n            }\n\n            if (writeToDisk) {\n                // some tests initialize QuorumPeer without a static config file\n                if (configFilename != null) {\n                    try {\n                        String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n                        QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n                        QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n                    } catch (IOException e) {\n                        LOG.error(\"Error closing file\", e);\n                    }\n                } else {\n                    LOG.info(\"writeToDisk == true but configFilename == null\");\n                }\n            }\n\n            if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {\n                QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());\n            }\n            QuorumServer qs = qv.getAllMembers().get(getId());\n            if (qs != null) {\n                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n            }\n            updateObserverMasterList();\n            return prevQV;\n        }\n    }\n\n    private String makeDynamicConfigFilename(long version) {\n        return configFilename + \".dynamic.\" + Long.toHexString(version);\n    }\n\n    private boolean needEraseClientInfoFromStaticConfig() {\n        QuorumServer server = quorumVerifier.getAllMembers().get(getId());\n        return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);\n    }\n\n    /**\n     * Get an instance of LeaderElection\n     */\n    public Election getElectionAlg() {\n        return electionAlg;\n    }\n\n    /**\n     * Get the synclimit\n     */\n    public int getSyncLimit() {\n        return syncLimit;\n    }\n\n    /**\n     * Set the synclimit\n     */\n    public void setSyncLimit(int syncLimit) {\n        LOG.info(\"syncLimit set to {}\", syncLimit);\n        this.syncLimit = syncLimit;\n    }\n\n    /**\n     * Get the connectToLearnerMasterLimit\n     */\n    public int getConnectToLearnerMasterLimit() {\n        return connectToLearnerMasterLimit;\n    }\n\n    /**\n     * Set the connectToLearnerMasterLimit\n     */\n    public void setConnectToLearnerMasterLimit(int connectToLearnerMasterLimit) {\n        LOG.info(\"connectToLearnerMasterLimit set to {}\", connectToLearnerMasterLimit);\n        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;\n    }\n\n    /**\n     * The syncEnabled can also be set via a system property.\n     */\n    public static final String SYNC_ENABLED = \"zookeeper.observer.syncEnabled\";\n\n    /**\n     * Return syncEnabled.\n     */\n    public boolean getSyncEnabled() {\n        if (System.getProperty(SYNC_ENABLED) != null) {\n            LOG.info(\"{}={}\", SYNC_ENABLED, Boolean.getBoolean(SYNC_ENABLED));\n            return Boolean.getBoolean(SYNC_ENABLED);\n        } else {\n            return syncEnabled;\n        }\n    }\n\n    /**\n     * Set syncEnabled.\n     *\n     * @param syncEnabled\n     */\n    public void setSyncEnabled(boolean syncEnabled) {\n        this.syncEnabled = syncEnabled;\n    }\n\n    /**\n     * Gets the election type\n     */\n    public int getElectionType() {\n        return electionType;\n    }\n\n    /**\n     * Sets the election type\n     */\n    public void setElectionType(int electionType) {\n        this.electionType = electionType;\n    }\n\n    public boolean getQuorumListenOnAllIPs() {\n        return quorumListenOnAllIPs;\n    }\n\n    public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs) {\n        this.quorumListenOnAllIPs = quorumListenOnAllIPs;\n    }\n\n    public void setCnxnFactory(ServerCnxnFactory cnxnFactory) {\n        this.cnxnFactory = cnxnFactory;\n    }\n\n    public void setSecureCnxnFactory(ServerCnxnFactory secureCnxnFactory) {\n        this.secureCnxnFactory = secureCnxnFactory;\n    }\n\n    public void setSslQuorum(boolean sslQuorum) {\n        if (sslQuorum) {\n            LOG.info(\"Using TLS encrypted quorum communication\");\n        } else {\n            LOG.info(\"Using insecure (non-TLS) quorum communication\");\n        }\n        this.sslQuorum = sslQuorum;\n    }\n\n    public void setUsePortUnification(boolean shouldUsePortUnification) {\n        LOG.info(\"Port unification {}\", shouldUsePortUnification ? \"enabled\" : \"disabled\");\n        this.shouldUsePortUnification = shouldUsePortUnification;\n    }\n\n    private void startServerCnxnFactory() {\n        if (cnxnFactory != null) {\n            cnxnFactory.start();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.start();\n        }\n    }\n\n    private void shutdownServerCnxnFactory() {\n        if (cnxnFactory != null) {\n            cnxnFactory.shutdown();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.shutdown();\n        }\n    }\n\n    // Leader and learner will control the zookeeper server and pass it into QuorumPeer.\n    public void setZooKeeperServer(ZooKeeperServer zks) {\n        if (cnxnFactory != null) {\n            cnxnFactory.setZooKeeperServer(zks);\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.setZooKeeperServer(zks);\n        }\n    }\n\n    public void closeAllConnections() {\n        if (cnxnFactory != null) {\n            cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n        }\n    }\n\n    public int getClientPort() {\n        if (cnxnFactory != null) {\n            return cnxnFactory.getLocalPort();\n        }\n        return -1;\n    }\n\n    public void setTxnFactory(FileTxnSnapLog factory) {\n        this.logFactory = factory;\n    }\n\n    public FileTxnSnapLog getTxnFactory() {\n        return this.logFactory;\n    }\n\n    /**\n     * set zk database for this node\n     * @param database\n     */\n    public void setZKDatabase(ZKDatabase database) {\n        this.zkDb = database;\n    }\n\n    protected ZKDatabase getZkDb() {\n        return zkDb;\n    }\n\n    public synchronized void initConfigInZKDatabase() {\n        if (zkDb != null) {\n            zkDb.initConfigInZKDatabase(getQuorumVerifier());\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    /**\n     * get reference to QuorumCnxManager\n     */\n    public QuorumCnxManager getQuorumCnxManager() {\n        return qcmRef.get();\n    }\n    private long readLongFromFile(String name) throws IOException {\n        File file = new File(logFactory.getSnapDir(), name);\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String line = \"\";\n        try {\n            line = br.readLine();\n            return Long.parseLong(line);\n        } catch (NumberFormatException e) {\n            throw new IOException(\"Found \" + line + \" in \" + file);\n        } finally {\n            br.close();\n        }\n    }\n\n    private long acceptedEpoch = -1;\n    private long currentEpoch = -1;\n\n    public static final String CURRENT_EPOCH_FILENAME = \"currentEpoch\";\n\n    public static final String ACCEPTED_EPOCH_FILENAME = \"acceptedEpoch\";\n\n    /**\n     * Write a long value to disk atomically. Either succeeds or an exception\n     * is thrown.\n     * @param name file name to write the long to\n     * @param value the long value to write to the named file\n     * @throws IOException if the file cannot be written atomically\n     */\n    // visibleForTest\n     void writeLongToFile(String name, final long value) throws IOException {\n        File file = new File(logFactory.getSnapDir(), name);\n        new AtomicFileWritingIdiom(file, new WriterStatement() {\n            @Override\n            public void write(Writer bw) throws IOException {\n                bw.write(Long.toString(value));\n            }\n        });\n    }\n\n    public long getCurrentEpoch() throws IOException {\n        if (currentEpoch == -1) {\n            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n        }\n        return currentEpoch;\n    }\n\n    public long getAcceptedEpoch() throws IOException {\n        if (acceptedEpoch == -1) {\n            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n        }\n        return acceptedEpoch;\n    }\n\n    public void setCurrentEpoch(long e) throws IOException {\n        writeLongToFile(CURRENT_EPOCH_FILENAME, e);\n        currentEpoch = e;\n\n    }\n\n    public void setAcceptedEpoch(long e) throws IOException {\n        writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);\n        acceptedEpoch = e;\n    }\n\n    public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE) {\n        if (!isReconfigEnabled()) {\n            LOG.debug(\"Reconfig feature is disabled, skip reconfig processing.\");\n            return false;\n        }\n\n        InetSocketAddress oldClientAddr = getClientAddress();\n\n        // update last committed quorum verifier, write the new config to disk\n        // and restart leader election if config changed.\n        QuorumVerifier prevQV = setQuorumVerifier(qv, true);\n\n        // There is no log record for the initial config, thus after syncing\n        // with leader\n        // /zookeeper/config is empty! it is also possible that last committed\n        // config is propagated during leader election\n        // without the propagation the corresponding log records.\n        // so we should explicitly do this (this is not necessary when we're\n        // already a Follower/Observer, only\n        // for Learner):\n        initConfigInZKDatabase();\n\n        if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {\n            Map<Long, QuorumServer> newMembers = qv.getAllMembers();\n            updateRemotePeerMXBeans(newMembers);\n            if (restartLE) {\n                restartLeaderElection(prevQV, qv);\n            }\n\n            QuorumServer myNewQS = newMembers.get(getId());\n            if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {\n                cnxnFactory.reconfigure(myNewQS.clientAddr);\n                updateThreadName();\n            }\n\n            boolean roleChange = updateLearnerType(qv);\n            boolean leaderChange = false;\n            if (suggestedLeaderId != null) {\n                // zxid should be non-null too\n                leaderChange = updateVote(suggestedLeaderId, zxid);\n            } else {\n                long currentLeaderId = getCurrentVote().getId();\n                QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);\n                QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);\n                leaderChange = (myleaderInCurQV == null\n                                || myleaderInCurQV.addr == null\n                                || myleaderInNewQV == null\n                                || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));\n                // we don't have a designated leader - need to go into leader\n                // election\n                reconfigFlagClear();\n            }\n\n            return roleChange || leaderChange;\n        }\n        return false;\n\n    }\n\n    private void updateRemotePeerMXBeans(Map<Long, QuorumServer> newMembers) {\n        Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());\n        existingMembers.retainAll(jmxRemotePeerBean.keySet());\n        for (Long id : existingMembers) {\n            RemotePeerBean rBean = jmxRemotePeerBean.get(id);\n            rBean.setQuorumServer(newMembers.get(id));\n        }\n\n        Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());\n        joiningMembers.removeAll(jmxRemotePeerBean.keySet());\n        joiningMembers.remove(getId()); // remove self as it is local bean\n        for (Long id : joiningMembers) {\n            QuorumServer qs = newMembers.get(id);\n            RemotePeerBean rBean = new RemotePeerBean(this, qs);\n            try {\n                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                jmxRemotePeerBean.put(qs.id, rBean);\n            } catch (Exception e) {\n                LOG.warn(\"Failed to register with JMX\", e);\n            }\n        }\n\n        Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());\n        leavingMembers.removeAll(newMembers.keySet());\n        for (Long id : leavingMembers) {\n            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);\n            try {\n                MBeanRegistry.getInstance().unregister(rBean);\n            } catch (Exception e) {\n                LOG.warn(\"Failed to unregister with JMX\", e);\n            }\n        }\n    }\n\n    private ArrayList<QuorumServer> observerMasters = new ArrayList<>();\n    private void updateObserverMasterList() {\n        if (observerMasterPort <= 0) {\n            return; // observer masters not enabled\n        }\n        observerMasters.clear();\n        StringBuilder sb = new StringBuilder();\n        for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {\n            InetAddress address = server.addr.getReachableOrOne().getAddress();\n            InetSocketAddress addr = new InetSocketAddress(address, observerMasterPort);\n            observerMasters.add(new QuorumServer(server.id, addr));\n            sb.append(addr).append(\",\");\n        }\n        LOG.info(\"Updated learner master list to be {}\", sb.toString());\n        Collections.shuffle(observerMasters);\n        // Reset the internal index of the observerMaster when\n        // the observerMaster List is refreshed\n        nextObserverMaster = 0;\n    }\n\n    private boolean useObserverMasters() {\n        return getLearnerType() == LearnerType.OBSERVER && observerMasters.size() > 0;\n    }\n\n    private int nextObserverMaster = 0;\n    private QuorumServer nextObserverMaster() {\n        if (nextObserverMaster >= observerMasters.size()) {\n            nextObserverMaster = 0;\n            // Add a reconnect delay only after the observer\n            // has exhausted trying to connect to all the masters\n            // from the observerMasterList\n            if (isRunning()) {\n                Observer.waitForReconnectDelay();\n            }\n        }\n        return observerMasters.get(nextObserverMaster++);\n    }\n\n    QuorumServer findLearnerMaster(QuorumServer leader) {\n        if (useObserverMasters()) {\n            return nextObserverMaster();\n        } else {\n            // Add delay jitter to reduce the load on the leader\n            if (isRunning()) {\n                Observer.waitForReconnectDelay();\n            }\n            return leader;\n        }\n    }\n\n    /**\n     * Vet a given learner master's information.\n     * Allows specification by server id, ip  only, or ip and port\n     */\n    QuorumServer validateLearnerMaster(String desiredMaster) {\n        if (useObserverMasters()) {\n            Long sid;\n            try {\n                sid = Long.parseLong(desiredMaster);\n            } catch (NumberFormatException e) {\n                sid = null;\n            }\n            for (QuorumServer server : observerMasters) {\n                if (sid == null) {\n                    for (InetSocketAddress address : server.addr.getAllAddresses()) {\n                        String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();\n                        if (serverAddr.startsWith(desiredMaster)) {\n                            return server;\n                        }\n                    }\n                } else {\n                    if (sid.equals(server.id)) {\n                        return server;\n                    }\n                }\n            }\n            if (sid == null) {\n                LOG.info(\"could not find learner master address={}\", desiredMaster);\n            } else {\n                LOG.warn(\"could not find learner master sid={}\", sid);\n            }\n        } else {\n            LOG.info(\"cannot validate request, observer masters not enabled\");\n        }\n        return null;\n    }\n\n    private boolean updateLearnerType(QuorumVerifier newQV) {\n        //check if I'm an observer in new config\n        if (newQV.getObservingMembers().containsKey(getId())) {\n            if (getLearnerType() != LearnerType.OBSERVER) {\n                setLearnerType(LearnerType.OBSERVER);\n                LOG.info(\"Becoming an observer\");\n                reconfigFlagSet();\n                return true;\n            } else {\n                return false;\n            }\n        } else if (newQV.getVotingMembers().containsKey(getId())) {\n            if (getLearnerType() != LearnerType.PARTICIPANT) {\n                setLearnerType(LearnerType.PARTICIPANT);\n                LOG.info(\"Becoming a voting participant\");\n                reconfigFlagSet();\n                return true;\n            } else {\n                return false;\n            }\n        }\n        // I'm not in the view\n        if (getLearnerType() != LearnerType.PARTICIPANT) {\n            setLearnerType(LearnerType.PARTICIPANT);\n            LOG.info(\"Becoming a non-voting participant\");\n            reconfigFlagSet();\n            return true;\n        }\n        return false;\n    }\n\n    private boolean updateVote(long designatedLeader, long zxid) {\n        Vote currentVote = getCurrentVote();\n        if (currentVote != null && designatedLeader != currentVote.getId()) {\n            setCurrentVote(new Vote(designatedLeader, zxid));\n            reconfigFlagSet();\n            LOG.warn(\"Suggested leader: {}\", designatedLeader);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Updates leader election info to avoid inconsistencies when\n     * a new server tries to join the ensemble.\n     *\n     * Here is the inconsistency scenario we try to solve by updating the peer\n     * epoch after following leader:\n     *\n     * Let's say we have an ensemble with 3 servers z1, z2 and z3.\n     *\n     * 1. z1, z2 were following z3 with peerEpoch to be 0xb8, the new epoch is\n     *    0xb9, aka current accepted epoch on disk.\n     * 2. z2 get restarted, which will use 0xb9 as it's peer epoch when loading\n     *    the current accept epoch from disk.\n     * 3. z2 received notification from z1 and z3, which is following z3 with\n     *    epoch 0xb8, so it started following z3 again with peer epoch 0xb8.\n     * 4. before z2 successfully connected to z3, z3 get restarted with new\n     *    epoch 0xb9.\n     * 5. z2 will retry around a few round (default 5s) before giving up,\n     *    meanwhile it will report z3 as leader.\n     * 6. z1 restarted, and looking with peer epoch 0xb9.\n     * 7. z1 voted z3, and z3 was elected as leader again with peer epoch 0xb9.\n     * 8. z2 successfully connected to z3 before giving up, but with peer\n     *    epoch 0xb8.\n     * 9. z1 get restarted, looking for leader with peer epoch 0xba, but cannot\n     *    join, because z2 is reporting peer epoch 0xb8, while z3 is reporting\n     *    0xb9.\n     *\n     * By updating the election vote after actually following leader, we can\n     * avoid this kind of stuck happened.\n     *\n     * Btw, the zxid and electionEpoch could be inconsistent because of the same\n     * reason, it's better to update these as well after syncing with leader, but\n     * that required protocol change which is non trivial. This problem is worked\n     * around by skipping comparing the zxid and electionEpoch when counting for\n     * votes for out of election servers during looking for leader.\n     *\n     * See https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n     */\n    protected void updateElectionVote(long newEpoch) {\n        Vote currentVote = getCurrentVote();\n        if (currentVote != null) {\n            setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote\n                .getState()));\n        }\n    }\n\n    private void updateThreadName() {\n        String plain = cnxnFactory != null\n                ? cnxnFactory.getLocalAddress() != null\n                    ? formatInetAddr(cnxnFactory.getLocalAddress())\n                    : \"disabled\"\n                : \"disabled\";\n        String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : \"disabled\";\n        setName(String.format(\"QuorumPeer[myid=%d](plain=%s)(secure=%s)\", getId(), plain, secure));\n    }\n\n    /**\n     * Sets the time taken for leader election in milliseconds.\n     *\n     * @param electionTimeTaken time taken for leader election\n     */\n    void setElectionTimeTaken(long electionTimeTaken) {\n        this.electionTimeTaken = electionTimeTaken;\n    }\n\n    /**\n     * @return the time taken for leader election in milliseconds.\n     */\n    long getElectionTimeTaken() {\n        return electionTimeTaken;\n    }\n\n    void setQuorumServerSaslRequired(boolean serverSaslRequired) {\n        quorumServerSaslAuthRequired = serverSaslRequired;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, serverSaslRequired);\n    }\n\n    void setQuorumLearnerSaslRequired(boolean learnerSaslRequired) {\n        quorumLearnerSaslAuthRequired = learnerSaslRequired;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, learnerSaslRequired);\n    }\n\n    void setQuorumSaslEnabled(boolean enableAuth) {\n        quorumSaslEnableAuth = enableAuth;\n        if (!quorumSaslEnableAuth) {\n            LOG.info(\"QuorumPeer communication is not secured! (SASL auth disabled)\");\n        } else {\n            LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);\n        }\n    }\n\n    void setQuorumServicePrincipal(String servicePrincipal) {\n        quorumServicePrincipal = servicePrincipal;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, quorumServicePrincipal);\n    }\n\n    void setQuorumLearnerLoginContext(String learnerContext) {\n        quorumLearnerLoginContext = learnerContext;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, quorumLearnerLoginContext);\n    }\n\n    void setQuorumServerLoginContext(String serverContext) {\n        quorumServerLoginContext = serverContext;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT, quorumServerLoginContext);\n    }\n\n    void setQuorumCnxnThreadsSize(int qCnxnThreadsSize) {\n        if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {\n            quorumCnxnThreadsSize = qCnxnThreadsSize;\n        }\n        LOG.info(\"quorum.cnxn.threads.size set to {}\", quorumCnxnThreadsSize);\n    }\n\n    boolean isQuorumSaslAuthEnabled() {\n        return quorumSaslEnableAuth;\n    }\n\n    private boolean isQuorumServerSaslAuthRequired() {\n        return quorumServerSaslAuthRequired;\n    }\n\n    private boolean isQuorumLearnerSaslAuthRequired() {\n        return quorumLearnerSaslAuthRequired;\n    }\n\n    public QuorumCnxManager createCnxnManager() {\n        int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;\n        LOG.info(\"Using {}ms as the quorum cnxn socket timeout\", timeout);\n        return new QuorumCnxManager(\n            this,\n            this.getId(),\n            this.getView(),\n            this.authServer,\n            this.authLearner,\n            timeout,\n            this.getQuorumListenOnAllIPs(),\n            this.quorumCnxnThreadsSize,\n            this.isQuorumSaslAuthEnabled());\n    }\n\n    boolean isLeader(long id) {\n        Vote vote = getCurrentVote();\n        return vote != null && id == vote.getId();\n    }\n\n    public boolean isReconfigEnabled() {\n        return reconfigEnabled;\n    }\n\n    @InterfaceAudience.Private\n    /**\n     * This is a metric that depends on the status of the peer.\n     */ public Integer getSynced_observers_metric() {\n        if (leader != null) {\n            return leader.getObservingLearners().size();\n        } else if (follower != null) {\n            return follower.getSyncedObserverSize();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Create a new QuorumPeer and apply all the values per the already-parsed config.\n     *\n     * @param config The appertained quorum peer config.\n     * @return A QuorumPeer instantiated with specified peer config. Note this peer\n     *         is not fully initialized; caller should finish initialization through\n     *         additional configurations (connection factory settings, etc).\n     *\n     * @throws IOException\n     */\n    public static QuorumPeer createFromConfig(QuorumPeerConfig config) throws IOException {\n        QuorumPeer quorumPeer = new QuorumPeer();\n        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));\n        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());\n        quorumPeer.setElectionType(config.getElectionAlg());\n        quorumPeer.setMyid(config.getServerId());\n        quorumPeer.setTickTime(config.getTickTime());\n        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n        quorumPeer.setInitLimit(config.getInitLimit());\n        quorumPeer.setSyncLimit(config.getSyncLimit());\n        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());\n        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());\n        quorumPeer.setConfigFileName(config.getConfigFilename());\n        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());\n        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n        if (config.getLastSeenQuorumVerifier() != null) {\n            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n        }\n        quorumPeer.initConfigInZKDatabase();\n        quorumPeer.setSslQuorum(config.isSslQuorum());\n        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());\n        quorumPeer.setLearnerType(config.getPeerType());\n        quorumPeer.setSyncEnabled(config.getSyncEnabled());\n        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n        if (config.sslQuorumReloadCertFiles) {\n            quorumPeer.getX509Util().enableCertFileReloading();\n        }\n        quorumPeer.setMultiAddressEnabled(config.isMultiAddressEnabled());\n        quorumPeer.setMultiAddressReachabilityCheckEnabled(config.isMultiAddressReachabilityCheckEnabled());\n        quorumPeer.setMultiAddressReachabilityCheckTimeoutMs(config.getMultiAddressReachabilityCheckTimeoutMs());\n\n        // sets quorum sasl authentication configurations\n        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n        if (quorumPeer.isQuorumSaslAuthEnabled()) {\n            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n        }\n        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n\n        if (config.jvmPauseMonitorToRun) {\n            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));\n        }\n\n        return quorumPeer;\n    }\n\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.quorum;\n\nimport static org.apache.zookeeper.common.NetUtils.formatInetAddr;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.StringReader;\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicLong;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\nimport javax.security.sasl.SaslException;\nimport org.apache.yetus.audience.InterfaceAudience;\nimport org.apache.zookeeper.KeeperException.BadArgumentsException;\nimport org.apache.zookeeper.common.AtomicFileWritingIdiom;\nimport org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;\nimport org.apache.zookeeper.common.QuorumX509Util;\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.common.X509Exception;\nimport org.apache.zookeeper.jmx.MBeanRegistry;\nimport org.apache.zookeeper.jmx.ZKMBeanInfo;\nimport org.apache.zookeeper.server.ServerCnxn;\nimport org.apache.zookeeper.server.ServerCnxnFactory;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ZKDatabase;\nimport org.apache.zookeeper.server.ZooKeeperServer;\nimport org.apache.zookeeper.server.ZooKeeperThread;\nimport org.apache.zookeeper.server.admin.AdminServer;\nimport org.apache.zookeeper.server.admin.AdminServer.AdminServerException;\nimport org.apache.zookeeper.server.admin.AdminServerFactory;\nimport org.apache.zookeeper.server.persistence.FileTxnSnapLog;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;\nimport org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;\nimport org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;\nimport org.apache.zookeeper.server.quorum.auth.QuorumAuth;\nimport org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\nimport org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\nimport org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;\nimport org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;\nimport org.apache.zookeeper.server.quorum.flexible.QuorumMaj;\nimport org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\nimport org.apache.zookeeper.server.util.ConfigUtils;\nimport org.apache.zookeeper.server.util.JvmPauseMonitor;\nimport org.apache.zookeeper.server.util.ZxidUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This class manages the quorum protocol. There are three states this server\n * can be in:\n * <ol>\n * <li>Leader election - each server will elect a leader (proposing itself as a\n * leader initially).<\/li>\n * <li>Follower - the server will synchronize with the leader and replicate any\n * transactions.<\/li>\n * <li>Leader - the server will process requests and forward them to followers.\n * A majority of followers must log the request before it can be accepted.\n * <\/ol>\n *\n * This class will setup a datagram socket that will always respond with its\n * view of the current leader. The response will take the form of:\n *\n * <pre>\n * int xid;\n *\n * long myid;\n *\n * long leader_id;\n *\n * long leader_zxid;\n * <\/pre>\n *\n * The request for the current leader will consist solely of an xid: int xid;\n */\npublic class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider {\n\n    private static final Logger LOG = LoggerFactory.getLogger(QuorumPeer.class);\n\n    public static final String CONFIG_KEY_KERBEROS_CANONICALIZE_HOST_NAMES = \"zookeeper.kerberos.canonicalizeHostNames\";\n    public static final String CONFIG_DEFAULT_KERBEROS_CANONICALIZE_HOST_NAMES = \"false\";\n\n    private QuorumBean jmxQuorumBean;\n    LocalPeerBean jmxLocalPeerBean;\n    private Map<Long, RemotePeerBean> jmxRemotePeerBean;\n    LeaderElectionBean jmxLeaderElectionBean;\n\n    // The QuorumCnxManager is held through an AtomicReference to ensure cross-thread visibility\n    // of updates; see the implementation comment at setLastSeenQuorumVerifier().\n    private AtomicReference<QuorumCnxManager> qcmRef = new AtomicReference<>();\n\n    QuorumAuthServer authServer;\n    QuorumAuthLearner authLearner;\n\n    /**\n     * ZKDatabase is a top level member of quorumpeer\n     * which will be used in all the zookeeperservers\n     * instantiated later. Also, it is created once on\n     * bootup and only thrown away in case of a truncate\n     * message from the leader\n     */\n    private ZKDatabase zkDb;\n\n    private JvmPauseMonitor jvmPauseMonitor;\n\n    public static final class AddressTuple {\n\n        public final MultipleAddresses quorumAddr;\n        public final MultipleAddresses electionAddr;\n        public final InetSocketAddress clientAddr;\n\n        public AddressTuple(MultipleAddresses quorumAddr, MultipleAddresses electionAddr, InetSocketAddress clientAddr) {\n            this.quorumAddr = quorumAddr;\n            this.electionAddr = electionAddr;\n            this.clientAddr = clientAddr;\n        }\n\n    }\n\n    private int observerMasterPort;\n\n    public int getObserverMasterPort() {\n        return observerMasterPort;\n    }\n\n    public void setObserverMasterPort(int observerMasterPort) {\n        this.observerMasterPort = observerMasterPort;\n    }\n\n    public static final String CONFIG_KEY_MULTI_ADDRESS_ENABLED = \"zookeeper.multiAddress.enabled\";\n    public static final String CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED = \"false\";\n\n    private boolean multiAddressEnabled = true;\n    public boolean isMultiAddressEnabled() {\n        return multiAddressEnabled;\n    }\n\n    public void setMultiAddressEnabled(boolean multiAddressEnabled) {\n        this.multiAddressEnabled = multiAddressEnabled;\n        LOG.info(\"multiAddress.enabled set to {}\", multiAddressEnabled);\n    }\n\n    public static final String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_TIMEOUT_MS = \"zookeeper.multiAddress.reachabilityCheckTimeoutMs\";\n\n    private int multiAddressReachabilityCheckTimeoutMs = (int) MultipleAddresses.DEFAULT_TIMEOUT.toMillis();\n    public int getMultiAddressReachabilityCheckTimeoutMs() {\n        return multiAddressReachabilityCheckTimeoutMs;\n    }\n\n    public void setMultiAddressReachabilityCheckTimeoutMs(int multiAddressReachabilityCheckTimeoutMs) {\n        this.multiAddressReachabilityCheckTimeoutMs = multiAddressReachabilityCheckTimeoutMs;\n        LOG.info(\"multiAddress.reachabilityCheckTimeoutMs set to {}\", multiAddressReachabilityCheckTimeoutMs);\n    }\n\n    public static final String CONFIG_KEY_MULTI_ADDRESS_REACHABILITY_CHECK_ENABLED = \"zookeeper.multiAddress.reachabilityCheckEnabled\";\n\n    private boolean multiAddressReachabilityCheckEnabled = true;\n\n    public boolean isMultiAddressReachabilityCheckEnabled() {\n        return multiAddressReachabilityCheckEnabled;\n    }\n\n    public void setMultiAddressReachabilityCheckEnabled(boolean multiAddressReachabilityCheckEnabled) {\n        this.multiAddressReachabilityCheckEnabled = multiAddressReachabilityCheckEnabled;\n        LOG.info(\"multiAddress.reachabilityCheckEnabled set to {}\", multiAddressReachabilityCheckEnabled);\n    }\n\n    public static class QuorumServer {\n\n        public MultipleAddresses addr = new MultipleAddresses();\n\n        public MultipleAddresses electionAddr = new MultipleAddresses();\n\n        public InetSocketAddress clientAddr = null;\n\n        public long id;\n\n        public String hostname;\n\n        public LearnerType type = LearnerType.PARTICIPANT;\n\n        public boolean isClientAddrFromStatic = false;\n\n        private List<InetSocketAddress> myAddrs;\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr) {\n            this(id, addr, electionAddr, clientAddr, LearnerType.PARTICIPANT);\n        }\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr) {\n            this(id, addr, electionAddr, null, LearnerType.PARTICIPANT);\n        }\n\n        // VisibleForTesting\n        public QuorumServer(long id, InetSocketAddress addr) {\n            this(id, addr, null, null, LearnerType.PARTICIPANT);\n        }\n\n        public long getId() {\n            return id;\n        }\n\n        /**\n         * Performs a DNS lookup for server address and election address.\n         *\n         * If the DNS lookup fails, this.addr and electionAddr remain\n         * unmodified.\n         */\n        public void recreateSocketAddresses() {\n            if (this.addr.isEmpty()) {\n                LOG.warn(\"Server address has not been initialized\");\n                return;\n            }\n            if (this.electionAddr.isEmpty()) {\n                LOG.warn(\"Election address has not been initialized\");\n                return;\n            }\n            this.addr.recreateSocketAddresses();\n            this.electionAddr.recreateSocketAddresses();\n        }\n\n        private LearnerType getType(String s) throws ConfigException {\n            switch (s.trim().toLowerCase()) {\n                case \"observer\":\n                    return LearnerType.OBSERVER;\n                case \"participant\":\n                    return LearnerType.PARTICIPANT;\n                default:\n                    throw new ConfigException(\"Unrecognised peertype: \" + s);\n            }\n        }\n\n        public QuorumServer(long sid, String addressStr) throws ConfigException {\n            this(sid, addressStr, QuorumServer::getInetAddress);\n        }\n\n        QuorumServer(long sid, String addressStr, Function<InetSocketAddress, InetAddress> getInetAddress) throws ConfigException {\n            this.id = sid;\n            initializeWithAddressString(addressStr, getInetAddress);\n        }\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, LearnerType type) {\n            this(id, addr, electionAddr, null, type);\n        }\n\n        public QuorumServer(long id, InetSocketAddress addr, InetSocketAddress electionAddr, InetSocketAddress clientAddr, LearnerType type) {\n            this.id = id;\n            if (addr != null) {\n                this.addr.addAddress(addr);\n            }\n            if (electionAddr != null) {\n                this.electionAddr.addAddress(electionAddr);\n            }\n            this.type = type;\n            this.clientAddr = clientAddr;\n\n            setMyAddrs();\n        }\n\n        private static final String wrongFormat =\n            \" does not have the form server_config or server_config;client_config\"\n            + \" where server_config is the pipe separated list of host:port:port or host:port:port:type\"\n            + \" and client_config is port or host:port\";\n\n        private void initializeWithAddressString(String addressStr, Function<InetSocketAddress, InetAddress> getInetAddress) throws ConfigException {\n            LearnerType newType = null;\n            String[] serverClientParts = addressStr.split(\";\");\n            String[] serverAddresses = serverClientParts[0].split(\"\\\\|\");\n\n            if (serverClientParts.length == 2) {\n                String[] clientParts = ConfigUtils.getHostAndPort(serverClientParts[1]);\n                if (clientParts.length > 2) {\n                    throw new ConfigException(addressStr + wrongFormat);\n                }\n\n                // is client_config a host:port or just a port\n                String clientHostName = (clientParts.length == 2) ? clientParts[0] : \"0.0.0.0\";\n                try {\n                    clientAddr = new InetSocketAddress(clientHostName, Integer.parseInt(clientParts[clientParts.length - 1]));\n                } catch (NumberFormatException e) {\n                    throw new ConfigException(\"Address unresolved: \" + hostname + \":\" + clientParts[clientParts.length - 1]);\n                }\n            }\n\n            boolean multiAddressEnabled = Boolean.parseBoolean(\n                System.getProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, QuorumPeer.CONFIG_DEFAULT_MULTI_ADDRESS_ENABLED));\n            if (!multiAddressEnabled && serverAddresses.length > 1) {\n                throw new ConfigException(\"Multiple address feature is disabled, but multiple addresses were specified for sid \" + this.id);\n            }\n\n            boolean canonicalize = Boolean.parseBoolean(\n                System.getProperty(\n                    CONFIG_KEY_KERBEROS_CANONICALIZE_HOST_NAMES,\n                    CONFIG_DEFAULT_KERBEROS_CANONICALIZE_HOST_NAMES));\n\n            for (String serverAddress : serverAddresses) {\n                String serverParts[] = ConfigUtils.getHostAndPort(serverAddress);\n                if ((serverClientParts.length > 2) || (serverParts.length < 3)\n                        || (serverParts.length > 4)) {\n                    throw new ConfigException(addressStr + wrongFormat);\n                }\n\n                String serverHostName = serverParts[0];\n\n                // server_config should be either host:port:port or host:port:port:type\n                InetSocketAddress tempAddress;\n                InetSocketAddress tempElectionAddress;\n                try {\n                    tempAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[1]));\n                    addr.addAddress(tempAddress);\n                } catch (NumberFormatException e) {\n                    throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[1]);\n                }\n                try {\n                    tempElectionAddress = new InetSocketAddress(serverHostName, Integer.parseInt(serverParts[2]));\n                    electionAddr.addAddress(tempElectionAddress);\n                } catch (NumberFormatException e) {\n                    throw new ConfigException(\"Address unresolved: \" + serverHostName + \":\" + serverParts[2]);\n                }\n\n                if (tempAddress.getPort() == tempElectionAddress.getPort()) {\n                    throw new ConfigException(\"Client and election port must be different! Please update the \"\n                            + \"configuration file on server.\" + this.id);\n                }\n\n                if (canonicalize) {\n                    InetAddress ia = getInetAddress.apply(tempAddress);\n                    if (ia == null) {\n                        throw new ConfigException(\"Unable to canonicalize address \" + serverHostName + \" because it's not resolvable\");\n                    }\n\n                    String canonicalHostName = ia.getCanonicalHostName();\n\n                    if (!canonicalHostName.equals(serverHostName)\n                        // Avoid using literal IP address when\n                        // security check fails\n                        && !canonicalHostName.equals(ia.getHostAddress())) {\n                        LOG.info(\"Host name for quorum server {} \"\n                            + \"canonicalized from {} to {}\",\n                            this.id, serverHostName, canonicalHostName);\n                        serverHostName = canonicalHostName;\n                    }\n                }\n\n                if (serverParts.length == 4) {\n                    LearnerType tempType = getType(serverParts[3]);\n                    if (newType == null) {\n                        newType = tempType;\n                    }\n\n                    if (newType != tempType) {\n                        throw new ConfigException(\"Multiple addresses should have similar roles: \" + type + \" vs \" + tempType);\n                    }\n                }\n\n                this.hostname = serverHostName;\n            }\n\n            if (newType != null) {\n                type = newType;\n            }\n\n            setMyAddrs();\n        }\n\n        private static InetAddress getInetAddress(InetSocketAddress addr) {\n            return addr.getAddress();\n        }\n\n        private void setMyAddrs() {\n            this.myAddrs = new ArrayList<>();\n            this.myAddrs.addAll(this.addr.getAllAddresses());\n            this.myAddrs.add(this.clientAddr);\n            this.myAddrs.addAll(this.electionAddr.getAllAddresses());\n            this.myAddrs = excludedSpecialAddresses(this.myAddrs);\n        }\n\n        public static String delimitedHostString(InetSocketAddress addr) {\n            String host = addr.getHostString();\n            if (host.contains(\":\")) {\n                return \"[\" + host + \"]\";\n            } else {\n                return host;\n            }\n        }\n\n        public String toString() {\n            StringWriter sw = new StringWriter();\n\n            List<InetSocketAddress> addrList = new LinkedList<>(addr.getAllAddresses());\n            List<InetSocketAddress> electionAddrList = new LinkedList<>(electionAddr.getAllAddresses());\n\n            if (addrList.size() > 0 && electionAddrList.size() > 0) {\n                addrList.sort(Comparator.comparing(InetSocketAddress::getHostString));\n                electionAddrList.sort(Comparator.comparing(InetSocketAddress::getHostString));\n                sw.append(IntStream.range(0, addrList.size()).mapToObj(i -> String.format(\"%s:%d:%d\",\n                        delimitedHostString(addrList.get(i)), addrList.get(i).getPort(), electionAddrList.get(i).getPort()))\n                        .collect(Collectors.joining(\"|\")));\n            }\n\n            if (type == LearnerType.OBSERVER) {\n                sw.append(\":observer\");\n            } else if (type == LearnerType.PARTICIPANT) {\n                sw.append(\":participant\");\n            }\n\n            if (clientAddr != null && !isClientAddrFromStatic) {\n                sw.append(\";\");\n                sw.append(delimitedHostString(clientAddr));\n                sw.append(\":\");\n                sw.append(String.valueOf(clientAddr.getPort()));\n            }\n\n            return sw.toString();\n        }\n\n        public int hashCode() {\n            assert false : \"hashCode not designed\";\n            return 42; // any arbitrary constant will do\n        }\n\n        private boolean checkAddressesEqual(InetSocketAddress addr1, InetSocketAddress addr2) {\n            return (addr1 != null || addr2 == null)\n                   && (addr1 == null || addr2 != null)\n                   && (addr1 == null || addr2 == null || addr1.equals(addr2));\n        }\n\n        public boolean equals(Object o) {\n            if (!(o instanceof QuorumServer)) {\n                return false;\n            }\n            QuorumServer qs = (QuorumServer) o;\n            if ((qs.id != id) || (qs.type != type)) {\n                return false;\n            }\n            if (!addr.equals(qs.addr)) {\n                return false;\n            }\n            if (!electionAddr.equals(qs.electionAddr)) {\n                return false;\n            }\n            return checkAddressesEqual(clientAddr, qs.clientAddr);\n        }\n\n        public void checkAddressDuplicate(QuorumServer s) throws BadArgumentsException {\n            List<InetSocketAddress> otherAddrs = new ArrayList<>(s.addr.getAllAddresses());\n            otherAddrs.add(s.clientAddr);\n            otherAddrs.addAll(s.electionAddr.getAllAddresses());\n            otherAddrs = excludedSpecialAddresses(otherAddrs);\n\n            for (InetSocketAddress my : this.myAddrs) {\n\n                for (InetSocketAddress other : otherAddrs) {\n                    if (my.equals(other)) {\n                        String error = String.format(\"%s of server.%d conflicts %s of server.%d\", my, this.id, other, s.id);\n                        throw new BadArgumentsException(error);\n                    }\n                }\n            }\n        }\n\n        private List<InetSocketAddress> excludedSpecialAddresses(List<InetSocketAddress> addrs) {\n            List<InetSocketAddress> included = new ArrayList<>();\n\n            for (InetSocketAddress addr : addrs) {\n                if (addr == null) {\n                    continue;\n                }\n                InetAddress inetaddr = addr.getAddress();\n\n                if (inetaddr == null || inetaddr.isAnyLocalAddress() || // wildCard addresses (0.0.0.0 or [::])\n                    inetaddr.isLoopbackAddress()) { // loopback address(localhost/127.0.0.1)\n                    continue;\n                }\n                included.add(addr);\n            }\n            return included;\n        }\n\n    }\n\n    public enum ServerState {\n        LOOKING,\n        FOLLOWING,\n        LEADING,\n        OBSERVING\n    }\n\n    /**\n     * (Used for monitoring) shows the current phase of\n     * Zab protocol that peer is running.\n     */\n    public enum ZabState {\n        ELECTION,\n        DISCOVERY,\n        SYNCHRONIZATION,\n        BROADCAST\n    }\n\n    /**\n     * (Used for monitoring) When peer is in synchronization phase, this shows\n     * which synchronization mechanism is being used\n     */\n    public enum SyncMode {\n        NONE,\n        DIFF,\n        SNAP,\n        TRUNC\n    }\n\n    /*\n     * A peer can either be participating, which implies that it is willing to\n     * both vote in instances of consensus and to elect or become a Leader, or\n     * it may be observing in which case it isn't.\n     *\n     * We need this distinction to decide which ServerState to move to when\n     * conditions change (e.g. which state to become after LOOKING).\n     */\n    public enum LearnerType {\n        PARTICIPANT,\n        OBSERVER\n    }\n\n    /*\n     * To enable observers to have no identifier, we need a generic identifier\n     * at least for QuorumCnxManager. We use the following constant to as the\n     * value of such a generic identifier.\n     */\n\n    static final long OBSERVER_ID = Long.MAX_VALUE;\n\n    /*\n     * Record leader election time\n     */\n    public long start_fle, end_fle; // fle = fast leader election\n    public static final String FLE_TIME_UNIT = \"MS\";\n    private long unavailableStartTime;\n\n    /*\n     * Default value of peer is participant\n     */\n    private LearnerType learnerType = LearnerType.PARTICIPANT;\n\n    public LearnerType getLearnerType() {\n        return learnerType;\n    }\n\n    /**\n     * Sets the LearnerType\n     */\n    public void setLearnerType(LearnerType p) {\n        learnerType = p;\n    }\n\n    protected synchronized void setConfigFileName(String s) {\n        configFilename = s;\n    }\n\n    private String configFilename = null;\n\n    public int getQuorumSize() {\n        return getVotingView().size();\n    }\n\n    public void setJvmPauseMonitor(JvmPauseMonitor jvmPauseMonitor) {\n        this.jvmPauseMonitor = jvmPauseMonitor;\n    }\n\n    /**\n     * QuorumVerifier implementation; default (majority).\n     */\n\n    //last committed quorum verifier\n    private QuorumVerifier quorumVerifier;\n\n    //last proposed quorum verifier\n    private QuorumVerifier lastSeenQuorumVerifier = null;\n\n    // Lock object that guard access to quorumVerifier and lastSeenQuorumVerifier.\n    final Object QV_LOCK = new Object();\n\n    /**\n     * My id\n     */\n    private long myid;\n\n    /**\n     * get the id of this quorum peer.\n     */\n    public long getId() {\n        return myid;\n    }\n\n    // VisibleForTesting\n    void setId(long id) {\n        this.myid = id;\n    }\n\n    private boolean sslQuorum;\n    private boolean shouldUsePortUnification;\n\n    public boolean isSslQuorum() {\n        return sslQuorum;\n    }\n\n    public boolean shouldUsePortUnification() {\n        return shouldUsePortUnification;\n    }\n\n    private final QuorumX509Util x509Util;\n\n    QuorumX509Util getX509Util() {\n        return x509Util;\n    }\n\n    /**\n     * This is who I think the leader currently is.\n     */\n    private volatile Vote currentVote;\n\n    public synchronized Vote getCurrentVote() {\n        return currentVote;\n    }\n\n    public synchronized void setCurrentVote(Vote v) {\n        currentVote = v;\n    }\n\n    private volatile boolean running = true;\n\n    private String initialConfig;\n\n    /**\n     * The number of milliseconds of each tick\n     */\n    protected int tickTime;\n\n    /**\n     * Whether learners in this quorum should create new sessions as local.\n     * False by default to preserve existing behavior.\n     */\n    protected boolean localSessionsEnabled = false;\n\n    /**\n     * Whether learners in this quorum should upgrade local sessions to\n     * global. Only matters if local sessions are enabled.\n     */\n    protected boolean localSessionsUpgradingEnabled = true;\n\n    /**\n     * Minimum number of milliseconds to allow for session timeout.\n     * A value of -1 indicates unset, use default.\n     */\n    protected int minSessionTimeout = -1;\n\n    /**\n     * Maximum number of milliseconds to allow for session timeout.\n     * A value of -1 indicates unset, use default.\n     */\n    protected int maxSessionTimeout = -1;\n\n    /**\n     * The ZooKeeper server's socket backlog length. The number of connections\n     * that will be queued to be read before new connections are dropped. A\n     * value of one indicates the default backlog will be used.\n     */\n    protected int clientPortListenBacklog = -1;\n\n    /**\n     * The number of ticks that the initial synchronization phase can take\n     */\n    protected volatile int initLimit;\n\n    /**\n     * The number of ticks that can pass between sending a request and getting\n     * an acknowledgment\n     */\n    protected volatile int syncLimit;\n\n    /**\n     * The number of ticks that can pass before retrying to connect to learner master\n     */\n    protected volatile int connectToLearnerMasterLimit;\n\n    /**\n     * Enables/Disables sync request processor. This option is enabled\n     * by default and is to be used with observers.\n     */\n    protected boolean syncEnabled = true;\n\n    /**\n     * The current tick\n     */\n    protected AtomicInteger tick = new AtomicInteger();\n\n    /**\n     * Whether or not to listen on all IPs for the two quorum ports\n     * (broadcast and fast leader election).\n     */\n    protected boolean quorumListenOnAllIPs = false;\n\n    /**\n     * Keeps time taken for leader election in milliseconds. Sets the value to\n     * this variable only after the completion of leader election.\n     */\n    private long electionTimeTaken = -1;\n\n    /**\n     * Enable/Disables quorum authentication using sasl. Defaulting to false.\n     */\n    protected boolean quorumSaslEnableAuth;\n\n    /**\n     * If this is false, quorum peer server will accept another quorum peer client\n     * connection even if the authentication did not succeed. This can be used while\n     * upgrading ZooKeeper server. Defaulting to false (required).\n     */\n    protected boolean quorumServerSaslAuthRequired;\n\n    /**\n     * If this is false, quorum peer learner will talk to quorum peer server\n     * without authentication. This can be used while upgrading ZooKeeper\n     * server. Defaulting to false (required).\n     */\n    protected boolean quorumLearnerSaslAuthRequired;\n\n    /**\n     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.\n     */\n    protected String quorumServicePrincipal;\n\n    /**\n     * Quorum learner login context name in jaas-conf file to read the kerberos\n     * security details. Defaulting to 'QuorumLearner'.\n     */\n    protected String quorumLearnerLoginContext;\n\n    /**\n     * Quorum server login context name in jaas-conf file to read the kerberos\n     * security details. Defaulting to 'QuorumServer'.\n     */\n    protected String quorumServerLoginContext;\n\n    // TODO: need to tune the default value of thread size\n    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;\n    /**\n     * The maximum number of threads to allow in the connectionExecutors thread\n     * pool which will be used to initiate quorum server connections.\n     */\n    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;\n\n    public static final String QUORUM_CNXN_TIMEOUT_MS = \"zookeeper.quorumCnxnTimeoutMs\";\n    private static int quorumCnxnTimeoutMs;\n\n    static {\n        quorumCnxnTimeoutMs = Integer.getInteger(QUORUM_CNXN_TIMEOUT_MS, -1);\n        LOG.info(\"{}={}\", QUORUM_CNXN_TIMEOUT_MS, quorumCnxnTimeoutMs);\n    }\n\n    /**\n     * @deprecated As of release 3.4.0, this class has been deprecated, since\n     * it is used with one of the udp-based versions of leader election, which\n     * we are also deprecating.\n     *\n     * This class simply responds to requests for the current leader of this\n     * node.\n     * <p>\n     * The request contains just an xid generated by the requestor.\n     * <p>\n     * The response has the xid, the id of this server, the id of the leader,\n     * and the zxid of the leader.\n     *\n     *\n     */\n    @Deprecated\n    class ResponderThread extends ZooKeeperThread {\n\n        ResponderThread() {\n            super(\"ResponderThread\");\n        }\n\n        volatile boolean running = true;\n\n        @Override\n        public void run() {\n            try {\n                byte[] b = new byte[36];\n                ByteBuffer responseBuffer = ByteBuffer.wrap(b);\n                DatagramPacket packet = new DatagramPacket(b, b.length);\n                while (running) {\n                    udpSocket.receive(packet);\n                    if (packet.getLength() != 4) {\n                        LOG.warn(\"Got more than just an xid! Len = {}\", packet.getLength());\n                    } else {\n                        responseBuffer.clear();\n                        responseBuffer.getInt(); // Skip the xid\n                        responseBuffer.putLong(myid);\n                        Vote current = getCurrentVote();\n                        switch (getPeerState()) {\n                        case LOOKING:\n                            responseBuffer.putLong(current.getId());\n                            responseBuffer.putLong(current.getZxid());\n                            break;\n                        case LEADING:\n                            responseBuffer.putLong(myid);\n                            try {\n                                long proposed;\n                                synchronized (leader) {\n                                    proposed = leader.lastProposed;\n                                }\n                                responseBuffer.putLong(proposed);\n                            } catch (NullPointerException npe) {\n                                // This can happen in state transitions,\n                                // just ignore the request\n                            }\n                            break;\n                        case FOLLOWING:\n                            responseBuffer.putLong(current.getId());\n                            try {\n                                responseBuffer.putLong(follower.getZxid());\n                            } catch (NullPointerException npe) {\n                                // This can happen in state transitions,\n                                // just ignore the request\n                            }\n                            break;\n                        case OBSERVING:\n                            // Do nothing, Observers keep themselves to\n                            // themselves.\n                            break;\n                        }\n                        packet.setData(b);\n                        udpSocket.send(packet);\n                    }\n                    packet.setLength(b.length);\n                }\n            } catch (RuntimeException e) {\n                LOG.warn(\"Unexpected runtime exception in ResponderThread\", e);\n            } catch (IOException e) {\n                LOG.warn(\"Unexpected IO exception in ResponderThread\", e);\n            } finally {\n                LOG.warn(\"QuorumPeer responder thread exited\");\n            }\n        }\n\n    }\n\n    private ServerState state = ServerState.LOOKING;\n\n    private AtomicReference<ZabState> zabState = new AtomicReference<>(ZabState.ELECTION);\n    private AtomicReference<SyncMode> syncMode = new AtomicReference<>(SyncMode.NONE);\n    private AtomicReference<String> leaderAddress = new AtomicReference<String>(\"\");\n    private AtomicLong leaderId = new AtomicLong(-1);\n\n    private boolean reconfigFlag = false; // indicates that a reconfig just committed\n\n    public synchronized void setPeerState(ServerState newState) {\n        state = newState;\n        if (newState == ServerState.LOOKING) {\n            setLeaderAddressAndId(null, -1);\n            setZabState(ZabState.ELECTION);\n        } else {\n            LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n        }\n    }\n\n    public void setZabState(ZabState zabState) {\n        if ((zabState == ZabState.BROADCAST) && (unavailableStartTime != 0)) {\n            long unavailableTime = Time.currentElapsedTime() - unavailableStartTime;\n            ServerMetrics.getMetrics().UNAVAILABLE_TIME.add(unavailableTime);\n            if (getPeerState() == ServerState.LEADING) {\n                ServerMetrics.getMetrics().LEADER_UNAVAILABLE_TIME.add(unavailableTime);\n            }\n            unavailableStartTime = 0;\n        }\n        this.zabState.set(zabState);\n        LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n    }\n\n    public void setSyncMode(SyncMode syncMode) {\n        this.syncMode.set(syncMode);\n        LOG.info(\"Peer state changed: {}\", getDetailedPeerState());\n    }\n\n    public ZabState getZabState() {\n        return zabState.get();\n    }\n\n    public SyncMode getSyncMode() {\n        return syncMode.get();\n    }\n\n    public void setLeaderAddressAndId(MultipleAddresses addr, long newId) {\n        if (addr != null) {\n            leaderAddress.set(String.join(\"|\", addr.getAllHostStrings()));\n        } else {\n            leaderAddress.set(null);\n        }\n        leaderId.set(newId);\n    }\n\n    public String getLeaderAddress() {\n        return leaderAddress.get();\n    }\n\n    public long getLeaderId() {\n        return leaderId.get();\n    }\n\n    public String getDetailedPeerState() {\n        final StringBuilder sb = new StringBuilder(getPeerState().toString().toLowerCase());\n        final ZabState zabState = getZabState();\n        if (!ZabState.ELECTION.equals(zabState)) {\n            sb.append(\" - \").append(zabState.toString().toLowerCase());\n        }\n        final SyncMode syncMode = getSyncMode();\n        if (!SyncMode.NONE.equals(syncMode)) {\n            sb.append(\" - \").append(syncMode.toString().toLowerCase());\n        }\n        return sb.toString();\n    }\n\n    public synchronized void reconfigFlagSet() {\n        reconfigFlag = true;\n    }\n    public synchronized void reconfigFlagClear() {\n        reconfigFlag = false;\n    }\n    public synchronized boolean isReconfigStateChange() {\n        return reconfigFlag;\n    }\n    public synchronized ServerState getPeerState() {\n        return state;\n    }\n\n    DatagramSocket udpSocket;\n\n    private final AtomicReference<AddressTuple> myAddrs = new AtomicReference<>();\n\n    /**\n     * Resolves hostname for a given server ID.\n     *\n     * This method resolves hostname for a given server ID in both quorumVerifer\n     * and lastSeenQuorumVerifier. If the server ID matches the local server ID,\n     * it also updates myAddrs.\n     */\n    public void recreateSocketAddresses(long id) {\n        QuorumVerifier qv = getQuorumVerifier();\n        if (qv != null) {\n            QuorumServer qs = qv.getAllMembers().get(id);\n            if (qs != null) {\n                qs.recreateSocketAddresses();\n                if (id == getId()) {\n                    setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n                }\n            }\n        }\n        qv = getLastSeenQuorumVerifier();\n        if (qv != null) {\n            QuorumServer qs = qv.getAllMembers().get(id);\n            if (qs != null) {\n                qs.recreateSocketAddresses();\n            }\n        }\n    }\n\n    private AddressTuple getAddrs() {\n        AddressTuple addrs = myAddrs.get();\n        if (addrs != null) {\n            return addrs;\n        }\n        try {\n            synchronized (QV_LOCK) {\n                addrs = myAddrs.get();\n                while (addrs == null) {\n                    QV_LOCK.wait();\n                    addrs = myAddrs.get();\n                }\n                return addrs;\n            }\n        } catch (InterruptedException e) {\n            Thread.currentThread().interrupt();\n            throw new RuntimeException(e);\n        }\n    }\n\n    public MultipleAddresses getQuorumAddress() {\n        return getAddrs().quorumAddr;\n    }\n\n    public MultipleAddresses getElectionAddress() {\n        return getAddrs().electionAddr;\n    }\n\n    public InetSocketAddress getClientAddress() {\n        final AddressTuple addrs = myAddrs.get();\n        return (addrs == null) ? null : addrs.clientAddr;\n    }\n\n    private void setAddrs(MultipleAddresses quorumAddr, MultipleAddresses electionAddr, InetSocketAddress clientAddr) {\n        synchronized (QV_LOCK) {\n            myAddrs.set(new AddressTuple(quorumAddr, electionAddr, clientAddr));\n            QV_LOCK.notifyAll();\n        }\n    }\n\n    private int electionType;\n\n    Election electionAlg;\n\n    ServerCnxnFactory cnxnFactory;\n    ServerCnxnFactory secureCnxnFactory;\n\n    private FileTxnSnapLog logFactory = null;\n\n    private final QuorumStats quorumStats;\n\n    AdminServer adminServer;\n\n    private final boolean reconfigEnabled;\n\n    public static QuorumPeer testingQuorumPeer() throws SaslException {\n        return new QuorumPeer();\n    }\n\n    public QuorumPeer() throws SaslException {\n        super(\"QuorumPeer\");\n        quorumStats = new QuorumStats(this);\n        jmxRemotePeerBean = new HashMap<Long, RemotePeerBean>();\n        adminServer = AdminServerFactory.createAdminServer();\n        x509Util = createX509Util();\n        initialize();\n        reconfigEnabled = QuorumPeerConfig.isReconfigEnabled();\n    }\n\n    // VisibleForTesting\n    QuorumX509Util createX509Util() {\n        return new QuorumX509Util();\n    }\n\n    /**\n     * For backward compatibility purposes, we instantiate QuorumMaj by default.\n     */\n\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, ServerCnxnFactory cnxnFactory) throws IOException {\n        this(quorumPeers, dataDir, dataLogDir, electionType, myid, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit, false, cnxnFactory, new QuorumMaj(quorumPeers));\n    }\n\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir, File dataLogDir, int electionType, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, boolean quorumListenOnAllIPs, ServerCnxnFactory cnxnFactory, QuorumVerifier quorumConfig) throws IOException {\n        this();\n        this.cnxnFactory = cnxnFactory;\n        this.electionType = electionType;\n        this.myid = myid;\n        this.tickTime = tickTime;\n        this.initLimit = initLimit;\n        this.syncLimit = syncLimit;\n        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;\n        this.quorumListenOnAllIPs = quorumListenOnAllIPs;\n        this.logFactory = new FileTxnSnapLog(dataLogDir, dataDir);\n        this.zkDb = new ZKDatabase(this.logFactory);\n        if (quorumConfig == null) {\n            quorumConfig = new QuorumMaj(quorumPeers);\n        }\n        setQuorumVerifier(quorumConfig, false);\n        adminServer = AdminServerFactory.createAdminServer();\n    }\n\n    public void initialize() throws SaslException {\n        // init quorum auth server & learner\n        if (isQuorumSaslAuthEnabled()) {\n            Set<String> authzHosts = new HashSet<String>();\n            for (QuorumServer qs : getView().values()) {\n                authzHosts.add(qs.hostname);\n            }\n            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(), quorumServerLoginContext, authzHosts);\n            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(), quorumServicePrincipal, quorumLearnerLoginContext);\n        } else {\n            authServer = new NullQuorumAuthServer();\n            authLearner = new NullQuorumAuthLearner();\n        }\n    }\n\n    QuorumStats quorumStats() {\n        return quorumStats;\n    }\n\n    @Override\n    public synchronized void start() {\n        if (!getView().containsKey(myid)) {\n            throw new RuntimeException(\"My id \" + myid + \" not in the peer list\");\n        }\n        loadDataBase();\n        startServerCnxnFactory();\n        try {\n            adminServer.start();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem starting AdminServer\", e);\n            System.out.println(e);\n        }\n        startLeaderElection();\n        startJvmPauseMonitor();\n        super.start();\n    }\n\n    private void loadDataBase() {\n        try {\n            zkDb.loadDataBase();\n\n            // load the epochs\n            long lastProcessedZxid = zkDb.getDataTree().lastProcessedZxid;\n            long epochOfZxid = ZxidUtils.getEpochFromZxid(lastProcessedZxid);\n            try {\n                currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n            } catch (FileNotFoundException e) {\n                // pick a reasonable epoch number\n                // this should only happen once when moving to a\n                // new code version\n                currentEpoch = epochOfZxid;\n                LOG.info(\n                    \"{} not found! Creating with a reasonable default of {}. \"\n                        + \"This should only happen when you are upgrading your installation\",\n                    CURRENT_EPOCH_FILENAME,\n                    currentEpoch);\n                writeLongToFile(CURRENT_EPOCH_FILENAME, currentEpoch);\n            }\n            if (epochOfZxid > currentEpoch) {\n                throw new IOException(\"The current epoch, \"\n                                      + ZxidUtils.zxidToString(currentEpoch)\n                                      + \", is older than the last zxid, \"\n                                      + lastProcessedZxid);\n            }\n            try {\n                acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n            } catch (FileNotFoundException e) {\n                // pick a reasonable epoch number\n                // this should only happen once when moving to a\n                // new code version\n                acceptedEpoch = epochOfZxid;\n                LOG.info(\n                    \"{} not found! Creating with a reasonable default of {}. \"\n                        + \"This should only happen when you are upgrading your installation\",\n                    ACCEPTED_EPOCH_FILENAME,\n                    acceptedEpoch);\n                writeLongToFile(ACCEPTED_EPOCH_FILENAME, acceptedEpoch);\n            }\n            if (acceptedEpoch < currentEpoch) {\n                throw new IOException(\"The accepted epoch, \"\n                                      + ZxidUtils.zxidToString(acceptedEpoch)\n                                      + \" is less than the current epoch, \"\n                                      + ZxidUtils.zxidToString(currentEpoch));\n            }\n        } catch (IOException ie) {\n            LOG.error(\"Unable to load database on disk\", ie);\n            throw new RuntimeException(\"Unable to run quorum server \", ie);\n        }\n    }\n\n    ResponderThread responder;\n\n    public synchronized void stopLeaderElection() {\n        responder.running = false;\n        responder.interrupt();\n    }\n    public synchronized void startLeaderElection() {\n        try {\n            if (getPeerState() == ServerState.LOOKING) {\n                currentVote = new Vote(myid, getLastLoggedZxid(), getCurrentEpoch());\n            }\n        } catch (IOException e) {\n            RuntimeException re = new RuntimeException(e.getMessage());\n            re.setStackTrace(e.getStackTrace());\n            throw re;\n        }\n\n        this.electionAlg = createElectionAlgorithm(electionType);\n    }\n\n    private void startJvmPauseMonitor() {\n        if (this.jvmPauseMonitor != null) {\n            this.jvmPauseMonitor.serviceStart();\n        }\n    }\n\n    /**\n     * Count the number of nodes in the map that could be followers.\n     * @param peers\n     * @return The number of followers in the map\n     */\n    protected static int countParticipants(Map<Long, QuorumServer> peers) {\n        int count = 0;\n        for (QuorumServer q : peers.values()) {\n            if (q.type == LearnerType.PARTICIPANT) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    /**\n     * This constructor is only used by the existing unit test code.\n     * It defaults to FileLogProvider persistence provider.\n     */\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit) throws IOException {\n        this(\n            quorumPeers,\n            snapDir,\n            logDir,\n            electionAlg,\n            myid,\n            tickTime,\n            initLimit,\n            syncLimit,\n            connectToLearnerMasterLimit,\n            false,\n            ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),\n            new QuorumMaj(quorumPeers));\n    }\n\n    /**\n     * This constructor is only used by the existing unit test code.\n     * It defaults to FileLogProvider persistence provider.\n     */\n    public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File snapDir, File logDir, int clientPort, int electionAlg, long myid, int tickTime, int initLimit, int syncLimit, int connectToLearnerMasterLimit, QuorumVerifier quorumConfig) throws IOException {\n        this(\n            quorumPeers,\n            snapDir,\n            logDir,\n            electionAlg,\n            myid,\n            tickTime,\n            initLimit,\n            syncLimit,\n            connectToLearnerMasterLimit,\n            false,\n            ServerCnxnFactory.createFactory(getClientAddress(quorumPeers, myid, clientPort), -1),\n            quorumConfig);\n    }\n\n    private static InetSocketAddress getClientAddress(Map<Long, QuorumServer> quorumPeers, long myid, int clientPort) throws IOException {\n        QuorumServer quorumServer = quorumPeers.get(myid);\n        if (null == quorumServer) {\n            throw new IOException(\"No QuorumServer correspoding to myid \" + myid);\n        }\n        if (null == quorumServer.clientAddr) {\n            return new InetSocketAddress(clientPort);\n        }\n        if (quorumServer.clientAddr.getPort() != clientPort) {\n            throw new IOException(\"QuorumServer port \"\n                                  + quorumServer.clientAddr.getPort()\n                                  + \" does not match with given port \"\n                                  + clientPort);\n        }\n        return quorumServer.clientAddr;\n    }\n\n    /**\n     * returns the highest zxid that this host has seen\n     *\n     * @return the highest zxid for this host\n     */\n    public long getLastLoggedZxid() {\n        if (!zkDb.isInitialized()) {\n            loadDataBase();\n        }\n        return zkDb.getDataTreeLastProcessedZxid();\n    }\n\n    public Follower follower;\n    public Leader leader;\n    public Observer observer;\n\n    protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException {\n        return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb));\n    }\n\n    protected Leader makeLeader(FileTxnSnapLog logFactory) throws IOException, X509Exception {\n        return new Leader(this, new LeaderZooKeeperServer(logFactory, this, this.zkDb));\n    }\n\n    protected Observer makeObserver(FileTxnSnapLog logFactory) throws IOException {\n        return new Observer(this, new ObserverZooKeeperServer(logFactory, this, this.zkDb));\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected Election createElectionAlgorithm(int electionAlgorithm) {\n        Election le = null;\n\n        //TODO: use a factory rather than a switch\n        switch (electionAlgorithm) {\n        case 1:\n            throw new UnsupportedOperationException(\"Election Algorithm 1 is not supported.\");\n        case 2:\n            throw new UnsupportedOperationException(\"Election Algorithm 2 is not supported.\");\n        case 3:\n            QuorumCnxManager qcm = createCnxnManager();\n            QuorumCnxManager oldQcm = qcmRef.getAndSet(qcm);\n            if (oldQcm != null) {\n                LOG.warn(\"Clobbering already-set QuorumCnxManager (restarting leader election?)\");\n                oldQcm.halt();\n            }\n            QuorumCnxManager.Listener listener = qcm.listener;\n            if (listener != null) {\n                listener.start();\n                FastLeaderElection fle = new FastLeaderElection(this, qcm);\n                fle.start();\n                le = fle;\n            } else {\n                LOG.error(\"Null listener when initializing cnx manager\");\n            }\n            break;\n        default:\n            assert false;\n        }\n        return le;\n    }\n\n    @SuppressWarnings(\"deprecation\")\n    protected Election makeLEStrategy() {\n        LOG.debug(\"Initializing leader election protocol...\");\n        return electionAlg;\n    }\n\n    protected synchronized void setLeader(Leader newLeader) {\n        leader = newLeader;\n    }\n\n    protected synchronized void setFollower(Follower newFollower) {\n        follower = newFollower;\n    }\n\n    protected synchronized void setObserver(Observer newObserver) {\n        observer = newObserver;\n    }\n\n    public synchronized ZooKeeperServer getActiveServer() {\n        if (leader != null) {\n            return leader.zk;\n        } else if (follower != null) {\n            return follower.zk;\n        } else if (observer != null) {\n            return observer.zk;\n        }\n        return null;\n    }\n\n    boolean shuttingDownLE = false;\n\n    @Override\n    public void run() {\n        updateThreadName();\n\n        LOG.debug(\"Starting quorum peer\");\n        try {\n            jmxQuorumBean = new QuorumBean(this);\n            MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n            for (QuorumServer s : getView().values()) {\n                ZKMBeanInfo p;\n                if (getId() == s.id) {\n                    p = jmxLocalPeerBean = new LocalPeerBean(this);\n                    try {\n                        MBeanRegistry.getInstance().register(p, jmxQuorumBean);\n                    } catch (Exception e) {\n                        LOG.warn(\"Failed to register with JMX\", e);\n                        jmxLocalPeerBean = null;\n                    }\n                } else {\n                    RemotePeerBean rBean = new RemotePeerBean(this, s);\n                    try {\n                        MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                        jmxRemotePeerBean.put(s.id, rBean);\n                    } catch (Exception e) {\n                        LOG.warn(\"Failed to register with JMX\", e);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            LOG.warn(\"Failed to register with JMX\", e);\n            jmxQuorumBean = null;\n        }\n\n        try {\n            /*\n             * Main loop\n             */\n            while (running) {\n                if (unavailableStartTime == 0) {\n                    unavailableStartTime = Time.currentElapsedTime();\n                }\n\n                switch (getPeerState()) {\n                case LOOKING:\n                    LOG.info(\"LOOKING\");\n                    ServerMetrics.getMetrics().LOOKING_COUNT.add(1);\n\n                    if (Boolean.getBoolean(\"readonlymode.enabled\")) {\n                        LOG.info(\"Attempting to start ReadOnlyZooKeeperServer\");\n\n                        // Create read-only server but don't start it immediately\n                        final ReadOnlyZooKeeperServer roZk = new ReadOnlyZooKeeperServer(logFactory, this, this.zkDb);\n\n                        // Instead of starting roZk immediately, wait some grace\n                        // period before we decide we're partitioned.\n                        //\n                        // Thread is used here because otherwise it would require\n                        // changes in each of election strategy classes which is\n                        // unnecessary code coupling.\n                        Thread roZkMgr = new Thread() {\n                            public void run() {\n                                try {\n                                    // lower-bound grace period to 2 secs\n                                    sleep(Math.max(2000, tickTime));\n                                    if (ServerState.LOOKING.equals(getPeerState())) {\n                                        roZk.startup();\n                                    }\n                                } catch (InterruptedException e) {\n                                    LOG.info(\"Interrupted while attempting to start ReadOnlyZooKeeperServer, not started\");\n                                } catch (Exception e) {\n                                    LOG.error(\"FAILED to start ReadOnlyZooKeeperServer\", e);\n                                }\n                            }\n                        };\n                        try {\n                            roZkMgr.start();\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        } finally {\n                            // If the thread is in the the grace period, interrupt\n                            // to come out of waiting.\n                            roZkMgr.interrupt();\n                            roZk.shutdown();\n                        }\n                    } else {\n                        try {\n                            reconfigFlagClear();\n                            if (shuttingDownLE) {\n                                shuttingDownLE = false;\n                                startLeaderElection();\n                            }\n                            setCurrentVote(makeLEStrategy().lookForLeader());\n                        } catch (Exception e) {\n                            LOG.warn(\"Unexpected exception\", e);\n                            setPeerState(ServerState.LOOKING);\n                        }\n                    }\n                    break;\n                case OBSERVING:\n                    try {\n                        LOG.info(\"OBSERVING\");\n                        setObserver(makeObserver(logFactory));\n                        observer.observeLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        observer.shutdown();\n                        setObserver(null);\n                        updateServerState();\n\n                        // Add delay jitter before we switch to LOOKING\n                        // state to reduce the load of ObserverMaster\n                        if (isRunning()) {\n                            Observer.waitForObserverElectionDelay();\n                        }\n                    }\n                    break;\n                case FOLLOWING:\n                    try {\n                        LOG.info(\"FOLLOWING\");\n                        setFollower(makeFollower(logFactory));\n                        follower.followLeader();\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        follower.shutdown();\n                        setFollower(null);\n                        updateServerState();\n                    }\n                    break;\n                case LEADING:\n                    LOG.info(\"LEADING\");\n                    try {\n                        setLeader(makeLeader(logFactory));\n                        leader.lead();\n                        setLeader(null);\n                    } catch (Exception e) {\n                        LOG.warn(\"Unexpected exception\", e);\n                    } finally {\n                        if (leader != null) {\n                            leader.shutdown(\"Forcing shutdown\");\n                            setLeader(null);\n                        }\n                        updateServerState();\n                    }\n                    break;\n                }\n            }\n        } finally {\n            LOG.warn(\"QuorumPeer main thread exited\");\n            MBeanRegistry instance = MBeanRegistry.getInstance();\n            instance.unregister(jmxQuorumBean);\n            instance.unregister(jmxLocalPeerBean);\n\n            for (RemotePeerBean remotePeerBean : jmxRemotePeerBean.values()) {\n                instance.unregister(remotePeerBean);\n            }\n\n            jmxQuorumBean = null;\n            jmxLocalPeerBean = null;\n            jmxRemotePeerBean = null;\n        }\n    }\n\n    private synchronized void updateServerState() {\n        if (!reconfigFlag) {\n            setPeerState(ServerState.LOOKING);\n            LOG.warn(\"PeerState set to LOOKING\");\n            return;\n        }\n\n        if (getId() == getCurrentVote().getId()) {\n            setPeerState(ServerState.LEADING);\n            LOG.debug(\"PeerState set to LEADING\");\n        } else if (getLearnerType() == LearnerType.PARTICIPANT) {\n            setPeerState(ServerState.FOLLOWING);\n            LOG.debug(\"PeerState set to FOLLOWING\");\n        } else if (getLearnerType() == LearnerType.OBSERVER) {\n            setPeerState(ServerState.OBSERVING);\n            LOG.debug(\"PeerState set to OBSERVER\");\n        } else { // currently shouldn't happen since there are only 2 learner types\n            setPeerState(ServerState.LOOKING);\n            LOG.debug(\"Should not be here\");\n        }\n        reconfigFlag = false;\n    }\n\n    public void shutdown() {\n        running = false;\n        x509Util.close();\n        if (leader != null) {\n            leader.shutdown(\"quorum Peer shutdown\");\n        }\n        if (follower != null) {\n            follower.shutdown();\n        }\n        shutdownServerCnxnFactory();\n        if (udpSocket != null) {\n            udpSocket.close();\n        }\n        if (jvmPauseMonitor != null) {\n            jvmPauseMonitor.serviceStop();\n        }\n\n        try {\n            adminServer.shutdown();\n        } catch (AdminServerException e) {\n            LOG.warn(\"Problem stopping AdminServer\", e);\n        }\n\n        if (getElectionAlg() != null) {\n            this.interrupt();\n            getElectionAlg().shutdown();\n        }\n        try {\n            zkDb.close();\n        } catch (IOException ie) {\n            LOG.warn(\"Error closing logs \", ie);\n        }\n    }\n\n    /**\n     * A 'view' is a node's current opinion of the membership of the entire\n     * ensemble.\n     */\n    public Map<Long, QuorumPeer.QuorumServer> getView() {\n        return Collections.unmodifiableMap(getQuorumVerifier().getAllMembers());\n    }\n\n    /**\n     * Observers are not contained in this view, only nodes with\n     * PeerType=PARTICIPANT.\n     */\n    public Map<Long, QuorumPeer.QuorumServer> getVotingView() {\n        return getQuorumVerifier().getVotingMembers();\n    }\n\n    /**\n     * Returns only observers, no followers.\n     */\n    public Map<Long, QuorumPeer.QuorumServer> getObservingView() {\n        return getQuorumVerifier().getObservingMembers();\n    }\n\n    public synchronized Set<Long> getCurrentAndNextConfigVoters() {\n        Set<Long> voterIds = new HashSet<Long>(getQuorumVerifier().getVotingMembers().keySet());\n        if (getLastSeenQuorumVerifier() != null) {\n            voterIds.addAll(getLastSeenQuorumVerifier().getVotingMembers().keySet());\n        }\n        return voterIds;\n    }\n\n    /**\n     * Check if a node is in the current view. With static membership, the\n     * result of this check will never change; only when dynamic membership\n     * is introduced will this be more useful.\n     */\n    public boolean viewContains(Long sid) {\n        return this.getView().containsKey(sid);\n    }\n\n    /**\n     * Only used by QuorumStats at the moment\n     */\n    public String[] getQuorumPeers() {\n        List<String> l = new ArrayList<String>();\n        synchronized (this) {\n            if (leader != null) {\n                for (LearnerHandler fh : leader.getLearners()) {\n                    if (fh.getSocket() != null) {\n                        String s = formatInetAddr((InetSocketAddress) fh.getSocket().getRemoteSocketAddress());\n                        if (leader.isLearnerSynced(fh)) {\n                            s += \"*\";\n                        }\n                        l.add(s);\n                    }\n                }\n            } else if (follower != null) {\n                l.add(formatInetAddr((InetSocketAddress) follower.sock.getRemoteSocketAddress()));\n            }\n        }\n        return l.toArray(new String[0]);\n    }\n\n    public String getServerState() {\n        switch (getPeerState()) {\n        case LOOKING:\n            return QuorumStats.Provider.LOOKING_STATE;\n        case LEADING:\n            return QuorumStats.Provider.LEADING_STATE;\n        case FOLLOWING:\n            return QuorumStats.Provider.FOLLOWING_STATE;\n        case OBSERVING:\n            return QuorumStats.Provider.OBSERVING_STATE;\n        }\n        return QuorumStats.Provider.UNKNOWN_STATE;\n    }\n\n    /**\n     * set the id of this quorum peer.\n     */\n    public void setMyid(long myid) {\n        this.myid = myid;\n    }\n\n    public void setInitialConfig(String initialConfig) {\n        this.initialConfig = initialConfig;\n    }\n\n    public String getInitialConfig() {\n        return initialConfig;\n    }\n\n    /**\n     * Get the number of milliseconds of each tick\n     */\n    public int getTickTime() {\n        return tickTime;\n    }\n\n    /**\n     * Set the number of milliseconds of each tick\n     */\n    public void setTickTime(int tickTime) {\n        LOG.info(\"tickTime set to {}\", tickTime);\n        this.tickTime = tickTime;\n    }\n\n    /** Maximum number of connections allowed from particular host (ip) */\n    public int getMaxClientCnxnsPerHost() {\n        if (cnxnFactory != null) {\n            return cnxnFactory.getMaxClientCnxnsPerHost();\n        }\n        if (secureCnxnFactory != null) {\n            return secureCnxnFactory.getMaxClientCnxnsPerHost();\n        }\n        return -1;\n    }\n\n    /** Whether local sessions are enabled */\n    public boolean areLocalSessionsEnabled() {\n        return localSessionsEnabled;\n    }\n\n    /** Whether to enable local sessions */\n    public void enableLocalSessions(boolean flag) {\n        LOG.info(\"Local sessions {}\", (flag ? \"enabled\" : \"disabled\"));\n        localSessionsEnabled = flag;\n    }\n\n    /** Whether local sessions are allowed to upgrade to global sessions */\n    public boolean isLocalSessionsUpgradingEnabled() {\n        return localSessionsUpgradingEnabled;\n    }\n\n    /** Whether to allow local sessions to upgrade to global sessions */\n    public void enableLocalSessionsUpgrading(boolean flag) {\n        LOG.info(\"Local session upgrading {}\", (flag ? \"enabled\" : \"disabled\"));\n        localSessionsUpgradingEnabled = flag;\n    }\n\n    /** minimum session timeout in milliseconds */\n    public int getMinSessionTimeout() {\n        return minSessionTimeout;\n    }\n\n    /** minimum session timeout in milliseconds */\n    public void setMinSessionTimeout(int min) {\n        LOG.info(\"minSessionTimeout set to {}\", min);\n        this.minSessionTimeout = min;\n    }\n\n    /** maximum session timeout in milliseconds */\n    public int getMaxSessionTimeout() {\n        return maxSessionTimeout;\n    }\n\n    /** maximum session timeout in milliseconds */\n    public void setMaxSessionTimeout(int max) {\n        LOG.info(\"maxSessionTimeout set to {}\", max);\n        this.maxSessionTimeout = max;\n    }\n\n    /** The server socket's listen backlog length */\n    public int getClientPortListenBacklog() {\n        return this.clientPortListenBacklog;\n    }\n\n    /** Sets the server socket's listen backlog length. */\n    public void setClientPortListenBacklog(int backlog) {\n        this.clientPortListenBacklog = backlog;\n    }\n\n    /**\n     * Get the number of ticks that the initial synchronization phase can take\n     */\n    public int getInitLimit() {\n        return initLimit;\n    }\n\n    /**\n     * Set the number of ticks that the initial synchronization phase can take\n     */\n    public void setInitLimit(int initLimit) {\n        LOG.info(\"initLimit set to {}\", initLimit);\n        this.initLimit = initLimit;\n    }\n\n    /**\n     * Get the current tick\n     */\n    public int getTick() {\n        return tick.get();\n    }\n\n    public QuorumVerifier configFromString(String s) throws IOException, ConfigException {\n        Properties props = new Properties();\n        props.load(new StringReader(s));\n        return QuorumPeerConfig.parseDynamicConfig(props, electionType, false, false);\n    }\n\n    /**\n     * Return QuorumVerifier object for the last committed configuration.\n     */\n    public QuorumVerifier getQuorumVerifier() {\n        synchronized (QV_LOCK) {\n            return quorumVerifier;\n        }\n    }\n\n    /**\n     * Return QuorumVerifier object for the last proposed configuration.\n     */\n    public QuorumVerifier getLastSeenQuorumVerifier() {\n        synchronized (QV_LOCK) {\n            return lastSeenQuorumVerifier;\n        }\n    }\n\n    public synchronized void restartLeaderElection(QuorumVerifier qvOLD, QuorumVerifier qvNEW) {\n        if (qvOLD == null || !qvOLD.equals(qvNEW)) {\n            LOG.warn(\"Restarting Leader Election\");\n            getElectionAlg().shutdown();\n            shuttingDownLE = false;\n            startLeaderElection();\n        }\n    }\n\n    public String getNextDynamicConfigFilename() {\n        if (configFilename == null) {\n            LOG.warn(\"configFilename is null! This should only happen in tests.\");\n            return null;\n        }\n        return configFilename + QuorumPeerConfig.nextDynamicConfigFileSuffix;\n    }\n\n    // On entry to this method, qcm must be non-null and the locks on both qcm and QV_LOCK\n    // must be held.  We don't want quorumVerifier/lastSeenQuorumVerifier to change out from\n    // under us, so we have to hold QV_LOCK; and since the call to qcm.connectOne() will take\n    // the lock on qcm (and take QV_LOCK again inside that), the caller needs to have taken\n    // qcm outside QV_LOCK to avoid a deadlock against other callers of qcm.connectOne().\n    private void connectNewPeers(QuorumCnxManager qcm) {\n        if (quorumVerifier != null && lastSeenQuorumVerifier != null) {\n            Map<Long, QuorumServer> committedView = quorumVerifier.getAllMembers();\n            for (Entry<Long, QuorumServer> e : lastSeenQuorumVerifier.getAllMembers().entrySet()) {\n                if (e.getKey() != getId() && !committedView.containsKey(e.getKey())) {\n                    qcm.connectOne(e.getKey());\n                }\n            }\n        }\n    }\n\n    public void setLastSeenQuorumVerifier(QuorumVerifier qv, boolean writeToDisk) {\n        if (!isReconfigEnabled()) {\n            LOG.info(\"Dynamic reconfig is disabled, we don't store the last seen config.\");\n            return;\n        }\n\n        // If qcm is non-null, we may call qcm.connectOne(), which will take the lock on qcm\n        // and then take QV_LOCK.  Take the locks in the same order to ensure that we don't\n        // deadlock against other callers of connectOne().  If qcmRef gets set in another\n        // thread while we're inside the synchronized block, that does no harm; if we didn't\n        // take a lock on qcm (because it was null when we sampled it), we won't call\n        // connectOne() on it.  (Use of an AtomicReference is enough to guarantee visibility\n        // of updates that provably happen in another thread before entering this method.)\n        QuorumCnxManager qcm = qcmRef.get();\n        Object outerLockObject = (qcm != null) ? qcm : QV_LOCK;\n        synchronized (outerLockObject) {\n            synchronized (QV_LOCK) {\n                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() > qv.getVersion()) {\n                    LOG.error(\"setLastSeenQuorumVerifier called with stale config \"\n                              + qv.getVersion()\n                              + \". Current version: \"\n                              + quorumVerifier.getVersion());\n                }\n                // assuming that a version uniquely identifies a configuration, so if\n                // version is the same, nothing to do here.\n                if (lastSeenQuorumVerifier != null && lastSeenQuorumVerifier.getVersion() == qv.getVersion()) {\n                    return;\n                }\n                lastSeenQuorumVerifier = qv;\n                if (qcm != null) {\n                    connectNewPeers(qcm);\n                }\n\n                if (writeToDisk) {\n                    try {\n                        String fileName = getNextDynamicConfigFilename();\n                        if (fileName != null) {\n                            QuorumPeerConfig.writeDynamicConfig(fileName, qv, true);\n                        }\n                    } catch (IOException e) {\n                        LOG.error(\"Error writing next dynamic config file to disk\", e);\n                    }\n                }\n            }\n        }\n    }\n\n    public QuorumVerifier setQuorumVerifier(QuorumVerifier qv, boolean writeToDisk) {\n        synchronized (QV_LOCK) {\n            if ((quorumVerifier != null) && (quorumVerifier.getVersion() >= qv.getVersion())) {\n                // this is normal. For example - server found out about new config through FastLeaderElection gossiping\n                // and then got the same config in UPTODATE message so its already known\n                LOG.debug(\n                    \"{} setQuorumVerifier called with known or old config {}. Current version: {}\",\n                    getId(),\n                    qv.getVersion(),\n                    quorumVerifier.getVersion());\n                return quorumVerifier;\n            }\n            QuorumVerifier prevQV = quorumVerifier;\n            quorumVerifier = qv;\n            if (lastSeenQuorumVerifier == null || (qv.getVersion() > lastSeenQuorumVerifier.getVersion())) {\n                lastSeenQuorumVerifier = qv;\n            }\n\n            if (writeToDisk) {\n                // some tests initialize QuorumPeer without a static config file\n                if (configFilename != null) {\n                    try {\n                        String dynamicConfigFilename = makeDynamicConfigFilename(qv.getVersion());\n                        QuorumPeerConfig.writeDynamicConfig(dynamicConfigFilename, qv, false);\n                        QuorumPeerConfig.editStaticConfig(configFilename, dynamicConfigFilename, needEraseClientInfoFromStaticConfig());\n                    } catch (IOException e) {\n                        LOG.error(\"Error closing file\", e);\n                    }\n                } else {\n                    LOG.info(\"writeToDisk == true but configFilename == null\");\n                }\n            }\n\n            if (qv.getVersion() == lastSeenQuorumVerifier.getVersion()) {\n                QuorumPeerConfig.deleteFile(getNextDynamicConfigFilename());\n            }\n            QuorumServer qs = qv.getAllMembers().get(getId());\n            if (qs != null) {\n                setAddrs(qs.addr, qs.electionAddr, qs.clientAddr);\n            }\n            updateObserverMasterList();\n            return prevQV;\n        }\n    }\n\n    private String makeDynamicConfigFilename(long version) {\n        return configFilename + \".dynamic.\" + Long.toHexString(version);\n    }\n\n    private boolean needEraseClientInfoFromStaticConfig() {\n        QuorumServer server = quorumVerifier.getAllMembers().get(getId());\n        return (server != null && server.clientAddr != null && !server.isClientAddrFromStatic);\n    }\n\n    /**\n     * Get an instance of LeaderElection\n     */\n    public Election getElectionAlg() {\n        return electionAlg;\n    }\n\n    /**\n     * Get the synclimit\n     */\n    public int getSyncLimit() {\n        return syncLimit;\n    }\n\n    /**\n     * Set the synclimit\n     */\n    public void setSyncLimit(int syncLimit) {\n        LOG.info(\"syncLimit set to {}\", syncLimit);\n        this.syncLimit = syncLimit;\n    }\n\n    /**\n     * Get the connectToLearnerMasterLimit\n     */\n    public int getConnectToLearnerMasterLimit() {\n        return connectToLearnerMasterLimit;\n    }\n\n    /**\n     * Set the connectToLearnerMasterLimit\n     */\n    public void setConnectToLearnerMasterLimit(int connectToLearnerMasterLimit) {\n        LOG.info(\"connectToLearnerMasterLimit set to {}\", connectToLearnerMasterLimit);\n        this.connectToLearnerMasterLimit = connectToLearnerMasterLimit;\n    }\n\n    /**\n     * The syncEnabled can also be set via a system property.\n     */\n    public static final String SYNC_ENABLED = \"zookeeper.observer.syncEnabled\";\n\n    /**\n     * Return syncEnabled.\n     */\n    public boolean getSyncEnabled() {\n        if (System.getProperty(SYNC_ENABLED) != null) {\n            LOG.info(\"{}={}\", SYNC_ENABLED, Boolean.getBoolean(SYNC_ENABLED));\n            return Boolean.getBoolean(SYNC_ENABLED);\n        } else {\n            return syncEnabled;\n        }\n    }\n\n    /**\n     * Set syncEnabled.\n     *\n     * @param syncEnabled\n     */\n    public void setSyncEnabled(boolean syncEnabled) {\n        this.syncEnabled = syncEnabled;\n    }\n\n    /**\n     * Gets the election type\n     */\n    public int getElectionType() {\n        return electionType;\n    }\n\n    /**\n     * Sets the election type\n     */\n    public void setElectionType(int electionType) {\n        this.electionType = electionType;\n    }\n\n    public boolean getQuorumListenOnAllIPs() {\n        return quorumListenOnAllIPs;\n    }\n\n    public void setQuorumListenOnAllIPs(boolean quorumListenOnAllIPs) {\n        this.quorumListenOnAllIPs = quorumListenOnAllIPs;\n    }\n\n    public void setCnxnFactory(ServerCnxnFactory cnxnFactory) {\n        this.cnxnFactory = cnxnFactory;\n    }\n\n    public void setSecureCnxnFactory(ServerCnxnFactory secureCnxnFactory) {\n        this.secureCnxnFactory = secureCnxnFactory;\n    }\n\n    public void setSslQuorum(boolean sslQuorum) {\n        if (sslQuorum) {\n            LOG.info(\"Using TLS encrypted quorum communication\");\n        } else {\n            LOG.info(\"Using insecure (non-TLS) quorum communication\");\n        }\n        this.sslQuorum = sslQuorum;\n    }\n\n    public void setUsePortUnification(boolean shouldUsePortUnification) {\n        LOG.info(\"Port unification {}\", shouldUsePortUnification ? \"enabled\" : \"disabled\");\n        this.shouldUsePortUnification = shouldUsePortUnification;\n    }\n\n    private void startServerCnxnFactory() {\n        if (cnxnFactory != null) {\n            cnxnFactory.start();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.start();\n        }\n    }\n\n    private void shutdownServerCnxnFactory() {\n        if (cnxnFactory != null) {\n            cnxnFactory.shutdown();\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.shutdown();\n        }\n    }\n\n    // Leader and learner will control the zookeeper server and pass it into QuorumPeer.\n    public void setZooKeeperServer(ZooKeeperServer zks) {\n        if (cnxnFactory != null) {\n            cnxnFactory.setZooKeeperServer(zks);\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.setZooKeeperServer(zks);\n        }\n    }\n\n    public void closeAllConnections() {\n        if (cnxnFactory != null) {\n            cnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n        }\n        if (secureCnxnFactory != null) {\n            secureCnxnFactory.closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n        }\n    }\n\n    public int getClientPort() {\n        if (cnxnFactory != null) {\n            return cnxnFactory.getLocalPort();\n        }\n        return -1;\n    }\n\n    public void setTxnFactory(FileTxnSnapLog factory) {\n        this.logFactory = factory;\n    }\n\n    public FileTxnSnapLog getTxnFactory() {\n        return this.logFactory;\n    }\n\n    /**\n     * set zk database for this node\n     * @param database\n     */\n    public void setZKDatabase(ZKDatabase database) {\n        this.zkDb = database;\n    }\n\n    protected ZKDatabase getZkDb() {\n        return zkDb;\n    }\n\n    public synchronized void initConfigInZKDatabase() {\n        if (zkDb != null) {\n            zkDb.initConfigInZKDatabase(getQuorumVerifier());\n        }\n    }\n\n    public boolean isRunning() {\n        return running;\n    }\n\n    /**\n     * get reference to QuorumCnxManager\n     */\n    public QuorumCnxManager getQuorumCnxManager() {\n        return qcmRef.get();\n    }\n    private long readLongFromFile(String name) throws IOException {\n        File file = new File(logFactory.getSnapDir(), name);\n        BufferedReader br = new BufferedReader(new FileReader(file));\n        String line = \"\";\n        try {\n            line = br.readLine();\n            return Long.parseLong(line);\n        } catch (NumberFormatException e) {\n            throw new IOException(\"Found \" + line + \" in \" + file);\n        } finally {\n            br.close();\n        }\n    }\n\n    private long acceptedEpoch = -1;\n    private long currentEpoch = -1;\n\n    public static final String CURRENT_EPOCH_FILENAME = \"currentEpoch\";\n\n    public static final String ACCEPTED_EPOCH_FILENAME = \"acceptedEpoch\";\n\n    /**\n     * Write a long value to disk atomically. Either succeeds or an exception\n     * is thrown.\n     * @param name file name to write the long to\n     * @param value the long value to write to the named file\n     * @throws IOException if the file cannot be written atomically\n     */\n    // visibleForTest\n     void writeLongToFile(String name, final long value) throws IOException {\n        File file = new File(logFactory.getSnapDir(), name);\n        new AtomicFileWritingIdiom(file, new WriterStatement() {\n            @Override\n            public void write(Writer bw) throws IOException {\n                bw.write(Long.toString(value));\n            }\n        });\n    }\n\n    public long getCurrentEpoch() throws IOException {\n        if (currentEpoch == -1) {\n            currentEpoch = readLongFromFile(CURRENT_EPOCH_FILENAME);\n        }\n        return currentEpoch;\n    }\n\n    public long getAcceptedEpoch() throws IOException {\n        if (acceptedEpoch == -1) {\n            acceptedEpoch = readLongFromFile(ACCEPTED_EPOCH_FILENAME);\n        }\n        return acceptedEpoch;\n    }\n\n    public void setCurrentEpoch(long e) throws IOException {\n        writeLongToFile(CURRENT_EPOCH_FILENAME, e);\n        currentEpoch = e;\n\n    }\n\n    public void setAcceptedEpoch(long e) throws IOException {\n        writeLongToFile(ACCEPTED_EPOCH_FILENAME, e);\n        acceptedEpoch = e;\n    }\n\n    public boolean processReconfig(QuorumVerifier qv, Long suggestedLeaderId, Long zxid, boolean restartLE) {\n        if (!isReconfigEnabled()) {\n            LOG.debug(\"Reconfig feature is disabled, skip reconfig processing.\");\n            return false;\n        }\n\n        InetSocketAddress oldClientAddr = getClientAddress();\n\n        // update last committed quorum verifier, write the new config to disk\n        // and restart leader election if config changed.\n        QuorumVerifier prevQV = setQuorumVerifier(qv, true);\n\n        // There is no log record for the initial config, thus after syncing\n        // with leader\n        // /zookeeper/config is empty! it is also possible that last committed\n        // config is propagated during leader election\n        // without the propagation the corresponding log records.\n        // so we should explicitly do this (this is not necessary when we're\n        // already a Follower/Observer, only\n        // for Learner):\n        initConfigInZKDatabase();\n\n        if (prevQV.getVersion() < qv.getVersion() && !prevQV.equals(qv)) {\n            Map<Long, QuorumServer> newMembers = qv.getAllMembers();\n            updateRemotePeerMXBeans(newMembers);\n            if (restartLE) {\n                restartLeaderElection(prevQV, qv);\n            }\n\n            QuorumServer myNewQS = newMembers.get(getId());\n            if (myNewQS != null && myNewQS.clientAddr != null && !myNewQS.clientAddr.equals(oldClientAddr)) {\n                cnxnFactory.reconfigure(myNewQS.clientAddr);\n                updateThreadName();\n            }\n\n            boolean roleChange = updateLearnerType(qv);\n            boolean leaderChange = false;\n            if (suggestedLeaderId != null) {\n                // zxid should be non-null too\n                leaderChange = updateVote(suggestedLeaderId, zxid);\n            } else {\n                long currentLeaderId = getCurrentVote().getId();\n                QuorumServer myleaderInCurQV = prevQV.getVotingMembers().get(currentLeaderId);\n                QuorumServer myleaderInNewQV = qv.getVotingMembers().get(currentLeaderId);\n                leaderChange = (myleaderInCurQV == null\n                                || myleaderInCurQV.addr == null\n                                || myleaderInNewQV == null\n                                || !myleaderInCurQV.addr.equals(myleaderInNewQV.addr));\n                // we don't have a designated leader - need to go into leader\n                // election\n                reconfigFlagClear();\n            }\n\n            return roleChange || leaderChange;\n        }\n        return false;\n\n    }\n\n    private void updateRemotePeerMXBeans(Map<Long, QuorumServer> newMembers) {\n        Set<Long> existingMembers = new HashSet<Long>(newMembers.keySet());\n        existingMembers.retainAll(jmxRemotePeerBean.keySet());\n        for (Long id : existingMembers) {\n            RemotePeerBean rBean = jmxRemotePeerBean.get(id);\n            rBean.setQuorumServer(newMembers.get(id));\n        }\n\n        Set<Long> joiningMembers = new HashSet<Long>(newMembers.keySet());\n        joiningMembers.removeAll(jmxRemotePeerBean.keySet());\n        joiningMembers.remove(getId()); // remove self as it is local bean\n        for (Long id : joiningMembers) {\n            QuorumServer qs = newMembers.get(id);\n            RemotePeerBean rBean = new RemotePeerBean(this, qs);\n            try {\n                MBeanRegistry.getInstance().register(rBean, jmxQuorumBean);\n                jmxRemotePeerBean.put(qs.id, rBean);\n            } catch (Exception e) {\n                LOG.warn(\"Failed to register with JMX\", e);\n            }\n        }\n\n        Set<Long> leavingMembers = new HashSet<Long>(jmxRemotePeerBean.keySet());\n        leavingMembers.removeAll(newMembers.keySet());\n        for (Long id : leavingMembers) {\n            RemotePeerBean rBean = jmxRemotePeerBean.remove(id);\n            try {\n                MBeanRegistry.getInstance().unregister(rBean);\n            } catch (Exception e) {\n                LOG.warn(\"Failed to unregister with JMX\", e);\n            }\n        }\n    }\n\n    private ArrayList<QuorumServer> observerMasters = new ArrayList<>();\n    private void updateObserverMasterList() {\n        if (observerMasterPort <= 0) {\n            return; // observer masters not enabled\n        }\n        observerMasters.clear();\n        StringBuilder sb = new StringBuilder();\n        for (QuorumServer server : quorumVerifier.getVotingMembers().values()) {\n            InetAddress address = server.addr.getReachableOrOne().getAddress();\n            InetSocketAddress addr = new InetSocketAddress(address, observerMasterPort);\n            observerMasters.add(new QuorumServer(server.id, addr));\n            sb.append(addr).append(\",\");\n        }\n        LOG.info(\"Updated learner master list to be {}\", sb.toString());\n        Collections.shuffle(observerMasters);\n        // Reset the internal index of the observerMaster when\n        // the observerMaster List is refreshed\n        nextObserverMaster = 0;\n    }\n\n    private boolean useObserverMasters() {\n        return getLearnerType() == LearnerType.OBSERVER && observerMasters.size() > 0;\n    }\n\n    private int nextObserverMaster = 0;\n    private QuorumServer nextObserverMaster() {\n        if (nextObserverMaster >= observerMasters.size()) {\n            nextObserverMaster = 0;\n            // Add a reconnect delay only after the observer\n            // has exhausted trying to connect to all the masters\n            // from the observerMasterList\n            if (isRunning()) {\n                Observer.waitForReconnectDelay();\n            }\n        }\n        return observerMasters.get(nextObserverMaster++);\n    }\n\n    QuorumServer findLearnerMaster(QuorumServer leader) {\n        if (useObserverMasters()) {\n            return nextObserverMaster();\n        } else {\n            // Add delay jitter to reduce the load on the leader\n            if (isRunning()) {\n                Observer.waitForReconnectDelay();\n            }\n            return leader;\n        }\n    }\n\n    /**\n     * Vet a given learner master's information.\n     * Allows specification by server id, ip  only, or ip and port\n     */\n    QuorumServer validateLearnerMaster(String desiredMaster) {\n        if (useObserverMasters()) {\n            Long sid;\n            try {\n                sid = Long.parseLong(desiredMaster);\n            } catch (NumberFormatException e) {\n                sid = null;\n            }\n            for (QuorumServer server : observerMasters) {\n                if (sid == null) {\n                    for (InetSocketAddress address : server.addr.getAllAddresses()) {\n                        String serverAddr = address.getAddress().getHostAddress() + ':' + address.getPort();\n                        if (serverAddr.startsWith(desiredMaster)) {\n                            return server;\n                        }\n                    }\n                } else {\n                    if (sid.equals(server.id)) {\n                        return server;\n                    }\n                }\n            }\n            if (sid == null) {\n                LOG.info(\"could not find learner master address={}\", desiredMaster);\n            } else {\n                LOG.warn(\"could not find learner master sid={}\", sid);\n            }\n        } else {\n            LOG.info(\"cannot validate request, observer masters not enabled\");\n        }\n        return null;\n    }\n\n    private boolean updateLearnerType(QuorumVerifier newQV) {\n        //check if I'm an observer in new config\n        if (newQV.getObservingMembers().containsKey(getId())) {\n            if (getLearnerType() != LearnerType.OBSERVER) {\n                setLearnerType(LearnerType.OBSERVER);\n                LOG.info(\"Becoming an observer\");\n                reconfigFlagSet();\n                return true;\n            } else {\n                return false;\n            }\n        } else if (newQV.getVotingMembers().containsKey(getId())) {\n            if (getLearnerType() != LearnerType.PARTICIPANT) {\n                setLearnerType(LearnerType.PARTICIPANT);\n                LOG.info(\"Becoming a voting participant\");\n                reconfigFlagSet();\n                return true;\n            } else {\n                return false;\n            }\n        }\n        // I'm not in the view\n        if (getLearnerType() != LearnerType.PARTICIPANT) {\n            setLearnerType(LearnerType.PARTICIPANT);\n            LOG.info(\"Becoming a non-voting participant\");\n            reconfigFlagSet();\n            return true;\n        }\n        return false;\n    }\n\n    private boolean updateVote(long designatedLeader, long zxid) {\n        Vote currentVote = getCurrentVote();\n        if (currentVote != null && designatedLeader != currentVote.getId()) {\n            setCurrentVote(new Vote(designatedLeader, zxid));\n            reconfigFlagSet();\n            LOG.warn(\"Suggested leader: {}\", designatedLeader);\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Updates leader election info to avoid inconsistencies when\n     * a new server tries to join the ensemble.\n     *\n     * Here is the inconsistency scenario we try to solve by updating the peer\n     * epoch after following leader:\n     *\n     * Let's say we have an ensemble with 3 servers z1, z2 and z3.\n     *\n     * 1. z1, z2 were following z3 with peerEpoch to be 0xb8, the new epoch is\n     *    0xb9, aka current accepted epoch on disk.\n     * 2. z2 get restarted, which will use 0xb9 as it's peer epoch when loading\n     *    the current accept epoch from disk.\n     * 3. z2 received notification from z1 and z3, which is following z3 with\n     *    epoch 0xb8, so it started following z3 again with peer epoch 0xb8.\n     * 4. before z2 successfully connected to z3, z3 get restarted with new\n     *    epoch 0xb9.\n     * 5. z2 will retry around a few round (default 5s) before giving up,\n     *    meanwhile it will report z3 as leader.\n     * 6. z1 restarted, and looking with peer epoch 0xb9.\n     * 7. z1 voted z3, and z3 was elected as leader again with peer epoch 0xb9.\n     * 8. z2 successfully connected to z3 before giving up, but with peer\n     *    epoch 0xb8.\n     * 9. z1 get restarted, looking for leader with peer epoch 0xba, but cannot\n     *    join, because z2 is reporting peer epoch 0xb8, while z3 is reporting\n     *    0xb9.\n     *\n     * By updating the election vote after actually following leader, we can\n     * avoid this kind of stuck happened.\n     *\n     * Btw, the zxid and electionEpoch could be inconsistent because of the same\n     * reason, it's better to update these as well after syncing with leader, but\n     * that required protocol change which is non trivial. This problem is worked\n     * around by skipping comparing the zxid and electionEpoch when counting for\n     * votes for out of election servers during looking for leader.\n     *\n     * See https://issues.apache.org/jira/browse/ZOOKEEPER-1732\n     */\n    protected void updateElectionVote(long newEpoch) {\n        Vote currentVote = getCurrentVote();\n        if (currentVote != null) {\n            setCurrentVote(new Vote(currentVote.getId(), currentVote.getZxid(), currentVote.getElectionEpoch(), newEpoch, currentVote\n                .getState()));\n        }\n    }\n\n    private void updateThreadName() {\n        String plain = cnxnFactory != null\n                ? cnxnFactory.getLocalAddress() != null\n                    ? formatInetAddr(cnxnFactory.getLocalAddress())\n                    : \"disabled\"\n                : \"disabled\";\n        String secure = secureCnxnFactory != null ? formatInetAddr(secureCnxnFactory.getLocalAddress()) : \"disabled\";\n        setName(String.format(\"QuorumPeer[myid=%d](plain=%s)(secure=%s)\", getId(), plain, secure));\n    }\n\n    /**\n     * Sets the time taken for leader election in milliseconds.\n     *\n     * @param electionTimeTaken time taken for leader election\n     */\n    void setElectionTimeTaken(long electionTimeTaken) {\n        this.electionTimeTaken = electionTimeTaken;\n    }\n\n    /**\n     * @return the time taken for leader election in milliseconds.\n     */\n    long getElectionTimeTaken() {\n        return electionTimeTaken;\n    }\n\n    void setQuorumServerSaslRequired(boolean serverSaslRequired) {\n        quorumServerSaslAuthRequired = serverSaslRequired;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, serverSaslRequired);\n    }\n\n    void setQuorumLearnerSaslRequired(boolean learnerSaslRequired) {\n        quorumLearnerSaslAuthRequired = learnerSaslRequired;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, learnerSaslRequired);\n    }\n\n    void setQuorumSaslEnabled(boolean enableAuth) {\n        quorumSaslEnableAuth = enableAuth;\n        if (!quorumSaslEnableAuth) {\n            LOG.info(\"QuorumPeer communication is not secured! (SASL auth disabled)\");\n        } else {\n            LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);\n        }\n    }\n\n    void setQuorumServicePrincipal(String servicePrincipal) {\n        quorumServicePrincipal = servicePrincipal;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, quorumServicePrincipal);\n    }\n\n    void setQuorumLearnerLoginContext(String learnerContext) {\n        quorumLearnerLoginContext = learnerContext;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, quorumLearnerLoginContext);\n    }\n\n    void setQuorumServerLoginContext(String serverContext) {\n        quorumServerLoginContext = serverContext;\n        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT, quorumServerLoginContext);\n    }\n\n    void setQuorumCnxnThreadsSize(int qCnxnThreadsSize) {\n        if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {\n            quorumCnxnThreadsSize = qCnxnThreadsSize;\n        }\n        LOG.info(\"quorum.cnxn.threads.size set to {}\", quorumCnxnThreadsSize);\n    }\n\n    boolean isQuorumSaslAuthEnabled() {\n        return quorumSaslEnableAuth;\n    }\n\n    private boolean isQuorumServerSaslAuthRequired() {\n        return quorumServerSaslAuthRequired;\n    }\n\n    private boolean isQuorumLearnerSaslAuthRequired() {\n        return quorumLearnerSaslAuthRequired;\n    }\n\n    public QuorumCnxManager createCnxnManager() {\n        int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit;\n        LOG.info(\"Using {}ms as the quorum cnxn socket timeout\", timeout);\n        return new QuorumCnxManager(\n            this,\n            this.getId(),\n            this.getView(),\n            this.authServer,\n            this.authLearner,\n            timeout,\n            this.getQuorumListenOnAllIPs(),\n            this.quorumCnxnThreadsSize,\n            this.isQuorumSaslAuthEnabled());\n    }\n\n    boolean isLeader(long id) {\n        Vote vote = getCurrentVote();\n        return vote != null && id == vote.getId();\n    }\n\n    public boolean isReconfigEnabled() {\n        return reconfigEnabled;\n    }\n\n    @InterfaceAudience.Private\n    /**\n     * This is a metric that depends on the status of the peer.\n     */ public Integer getSynced_observers_metric() {\n        if (leader != null) {\n            return leader.getObservingLearners().size();\n        } else if (follower != null) {\n            return follower.getSyncedObserverSize();\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Create a new QuorumPeer and apply all the values per the already-parsed config.\n     *\n     * @param config The appertained quorum peer config.\n     * @return A QuorumPeer instantiated with specified peer config. Note this peer\n     *         is not fully initialized; caller should finish initialization through\n     *         additional configurations (connection factory settings, etc).\n     *\n     * @throws IOException\n     */\n    public static QuorumPeer createFromConfig(QuorumPeerConfig config) throws IOException {\n        QuorumPeer quorumPeer = new QuorumPeer();\n        quorumPeer.setTxnFactory(new FileTxnSnapLog(config.getDataLogDir(), config.getDataDir()));\n        quorumPeer.enableLocalSessions(config.areLocalSessionsEnabled());\n        quorumPeer.enableLocalSessionsUpgrading(config.isLocalSessionsUpgradingEnabled());\n        quorumPeer.setElectionType(config.getElectionAlg());\n        quorumPeer.setMyid(config.getServerId());\n        quorumPeer.setTickTime(config.getTickTime());\n        quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n        quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n        quorumPeer.setInitLimit(config.getInitLimit());\n        quorumPeer.setSyncLimit(config.getSyncLimit());\n        quorumPeer.setConnectToLearnerMasterLimit(config.getConnectToLearnerMasterLimit());\n        quorumPeer.setObserverMasterPort(config.getObserverMasterPort());\n        quorumPeer.setConfigFileName(config.getConfigFilename());\n        quorumPeer.setClientPortListenBacklog(config.getClientPortListenBacklog());\n        quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n        quorumPeer.setQuorumVerifier(config.getQuorumVerifier(), false);\n        if (config.getLastSeenQuorumVerifier() != null) {\n            quorumPeer.setLastSeenQuorumVerifier(config.getLastSeenQuorumVerifier(), false);\n        }\n        quorumPeer.initConfigInZKDatabase();\n        quorumPeer.setSslQuorum(config.isSslQuorum());\n        quorumPeer.setUsePortUnification(config.shouldUsePortUnification());\n        quorumPeer.setLearnerType(config.getPeerType());\n        quorumPeer.setSyncEnabled(config.getSyncEnabled());\n        quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n        if (config.sslQuorumReloadCertFiles) {\n            quorumPeer.getX509Util().enableCertFileReloading();\n        }\n        quorumPeer.setMultiAddressEnabled(config.isMultiAddressEnabled());\n        quorumPeer.setMultiAddressReachabilityCheckEnabled(config.isMultiAddressReachabilityCheckEnabled());\n        quorumPeer.setMultiAddressReachabilityCheckTimeoutMs(config.getMultiAddressReachabilityCheckTimeoutMs());\n\n        // sets quorum sasl authentication configurations\n        quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n        if (quorumPeer.isQuorumSaslAuthEnabled()) {\n            quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n            quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n            quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n            quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n            quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n        }\n        quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n\n        if (config.jvmPauseMonitorToRun) {\n            quorumPeer.setJvmPauseMonitor(new JvmPauseMonitor(config));\n        }\n\n        return quorumPeer;\n    }\n\n}\n","lineNo":342}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.KeeperException.Code;\nimport org.apache.zookeeper.ZooDefs.OpCode;\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.DataTree.ProcessTxnResult;\nimport org.apache.zookeeper.server.Request;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ServerStats;\nimport org.apache.zookeeper.server.ZooTrace;\nimport org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;\nimport org.apache.zookeeper.txn.CreateSessionTxn;\nimport org.apache.zookeeper.txn.TxnDigest;\nimport org.apache.zookeeper.txn.TxnHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This is a helper class\n * above the implementations\n * of txnlog and snapshot\n * classes\n */\npublic class FileTxnSnapLog {\n\n    //the directory containing the\n    //the transaction logs\n    final File dataDir;\n    //the directory containing the\n    //the snapshot directory\n    final File snapDir;\n    TxnLog txnLog;\n    SnapShot snapLog;\n    private final boolean autoCreateDB;\n    private final boolean trustEmptySnapshot;\n    public static final int VERSION = 2;\n    public static final String version = \"version-\";\n\n    private static final Logger LOG = LoggerFactory.getLogger(FileTxnSnapLog.class);\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE = \"zookeeper.datadir.autocreate\";\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT = \"true\";\n\n    static final String ZOOKEEPER_DB_AUTOCREATE = \"zookeeper.db.autocreate\";\n\n    private static final String ZOOKEEPER_DB_AUTOCREATE_DEFAULT = \"true\";\n\n    public static final String ZOOKEEPER_SNAPSHOT_TRUST_EMPTY = \"zookeeper.snapshot.trust.empty\";\n\n    private static final String EMPTY_SNAPSHOT_WARNING = \"No snapshot found, but there are log entries. \";\n\n    /**\n     * This listener helps\n     * the external apis calling\n     * restore to gather information\n     * while the data is being\n     * restored.\n     */\n    public interface PlayBackListener {\n\n        void onTxnLoaded(TxnHeader hdr, Record rec, TxnDigest digest);\n\n    }\n\n    /**\n     * Finalizing restore of data tree through\n     * a set of operations (replaying transaction logs,\n     * calculating data tree digests, and so on.).\n     */\n    private interface RestoreFinalizer {\n        /**\n         * @return the highest zxid of restored data tree.\n         */\n        long run() throws IOException;\n    }\n\n    /**\n     * the constructor which takes the datadir and\n     * snapdir.\n     * @param dataDir the transaction directory\n     * @param snapDir the snapshot directory\n     */\n    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n        LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n\n        this.dataDir = new File(dataDir, version + VERSION);\n        this.snapDir = new File(snapDir, version + VERSION);\n\n        // by default create snap/log dirs, but otherwise complain instead\n        // See ZOOKEEPER-1161 for more details\n        boolean enableAutocreate = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n\n        trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n        LOG.info(\"{} : {}\", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);\n\n        if (!this.dataDir.exists()) {\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing data directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \" Please create this directory manually.\",\n                    this.dataDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n                throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n            }\n        }\n        if (!this.dataDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n        }\n\n        if (!this.snapDir.exists()) {\n            // by default create this directory, but otherwise complain instead\n            // See ZOOKEEPER-1161 for more details\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \"Please create this directory manually.\",\n                    this.snapDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n                throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n            }\n        }\n        if (!this.snapDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n        }\n\n        // check content of transaction log and snapshot dirs if they are two different directories\n        // See ZOOKEEPER-2967 for more details\n        if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n            checkLogDir();\n            checkSnapDir();\n        }\n\n        txnLog = new FileTxnLog(this.dataDir);\n        snapLog = new FileSnap(this.snapDir);\n\n        autoCreateDB = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n    }\n\n    public void setServerStats(ServerStats serverStats) {\n        txnLog.setServerStats(serverStats);\n    }\n\n    private void checkLogDir() throws LogDirContentCheckException {\n        File[] files = this.dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isSnapshotFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new LogDirContentCheckException(\n                \"Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    private void checkSnapDir() throws SnapDirContentCheckException {\n        File[] files = this.snapDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isLogFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new SnapDirContentCheckException(\n                \"Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    /**\n     * get the datadir used by this filetxn\n     * snap log\n     * @return the data dir\n     */\n    public File getDataDir() {\n        return this.dataDir;\n    }\n\n    /**\n     * get the snap dir used by this\n     * filetxn snap log\n     * @return the snap dir\n     */\n    public File getSnapDir() {\n        return this.snapDir;\n    }\n\n    /**\n     * get information of the last saved/restored snapshot\n     * @return info of last snapshot\n     */\n    public SnapshotInfo getLastSnapshotInfo() {\n        return this.snapLog.getLastSnapshotInfo();\n    }\n\n    /**\n     * this function restores the server\n     * database after reading from the\n     * snapshots and transaction logs\n     * @param dt the datatree to be restored\n     * @param sessions the sessions to be restored\n     * @param listener the playback listener to run on the\n     * database restoration\n     * @return the highest zxid restored\n     * @throws IOException\n     */\n    public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException {\n        long snapLoadingStartTime = Time.currentElapsedTime();\n        long deserializeResult = snapLog.deserialize(dt, sessions);\n        ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        boolean trustEmptyDB;\n        File initFile = new File(dataDir.getParent(), \"initialize\");\n        if (Files.deleteIfExists(initFile.toPath())) {\n            LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n            trustEmptyDB = true;\n        } else {\n            trustEmptyDB = autoCreateDB;\n        }\n\n        RestoreFinalizer finalizer = () -> {\n            long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n            // The snapshotZxidDigest will reset after replaying the txn of the\n            // zxid in the snapshotZxidDigest, if it's not reset to null after\n            // restoring, it means either there are not enough txns to cover that\n            // zxid or that txn is missing\n            DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n            if (snapshotZxidDigest != null) {\n                LOG.warn(\n                        \"Highest txn zxid 0x{} is not covering the snapshot digest zxid 0x{}, \"\n                                + \"which might lead to inconsistent state\",\n                        Long.toHexString(highestZxid),\n                        Long.toHexString(snapshotZxidDigest.getZxid()));\n            }\n            return highestZxid;\n        };\n\n        if (-1L == deserializeResult) {\n            /* this means that we couldn't find any snapshot, so we need to\n             * initialize an empty database (reported in ZOOKEEPER-2325) */\n            if (txnLog.getLastLoggedZxid() != -1) {\n                // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n                // from old versions of zookeeper (3.4.x, pre 3.5.3).\n                if (!trustEmptySnapshot) {\n                    throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n                } else {\n                    LOG.warn(\"{}This should only be allowed during upgrading.\", EMPTY_SNAPSHOT_WARNING);\n                    return finalizer.run();\n                }\n            }\n\n            if (trustEmptyDB) {\n                /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n                 *       or use Map on save() */\n                save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n\n                /* return a zxid of 0, since we know the database is empty */\n                return 0L;\n            } else {\n                /* return a zxid of -1, since we are possibly missing data */\n                LOG.warn(\"Unexpected empty data tree, setting zxid to -1\");\n                dt.lastProcessedZxid = -1L;\n                return -1L;\n            }\n        }\n\n        return finalizer.run();\n    }\n\n    /**\n     * This function will fast forward the server database to have the latest\n     * transactions in it.  This is the same as restore, but only reads from\n     * the transaction logs and not restores from a snapshot.\n     * @param dt the datatree to write transactions to.\n     * @param sessions the sessions to be restored.\n     * @param listener the playback listener to run on the\n     * database transactions.\n     * @return the highest zxid restored.\n     * @throws IOException\n     */\n    public long fastForwardFromEdits(\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        PlayBackListener listener) throws IOException {\n        TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);\n        long highestZxid = dt.lastProcessedZxid;\n        TxnHeader hdr;\n        int txnLoaded = 0;\n        long startTime = Time.currentElapsedTime();\n        try {\n            while (true) {\n                // iterator points to\n                // the first valid txn when initialized\n                hdr = itr.getHeader();\n                if (hdr == null) {\n                    //empty logs\n                    return dt.lastProcessedZxid;\n                }\n                if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n                    LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n                } else {\n                    highestZxid = hdr.getZxid();\n                }\n                try {\n                    processTransaction(hdr, dt, sessions, itr.getTxn());\n                    dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n                    txnLoaded++;\n                } catch (KeeperException.NoNodeException e) {\n                    throw new IOException(\"Failed to process transaction type: \"\n                                          + hdr.getType()\n                                          + \" error: \"\n                                          + e.getMessage(),\n                                          e);\n                }\n                listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n                if (!itr.next()) {\n                    break;\n                }\n            }\n        } finally {\n            if (itr != null) {\n                itr.close();\n            }\n        }\n\n        long loadTime = Time.currentElapsedTime() - startTime;\n        LOG.info(\"{} txns loaded in {} ms\", txnLoaded, loadTime);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);\n\n        return highestZxid;\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid) throws IOException {\n        return readTxnLog(zxid, true);\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @param fastForward true if the iterator should be fast forwarded to point\n     *        to the txn of a given zxid, else the iterator will point to the\n     *        starting txn of a txnlog that may contain txn of a given zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid, boolean fastForward) throws IOException {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.read(zxid, fastForward);\n    }\n\n    /**\n     * process the transaction on the datatree\n     * @param hdr the hdr of the transaction\n     * @param dt the datatree to apply transaction to\n     * @param sessions the sessions to be restored\n     * @param txn the transaction to be applied\n     */\n    public void processTransaction(\n        TxnHeader hdr,\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        Record txn) throws KeeperException.NoNodeException {\n        ProcessTxnResult rc;\n        switch (hdr.getType()) {\n        case OpCode.createSession:\n            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- create session in log: 0x\" + Long.toHexString(hdr.getClientId())\n                    + \" with timeout: \" + ((CreateSessionTxn) txn).getTimeOut());\n            }\n            // give dataTree a chance to sync its lastProcessedZxid\n            rc = dt.processTxn(hdr, txn);\n            break;\n        case OpCode.closeSession:\n            sessions.remove(hdr.getClientId());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- close session in log: 0x\" + Long.toHexString(hdr.getClientId()));\n            }\n            rc = dt.processTxn(hdr, txn);\n            break;\n        default:\n            rc = dt.processTxn(hdr, txn);\n        }\n\n        /*\n         * Snapshots are lazily created. So when a snapshot is in progress,\n         * there is a chance for later transactions to make into the\n         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n         * errors could occur. It should be safe to ignore these.\n         */\n        if (rc.err != Code.OK.intValue()) {\n            LOG.debug(\"Ignoring processTxn failure hdr: {}, error: {}, path: {}\", hdr.getType(), rc.err, rc.path);\n        }\n    }\n\n    /**\n     * the last logged zxid on the transaction logs\n     * @return the last logged zxid\n     */\n    public long getLastLoggedZxid() {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.getLastLoggedZxid();\n    }\n\n    /**\n     * save the datatree and the sessions into a snapshot\n     * @param dataTree the datatree to be serialized onto disk\n     * @param sessionsWithTimeouts the session timeouts to be\n     * serialized onto disk\n     * @param syncSnap sync the snapshot immediately after write\n     * @throws IOException\n     */\n    public void save(\n        DataTree dataTree,\n        ConcurrentHashMap<Long, Integer> sessionsWithTimeouts,\n        boolean syncSnap) throws IOException {\n        long lastZxid = dataTree.lastProcessedZxid;\n        File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));\n        LOG.info(\"Snapshotting: 0x{} to {}\", Long.toHexString(lastZxid), snapshotFile);\n        try {\n            snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);\n        } catch (IOException e) {\n            if (snapshotFile.length() == 0) {\n                /* This may be caused by a full disk. In such a case, the server\n                 * will get stuck in a loop where it tries to write a snapshot\n                 * out to disk, and ends up creating an empty file instead.\n                 * Doing so will eventually result in valid snapshots being\n                 * removed during cleanup. */\n                if (snapshotFile.delete()) {\n                    LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                } else {\n                    LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                }\n            } else {\n                /* Something else went wrong when writing the snapshot out to\n                 * disk. If this snapshot file is invalid, when restarting,\n                 * ZooKeeper will skip it, and find the last known good snapshot\n                 * instead. */\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * truncate the transaction logs the zxid\n     * specified\n     * @param zxid the zxid to truncate the logs to\n     * @return true if able to truncate the log, false if not\n     * @throws IOException\n     */\n    public boolean truncateLog(long zxid) {\n        try {\n            // close the existing txnLog and snapLog\n            close();\n\n            // truncate it\n            try (FileTxnLog truncLog = new FileTxnLog(dataDir)) {\n                boolean truncated = truncLog.truncate(zxid);\n\n                // re-open the txnLog and snapLog\n                // I'd rather just close/reopen this object itself, however that\n                // would have a big impact outside ZKDatabase as there are other\n                // objects holding a reference to this object.\n                txnLog = new FileTxnLog(dataDir);\n                snapLog = new FileSnap(snapDir);\n\n                return truncated;\n            }\n        } catch (IOException e) {\n            LOG.error(\"Unable to truncate Txn log\", e);\n            return false;\n        }\n    }\n\n    /**\n     * the most recent snapshot in the snapshot\n     * directory\n     * @return the file that contains the most\n     * recent snapshot\n     * @throws IOException\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findMostRecentSnapshot();\n    }\n\n    /**\n     * the n most recent snapshots\n     * @param n the number of recent snapshots\n     * @return the list of n most recent snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNRecentSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNRecentSnapshots(n);\n    }\n\n    /**\n     * the n recent valid snapshots\n     * @param n the number of recent valid snapshots\n     * @return the list of n recent valid snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNValidSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNValidSnapshots(n);\n    }\n\n    /**\n     * get the snapshot logs which may contain transactions newer than the given zxid.\n     * This includes logs with starting zxid greater than given zxid, as well as the\n     * newest transaction log with starting zxid less than given zxid.  The latter log\n     * file may contain transactions beyond given zxid.\n     * @param zxid the zxid that contains logs greater than\n     * zxid\n     * @return the snapshot logs which may contain transactions newer than the given zxid\n     */\n    public File[] getSnapshotLogs(long zxid) {\n        return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);\n    }\n\n    /**\n     * append the request to the transaction logs\n     * @param si the request to be appended\n     * @return true iff something appended, otw false\n     * @throws IOException\n     */\n    public boolean append(Request si) throws IOException {\n        return txnLog.append(si.getHdr(), si.getTxn(), si.getTxnDigest());\n    }\n\n    /**\n     * commit the transaction of logs\n     * @throws IOException\n     */\n    public void commit() throws IOException {\n        txnLog.commit();\n    }\n\n    /**\n     *\n     * @return elapsed sync time of transaction log commit in milliseconds\n     */\n    public long getTxnLogElapsedSyncTime() {\n        return txnLog.getTxnLogSyncElapsedTime();\n    }\n\n    /**\n     * roll the transaction logs\n     * @throws IOException\n     */\n    public void rollLog() throws IOException {\n        txnLog.rollLog();\n    }\n\n    /**\n     * close the transaction log files\n     * @throws IOException\n     */\n    public void close() throws IOException {\n        if (txnLog != null) {\n            txnLog.close();\n            txnLog = null;\n        }\n        if (snapLog != null) {\n            snapLog.close();\n            snapLog = null;\n        }\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class DatadirException extends IOException {\n\n        public DatadirException(String msg) {\n            super(msg);\n        }\n        public DatadirException(String msg, Exception e) {\n            super(msg, e);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class LogDirContentCheckException extends DatadirException {\n\n        public LogDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class SnapDirContentCheckException extends DatadirException {\n\n        public SnapDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    public void setTotalLogSize(long size) {\n        txnLog.setTotalLogSize(size);\n    }\n\n    public long getTotalLogSize() {\n        return txnLog.getTotalLogSize();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.KeeperException.Code;\nimport org.apache.zookeeper.ZooDefs.OpCode;\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.DataTree.ProcessTxnResult;\nimport org.apache.zookeeper.server.Request;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ServerStats;\nimport org.apache.zookeeper.server.ZooTrace;\nimport org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;\nimport org.apache.zookeeper.txn.CreateSessionTxn;\nimport org.apache.zookeeper.txn.TxnDigest;\nimport org.apache.zookeeper.txn.TxnHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This is a helper class\n * above the implementations\n * of txnlog and snapshot\n * classes\n */\npublic class FileTxnSnapLog {\n\n    //the directory containing the\n    //the transaction logs\n    final File dataDir;\n    //the directory containing the\n    //the snapshot directory\n    final File snapDir;\n    TxnLog txnLog;\n    SnapShot snapLog;\n    private final boolean autoCreateDB;\n    private final boolean trustEmptySnapshot;\n    public static final int VERSION = 2;\n    public static final String version = \"version-\";\n\n    private static final Logger LOG = LoggerFactory.getLogger(FileTxnSnapLog.class);\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE = \"zookeeper.datadir.autocreate\";\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT = \"true\";\n\n    static final String ZOOKEEPER_DB_AUTOCREATE = \"zookeeper.db.autocreate\";\n\n    private static final String ZOOKEEPER_DB_AUTOCREATE_DEFAULT = \"true\";\n\n    public static final String ZOOKEEPER_SNAPSHOT_TRUST_EMPTY = \"zookeeper.snapshot.trust.empty\";\n\n    private static final String EMPTY_SNAPSHOT_WARNING = \"No snapshot found, but there are log entries. \";\n\n    /**\n     * This listener helps\n     * the external apis calling\n     * restore to gather information\n     * while the data is being\n     * restored.\n     */\n    public interface PlayBackListener {\n\n        void onTxnLoaded(TxnHeader hdr, Record rec, TxnDigest digest);\n\n    }\n\n    /**\n     * Finalizing restore of data tree through\n     * a set of operations (replaying transaction logs,\n     * calculating data tree digests, and so on.).\n     */\n    private interface RestoreFinalizer {\n        /**\n         * @return the highest zxid of restored data tree.\n         */\n        long run() throws IOException;\n    }\n\n    /**\n     * the constructor which takes the datadir and\n     * snapdir.\n     * @param dataDir the transaction directory\n     * @param snapDir the snapshot directory\n     */\n    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n        LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n\n        this.dataDir = new File(dataDir, version + VERSION);\n        this.snapDir = new File(snapDir, version + VERSION);\n\n        // by default create snap/log dirs, but otherwise complain instead\n        // See ZOOKEEPER-1161 for more details\n        boolean enableAutocreate = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n\n        trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n        LOG.info(\"{} : {}\", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);\n\n        if (!this.dataDir.exists()) {\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing data directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \" Please create this directory manually.\",\n                    this.dataDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n                throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n            }\n        }\n        if (!this.dataDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n        }\n\n        if (!this.snapDir.exists()) {\n            // by default create this directory, but otherwise complain instead\n            // See ZOOKEEPER-1161 for more details\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \"Please create this directory manually.\",\n                    this.snapDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n                throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n            }\n        }\n        if (!this.snapDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n        }\n\n        // check content of transaction log and snapshot dirs if they are two different directories\n        // See ZOOKEEPER-2967 for more details\n        if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n            checkLogDir();\n            checkSnapDir();\n        }\n\n        txnLog = new FileTxnLog(this.dataDir);\n        snapLog = new FileSnap(this.snapDir);\n\n        autoCreateDB = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n    }\n\n    public void setServerStats(ServerStats serverStats) {\n        txnLog.setServerStats(serverStats);\n    }\n\n    private void checkLogDir() throws LogDirContentCheckException {\n        File[] files = this.dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isSnapshotFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new LogDirContentCheckException(\n                \"Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    private void checkSnapDir() throws SnapDirContentCheckException {\n        File[] files = this.snapDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isLogFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new SnapDirContentCheckException(\n                \"Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    /**\n     * get the datadir used by this filetxn\n     * snap log\n     * @return the data dir\n     */\n    public File getDataDir() {\n        return this.dataDir;\n    }\n\n    /**\n     * get the snap dir used by this\n     * filetxn snap log\n     * @return the snap dir\n     */\n    public File getSnapDir() {\n        return this.snapDir;\n    }\n\n    /**\n     * get information of the last saved/restored snapshot\n     * @return info of last snapshot\n     */\n    public SnapshotInfo getLastSnapshotInfo() {\n        return this.snapLog.getLastSnapshotInfo();\n    }\n\n    /**\n     * this function restores the server\n     * database after reading from the\n     * snapshots and transaction logs\n     * @param dt the datatree to be restored\n     * @param sessions the sessions to be restored\n     * @param listener the playback listener to run on the\n     * database restoration\n     * @return the highest zxid restored\n     * @throws IOException\n     */\n    public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException {\n        long snapLoadingStartTime = Time.currentElapsedTime();\n        long deserializeResult = snapLog.deserialize(dt, sessions);\n        ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        boolean trustEmptyDB;\n        File initFile = new File(dataDir.getParent(), \"initialize\");\n        if (Files.deleteIfExists(initFile.toPath())) {\n            LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n            trustEmptyDB = true;\n        } else {\n            trustEmptyDB = autoCreateDB;\n        }\n\n        RestoreFinalizer finalizer = () -> {\n            long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n            // The snapshotZxidDigest will reset after replaying the txn of the\n            // zxid in the snapshotZxidDigest, if it's not reset to null after\n            // restoring, it means either there are not enough txns to cover that\n            // zxid or that txn is missing\n            DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n            if (snapshotZxidDigest != null) {\n                LOG.warn(\n                        \"Highest txn zxid 0x{} is not covering the snapshot digest zxid 0x{}, \"\n                                + \"which might lead to inconsistent state\",\n                        Long.toHexString(highestZxid),\n                        Long.toHexString(snapshotZxidDigest.getZxid()));\n            }\n            return highestZxid;\n        };\n\n        if (-1L == deserializeResult) {\n            /* this means that we couldn't find any snapshot, so we need to\n             * initialize an empty database (reported in ZOOKEEPER-2325) */\n            if (txnLog.getLastLoggedZxid() != -1) {\n                // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n                // from old versions of zookeeper (3.4.x, pre 3.5.3).\n                if (!trustEmptySnapshot) {\n                    throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n                } else {\n                    LOG.warn(\"{}This should only be allowed during upgrading.\", EMPTY_SNAPSHOT_WARNING);\n                    return finalizer.run();\n                }\n            }\n\n            if (trustEmptyDB) {\n                /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n                 *       or use Map on save() */\n                save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n\n                /* return a zxid of 0, since we know the database is empty */\n                return 0L;\n            } else {\n                /* return a zxid of -1, since we are possibly missing data */\n                LOG.warn(\"Unexpected empty data tree, setting zxid to -1\");\n                dt.lastProcessedZxid = -1L;\n                return -1L;\n            }\n        }\n\n        return finalizer.run();\n    }\n\n    /**\n     * This function will fast forward the server database to have the latest\n     * transactions in it.  This is the same as restore, but only reads from\n     * the transaction logs and not restores from a snapshot.\n     * @param dt the datatree to write transactions to.\n     * @param sessions the sessions to be restored.\n     * @param listener the playback listener to run on the\n     * database transactions.\n     * @return the highest zxid restored.\n     * @throws IOException\n     */\n    public long fastForwardFromEdits(\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        PlayBackListener listener) throws IOException {\n        TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);\n        long highestZxid = dt.lastProcessedZxid;\n        TxnHeader hdr;\n        int txnLoaded = 0;\n        long startTime = Time.currentElapsedTime();\n        try {\n            while (true) {\n                // iterator points to\n                // the first valid txn when initialized\n                hdr = itr.getHeader();\n                if (hdr == null) {\n                    //empty logs\n                    return dt.lastProcessedZxid;\n                }\n                if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n                    LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n                } else {\n                    highestZxid = hdr.getZxid();\n                }\n                try {\n                    processTransaction(hdr, dt, sessions, itr.getTxn());\n                    dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n                    txnLoaded++;\n                } catch (KeeperException.NoNodeException e) {\n                    throw new IOException(\"Failed to process transaction type: \"\n                                          + hdr.getType()\n                                          + \" error: \"\n                                          + e.getMessage(),\n                                          e);\n                }\n                listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n                if (!itr.next()) {\n                    break;\n                }\n            }\n        } finally {\n            if (itr != null) {\n                itr.close();\n            }\n        }\n\n        long loadTime = Time.currentElapsedTime() - startTime;\n        LOG.info(\"{} txns loaded in {} ms\", txnLoaded, loadTime);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);\n\n        return highestZxid;\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid) throws IOException {\n        return readTxnLog(zxid, true);\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @param fastForward true if the iterator should be fast forwarded to point\n     *        to the txn of a given zxid, else the iterator will point to the\n     *        starting txn of a txnlog that may contain txn of a given zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid, boolean fastForward) throws IOException {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.read(zxid, fastForward);\n    }\n\n    /**\n     * process the transaction on the datatree\n     * @param hdr the hdr of the transaction\n     * @param dt the datatree to apply transaction to\n     * @param sessions the sessions to be restored\n     * @param txn the transaction to be applied\n     */\n    public void processTransaction(\n        TxnHeader hdr,\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        Record txn) throws KeeperException.NoNodeException {\n        ProcessTxnResult rc;\n        switch (hdr.getType()) {\n        case OpCode.createSession:\n            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- create session in log: 0x\" + Long.toHexString(hdr.getClientId())\n                    + \" with timeout: \" + ((CreateSessionTxn) txn).getTimeOut());\n            }\n            // give dataTree a chance to sync its lastProcessedZxid\n            rc = dt.processTxn(hdr, txn);\n            break;\n        case OpCode.closeSession:\n            sessions.remove(hdr.getClientId());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- close session in log: 0x\" + Long.toHexString(hdr.getClientId()));\n            }\n            rc = dt.processTxn(hdr, txn);\n            break;\n        default:\n            rc = dt.processTxn(hdr, txn);\n        }\n\n        /*\n         * Snapshots are lazily created. So when a snapshot is in progress,\n         * there is a chance for later transactions to make into the\n         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n         * errors could occur. It should be safe to ignore these.\n         */\n        if (rc.err != Code.OK.intValue()) {\n            LOG.debug(\"Ignoring processTxn failure hdr: {}, error: {}, path: {}\", hdr.getType(), rc.err, rc.path);\n        }\n    }\n\n    /**\n     * the last logged zxid on the transaction logs\n     * @return the last logged zxid\n     */\n    public long getLastLoggedZxid() {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.getLastLoggedZxid();\n    }\n\n    /**\n     * save the datatree and the sessions into a snapshot\n     * @param dataTree the datatree to be serialized onto disk\n     * @param sessionsWithTimeouts the session timeouts to be\n     * serialized onto disk\n     * @param syncSnap sync the snapshot immediately after write\n     * @throws IOException\n     */\n    public void save(\n        DataTree dataTree,\n        ConcurrentHashMap<Long, Integer> sessionsWithTimeouts,\n        boolean syncSnap) throws IOException {\n        long lastZxid = dataTree.lastProcessedZxid;\n        File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));\n        LOG.info(\"Snapshotting: 0x{} to {}\", Long.toHexString(lastZxid), snapshotFile);\n        try {\n            snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);\n        } catch (IOException e) {\n            if (snapshotFile.length() == 0) {\n                /* This may be caused by a full disk. In such a case, the server\n                 * will get stuck in a loop where it tries to write a snapshot\n                 * out to disk, and ends up creating an empty file instead.\n                 * Doing so will eventually result in valid snapshots being\n                 * removed during cleanup. */\n                if (snapshotFile.delete()) {\n                    LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                } else {\n                    LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                }\n            } else {\n                /* Something else went wrong when writing the snapshot out to\n                 * disk. If this snapshot file is invalid, when restarting,\n                 * ZooKeeper will skip it, and find the last known good snapshot\n                 * instead. */\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * truncate the transaction logs the zxid\n     * specified\n     * @param zxid the zxid to truncate the logs to\n     * @return true if able to truncate the log, false if not\n     * @throws IOException\n     */\n    public boolean truncateLog(long zxid) {\n        try {\n            // close the existing txnLog and snapLog\n            close();\n\n            // truncate it\n            try (FileTxnLog truncLog = new FileTxnLog(dataDir)) {\n                boolean truncated = truncLog.truncate(zxid);\n\n                // re-open the txnLog and snapLog\n                // I'd rather just close/reopen this object itself, however that\n                // would have a big impact outside ZKDatabase as there are other\n                // objects holding a reference to this object.\n                txnLog = new FileTxnLog(dataDir);\n                snapLog = new FileSnap(snapDir);\n\n                return truncated;\n            }\n        } catch (IOException e) {\n            LOG.error(\"Unable to truncate Txn log\", e);\n            return false;\n        }\n    }\n\n    /**\n     * the most recent snapshot in the snapshot\n     * directory\n     * @return the file that contains the most\n     * recent snapshot\n     * @throws IOException\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findMostRecentSnapshot();\n    }\n\n    /**\n     * the n most recent snapshots\n     * @param n the number of recent snapshots\n     * @return the list of n most recent snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNRecentSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNRecentSnapshots(n);\n    }\n\n    /**\n     * the n recent valid snapshots\n     * @param n the number of recent valid snapshots\n     * @return the list of n recent valid snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNValidSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNValidSnapshots(n);\n    }\n\n    /**\n     * get the snapshot logs which may contain transactions newer than the given zxid.\n     * This includes logs with starting zxid greater than given zxid, as well as the\n     * newest transaction log with starting zxid less than given zxid.  The latter log\n     * file may contain transactions beyond given zxid.\n     * @param zxid the zxid that contains logs greater than\n     * zxid\n     * @return the snapshot logs which may contain transactions newer than the given zxid\n     */\n    public File[] getSnapshotLogs(long zxid) {\n        return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);\n    }\n\n    /**\n     * append the request to the transaction logs\n     * @param si the request to be appended\n     * @return true iff something appended, otw false\n     * @throws IOException\n     */\n    public boolean append(Request si) throws IOException {\n        return txnLog.append(si.getHdr(), si.getTxn(), si.getTxnDigest());\n    }\n\n    /**\n     * commit the transaction of logs\n     * @throws IOException\n     */\n    public void commit() throws IOException {\n        txnLog.commit();\n    }\n\n    /**\n     *\n     * @return elapsed sync time of transaction log commit in milliseconds\n     */\n    public long getTxnLogElapsedSyncTime() {\n        return txnLog.getTxnLogSyncElapsedTime();\n    }\n\n    /**\n     * roll the transaction logs\n     * @throws IOException\n     */\n    public void rollLog() throws IOException {\n        txnLog.rollLog();\n    }\n\n    /**\n     * close the transaction log files\n     * @throws IOException\n     */\n    public void close() throws IOException {\n        TxnLog txnLogToClose = txnLog;\n        if (txnLogToClose != null) {\n            txnLogToClose.close();\n        }\n        txnLog = null;\n        SnapShot snapSlogToClose = snapLog;\n        if (snapSlogToClose != null) {\n            snapSlogToClose.close();\n        }\n        snapLog = null;\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class DatadirException extends IOException {\n\n        public DatadirException(String msg) {\n            super(msg);\n        }\n        public DatadirException(String msg, Exception e) {\n            super(msg, e);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class LogDirContentCheckException extends DatadirException {\n\n        public LogDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class SnapDirContentCheckException extends DatadirException {\n\n        public SnapDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    public void setTotalLogSize(long size) {\n        txnLog.setTotalLogSize(size);\n    }\n\n    public long getTotalLogSize() {\n        return txnLog.getTotalLogSize();\n    }\n}\n","lineNo":614}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.KeeperException.Code;\nimport org.apache.zookeeper.ZooDefs.OpCode;\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.DataTree.ProcessTxnResult;\nimport org.apache.zookeeper.server.Request;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ServerStats;\nimport org.apache.zookeeper.server.ZooTrace;\nimport org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;\nimport org.apache.zookeeper.txn.CreateSessionTxn;\nimport org.apache.zookeeper.txn.TxnDigest;\nimport org.apache.zookeeper.txn.TxnHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This is a helper class\n * above the implementations\n * of txnlog and snapshot\n * classes\n */\npublic class FileTxnSnapLog {\n\n    //the directory containing the\n    //the transaction logs\n    final File dataDir;\n    //the directory containing the\n    //the snapshot directory\n    final File snapDir;\n    TxnLog txnLog;\n    SnapShot snapLog;\n    private final boolean autoCreateDB;\n    private final boolean trustEmptySnapshot;\n    public static final int VERSION = 2;\n    public static final String version = \"version-\";\n\n    private static final Logger LOG = LoggerFactory.getLogger(FileTxnSnapLog.class);\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE = \"zookeeper.datadir.autocreate\";\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT = \"true\";\n\n    static final String ZOOKEEPER_DB_AUTOCREATE = \"zookeeper.db.autocreate\";\n\n    private static final String ZOOKEEPER_DB_AUTOCREATE_DEFAULT = \"true\";\n\n    public static final String ZOOKEEPER_SNAPSHOT_TRUST_EMPTY = \"zookeeper.snapshot.trust.empty\";\n\n    private static final String EMPTY_SNAPSHOT_WARNING = \"No snapshot found, but there are log entries. \";\n\n    /**\n     * This listener helps\n     * the external apis calling\n     * restore to gather information\n     * while the data is being\n     * restored.\n     */\n    public interface PlayBackListener {\n\n        void onTxnLoaded(TxnHeader hdr, Record rec, TxnDigest digest);\n\n    }\n\n    /**\n     * Finalizing restore of data tree through\n     * a set of operations (replaying transaction logs,\n     * calculating data tree digests, and so on.).\n     */\n    private interface RestoreFinalizer {\n        /**\n         * @return the highest zxid of restored data tree.\n         */\n        long run() throws IOException;\n    }\n\n    /**\n     * the constructor which takes the datadir and\n     * snapdir.\n     * @param dataDir the transaction directory\n     * @param snapDir the snapshot directory\n     */\n    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n        LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n\n        this.dataDir = new File(dataDir, version + VERSION);\n        this.snapDir = new File(snapDir, version + VERSION);\n\n        // by default create snap/log dirs, but otherwise complain instead\n        // See ZOOKEEPER-1161 for more details\n        boolean enableAutocreate = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n\n        trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n        LOG.info(\"{} : {}\", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);\n\n        if (!this.dataDir.exists()) {\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing data directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \" Please create this directory manually.\",\n                    this.dataDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n                throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n            }\n        }\n        if (!this.dataDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n        }\n\n        if (!this.snapDir.exists()) {\n            // by default create this directory, but otherwise complain instead\n            // See ZOOKEEPER-1161 for more details\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \"Please create this directory manually.\",\n                    this.snapDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n                throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n            }\n        }\n        if (!this.snapDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n        }\n\n        // check content of transaction log and snapshot dirs if they are two different directories\n        // See ZOOKEEPER-2967 for more details\n        if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n            checkLogDir();\n            checkSnapDir();\n        }\n\n        txnLog = new FileTxnLog(this.dataDir);\n        snapLog = new FileSnap(this.snapDir);\n\n        autoCreateDB = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n    }\n\n    public void setServerStats(ServerStats serverStats) {\n        txnLog.setServerStats(serverStats);\n    }\n\n    private void checkLogDir() throws LogDirContentCheckException {\n        File[] files = this.dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isSnapshotFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new LogDirContentCheckException(\n                \"Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    private void checkSnapDir() throws SnapDirContentCheckException {\n        File[] files = this.snapDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isLogFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new SnapDirContentCheckException(\n                \"Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    /**\n     * get the datadir used by this filetxn\n     * snap log\n     * @return the data dir\n     */\n    public File getDataDir() {\n        return this.dataDir;\n    }\n\n    /**\n     * get the snap dir used by this\n     * filetxn snap log\n     * @return the snap dir\n     */\n    public File getSnapDir() {\n        return this.snapDir;\n    }\n\n    /**\n     * get information of the last saved/restored snapshot\n     * @return info of last snapshot\n     */\n    public SnapshotInfo getLastSnapshotInfo() {\n        return this.snapLog.getLastSnapshotInfo();\n    }\n\n    /**\n     * this function restores the server\n     * database after reading from the\n     * snapshots and transaction logs\n     * @param dt the datatree to be restored\n     * @param sessions the sessions to be restored\n     * @param listener the playback listener to run on the\n     * database restoration\n     * @return the highest zxid restored\n     * @throws IOException\n     */\n    public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException {\n        long snapLoadingStartTime = Time.currentElapsedTime();\n        long deserializeResult = snapLog.deserialize(dt, sessions);\n        ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        boolean trustEmptyDB;\n        File initFile = new File(dataDir.getParent(), \"initialize\");\n        if (Files.deleteIfExists(initFile.toPath())) {\n            LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n            trustEmptyDB = true;\n        } else {\n            trustEmptyDB = autoCreateDB;\n        }\n\n        RestoreFinalizer finalizer = () -> {\n            long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n            // The snapshotZxidDigest will reset after replaying the txn of the\n            // zxid in the snapshotZxidDigest, if it's not reset to null after\n            // restoring, it means either there are not enough txns to cover that\n            // zxid or that txn is missing\n            DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n            if (snapshotZxidDigest != null) {\n                LOG.warn(\n                        \"Highest txn zxid 0x{} is not covering the snapshot digest zxid 0x{}, \"\n                                + \"which might lead to inconsistent state\",\n                        Long.toHexString(highestZxid),\n                        Long.toHexString(snapshotZxidDigest.getZxid()));\n            }\n            return highestZxid;\n        };\n\n        if (-1L == deserializeResult) {\n            /* this means that we couldn't find any snapshot, so we need to\n             * initialize an empty database (reported in ZOOKEEPER-2325) */\n            if (txnLog.getLastLoggedZxid() != -1) {\n                // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n                // from old versions of zookeeper (3.4.x, pre 3.5.3).\n                if (!trustEmptySnapshot) {\n                    throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n                } else {\n                    LOG.warn(\"{}This should only be allowed during upgrading.\", EMPTY_SNAPSHOT_WARNING);\n                    return finalizer.run();\n                }\n            }\n\n            if (trustEmptyDB) {\n                /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n                 *       or use Map on save() */\n                save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n\n                /* return a zxid of 0, since we know the database is empty */\n                return 0L;\n            } else {\n                /* return a zxid of -1, since we are possibly missing data */\n                LOG.warn(\"Unexpected empty data tree, setting zxid to -1\");\n                dt.lastProcessedZxid = -1L;\n                return -1L;\n            }\n        }\n\n        return finalizer.run();\n    }\n\n    /**\n     * This function will fast forward the server database to have the latest\n     * transactions in it.  This is the same as restore, but only reads from\n     * the transaction logs and not restores from a snapshot.\n     * @param dt the datatree to write transactions to.\n     * @param sessions the sessions to be restored.\n     * @param listener the playback listener to run on the\n     * database transactions.\n     * @return the highest zxid restored.\n     * @throws IOException\n     */\n    public long fastForwardFromEdits(\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        PlayBackListener listener) throws IOException {\n        TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);\n        long highestZxid = dt.lastProcessedZxid;\n        TxnHeader hdr;\n        int txnLoaded = 0;\n        long startTime = Time.currentElapsedTime();\n        try {\n            while (true) {\n                // iterator points to\n                // the first valid txn when initialized\n                hdr = itr.getHeader();\n                if (hdr == null) {\n                    //empty logs\n                    return dt.lastProcessedZxid;\n                }\n                if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n                    LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n                } else {\n                    highestZxid = hdr.getZxid();\n                }\n                try {\n                    processTransaction(hdr, dt, sessions, itr.getTxn());\n                    dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n                    txnLoaded++;\n                } catch (KeeperException.NoNodeException e) {\n                    throw new IOException(\"Failed to process transaction type: \"\n                                          + hdr.getType()\n                                          + \" error: \"\n                                          + e.getMessage(),\n                                          e);\n                }\n                listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n                if (!itr.next()) {\n                    break;\n                }\n            }\n        } finally {\n            if (itr != null) {\n                itr.close();\n            }\n        }\n\n        long loadTime = Time.currentElapsedTime() - startTime;\n        LOG.info(\"{} txns loaded in {} ms\", txnLoaded, loadTime);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);\n\n        return highestZxid;\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid) throws IOException {\n        return readTxnLog(zxid, true);\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @param fastForward true if the iterator should be fast forwarded to point\n     *        to the txn of a given zxid, else the iterator will point to the\n     *        starting txn of a txnlog that may contain txn of a given zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid, boolean fastForward) throws IOException {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.read(zxid, fastForward);\n    }\n\n    /**\n     * process the transaction on the datatree\n     * @param hdr the hdr of the transaction\n     * @param dt the datatree to apply transaction to\n     * @param sessions the sessions to be restored\n     * @param txn the transaction to be applied\n     */\n    public void processTransaction(\n        TxnHeader hdr,\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        Record txn) throws KeeperException.NoNodeException {\n        ProcessTxnResult rc;\n        switch (hdr.getType()) {\n        case OpCode.createSession:\n            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- create session in log: 0x\" + Long.toHexString(hdr.getClientId())\n                    + \" with timeout: \" + ((CreateSessionTxn) txn).getTimeOut());\n            }\n            // give dataTree a chance to sync its lastProcessedZxid\n            rc = dt.processTxn(hdr, txn);\n            break;\n        case OpCode.closeSession:\n            sessions.remove(hdr.getClientId());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- close session in log: 0x\" + Long.toHexString(hdr.getClientId()));\n            }\n            rc = dt.processTxn(hdr, txn);\n            break;\n        default:\n            rc = dt.processTxn(hdr, txn);\n        }\n\n        /*\n         * Snapshots are lazily created. So when a snapshot is in progress,\n         * there is a chance for later transactions to make into the\n         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n         * errors could occur. It should be safe to ignore these.\n         */\n        if (rc.err != Code.OK.intValue()) {\n            LOG.debug(\"Ignoring processTxn failure hdr: {}, error: {}, path: {}\", hdr.getType(), rc.err, rc.path);\n        }\n    }\n\n    /**\n     * the last logged zxid on the transaction logs\n     * @return the last logged zxid\n     */\n    public long getLastLoggedZxid() {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.getLastLoggedZxid();\n    }\n\n    /**\n     * save the datatree and the sessions into a snapshot\n     * @param dataTree the datatree to be serialized onto disk\n     * @param sessionsWithTimeouts the session timeouts to be\n     * serialized onto disk\n     * @param syncSnap sync the snapshot immediately after write\n     * @throws IOException\n     */\n    public void save(\n        DataTree dataTree,\n        ConcurrentHashMap<Long, Integer> sessionsWithTimeouts,\n        boolean syncSnap) throws IOException {\n        long lastZxid = dataTree.lastProcessedZxid;\n        File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));\n        LOG.info(\"Snapshotting: 0x{} to {}\", Long.toHexString(lastZxid), snapshotFile);\n        try {\n            snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);\n        } catch (IOException e) {\n            if (snapshotFile.length() == 0) {\n                /* This may be caused by a full disk. In such a case, the server\n                 * will get stuck in a loop where it tries to write a snapshot\n                 * out to disk, and ends up creating an empty file instead.\n                 * Doing so will eventually result in valid snapshots being\n                 * removed during cleanup. */\n                if (snapshotFile.delete()) {\n                    LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                } else {\n                    LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                }\n            } else {\n                /* Something else went wrong when writing the snapshot out to\n                 * disk. If this snapshot file is invalid, when restarting,\n                 * ZooKeeper will skip it, and find the last known good snapshot\n                 * instead. */\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * truncate the transaction logs the zxid\n     * specified\n     * @param zxid the zxid to truncate the logs to\n     * @return true if able to truncate the log, false if not\n     * @throws IOException\n     */\n    public boolean truncateLog(long zxid) {\n        try {\n            // close the existing txnLog and snapLog\n            close();\n\n            // truncate it\n            try (FileTxnLog truncLog = new FileTxnLog(dataDir)) {\n                boolean truncated = truncLog.truncate(zxid);\n\n                // re-open the txnLog and snapLog\n                // I'd rather just close/reopen this object itself, however that\n                // would have a big impact outside ZKDatabase as there are other\n                // objects holding a reference to this object.\n                txnLog = new FileTxnLog(dataDir);\n                snapLog = new FileSnap(snapDir);\n\n                return truncated;\n            }\n        } catch (IOException e) {\n            LOG.error(\"Unable to truncate Txn log\", e);\n            return false;\n        }\n    }\n\n    /**\n     * the most recent snapshot in the snapshot\n     * directory\n     * @return the file that contains the most\n     * recent snapshot\n     * @throws IOException\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findMostRecentSnapshot();\n    }\n\n    /**\n     * the n most recent snapshots\n     * @param n the number of recent snapshots\n     * @return the list of n most recent snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNRecentSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNRecentSnapshots(n);\n    }\n\n    /**\n     * the n recent valid snapshots\n     * @param n the number of recent valid snapshots\n     * @return the list of n recent valid snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNValidSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNValidSnapshots(n);\n    }\n\n    /**\n     * get the snapshot logs which may contain transactions newer than the given zxid.\n     * This includes logs with starting zxid greater than given zxid, as well as the\n     * newest transaction log with starting zxid less than given zxid.  The latter log\n     * file may contain transactions beyond given zxid.\n     * @param zxid the zxid that contains logs greater than\n     * zxid\n     * @return the snapshot logs which may contain transactions newer than the given zxid\n     */\n    public File[] getSnapshotLogs(long zxid) {\n        return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);\n    }\n\n    /**\n     * append the request to the transaction logs\n     * @param si the request to be appended\n     * @return true iff something appended, otw false\n     * @throws IOException\n     */\n    public boolean append(Request si) throws IOException {\n        return txnLog.append(si.getHdr(), si.getTxn(), si.getTxnDigest());\n    }\n\n    /**\n     * commit the transaction of logs\n     * @throws IOException\n     */\n    public void commit() throws IOException {\n        txnLog.commit();\n    }\n\n    /**\n     *\n     * @return elapsed sync time of transaction log commit in milliseconds\n     */\n    public long getTxnLogElapsedSyncTime() {\n        return txnLog.getTxnLogSyncElapsedTime();\n    }\n\n    /**\n     * roll the transaction logs\n     * @throws IOException\n     */\n    public void rollLog() throws IOException {\n        txnLog.rollLog();\n    }\n\n    /**\n     * close the transaction log files\n     * @throws IOException\n     */\n    public void close() throws IOException {\n        if (txnLog != null) {\n            txnLog.close();\n            txnLog = null;\n        }\n        if (snapLog != null) {\n            snapLog.close();\n            snapLog = null;\n        }\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class DatadirException extends IOException {\n\n        public DatadirException(String msg) {\n            super(msg);\n        }\n        public DatadirException(String msg, Exception e) {\n            super(msg, e);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class LogDirContentCheckException extends DatadirException {\n\n        public LogDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class SnapDirContentCheckException extends DatadirException {\n\n        public SnapDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    public void setTotalLogSize(long size) {\n        txnLog.setTotalLogSize(size);\n    }\n\n    public long getTotalLogSize() {\n        return txnLog.getTotalLogSize();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server.persistence;\n\nimport java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport org.apache.jute.Record;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.KeeperException.Code;\nimport org.apache.zookeeper.ZooDefs.OpCode;\nimport org.apache.zookeeper.common.Time;\nimport org.apache.zookeeper.server.DataTree;\nimport org.apache.zookeeper.server.DataTree.ProcessTxnResult;\nimport org.apache.zookeeper.server.Request;\nimport org.apache.zookeeper.server.ServerMetrics;\nimport org.apache.zookeeper.server.ServerStats;\nimport org.apache.zookeeper.server.ZooTrace;\nimport org.apache.zookeeper.server.persistence.TxnLog.TxnIterator;\nimport org.apache.zookeeper.txn.CreateSessionTxn;\nimport org.apache.zookeeper.txn.TxnDigest;\nimport org.apache.zookeeper.txn.TxnHeader;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * This is a helper class\n * above the implementations\n * of txnlog and snapshot\n * classes\n */\npublic class FileTxnSnapLog {\n\n    //the directory containing the\n    //the transaction logs\n    final File dataDir;\n    //the directory containing the\n    //the snapshot directory\n    final File snapDir;\n    TxnLog txnLog;\n    SnapShot snapLog;\n    private final boolean autoCreateDB;\n    private final boolean trustEmptySnapshot;\n    public static final int VERSION = 2;\n    public static final String version = \"version-\";\n\n    private static final Logger LOG = LoggerFactory.getLogger(FileTxnSnapLog.class);\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE = \"zookeeper.datadir.autocreate\";\n\n    public static final String ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT = \"true\";\n\n    static final String ZOOKEEPER_DB_AUTOCREATE = \"zookeeper.db.autocreate\";\n\n    private static final String ZOOKEEPER_DB_AUTOCREATE_DEFAULT = \"true\";\n\n    public static final String ZOOKEEPER_SNAPSHOT_TRUST_EMPTY = \"zookeeper.snapshot.trust.empty\";\n\n    private static final String EMPTY_SNAPSHOT_WARNING = \"No snapshot found, but there are log entries. \";\n\n    /**\n     * This listener helps\n     * the external apis calling\n     * restore to gather information\n     * while the data is being\n     * restored.\n     */\n    public interface PlayBackListener {\n\n        void onTxnLoaded(TxnHeader hdr, Record rec, TxnDigest digest);\n\n    }\n\n    /**\n     * Finalizing restore of data tree through\n     * a set of operations (replaying transaction logs,\n     * calculating data tree digests, and so on.).\n     */\n    private interface RestoreFinalizer {\n        /**\n         * @return the highest zxid of restored data tree.\n         */\n        long run() throws IOException;\n    }\n\n    /**\n     * the constructor which takes the datadir and\n     * snapdir.\n     * @param dataDir the transaction directory\n     * @param snapDir the snapshot directory\n     */\n    public FileTxnSnapLog(File dataDir, File snapDir) throws IOException {\n        LOG.debug(\"Opening datadir:{} snapDir:{}\", dataDir, snapDir);\n\n        this.dataDir = new File(dataDir, version + VERSION);\n        this.snapDir = new File(snapDir, version + VERSION);\n\n        // by default create snap/log dirs, but otherwise complain instead\n        // See ZOOKEEPER-1161 for more details\n        boolean enableAutocreate = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DATADIR_AUTOCREATE, ZOOKEEPER_DATADIR_AUTOCREATE_DEFAULT));\n\n        trustEmptySnapshot = Boolean.getBoolean(ZOOKEEPER_SNAPSHOT_TRUST_EMPTY);\n        LOG.info(\"{} : {}\", ZOOKEEPER_SNAPSHOT_TRUST_EMPTY, trustEmptySnapshot);\n\n        if (!this.dataDir.exists()) {\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing data directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \" Please create this directory manually.\",\n                    this.dataDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.dataDir.mkdirs() && !this.dataDir.exists()) {\n                throw new DatadirException(\"Unable to create data directory \" + this.dataDir);\n            }\n        }\n        if (!this.dataDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to data directory \" + this.dataDir);\n        }\n\n        if (!this.snapDir.exists()) {\n            // by default create this directory, but otherwise complain instead\n            // See ZOOKEEPER-1161 for more details\n            if (!enableAutocreate) {\n                throw new DatadirException(String.format(\n                    \"Missing snap directory %s, automatic data directory creation is disabled (%s is false).\"\n                    + \"Please create this directory manually.\",\n                    this.snapDir,\n                    ZOOKEEPER_DATADIR_AUTOCREATE));\n            }\n\n            if (!this.snapDir.mkdirs() && !this.snapDir.exists()) {\n                throw new DatadirException(\"Unable to create snap directory \" + this.snapDir);\n            }\n        }\n        if (!this.snapDir.canWrite()) {\n            throw new DatadirException(\"Cannot write to snap directory \" + this.snapDir);\n        }\n\n        // check content of transaction log and snapshot dirs if they are two different directories\n        // See ZOOKEEPER-2967 for more details\n        if (!this.dataDir.getPath().equals(this.snapDir.getPath())) {\n            checkLogDir();\n            checkSnapDir();\n        }\n\n        txnLog = new FileTxnLog(this.dataDir);\n        snapLog = new FileSnap(this.snapDir);\n\n        autoCreateDB = Boolean.parseBoolean(\n            System.getProperty(ZOOKEEPER_DB_AUTOCREATE, ZOOKEEPER_DB_AUTOCREATE_DEFAULT));\n    }\n\n    public void setServerStats(ServerStats serverStats) {\n        txnLog.setServerStats(serverStats);\n    }\n\n    private void checkLogDir() throws LogDirContentCheckException {\n        File[] files = this.dataDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isSnapshotFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new LogDirContentCheckException(\n                \"Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    private void checkSnapDir() throws SnapDirContentCheckException {\n        File[] files = this.snapDir.listFiles(new FilenameFilter() {\n            @Override\n            public boolean accept(File dir, String name) {\n                return Util.isLogFileName(name);\n            }\n        });\n        if (files != null && files.length > 0) {\n            throw new SnapDirContentCheckException(\n                \"Snapshot directory has log files. Check if dataLogDir and dataDir configuration is correct.\");\n        }\n    }\n\n    /**\n     * get the datadir used by this filetxn\n     * snap log\n     * @return the data dir\n     */\n    public File getDataDir() {\n        return this.dataDir;\n    }\n\n    /**\n     * get the snap dir used by this\n     * filetxn snap log\n     * @return the snap dir\n     */\n    public File getSnapDir() {\n        return this.snapDir;\n    }\n\n    /**\n     * get information of the last saved/restored snapshot\n     * @return info of last snapshot\n     */\n    public SnapshotInfo getLastSnapshotInfo() {\n        return this.snapLog.getLastSnapshotInfo();\n    }\n\n    /**\n     * this function restores the server\n     * database after reading from the\n     * snapshots and transaction logs\n     * @param dt the datatree to be restored\n     * @param sessions the sessions to be restored\n     * @param listener the playback listener to run on the\n     * database restoration\n     * @return the highest zxid restored\n     * @throws IOException\n     */\n    public long restore(DataTree dt, Map<Long, Integer> sessions, PlayBackListener listener) throws IOException {\n        long snapLoadingStartTime = Time.currentElapsedTime();\n        long deserializeResult = snapLog.deserialize(dt, sessions);\n        ServerMetrics.getMetrics().STARTUP_SNAP_LOAD_TIME.add(Time.currentElapsedTime() - snapLoadingStartTime);\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        boolean trustEmptyDB;\n        File initFile = new File(dataDir.getParent(), \"initialize\");\n        if (Files.deleteIfExists(initFile.toPath())) {\n            LOG.info(\"Initialize file found, an empty database will not block voting participation\");\n            trustEmptyDB = true;\n        } else {\n            trustEmptyDB = autoCreateDB;\n        }\n\n        RestoreFinalizer finalizer = () -> {\n            long highestZxid = fastForwardFromEdits(dt, sessions, listener);\n            // The snapshotZxidDigest will reset after replaying the txn of the\n            // zxid in the snapshotZxidDigest, if it's not reset to null after\n            // restoring, it means either there are not enough txns to cover that\n            // zxid or that txn is missing\n            DataTree.ZxidDigest snapshotZxidDigest = dt.getDigestFromLoadedSnapshot();\n            if (snapshotZxidDigest != null) {\n                LOG.warn(\n                        \"Highest txn zxid 0x{} is not covering the snapshot digest zxid 0x{}, \"\n                                + \"which might lead to inconsistent state\",\n                        Long.toHexString(highestZxid),\n                        Long.toHexString(snapshotZxidDigest.getZxid()));\n            }\n            return highestZxid;\n        };\n\n        if (-1L == deserializeResult) {\n            /* this means that we couldn't find any snapshot, so we need to\n             * initialize an empty database (reported in ZOOKEEPER-2325) */\n            if (txnLog.getLastLoggedZxid() != -1) {\n                // ZOOKEEPER-3056: provides an escape hatch for users upgrading\n                // from old versions of zookeeper (3.4.x, pre 3.5.3).\n                if (!trustEmptySnapshot) {\n                    throw new IOException(EMPTY_SNAPSHOT_WARNING + \"Something is broken!\");\n                } else {\n                    LOG.warn(\"{}This should only be allowed during upgrading.\", EMPTY_SNAPSHOT_WARNING);\n                    return finalizer.run();\n                }\n            }\n\n            if (trustEmptyDB) {\n                /* TODO: (br33d) we should either put a ConcurrentHashMap on restore()\n                 *       or use Map on save() */\n                save(dt, (ConcurrentHashMap<Long, Integer>) sessions, false);\n\n                /* return a zxid of 0, since we know the database is empty */\n                return 0L;\n            } else {\n                /* return a zxid of -1, since we are possibly missing data */\n                LOG.warn(\"Unexpected empty data tree, setting zxid to -1\");\n                dt.lastProcessedZxid = -1L;\n                return -1L;\n            }\n        }\n\n        return finalizer.run();\n    }\n\n    /**\n     * This function will fast forward the server database to have the latest\n     * transactions in it.  This is the same as restore, but only reads from\n     * the transaction logs and not restores from a snapshot.\n     * @param dt the datatree to write transactions to.\n     * @param sessions the sessions to be restored.\n     * @param listener the playback listener to run on the\n     * database transactions.\n     * @return the highest zxid restored.\n     * @throws IOException\n     */\n    public long fastForwardFromEdits(\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        PlayBackListener listener) throws IOException {\n        TxnIterator itr = txnLog.read(dt.lastProcessedZxid + 1);\n        long highestZxid = dt.lastProcessedZxid;\n        TxnHeader hdr;\n        int txnLoaded = 0;\n        long startTime = Time.currentElapsedTime();\n        try {\n            while (true) {\n                // iterator points to\n                // the first valid txn when initialized\n                hdr = itr.getHeader();\n                if (hdr == null) {\n                    //empty logs\n                    return dt.lastProcessedZxid;\n                }\n                if (hdr.getZxid() < highestZxid && highestZxid != 0) {\n                    LOG.error(\"{}(highestZxid) > {}(next log) for type {}\", highestZxid, hdr.getZxid(), hdr.getType());\n                } else {\n                    highestZxid = hdr.getZxid();\n                }\n                try {\n                    processTransaction(hdr, dt, sessions, itr.getTxn());\n                    dt.compareDigest(hdr, itr.getTxn(), itr.getDigest());\n                    txnLoaded++;\n                } catch (KeeperException.NoNodeException e) {\n                    throw new IOException(\"Failed to process transaction type: \"\n                                          + hdr.getType()\n                                          + \" error: \"\n                                          + e.getMessage(),\n                                          e);\n                }\n                listener.onTxnLoaded(hdr, itr.getTxn(), itr.getDigest());\n                if (!itr.next()) {\n                    break;\n                }\n            }\n        } finally {\n            if (itr != null) {\n                itr.close();\n            }\n        }\n\n        long loadTime = Time.currentElapsedTime() - startTime;\n        LOG.info(\"{} txns loaded in {} ms\", txnLoaded, loadTime);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOADED.add(txnLoaded);\n        ServerMetrics.getMetrics().STARTUP_TXNS_LOAD_TIME.add(loadTime);\n\n        return highestZxid;\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid) throws IOException {\n        return readTxnLog(zxid, true);\n    }\n\n    /**\n     * Get TxnIterator for iterating through txnlog starting at a given zxid\n     *\n     * @param zxid starting zxid\n     * @param fastForward true if the iterator should be fast forwarded to point\n     *        to the txn of a given zxid, else the iterator will point to the\n     *        starting txn of a txnlog that may contain txn of a given zxid\n     * @return TxnIterator\n     * @throws IOException\n     */\n    public TxnIterator readTxnLog(long zxid, boolean fastForward) throws IOException {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.read(zxid, fastForward);\n    }\n\n    /**\n     * process the transaction on the datatree\n     * @param hdr the hdr of the transaction\n     * @param dt the datatree to apply transaction to\n     * @param sessions the sessions to be restored\n     * @param txn the transaction to be applied\n     */\n    public void processTransaction(\n        TxnHeader hdr,\n        DataTree dt,\n        Map<Long, Integer> sessions,\n        Record txn) throws KeeperException.NoNodeException {\n        ProcessTxnResult rc;\n        switch (hdr.getType()) {\n        case OpCode.createSession:\n            sessions.put(hdr.getClientId(), ((CreateSessionTxn) txn).getTimeOut());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- create session in log: 0x\" + Long.toHexString(hdr.getClientId())\n                    + \" with timeout: \" + ((CreateSessionTxn) txn).getTimeOut());\n            }\n            // give dataTree a chance to sync its lastProcessedZxid\n            rc = dt.processTxn(hdr, txn);\n            break;\n        case OpCode.closeSession:\n            sessions.remove(hdr.getClientId());\n            if (LOG.isTraceEnabled()) {\n                ZooTrace.logTraceMessage(\n                    LOG,\n                    ZooTrace.SESSION_TRACE_MASK,\n                    \"playLog --- close session in log: 0x\" + Long.toHexString(hdr.getClientId()));\n            }\n            rc = dt.processTxn(hdr, txn);\n            break;\n        default:\n            rc = dt.processTxn(hdr, txn);\n        }\n\n        /*\n         * Snapshots are lazily created. So when a snapshot is in progress,\n         * there is a chance for later transactions to make into the\n         * snapshot. Then when the snapshot is restored, NONODE/NODEEXISTS\n         * errors could occur. It should be safe to ignore these.\n         */\n        if (rc.err != Code.OK.intValue()) {\n            LOG.debug(\"Ignoring processTxn failure hdr: {}, error: {}, path: {}\", hdr.getType(), rc.err, rc.path);\n        }\n    }\n\n    /**\n     * the last logged zxid on the transaction logs\n     * @return the last logged zxid\n     */\n    public long getLastLoggedZxid() {\n        FileTxnLog txnLog = new FileTxnLog(dataDir);\n        return txnLog.getLastLoggedZxid();\n    }\n\n    /**\n     * save the datatree and the sessions into a snapshot\n     * @param dataTree the datatree to be serialized onto disk\n     * @param sessionsWithTimeouts the session timeouts to be\n     * serialized onto disk\n     * @param syncSnap sync the snapshot immediately after write\n     * @throws IOException\n     */\n    public void save(\n        DataTree dataTree,\n        ConcurrentHashMap<Long, Integer> sessionsWithTimeouts,\n        boolean syncSnap) throws IOException {\n        long lastZxid = dataTree.lastProcessedZxid;\n        File snapshotFile = new File(snapDir, Util.makeSnapshotName(lastZxid));\n        LOG.info(\"Snapshotting: 0x{} to {}\", Long.toHexString(lastZxid), snapshotFile);\n        try {\n            snapLog.serialize(dataTree, sessionsWithTimeouts, snapshotFile, syncSnap);\n        } catch (IOException e) {\n            if (snapshotFile.length() == 0) {\n                /* This may be caused by a full disk. In such a case, the server\n                 * will get stuck in a loop where it tries to write a snapshot\n                 * out to disk, and ends up creating an empty file instead.\n                 * Doing so will eventually result in valid snapshots being\n                 * removed during cleanup. */\n                if (snapshotFile.delete()) {\n                    LOG.info(\"Deleted empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                } else {\n                    LOG.warn(\"Could not delete empty snapshot file: {}\", snapshotFile.getAbsolutePath());\n                }\n            } else {\n                /* Something else went wrong when writing the snapshot out to\n                 * disk. If this snapshot file is invalid, when restarting,\n                 * ZooKeeper will skip it, and find the last known good snapshot\n                 * instead. */\n            }\n            throw e;\n        }\n    }\n\n    /**\n     * truncate the transaction logs the zxid\n     * specified\n     * @param zxid the zxid to truncate the logs to\n     * @return true if able to truncate the log, false if not\n     * @throws IOException\n     */\n    public boolean truncateLog(long zxid) {\n        try {\n            // close the existing txnLog and snapLog\n            close();\n\n            // truncate it\n            try (FileTxnLog truncLog = new FileTxnLog(dataDir)) {\n                boolean truncated = truncLog.truncate(zxid);\n\n                // re-open the txnLog and snapLog\n                // I'd rather just close/reopen this object itself, however that\n                // would have a big impact outside ZKDatabase as there are other\n                // objects holding a reference to this object.\n                txnLog = new FileTxnLog(dataDir);\n                snapLog = new FileSnap(snapDir);\n\n                return truncated;\n            }\n        } catch (IOException e) {\n            LOG.error(\"Unable to truncate Txn log\", e);\n            return false;\n        }\n    }\n\n    /**\n     * the most recent snapshot in the snapshot\n     * directory\n     * @return the file that contains the most\n     * recent snapshot\n     * @throws IOException\n     */\n    public File findMostRecentSnapshot() throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findMostRecentSnapshot();\n    }\n\n    /**\n     * the n most recent snapshots\n     * @param n the number of recent snapshots\n     * @return the list of n most recent snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNRecentSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNRecentSnapshots(n);\n    }\n\n    /**\n     * the n recent valid snapshots\n     * @param n the number of recent valid snapshots\n     * @return the list of n recent valid snapshots, with\n     * the most recent in front\n     * @throws IOException\n     */\n    public List<File> findNValidSnapshots(int n) throws IOException {\n        FileSnap snaplog = new FileSnap(snapDir);\n        return snaplog.findNValidSnapshots(n);\n    }\n\n    /**\n     * get the snapshot logs which may contain transactions newer than the given zxid.\n     * This includes logs with starting zxid greater than given zxid, as well as the\n     * newest transaction log with starting zxid less than given zxid.  The latter log\n     * file may contain transactions beyond given zxid.\n     * @param zxid the zxid that contains logs greater than\n     * zxid\n     * @return the snapshot logs which may contain transactions newer than the given zxid\n     */\n    public File[] getSnapshotLogs(long zxid) {\n        return FileTxnLog.getLogFiles(dataDir.listFiles(), zxid);\n    }\n\n    /**\n     * append the request to the transaction logs\n     * @param si the request to be appended\n     * @return true iff something appended, otw false\n     * @throws IOException\n     */\n    public boolean append(Request si) throws IOException {\n        return txnLog.append(si.getHdr(), si.getTxn(), si.getTxnDigest());\n    }\n\n    /**\n     * commit the transaction of logs\n     * @throws IOException\n     */\n    public void commit() throws IOException {\n        txnLog.commit();\n    }\n\n    /**\n     *\n     * @return elapsed sync time of transaction log commit in milliseconds\n     */\n    public long getTxnLogElapsedSyncTime() {\n        return txnLog.getTxnLogSyncElapsedTime();\n    }\n\n    /**\n     * roll the transaction logs\n     * @throws IOException\n     */\n    public void rollLog() throws IOException {\n        txnLog.rollLog();\n    }\n\n    /**\n     * close the transaction log files\n     * @throws IOException\n     */\n    public void close() throws IOException {\n        TxnLog txnLogToClose = txnLog;\n        if (txnLogToClose != null) {\n            txnLogToClose.close();\n        }\n        txnLog = null;\n        SnapShot snapSlogToClose = snapLog;\n        if (snapSlogToClose != null) {\n            snapSlogToClose.close();\n        }\n        snapLog = null;\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class DatadirException extends IOException {\n\n        public DatadirException(String msg) {\n            super(msg);\n        }\n        public DatadirException(String msg, Exception e) {\n            super(msg, e);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class LogDirContentCheckException extends DatadirException {\n\n        public LogDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    @SuppressWarnings(\"serial\")\n    public static class SnapDirContentCheckException extends DatadirException {\n\n        public SnapDirContentCheckException(String msg) {\n            super(msg);\n        }\n\n    }\n\n    public void setTotalLogSize(long size) {\n        txnLog.setTotalLogSize(size);\n    }\n\n    public long getTotalLogSize() {\n        return txnLog.getTotalLogSize();\n    }\n}\n","lineNo":619}
{"Smelly Sample":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandler.Sharable;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.ChannelGroupFuture;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.OptionalSslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.AttributeKey;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.DefaultEventExecutor;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLPeerUnverifiedException;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.X509KeyManager;\nimport javax.net.ssl.X509TrustManager;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.common.ClientX509Util;\nimport org.apache.zookeeper.common.NettyUtils;\nimport org.apache.zookeeper.common.SSLContextAndOptions;\nimport org.apache.zookeeper.common.X509Exception;\nimport org.apache.zookeeper.common.X509Exception.SSLContextException;\nimport org.apache.zookeeper.server.NettyServerCnxn.HandshakeState;\nimport org.apache.zookeeper.server.auth.ProviderRegistry;\nimport org.apache.zookeeper.server.auth.X509AuthenticationProvider;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxnFactory extends ServerCnxnFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxnFactory.class);\n\n    /**\n     * Allow client-server sockets to accept both SSL and plaintext connections\n     */\n    public static final String PORT_UNIFICATION_KEY = \"zookeeper.client.portUnification\";\n    private final boolean shouldUsePortUnification;\n\n    /**\n     * The first byte in TLS protocol is the content type of the subsequent record.\n     * Handshakes use value 22 (0x16) so the first byte offered on any TCP connection\n     * attempting to establish a TLS connection will be this value.\n     * https://tools.ietf.org/html/rfc8446#page-79\n     */\n    private static final byte TLS_HANDSHAKE_RECORD_TYPE = 0x16;\n\n    private final AtomicInteger outstandingHandshake = new AtomicInteger();\n    public static final String OUTSTANDING_HANDSHAKE_LIMIT = \"zookeeper.netty.server.outstandingHandshake.limit\";\n    private int outstandingHandshakeLimit;\n    private boolean handshakeThrottlingEnabled;\n\n    public void setOutstandingHandshakeLimit(int limit) {\n        outstandingHandshakeLimit = limit;\n        handshakeThrottlingEnabled = (secure || shouldUsePortUnification) && outstandingHandshakeLimit > 0;\n        LOG.info(\"handshakeThrottlingEnabled = {}, {} = {}\",\n                handshakeThrottlingEnabled, OUTSTANDING_HANDSHAKE_LIMIT, outstandingHandshakeLimit);\n    }\n\n    private final ServerBootstrap bootstrap;\n    private Channel parentChannel;\n    private final ChannelGroup allChannels = new DefaultChannelGroup(\"zkServerCnxns\", new DefaultEventExecutor());\n    private final Map<InetAddress, AtomicInteger> ipMap = new ConcurrentHashMap<>();\n    private InetSocketAddress localAddress;\n    private int maxClientCnxns = 60;\n    int listenBacklog = -1;\n    private final ClientX509Util x509Util;\n\n    public static final String NETTY_ADVANCED_FLOW_CONTROL = \"zookeeper.netty.advancedFlowControl.enabled\";\n    private boolean advancedFlowControlEnabled = false;\n\n    private static final AttributeKey<NettyServerCnxn> CONNECTION_ATTRIBUTE = AttributeKey.valueOf(\"NettyServerCnxn\");\n\n    private static final AtomicReference<ByteBufAllocator> TEST_ALLOCATOR = new AtomicReference<>(null);\n\n    /**\n     * A handler that detects whether the client would like to use\n     * TLS or not and responds in kind. The first bytes are examined\n     * for the static TLS headers to make the determination and\n     * placed back in the stream with the correct ChannelHandler\n     * instantiated.\n     */\n    class DualModeSslHandler extends OptionalSslHandler {\n\n        DualModeSslHandler(SslContext sslContext) {\n            super(sslContext);\n        }\n\n        @Override\n        protected void decode(ChannelHandlerContext context, ByteBuf in, List<Object> out) throws Exception {\n            if (in.readableBytes() >= 5) {\n                super.decode(context, in, out);\n            } else if (in.readableBytes() > 0) {\n                // It requires 5 bytes to detect a proper ssl connection. In the\n                // case that the server receives fewer, check if we can fail to plaintext.\n                // This will occur when for any four letter work commands.\n                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n                    LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n                    handleNonSsl(context);\n                }\n            }\n        }\n\n        /**\n         * pulled directly from OptionalSslHandler to allow for access\n         * @param context\n         */\n        private void handleNonSsl(ChannelHandlerContext context) {\n            ChannelHandler handler = this.newNonSslHandler(context);\n            if (handler != null) {\n                context.pipeline().replace(this, this.newNonSslHandlerName(), handler);\n            } else {\n                context.pipeline().remove(this);\n            }\n        }\n\n        @Override\n        protected SslHandler newSslHandler(ChannelHandlerContext context, SslContext sslContext) {\n            NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n            LOG.debug(\"creating ssl handler for session {}\", cnxn.getSessionId());\n            SslHandler handler = super.newSslHandler(context, sslContext);\n            Future<Channel> handshakeFuture = handler.handshakeFuture();\n            handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));\n            return handler;\n        }\n\n        @Override\n        protected ChannelHandler newNonSslHandler(ChannelHandlerContext context) {\n            NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n            LOG.debug(\"creating plaintext handler for session {}\", cnxn.getSessionId());\n            // Mark handshake finished if it's a insecure cnxn\n            updateHandshakeCountIfStarted(cnxn);\n            allChannels.add(context.channel());\n            addCnxn(cnxn);\n            return super.newNonSslHandler(context);\n        }\n\n    }\n\n    private void updateHandshakeCountIfStarted(NettyServerCnxn cnxn) {\n        if (cnxn != null && cnxn.getHandshakeState() == HandshakeState.STARTED) {\n            cnxn.setHandshakeState(HandshakeState.FINISHED);\n            outstandingHandshake.addAndGet(-1);\n        }\n    }\n\n    /**\n     * This is an inner class since we need to extend ChannelDuplexHandler, but\n     * NettyServerCnxnFactory already extends ServerCnxnFactory. By making it inner\n     * this class gets access to the member variables and methods.\n     */\n    @Sharable\n    class CnxnChannelHandler extends ChannelDuplexHandler {\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Channel active {}\", ctx.channel());\n            }\n\n            final Channel channel = ctx.channel();\n            if (limitTotalNumberOfCnxns()) {\n                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n                channel.close();\n                return;\n            }\n            InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n            if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {\n                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n                LOG.warn(\"Too many connections from {} - max is {}\", addr, maxClientCnxns);\n                channel.close();\n                return;\n            }\n\n            NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);\n            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);\n\n            // Check the zkServer assigned to the cnxn is still running,\n            // close it before starting the heavy TLS handshake\n            if (!cnxn.isZKServerRunning()) {\n                LOG.warn(\"Zookeeper server is not running, close the connection before starting the TLS handshake\");\n                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n                channel.close();\n                return;\n            }\n\n            if (handshakeThrottlingEnabled) {\n                // Favor to check and throttling even in dual mode which\n                // accepts both secure and insecure connections, since\n                // it's more efficient than throttling when we know it's\n                // a secure connection in DualModeSslHandler.\n                //\n                // From benchmark, this reduced around 15% reconnect time.\n                int outstandingHandshakesNum = outstandingHandshake.addAndGet(1);\n                if (outstandingHandshakesNum > outstandingHandshakeLimit) {\n                    outstandingHandshake.addAndGet(-1);\n                    channel.close();\n                    ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED.add(1);\n                } else {\n                    cnxn.setHandshakeState(HandshakeState.STARTED);\n                }\n            }\n\n            if (secure) {\n                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);\n                Future<Channel> handshakeFuture = sslHandler.handshakeFuture();\n                handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));\n            } else if (!shouldUsePortUnification) {\n                allChannels.add(ctx.channel());\n                addCnxn(cnxn);\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Channel inactive {}\", ctx.channel());\n            }\n\n            allChannels.remove(ctx.channel());\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);\n            if (cnxn != null) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Channel inactive caused close {}\", cnxn);\n                }\n                updateHandshakeCountIfStarted(cnxn);\n                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            LOG.warn(\"Exception caught\", cause);\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);\n            if (cnxn != null) {\n                LOG.debug(\"Closing {}\", cnxn);\n                updateHandshakeCountIfStarted(cnxn);\n                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            try {\n                if (evt == NettyServerCnxn.ReadEvent.ENABLE) {\n                    LOG.debug(\"Received ReadEvent.ENABLE\");\n                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n                    // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n                    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n                    // after either of those. Check for null just to be safe ...\n                    if (cnxn != null) {\n                        if (cnxn.getQueuedReadableBytes() > 0) {\n                            cnxn.processQueuedBuffer();\n                            if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n                                // trigger a read if we have consumed all\n                                // backlog\n                                ctx.read();\n                                LOG.debug(\"Issued a read after queuedBuffer drained\");\n                            }\n                        }\n                    }\n                    if (!advancedFlowControlEnabled) {\n                        ctx.channel().config().setAutoRead(true);\n                    }\n                } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {\n                    LOG.debug(\"Received ReadEvent.DISABLE\");\n                    ctx.channel().config().setAutoRead(false);\n                }\n            } finally {\n                ReferenceCountUtil.release(evt);\n            }\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            try {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"message received called {}\", msg);\n                }\n                try {\n                    LOG.debug(\"New message {} from {}\", msg, ctx.channel());\n                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n                    if (cnxn == null) {\n                        LOG.error(\"channelRead() on a closed or closing NettyServerCnxn\");\n                    } else {\n                        cnxn.processMessage((ByteBuf) msg);\n                    }\n                } catch (Exception ex) {\n                    LOG.error(\"Unexpected exception in receive\", ex);\n                    throw ex;\n                }\n            } finally {\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            if (advancedFlowControlEnabled) {\n                NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n                if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {\n                    ctx.read();\n                    LOG.debug(\"Issued a read since we do not have anything to consume after channelReadComplete\");\n                }\n            }\n\n            ctx.fireChannelReadComplete();\n        }\n\n        // Use a single listener instance to reduce GC\n        // Note: this listener is only added when LOG.isTraceEnabled() is true,\n        // so it should not do any work other than trace logging.\n        private final GenericFutureListener<Future<Void>> onWriteCompletedTracer = (f) -> {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"write success: {}\", f.isSuccess());\n            }\n        };\n\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n            if (LOG.isTraceEnabled()) {\n                promise.addListener(onWriteCompletedTracer);\n            }\n            super.write(ctx, msg, promise);\n        }\n\n    }\n\n    final class CertificateVerifier implements GenericFutureListener<Future<Channel>> {\n\n        private final SslHandler sslHandler;\n        private final NettyServerCnxn cnxn;\n\n        CertificateVerifier(SslHandler sslHandler, NettyServerCnxn cnxn) {\n            this.sslHandler = sslHandler;\n            this.cnxn = cnxn;\n        }\n\n        /**\n         * Only allow the connection to stay open if certificate passes auth\n         */\n        public void operationComplete(Future<Channel> future) {\n            updateHandshakeCountIfStarted(cnxn);\n\n            if (future.isSuccess()) {\n                LOG.debug(\"Successful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n                SSLEngine eng = sslHandler.engine();\n                // Don't try to verify certificate if we didn't ask client to present one\n                if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {\n                    SSLSession session = eng.getSession();\n                    try {\n                        cnxn.setClientCertificateChain(session.getPeerCertificates());\n                    } catch (SSLPeerUnverifiedException e) {\n                        if (eng.getNeedClientAuth()) {\n                            // Certificate was requested but not present\n                            LOG.error(\"Error getting peer certificates\", e);\n                            cnxn.close();\n                            return;\n                        } else {\n                            // Certificate was requested but was optional\n                            // TODO: what auth info should we set on the connection?\n                            final Channel futureChannel = future.getNow();\n                            allChannels.add(Objects.requireNonNull(futureChannel));\n                            addCnxn(cnxn);\n                            return;\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"Error getting peer certificates\", e);\n                        cnxn.close();\n                        return;\n                    }\n\n                    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n\n                    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n\n                    if (authProvider == null) {\n                        LOG.error(\"X509 Auth provider not found: {}\", authProviderProp);\n                        cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n                        return;\n                    }\n\n                    if (KeeperException.Code.OK != authProvider.handleAuthentication(cnxn, null)) {\n                        LOG.error(\"Authentication failed for session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n                        cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n                        return;\n                    }\n                }\n\n                final Channel futureChannel = future.getNow();\n                allChannels.add(Objects.requireNonNull(futureChannel));\n                addCnxn(cnxn);\n            } else {\n                LOG.error(\"Unsuccessful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n                ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);\n                cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);\n            }\n        }\n\n    }\n\n    @Sharable\n    static class ReadIssuedTrackingHandler extends ChannelDuplexHandler {\n\n        @Override\n        public void read(ChannelHandlerContext ctx) throws Exception {\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n            if (cnxn != null) {\n                cnxn.readIssuedAfterReadComplete++;\n            }\n\n            ctx.read();\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n            if (cnxn != null) {\n                cnxn.readIssuedAfterReadComplete = 0;\n            }\n\n            ctx.fireChannelReadComplete();\n        }\n\n    }\n\n    CnxnChannelHandler channelHandler = new CnxnChannelHandler();\n    ReadIssuedTrackingHandler readIssuedTrackingHandler = new ReadIssuedTrackingHandler();\n\n    private ServerBootstrap configureBootstrapAllocator(ServerBootstrap bootstrap) {\n        ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();\n        if (testAllocator != null) {\n            return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator)\n                            .childOption(ChannelOption.ALLOCATOR, testAllocator);\n        } else {\n            return bootstrap;\n        }\n    }\n\n    NettyServerCnxnFactory() {\n        x509Util = new ClientX509Util();\n\n        boolean usePortUnification = Boolean.getBoolean(PORT_UNIFICATION_KEY);\n        LOG.info(\"{}={}\", PORT_UNIFICATION_KEY, usePortUnification);\n        if (usePortUnification) {\n            try {\n                QuorumPeerConfig.configureSSLAuth();\n            } catch (QuorumPeerConfig.ConfigException e) {\n                LOG.error(\"unable to set up SslAuthProvider, turning off client port unification\", e);\n                usePortUnification = false;\n            }\n        }\n        this.shouldUsePortUnification = usePortUnification;\n\n        this.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);\n        LOG.info(\"{} = {}\", NETTY_ADVANCED_FLOW_CONTROL, this.advancedFlowControlEnabled);\n\n        setOutstandingHandshakeLimit(Integer.getInteger(OUTSTANDING_HANDSHAKE_LIMIT, -1));\n\n        EventLoopGroup bossGroup = NettyUtils.newNioOrEpollEventLoopGroup(NettyUtils.getClientReachableLocalInetAddressCount());\n        EventLoopGroup workerGroup = NettyUtils.newNioOrEpollEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workerGroup)\n                                                         .channel(NettyUtils.nioOrEpollServerSocketChannel())\n                                                         // parent channel options\n                                                         .option(ChannelOption.SO_REUSEADDR, true)\n                                                         // child channels options\n                                                         .childOption(ChannelOption.TCP_NODELAY, true)\n                                                         .childOption(ChannelOption.SO_LINGER, -1)\n                                                         .childHandler(new ChannelInitializer<SocketChannel>() {\n                                                             @Override\n                                                             protected void initChannel(SocketChannel ch) throws Exception {\n                                                                 ChannelPipeline pipeline = ch.pipeline();\n                                                                 if (advancedFlowControlEnabled) {\n                                                                     pipeline.addLast(readIssuedTrackingHandler);\n                                                                 }\n                                                                 if (secure) {\n                                                                     initSSL(pipeline, false);\n                                                                 } else if (shouldUsePortUnification) {\n                                                                     initSSL(pipeline, true);\n                                                                 }\n                                                                 pipeline.addLast(\"servercnxnfactory\", channelHandler);\n                                                             }\n                                                         });\n        this.bootstrap = configureBootstrapAllocator(bootstrap);\n        this.bootstrap.validate();\n    }\n\n    private synchronized void initSSL(ChannelPipeline p, boolean supportPlaintext) throws X509Exception, KeyManagementException, NoSuchAlgorithmException {\n        String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());\n        SslContext nettySslContext;\n        if (authProviderProp == null) {\n            SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();\n            nettySslContext = sslContextAndOptions.createNettyJdkSslContext(sslContextAndOptions.getSSLContext(), false);\n        } else {\n            SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);\n            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(\n                System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\"));\n\n            if (authProvider == null) {\n                LOG.error(\"Auth provider not found: {}\", authProviderProp);\n                throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n            }\n\n            sslContext.init(new X509KeyManager[]{authProvider.getKeyManager()}, new X509TrustManager[]{authProvider.getTrustManager()}, null);\n            nettySslContext = x509Util.getDefaultSSLContextAndOptions().createNettyJdkSslContext(sslContext, false);\n        }\n\n        if (supportPlaintext) {\n            p.addLast(\"ssl\", new DualModeSslHandler(nettySslContext));\n            LOG.debug(\"dual mode SSL handler added for channel: {}\", p.channel());\n        } else {\n            p.addLast(\"ssl\", nettySslContext.newHandler(p.channel().alloc()));\n            LOG.debug(\"SSL handler added for channel: {}\", p.channel());\n        }\n    }\n\n    @Override\n    public void closeAll(ServerCnxn.DisconnectReason reason) {\n        LOG.debug(\"closeAll()\");\n\n        // clear all the connections on which we are selecting\n        int length = cnxns.size();\n        for (ServerCnxn cnxn : cnxns) {\n            try {\n                // This will remove the cnxn from cnxns\n                cnxn.close(reason);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring exception closing cnxn sessionid 0x{}\", Long.toHexString(cnxn.getSessionId()), e);\n            }\n        }\n\n        LOG.debug(\"allChannels size: {} cnxns size: {}\", allChannels.size(), length);\n    }\n\n    @Override\n    public void configure(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException {\n        configureSaslLogin();\n        initMaxCnxns();\n        localAddress = addr;\n        this.maxClientCnxns = maxClientCnxns;\n        this.secure = secure;\n        this.listenBacklog = backlog;\n    }\n\n    /** {@inheritDoc} */\n    public int getMaxClientCnxnsPerHost() {\n        return maxClientCnxns;\n    }\n\n    /** {@inheritDoc} */\n    public void setMaxClientCnxnsPerHost(int max) {\n        maxClientCnxns = max;\n    }\n\n    /** {@inheritDoc} */\n    public int getSocketListenBacklog() {\n        return listenBacklog;\n    }\n\n    @Override\n    public int getLocalPort() {\n        return localAddress.getPort();\n    }\n\n    private boolean killed; // use synchronized(this) to access\n    @Override\n    public void join() throws InterruptedException {\n        synchronized (this) {\n            while (!killed) {\n                wait();\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        synchronized (this) {\n            if (killed) {\n                LOG.info(\"already shutdown {}\", localAddress);\n                return;\n            }\n        }\n        LOG.info(\"shutdown called {}\", localAddress);\n\n        x509Util.close();\n\n        if (login != null) {\n            login.shutdown();\n        }\n\n        final EventLoopGroup bossGroup = bootstrap.config().group();\n        final EventLoopGroup workerGroup = bootstrap.config().childGroup();\n        // null if factory never started\n        if (parentChannel != null) {\n            ChannelFuture parentCloseFuture = parentChannel.close();\n            if (bossGroup != null) {\n                parentCloseFuture.addListener(future -> {\n                    bossGroup.shutdownGracefully();\n                });\n            }\n            closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            ChannelGroupFuture allChannelsCloseFuture = allChannels.close();\n            if (workerGroup != null) {\n                allChannelsCloseFuture.addListener(future -> {\n                    workerGroup.shutdownGracefully();\n                });\n            }\n        } else {\n            if (bossGroup != null) {\n                bossGroup.shutdownGracefully();\n            }\n            if (workerGroup != null) {\n                workerGroup.shutdownGracefully();\n            }\n        }\n\n        if (zkServer != null) {\n            zkServer.shutdown();\n        }\n        synchronized (this) {\n            killed = true;\n            notifyAll();\n        }\n    }\n\n    @Override\n    public void start() {\n        if (listenBacklog != -1) {\n            bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);\n        }\n        LOG.info(\"binding to port {}\", localAddress);\n        parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();\n        // Port changes after bind() if the original port was 0, update\n        // localAddress to get the real port.\n        localAddress = (InetSocketAddress) parentChannel.localAddress();\n        LOG.info(\"bound to port {}\", getLocalPort());\n    }\n\n    public void reconfigure(InetSocketAddress addr) {\n        LOG.info(\"binding to port {}, {}\", addr, localAddress);\n        if (addr != null && localAddress != null) {\n            if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress()\n                    && localAddress.getAddress().isAnyLocalAddress()\n                    && addr.getPort() == localAddress.getPort())) {\n                 LOG.info(\"address is the same, skip rebinding\");\n                 return;\n            }\n        }\n\n        Channel oldChannel = parentChannel;\n        try {\n            parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();\n            // Port changes after bind() if the original port was 0, update\n            // localAddress to get the real port.\n            localAddress = (InetSocketAddress) parentChannel.localAddress();\n            LOG.info(\"bound to port {}\", getLocalPort());\n        } catch (Exception e) {\n            LOG.error(\"Error while reconfiguring\", e);\n        } finally {\n            oldChannel.close();\n        }\n    }\n\n    @Override\n    public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException {\n        start();\n        setZooKeeperServer(zks);\n        if (startServer) {\n            zks.startdata();\n            zks.startup();\n        }\n    }\n\n    @Override\n    public Iterable<ServerCnxn> getConnections() {\n        return cnxns;\n    }\n\n    @Override\n    public InetSocketAddress getLocalAddress() {\n        return localAddress;\n    }\n\n    private void addCnxn(final NettyServerCnxn cnxn) {\n        cnxns.add(cnxn);\n        InetAddress addr = ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();\n\n        ipMap.compute(addr, (a, cnxnCount) -> {\n            if (cnxnCount == null) {\n                cnxnCount = new AtomicInteger();\n            }\n            cnxnCount.incrementAndGet();\n            return cnxnCount;\n        });\n    }\n\n    void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress) {\n        ipMap.compute(remoteAddress, (addr, cnxnCount) -> {\n            if (cnxnCount == null) {\n                LOG.error(\"Unexpected remote address {} when removing cnxn {}\", remoteAddress, cnxn);\n                return null;\n            }\n            final int newValue = cnxnCount.decrementAndGet();\n            return newValue == 0 ? null : cnxnCount;\n        });\n    }\n\n    private int getClientCnxnCount(final InetAddress addr) {\n        final AtomicInteger count = ipMap.get(addr);\n        return count == null ? 0 : count.get();\n    }\n\n    @Override\n    public void resetAllConnectionStats() {\n        // No need to synchronize since cnxns is backed by a ConcurrentHashMap\n        for (ServerCnxn c : cnxns) {\n            c.resetStats();\n        }\n    }\n\n    @Override\n    public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief) {\n        Set<Map<String, Object>> info = new HashSet<Map<String, Object>>();\n        // No need to synchronize since cnxns is backed by a ConcurrentHashMap\n        for (ServerCnxn c : cnxns) {\n            info.add(c.getConnectionInfo(brief));\n        }\n        return info;\n    }\n\n    /**\n     * Sets the test ByteBufAllocator. This allocator will be used by all\n     * future instances of this class.\n     * It is not recommended to use this method outside of testing.\n     * @param allocator the ByteBufAllocator to use for all netty buffer\n     *                  allocations.\n     */\n    static void setTestAllocator(ByteBufAllocator allocator) {\n        TEST_ALLOCATOR.set(allocator);\n    }\n\n    /**\n     * Clears the test ByteBufAllocator. The default allocator will be used\n     * by all future instances of this class.\n     * It is not recommended to use this method outside of testing.\n     */\n    static void clearTestAllocator() {\n        TEST_ALLOCATOR.set(null);\n    }\n\n    // VisibleForTest\n    public void setAdvancedFlowControlEnabled(boolean advancedFlowControlEnabled) {\n        this.advancedFlowControlEnabled = advancedFlowControlEnabled;\n    }\n\n    // VisibleForTest\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    // VisibleForTest\n    public Channel getParentChannel() {\n        return parentChannel;\n    }\n\n    public int getOutstandingHandshakeNum() {\n        return outstandingHandshake.get();\n    }\n}\n","Method after Refactoring":"/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.zookeeper.server;\n\nimport io.netty.bootstrap.ServerBootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelDuplexHandler;\nimport io.netty.channel.ChannelFuture;\nimport io.netty.channel.ChannelHandler;\nimport io.netty.channel.ChannelHandler.Sharable;\nimport io.netty.channel.ChannelHandlerContext;\nimport io.netty.channel.ChannelInitializer;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.ChannelPipeline;\nimport io.netty.channel.ChannelPromise;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.group.ChannelGroup;\nimport io.netty.channel.group.ChannelGroupFuture;\nimport io.netty.channel.group.DefaultChannelGroup;\nimport io.netty.channel.socket.SocketChannel;\nimport io.netty.handler.ssl.OptionalSslHandler;\nimport io.netty.handler.ssl.SslContext;\nimport io.netty.handler.ssl.SslHandler;\nimport io.netty.util.AttributeKey;\nimport io.netty.util.ReferenceCountUtil;\nimport io.netty.util.concurrent.DefaultEventExecutor;\nimport io.netty.util.concurrent.Future;\nimport io.netty.util.concurrent.GenericFutureListener;\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.SocketAddress;\nimport java.security.KeyManagementException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.SSLEngine;\nimport javax.net.ssl.SSLPeerUnverifiedException;\nimport javax.net.ssl.SSLSession;\nimport javax.net.ssl.X509KeyManager;\nimport javax.net.ssl.X509TrustManager;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.common.ClientX509Util;\nimport org.apache.zookeeper.common.NettyUtils;\nimport org.apache.zookeeper.common.SSLContextAndOptions;\nimport org.apache.zookeeper.common.X509Exception;\nimport org.apache.zookeeper.common.X509Exception.SSLContextException;\nimport org.apache.zookeeper.server.NettyServerCnxn.HandshakeState;\nimport org.apache.zookeeper.server.auth.ProviderRegistry;\nimport org.apache.zookeeper.server.auth.X509AuthenticationProvider;\nimport org.apache.zookeeper.server.quorum.QuorumPeerConfig;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class NettyServerCnxnFactory extends ServerCnxnFactory {\n\n    private static final Logger LOG = LoggerFactory.getLogger(NettyServerCnxnFactory.class);\n\n    /**\n     * Allow client-server sockets to accept both SSL and plaintext connections\n     */\n    public static final String PORT_UNIFICATION_KEY = \"zookeeper.client.portUnification\";\n    private final boolean shouldUsePortUnification;\n\n    /**\n     * The first byte in TLS protocol is the content type of the subsequent record.\n     * Handshakes use value 22 (0x16) so the first byte offered on any TCP connection\n     * attempting to establish a TLS connection will be this value.\n     * https://tools.ietf.org/html/rfc8446#page-79\n     */\n    private static final byte TLS_HANDSHAKE_RECORD_TYPE = 0x16;\n\n    private final AtomicInteger outstandingHandshake = new AtomicInteger();\n    public static final String OUTSTANDING_HANDSHAKE_LIMIT = \"zookeeper.netty.server.outstandingHandshake.limit\";\n    private int outstandingHandshakeLimit;\n    private boolean handshakeThrottlingEnabled;\n\n    public void setOutstandingHandshakeLimit(int limit) {\n        outstandingHandshakeLimit = limit;\n        handshakeThrottlingEnabled = (secure || shouldUsePortUnification) && outstandingHandshakeLimit > 0;\n        LOG.info(\"handshakeThrottlingEnabled = {}, {} = {}\",\n                handshakeThrottlingEnabled, OUTSTANDING_HANDSHAKE_LIMIT, outstandingHandshakeLimit);\n    }\n\n    private final ServerBootstrap bootstrap;\n    private Channel parentChannel;\n    private final ChannelGroup allChannels = new DefaultChannelGroup(\"zkServerCnxns\", new DefaultEventExecutor());\n    private final Map<InetAddress, AtomicInteger> ipMap = new ConcurrentHashMap<>();\n    private InetSocketAddress localAddress;\n    private int maxClientCnxns = 60;\n    int listenBacklog = -1;\n    private final ClientX509Util x509Util;\n\n    public static final String NETTY_ADVANCED_FLOW_CONTROL = \"zookeeper.netty.advancedFlowControl.enabled\";\n    private boolean advancedFlowControlEnabled = false;\n\n    private static final AttributeKey<NettyServerCnxn> CONNECTION_ATTRIBUTE = AttributeKey.valueOf(\"NettyServerCnxn\");\n\n    private static final AtomicReference<ByteBufAllocator> TEST_ALLOCATOR = new AtomicReference<>(null);\n\n    /**\n     * A handler that detects whether the client would like to use\n     * TLS or not and responds in kind. The first bytes are examined\n     * for the static TLS headers to make the determination and\n     * placed back in the stream with the correct ChannelHandler\n     * instantiated.\n     */\n    class DualModeSslHandler extends OptionalSslHandler {\n\n        DualModeSslHandler(SslContext sslContext) {\n            super(sslContext);\n        }\n\n        @Override\n        protected void decode(ChannelHandlerContext context, ByteBuf in, List<Object> out) throws Exception {\n            if (in.readableBytes() >= 5) {\n                super.decode(context, in, out);\n            } else if (in.readableBytes() > 0) {\n                // It requires 5 bytes to detect a proper ssl connection. In the\n                // case that the server receives fewer, check if we can fail to plaintext.\n                // This will occur when for any four letter work commands.\n                if (TLS_HANDSHAKE_RECORD_TYPE != in.getByte(0)) {\n                    LOG.debug(\"first byte {} does not match TLS handshake, failing to plaintext\", in.getByte(0));\n                    handleNonSsl(context);\n                }\n            }\n        }\n\n        /**\n         * pulled directly from OptionalSslHandler to allow for access\n         * @param context\n         */\n        private void handleNonSsl(ChannelHandlerContext context) {\n            ChannelHandler handler = this.newNonSslHandler(context);\n            if (handler != null) {\n                context.pipeline().replace(this, this.newNonSslHandlerName(), handler);\n            } else {\n                context.pipeline().remove(this);\n            }\n        }\n\n        @Override\n        protected SslHandler newSslHandler(ChannelHandlerContext context, SslContext sslContext) {\n            NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n            LOG.debug(\"creating ssl handler for session {}\", cnxn.getSessionId());\n            SslHandler handler = super.newSslHandler(context, sslContext);\n            Future<Channel> handshakeFuture = handler.handshakeFuture();\n            handshakeFuture.addListener(new CertificateVerifier(handler, cnxn));\n            return handler;\n        }\n\n        @Override\n        protected ChannelHandler newNonSslHandler(ChannelHandlerContext context) {\n            NettyServerCnxn cnxn = Objects.requireNonNull(context.channel().attr(CONNECTION_ATTRIBUTE).get());\n            LOG.debug(\"creating plaintext handler for session {}\", cnxn.getSessionId());\n            // Mark handshake finished if it's a insecure cnxn\n            updateHandshakeCountIfStarted(cnxn);\n            allChannels.add(context.channel());\n            addCnxn(cnxn);\n            return super.newNonSslHandler(context);\n        }\n\n    }\n\n    private void updateHandshakeCountIfStarted(NettyServerCnxn cnxn) {\n        if (cnxn != null && cnxn.getHandshakeState() == HandshakeState.STARTED) {\n            cnxn.setHandshakeState(HandshakeState.FINISHED);\n            outstandingHandshake.addAndGet(-1);\n        }\n    }\n\n    /**\n     * This is an inner class since we need to extend ChannelDuplexHandler, but\n     * NettyServerCnxnFactory already extends ServerCnxnFactory. By making it inner\n     * this class gets access to the member variables and methods.\n     */\n    @Sharable\n    class CnxnChannelHandler extends ChannelDuplexHandler {\n\n        @Override\n        public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Channel active {}\", ctx.channel());\n            }\n\n            final Channel channel = ctx.channel();\n            if (limitTotalNumberOfCnxns()) {\n                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n                channel.close();\n                return;\n            }\n            InetAddress addr = ((InetSocketAddress) channel.remoteAddress()).getAddress();\n            if (maxClientCnxns > 0 && getClientCnxnCount(addr) >= maxClientCnxns) {\n                ServerMetrics.getMetrics().CONNECTION_REJECTED.add(1);\n                LOG.warn(\"Too many connections from {} - max is {}\", addr, maxClientCnxns);\n                channel.close();\n                return;\n            }\n\n            NettyServerCnxn cnxn = new NettyServerCnxn(channel, zkServer, NettyServerCnxnFactory.this);\n            ctx.channel().attr(CONNECTION_ATTRIBUTE).set(cnxn);\n\n            // Check the zkServer assigned to the cnxn is still running,\n            // close it before starting the heavy TLS handshake\n            if (!cnxn.isZKServerRunning()) {\n                LOG.warn(\"Zookeeper server is not running, close the connection before starting the TLS handshake\");\n                ServerMetrics.getMetrics().CNXN_CLOSED_WITHOUT_ZK_SERVER_RUNNING.add(1);\n                channel.close();\n                return;\n            }\n\n            if (handshakeThrottlingEnabled) {\n                // Favor to check and throttling even in dual mode which\n                // accepts both secure and insecure connections, since\n                // it's more efficient than throttling when we know it's\n                // a secure connection in DualModeSslHandler.\n                //\n                // From benchmark, this reduced around 15% reconnect time.\n                int outstandingHandshakesNum = outstandingHandshake.addAndGet(1);\n                if (outstandingHandshakesNum > outstandingHandshakeLimit) {\n                    outstandingHandshake.addAndGet(-1);\n                    channel.close();\n                    ServerMetrics.getMetrics().TLS_HANDSHAKE_EXCEEDED.add(1);\n                } else {\n                    cnxn.setHandshakeState(HandshakeState.STARTED);\n                }\n            }\n\n            if (secure) {\n                SslHandler sslHandler = ctx.pipeline().get(SslHandler.class);\n                Future<Channel> handshakeFuture = sslHandler.handshakeFuture();\n                handshakeFuture.addListener(new CertificateVerifier(sslHandler, cnxn));\n            } else if (!shouldUsePortUnification) {\n                allChannels.add(ctx.channel());\n                addCnxn(cnxn);\n            }\n            if (ctx.channel().pipeline().get(SslHandler.class) == null) {\n                SocketAddress remoteAddress = cnxn.getChannel().remoteAddress();\n                if (remoteAddress != null\n                        && !((InetSocketAddress) remoteAddress).getAddress().isLoopbackAddress()) {\n                    LOG.trace(\"NettyChannelHandler channelActive: remote={} local={}\", remoteAddress, cnxn.getChannel().localAddress());\n                    zkServer.serverStats().incrementNonMTLSRemoteConnCount();\n                } else {\n                    zkServer.serverStats().incrementNonMTLSLocalConnCount();\n                }\n            }\n        }\n\n        @Override\n        public void channelInactive(ChannelHandlerContext ctx) throws Exception {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"Channel inactive {}\", ctx.channel());\n            }\n\n            allChannels.remove(ctx.channel());\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);\n            if (cnxn != null) {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"Channel inactive caused close {}\", cnxn);\n                }\n                updateHandshakeCountIfStarted(cnxn);\n                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_DISCONNECTED);\n            }\n        }\n\n        @Override\n        public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n            LOG.warn(\"Exception caught\", cause);\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).getAndSet(null);\n            if (cnxn != null) {\n                LOG.debug(\"Closing {}\", cnxn);\n                updateHandshakeCountIfStarted(cnxn);\n                cnxn.close(ServerCnxn.DisconnectReason.CHANNEL_CLOSED_EXCEPTION);\n            }\n        }\n\n        @Override\n        public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n            try {\n                if (evt == NettyServerCnxn.ReadEvent.ENABLE) {\n                    LOG.debug(\"Received ReadEvent.ENABLE\");\n                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n                    // TODO: Not sure if cnxn can be null here. It becomes null if channelInactive()\n                    // or exceptionCaught() trigger, but it's unclear to me if userEventTriggered() can run\n                    // after either of those. Check for null just to be safe ...\n                    if (cnxn != null) {\n                        if (cnxn.getQueuedReadableBytes() > 0) {\n                            cnxn.processQueuedBuffer();\n                            if (advancedFlowControlEnabled && cnxn.getQueuedReadableBytes() == 0) {\n                                // trigger a read if we have consumed all\n                                // backlog\n                                ctx.read();\n                                LOG.debug(\"Issued a read after queuedBuffer drained\");\n                            }\n                        }\n                    }\n                    if (!advancedFlowControlEnabled) {\n                        ctx.channel().config().setAutoRead(true);\n                    }\n                } else if (evt == NettyServerCnxn.ReadEvent.DISABLE) {\n                    LOG.debug(\"Received ReadEvent.DISABLE\");\n                    ctx.channel().config().setAutoRead(false);\n                }\n            } finally {\n                ReferenceCountUtil.release(evt);\n            }\n        }\n\n        @Override\n        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n            try {\n                if (LOG.isTraceEnabled()) {\n                    LOG.trace(\"message received called {}\", msg);\n                }\n                try {\n                    LOG.debug(\"New message {} from {}\", msg, ctx.channel());\n                    NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n                    if (cnxn == null) {\n                        LOG.error(\"channelRead() on a closed or closing NettyServerCnxn\");\n                    } else {\n                        cnxn.processMessage((ByteBuf) msg);\n                    }\n                } catch (Exception ex) {\n                    LOG.error(\"Unexpected exception in receive\", ex);\n                    throw ex;\n                }\n            } finally {\n                ReferenceCountUtil.release(msg);\n            }\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            if (advancedFlowControlEnabled) {\n                NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n                if (cnxn != null && cnxn.getQueuedReadableBytes() == 0 && cnxn.readIssuedAfterReadComplete == 0) {\n                    ctx.read();\n                    LOG.debug(\"Issued a read since we do not have anything to consume after channelReadComplete\");\n                }\n            }\n\n            ctx.fireChannelReadComplete();\n        }\n\n        // Use a single listener instance to reduce GC\n        // Note: this listener is only added when LOG.isTraceEnabled() is true,\n        // so it should not do any work other than trace logging.\n        private final GenericFutureListener<Future<Void>> onWriteCompletedTracer = (f) -> {\n            if (LOG.isTraceEnabled()) {\n                LOG.trace(\"write success: {}\", f.isSuccess());\n            }\n        };\n\n        @Override\n        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n            if (LOG.isTraceEnabled()) {\n                promise.addListener(onWriteCompletedTracer);\n            }\n            super.write(ctx, msg, promise);\n        }\n\n    }\n\n    final class CertificateVerifier implements GenericFutureListener<Future<Channel>> {\n\n        private final SslHandler sslHandler;\n        private final NettyServerCnxn cnxn;\n\n        CertificateVerifier(SslHandler sslHandler, NettyServerCnxn cnxn) {\n            this.sslHandler = sslHandler;\n            this.cnxn = cnxn;\n        }\n\n        /**\n         * Only allow the connection to stay open if certificate passes auth\n         */\n        public void operationComplete(Future<Channel> future) {\n            updateHandshakeCountIfStarted(cnxn);\n\n            if (future.isSuccess()) {\n                LOG.debug(\"Successful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n                SSLEngine eng = sslHandler.engine();\n                // Don't try to verify certificate if we didn't ask client to present one\n                if (eng.getNeedClientAuth() || eng.getWantClientAuth()) {\n                    SSLSession session = eng.getSession();\n                    try {\n                        cnxn.setClientCertificateChain(session.getPeerCertificates());\n                    } catch (SSLPeerUnverifiedException e) {\n                        if (eng.getNeedClientAuth()) {\n                            // Certificate was requested but not present\n                            LOG.error(\"Error getting peer certificates\", e);\n                            cnxn.close();\n                            return;\n                        } else {\n                            // Certificate was requested but was optional\n                            // TODO: what auth info should we set on the connection?\n                            final Channel futureChannel = future.getNow();\n                            allChannels.add(Objects.requireNonNull(futureChannel));\n                            addCnxn(cnxn);\n                            return;\n                        }\n                    } catch (Exception e) {\n                        LOG.error(\"Error getting peer certificates\", e);\n                        cnxn.close();\n                        return;\n                    }\n\n                    String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\");\n\n                    X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(authProviderProp);\n\n                    if (authProvider == null) {\n                        LOG.error(\"X509 Auth provider not found: {}\", authProviderProp);\n                        cnxn.close(ServerCnxn.DisconnectReason.AUTH_PROVIDER_NOT_FOUND);\n                        return;\n                    }\n\n                    KeeperException.Code code = authProvider.handleAuthentication(cnxn, null);\n                    if (KeeperException.Code.OK != code) {\n                        zkServer.serverStats().incrementAuthFailedCount();\n                        LOG.error(\"Authentication failed for session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n                        cnxn.close(ServerCnxn.DisconnectReason.SASL_AUTH_FAILURE);\n                        return;\n                    }\n                }\n\n                final Channel futureChannel = future.getNow();\n                allChannels.add(Objects.requireNonNull(futureChannel));\n                addCnxn(cnxn);\n            } else {\n                zkServer.serverStats().incrementAuthFailedCount();\n                LOG.error(\"Unsuccessful handshake with session 0x{}\", Long.toHexString(cnxn.getSessionId()));\n                ServerMetrics.getMetrics().UNSUCCESSFUL_HANDSHAKE.add(1);\n                cnxn.close(ServerCnxn.DisconnectReason.FAILED_HANDSHAKE);\n            }\n        }\n\n    }\n\n    @Sharable\n    static class ReadIssuedTrackingHandler extends ChannelDuplexHandler {\n\n        @Override\n        public void read(ChannelHandlerContext ctx) throws Exception {\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n            if (cnxn != null) {\n                cnxn.readIssuedAfterReadComplete++;\n            }\n\n            ctx.read();\n        }\n\n        @Override\n        public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n            NettyServerCnxn cnxn = ctx.channel().attr(CONNECTION_ATTRIBUTE).get();\n            if (cnxn != null) {\n                cnxn.readIssuedAfterReadComplete = 0;\n            }\n\n            ctx.fireChannelReadComplete();\n        }\n\n    }\n\n    CnxnChannelHandler channelHandler = new CnxnChannelHandler();\n    ReadIssuedTrackingHandler readIssuedTrackingHandler = new ReadIssuedTrackingHandler();\n\n    private ServerBootstrap configureBootstrapAllocator(ServerBootstrap bootstrap) {\n        ByteBufAllocator testAllocator = TEST_ALLOCATOR.get();\n        if (testAllocator != null) {\n            return bootstrap.option(ChannelOption.ALLOCATOR, testAllocator)\n                            .childOption(ChannelOption.ALLOCATOR, testAllocator);\n        } else {\n            return bootstrap;\n        }\n    }\n\n    NettyServerCnxnFactory() {\n        x509Util = new ClientX509Util();\n\n        boolean usePortUnification = Boolean.getBoolean(PORT_UNIFICATION_KEY);\n        LOG.info(\"{}={}\", PORT_UNIFICATION_KEY, usePortUnification);\n        if (usePortUnification) {\n            try {\n                QuorumPeerConfig.configureSSLAuth();\n            } catch (QuorumPeerConfig.ConfigException e) {\n                LOG.error(\"unable to set up SslAuthProvider, turning off client port unification\", e);\n                usePortUnification = false;\n            }\n        }\n        this.shouldUsePortUnification = usePortUnification;\n\n        this.advancedFlowControlEnabled = Boolean.getBoolean(NETTY_ADVANCED_FLOW_CONTROL);\n        LOG.info(\"{} = {}\", NETTY_ADVANCED_FLOW_CONTROL, this.advancedFlowControlEnabled);\n\n        setOutstandingHandshakeLimit(Integer.getInteger(OUTSTANDING_HANDSHAKE_LIMIT, -1));\n\n        EventLoopGroup bossGroup = NettyUtils.newNioOrEpollEventLoopGroup(NettyUtils.getClientReachableLocalInetAddressCount());\n        EventLoopGroup workerGroup = NettyUtils.newNioOrEpollEventLoopGroup();\n        ServerBootstrap bootstrap = new ServerBootstrap().group(bossGroup, workerGroup)\n                                                         .channel(NettyUtils.nioOrEpollServerSocketChannel())\n                                                         // parent channel options\n                                                         .option(ChannelOption.SO_REUSEADDR, true)\n                                                         // child channels options\n                                                         .childOption(ChannelOption.TCP_NODELAY, true)\n                                                         .childOption(ChannelOption.SO_LINGER, -1)\n                                                         .childHandler(new ChannelInitializer<SocketChannel>() {\n                                                             @Override\n                                                             protected void initChannel(SocketChannel ch) throws Exception {\n                                                                 ChannelPipeline pipeline = ch.pipeline();\n                                                                 if (advancedFlowControlEnabled) {\n                                                                     pipeline.addLast(readIssuedTrackingHandler);\n                                                                 }\n                                                                 if (secure) {\n                                                                     initSSL(pipeline, false);\n                                                                 } else if (shouldUsePortUnification) {\n                                                                     initSSL(pipeline, true);\n                                                                 }\n                                                                 pipeline.addLast(\"servercnxnfactory\", channelHandler);\n                                                             }\n                                                         });\n        this.bootstrap = configureBootstrapAllocator(bootstrap);\n        this.bootstrap.validate();\n    }\n\n    private synchronized void initSSL(ChannelPipeline p, boolean supportPlaintext) throws X509Exception, KeyManagementException, NoSuchAlgorithmException {\n        String authProviderProp = System.getProperty(x509Util.getSslAuthProviderProperty());\n        SslContext nettySslContext;\n        if (authProviderProp == null) {\n            SSLContextAndOptions sslContextAndOptions = x509Util.getDefaultSSLContextAndOptions();\n            nettySslContext = sslContextAndOptions.createNettyJdkSslContext(sslContextAndOptions.getSSLContext(), false);\n        } else {\n            SSLContext sslContext = SSLContext.getInstance(ClientX509Util.DEFAULT_PROTOCOL);\n            X509AuthenticationProvider authProvider = (X509AuthenticationProvider) ProviderRegistry.getProvider(\n                System.getProperty(x509Util.getSslAuthProviderProperty(), \"x509\"));\n\n            if (authProvider == null) {\n                LOG.error(\"Auth provider not found: {}\", authProviderProp);\n                throw new SSLContextException(\"Could not create SSLContext with specified auth provider: \" + authProviderProp);\n            }\n\n            sslContext.init(new X509KeyManager[]{authProvider.getKeyManager()}, new X509TrustManager[]{authProvider.getTrustManager()}, null);\n            nettySslContext = x509Util.getDefaultSSLContextAndOptions().createNettyJdkSslContext(sslContext, false);\n        }\n\n        if (supportPlaintext) {\n            p.addLast(\"ssl\", new DualModeSslHandler(nettySslContext));\n            LOG.debug(\"dual mode SSL handler added for channel: {}\", p.channel());\n        } else {\n            p.addLast(\"ssl\", nettySslContext.newHandler(p.channel().alloc()));\n            LOG.debug(\"SSL handler added for channel: {}\", p.channel());\n        }\n    }\n\n    @Override\n    public void closeAll(ServerCnxn.DisconnectReason reason) {\n        LOG.debug(\"closeAll()\");\n\n        // clear all the connections on which we are selecting\n        int length = cnxns.size();\n        for (ServerCnxn cnxn : cnxns) {\n            try {\n                // This will remove the cnxn from cnxns\n                cnxn.close(reason);\n            } catch (Exception e) {\n                LOG.warn(\"Ignoring exception closing cnxn sessionid 0x{}\", Long.toHexString(cnxn.getSessionId()), e);\n            }\n        }\n\n        LOG.debug(\"allChannels size: {} cnxns size: {}\", allChannels.size(), length);\n    }\n\n    @Override\n    public void configure(InetSocketAddress addr, int maxClientCnxns, int backlog, boolean secure) throws IOException {\n        configureSaslLogin();\n        initMaxCnxns();\n        localAddress = addr;\n        this.maxClientCnxns = maxClientCnxns;\n        this.secure = secure;\n        this.listenBacklog = backlog;\n    }\n\n    /** {@inheritDoc} */\n    public int getMaxClientCnxnsPerHost() {\n        return maxClientCnxns;\n    }\n\n    /** {@inheritDoc} */\n    public void setMaxClientCnxnsPerHost(int max) {\n        maxClientCnxns = max;\n    }\n\n    /** {@inheritDoc} */\n    public int getSocketListenBacklog() {\n        return listenBacklog;\n    }\n\n    @Override\n    public int getLocalPort() {\n        return localAddress.getPort();\n    }\n\n    private boolean killed; // use synchronized(this) to access\n    @Override\n    public void join() throws InterruptedException {\n        synchronized (this) {\n            while (!killed) {\n                wait();\n            }\n        }\n    }\n\n    @Override\n    public void shutdown() {\n        synchronized (this) {\n            if (killed) {\n                LOG.info(\"already shutdown {}\", localAddress);\n                return;\n            }\n        }\n        LOG.info(\"shutdown called {}\", localAddress);\n\n        x509Util.close();\n\n        if (login != null) {\n            login.shutdown();\n        }\n\n        final EventLoopGroup bossGroup = bootstrap.config().group();\n        final EventLoopGroup workerGroup = bootstrap.config().childGroup();\n        // null if factory never started\n        if (parentChannel != null) {\n            ChannelFuture parentCloseFuture = parentChannel.close();\n            if (bossGroup != null) {\n                parentCloseFuture.addListener(future -> {\n                    bossGroup.shutdownGracefully();\n                });\n            }\n            closeAll(ServerCnxn.DisconnectReason.SERVER_SHUTDOWN);\n            ChannelGroupFuture allChannelsCloseFuture = allChannels.close();\n            if (workerGroup != null) {\n                allChannelsCloseFuture.addListener(future -> {\n                    workerGroup.shutdownGracefully();\n                });\n            }\n        } else {\n            if (bossGroup != null) {\n                bossGroup.shutdownGracefully();\n            }\n            if (workerGroup != null) {\n                workerGroup.shutdownGracefully();\n            }\n        }\n\n        if (zkServer != null) {\n            zkServer.shutdown();\n        }\n        synchronized (this) {\n            killed = true;\n            notifyAll();\n        }\n    }\n\n    @Override\n    public void start() {\n        if (listenBacklog != -1) {\n            bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog);\n        }\n        LOG.info(\"binding to port {}\", localAddress);\n        parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();\n        // Port changes after bind() if the original port was 0, update\n        // localAddress to get the real port.\n        localAddress = (InetSocketAddress) parentChannel.localAddress();\n        LOG.info(\"bound to port {}\", getLocalPort());\n    }\n\n    public void reconfigure(InetSocketAddress addr) {\n        LOG.info(\"binding to port {}, {}\", addr, localAddress);\n        if (addr != null && localAddress != null) {\n            if (addr.equals(localAddress) || (addr.getAddress().isAnyLocalAddress()\n                    && localAddress.getAddress().isAnyLocalAddress()\n                    && addr.getPort() == localAddress.getPort())) {\n                 LOG.info(\"address is the same, skip rebinding\");\n                 return;\n            }\n        }\n\n        Channel oldChannel = parentChannel;\n        try {\n            parentChannel = bootstrap.bind(addr).syncUninterruptibly().channel();\n            // Port changes after bind() if the original port was 0, update\n            // localAddress to get the real port.\n            localAddress = (InetSocketAddress) parentChannel.localAddress();\n            LOG.info(\"bound to port {}\", getLocalPort());\n        } catch (Exception e) {\n            LOG.error(\"Error while reconfiguring\", e);\n        } finally {\n            oldChannel.close();\n        }\n    }\n\n    @Override\n    public void startup(ZooKeeperServer zks, boolean startServer) throws IOException, InterruptedException {\n        start();\n        setZooKeeperServer(zks);\n        if (startServer) {\n            zks.startdata();\n            zks.startup();\n        }\n    }\n\n    @Override\n    public Iterable<ServerCnxn> getConnections() {\n        return cnxns;\n    }\n\n    @Override\n    public InetSocketAddress getLocalAddress() {\n        return localAddress;\n    }\n\n    private void addCnxn(final NettyServerCnxn cnxn) {\n        cnxns.add(cnxn);\n        InetAddress addr = ((InetSocketAddress) cnxn.getChannel().remoteAddress()).getAddress();\n\n        ipMap.compute(addr, (a, cnxnCount) -> {\n            if (cnxnCount == null) {\n                cnxnCount = new AtomicInteger();\n            }\n            cnxnCount.incrementAndGet();\n            return cnxnCount;\n        });\n    }\n\n    void removeCnxnFromIpMap(NettyServerCnxn cnxn, InetAddress remoteAddress) {\n        ipMap.compute(remoteAddress, (addr, cnxnCount) -> {\n            if (cnxnCount == null) {\n                LOG.error(\"Unexpected remote address {} when removing cnxn {}\", remoteAddress, cnxn);\n                return null;\n            }\n            final int newValue = cnxnCount.decrementAndGet();\n            return newValue == 0 ? null : cnxnCount;\n        });\n    }\n\n    private int getClientCnxnCount(final InetAddress addr) {\n        final AtomicInteger count = ipMap.get(addr);\n        return count == null ? 0 : count.get();\n    }\n\n    @Override\n    public void resetAllConnectionStats() {\n        // No need to synchronize since cnxns is backed by a ConcurrentHashMap\n        for (ServerCnxn c : cnxns) {\n            c.resetStats();\n        }\n    }\n\n    @Override\n    public Iterable<Map<String, Object>> getAllConnectionInfo(boolean brief) {\n        Set<Map<String, Object>> info = new HashSet<Map<String, Object>>();\n        // No need to synchronize since cnxns is backed by a ConcurrentHashMap\n        for (ServerCnxn c : cnxns) {\n            info.add(c.getConnectionInfo(brief));\n        }\n        return info;\n    }\n\n    /**\n     * Sets the test ByteBufAllocator. This allocator will be used by all\n     * future instances of this class.\n     * It is not recommended to use this method outside of testing.\n     * @param allocator the ByteBufAllocator to use for all netty buffer\n     *                  allocations.\n     */\n    static void setTestAllocator(ByteBufAllocator allocator) {\n        TEST_ALLOCATOR.set(allocator);\n    }\n\n    /**\n     * Clears the test ByteBufAllocator. The default allocator will be used\n     * by all future instances of this class.\n     * It is not recommended to use this method outside of testing.\n     */\n    static void clearTestAllocator() {\n        TEST_ALLOCATOR.set(null);\n    }\n\n    // VisibleForTest\n    public void setAdvancedFlowControlEnabled(boolean advancedFlowControlEnabled) {\n        this.advancedFlowControlEnabled = advancedFlowControlEnabled;\n    }\n\n    // VisibleForTest\n    public void setSecure(boolean secure) {\n        this.secure = secure;\n    }\n\n    // VisibleForTest\n    public Channel getParentChannel() {\n        return parentChannel;\n    }\n\n    public int getOutstandingHandshakeNum() {\n        return outstandingHandshake.get();\n    }\n}\n","lineNo":443}
{"Smelly Sample":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.graph.servlets;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.FileNotFoundException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.json.simple.JSONArray;\nimport org.json.simple.JSONObject;\nimport org.json.simple.JSONValue;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Fs extends JsonServlet\n{\n    String handleRequest(JsonRequest request) throws Exception\n    {\n\tString output = \"\";\n\tJSONArray filelist = new JSONArray();\n\n\tFile base = new File(request.getString(\"path\", \"/\"));\n\tif (!base.exists() || !base.isDirectory()) {\n\t    throw new FileNotFoundException(\"Couldn't find [\" + request + \"]\");\n\t}\n\tFile[] files = base.listFiles();\n\tArrays.sort(files, new Comparator<File>() { \n\t\tpublic int compare(File o1, File o2) {\n\t\t    if (o1.isDirectory() != o2.isDirectory()) {\n\t\t\tif (o1.isDirectory()) {\n\t\t\t    return -1;\n\t\t\t} else {\n\t\t\t    return 1;\n\t\t\t}\n\t\t    }\n\t\t    return o1.getName().compareToIgnoreCase(o2.getName());\n\t\t} \n\t    });\n\t\n\tfor (File f : files) {\n\t    JSONObject o = new JSONObject();\n\t    o.put(\"file\", f.getName());\n\t    o.put(\"type\", f.isDirectory() ? \"D\" : \"F\");\n\t    o.put(\"path\", f.getCanonicalPath());\n\t    filelist.add(o);\n\t}\n\treturn JSONValue.toJSONString(filelist);\n    }\n}\n","Method after Refactoring":"/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.zookeeper.graph.servlets;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\nimport com.fasterxml.jackson.core.util.MinimalPrettyPrinter;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.node.ArrayNode;\nimport com.fasterxml.jackson.databind.node.ObjectNode;\n\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Fs extends JsonServlet\n{\n    String handleRequest(JsonRequest request) throws Exception {\n\t\tFile base = new File(request.getString(\"path\", \"/\"));\n\t\tif (!base.exists() || !base.isDirectory()) {\n\t\t\tthrow new FileNotFoundException(\"Couldn't find [\" + request + \"]\");\n\t\t}\n\t\tFile[] files = base.listFiles();\n\t\tArrays.sort(files, new Comparator<File>() {\n\t\t\tpublic int compare(File o1, File o2) {\n\t\t\t\tif (o1.isDirectory() != o2.isDirectory()) {\n\t\t\t\tif (o1.isDirectory()) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn o1.getName().compareToIgnoreCase(o2.getName());\n\t\t\t}\n\t\t\t});\n\n\t\tString jsonString = generateJSON(files);\n\t\treturn jsonString;\n    }\n\n    protected static String generateJSON(File[] files) throws IOException {\n\t\tObjectMapper mapper = new ObjectMapper();\n\t\tArrayNode fileList = mapper.createArrayNode();\n\n\t\tfor (File f : files) {\n\t\t\tJsonNode node = mapper.createObjectNode().objectNode();\n\t\t\t((ObjectNode) node).put(\"file\", f.getName());\n\t\t\t((ObjectNode) node).put(\"type\", f.isDirectory() ? \"D\" : \"F\");\n\t\t\t((ObjectNode) node).put(\"path\", f.getCanonicalPath());\n\t\t\tfileList.add(node);\n\t\t}\n\n\t\tString jsonString = mapper.writer(new MinimalPrettyPrinter()).writeValueAsString(fileList);\n\t\treturn jsonString;\n\t}\n}\n","lineNo":54}
