{"Smelly Sample":"/*\n * \n * Copyright 2009-2022 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.UUID;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\n\nimport androidx.appcompat.widget.Toolbar;\nimport androidx.core.app.NotificationCompat;\nimport android.text.SpannableString;\nimport android.text.method.LinkMovementMethod;\nimport android.text.method.PasswordTransformationMethod;\nimport android.text.util.Linkify;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.exception.SamsungClipboardException;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.NotificationUtil;\nimport com.keepassdroid.utils.Types;\nimport com.keepassdroid.utils.Util;\n\npublic class EntryActivity extends LockCloseHideActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_REFRESH_POS = \"refresh_pos\";\n\n\tpublic static final int NOTIFY_USERNAME = 1;\n\tpublic static final int NOTIFY_PASSWORD = 2;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw, int pos) {\n\t\tIntent i;\n\t\t\n\t\tif ( pw instanceof PwEntryV4 ) {\n\t\t\ti = new Intent(act, EntryActivityV4.class);\n\t\t} else {\n\t\t\ti = new Intent(act, EntryActivity.class);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_ENTRY, Types.UUIDtoBytes(pw.getUUID()));\n\t\ti.putExtra(KEY_REFRESH_POS, pos);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\tprotected PwEntry mEntry;\n\tprivate Timer mTimer = new Timer();\n\tprivate boolean mShowPassword;\n\tprivate int mPos;\n\tprivate NotificationManager mNM;\n\tprivate BroadcastReceiver mIntentReceiver;\n\tprotected boolean readOnly = false;\n\t\n\tprivate DateFormat dateFormat;\n\tprivate DateFormat timeFormat;\n\t\n\tprotected void setEntryView() {\n\t\tsetContentView(R.layout.entry_view);\n\t}\n\t\n\tprotected void setupEditButtons() {\n\t\tButton edit = (Button) findViewById(R.id.entry_edit);\n\t\tedit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity.Launch(EntryActivity.this, mEntry);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tif (readOnly) {\n\t\t\tedit.setVisibility(View.GONE);\n\t\t\t\n\t\t\tView divider = findViewById(R.id.entry_divider2);\n\t\t\tdivider.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tmShowPassword = ! prefs.getBoolean(getString(R.string.maskpass_key), getResources().getBoolean(R.bool.maskpass_default));\n\t\t\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetEntryView();\n\t\tToolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\t\tsetSupportActionBar(toolbar);\n\n\t\tContext appCtx = getApplicationContext();\n\t\tdateFormat = android.text.format.DateFormat.getDateFormat(appCtx);\n\t\ttimeFormat = android.text.format.DateFormat.getTimeFormat(appCtx);\n\n\t\tDatabase db = App.getDB();\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( ! db.Loaded() ) {\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t\treadOnly = db.readOnly;\n\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\n\t\tIntent i = getIntent();\n\t\tUUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));\n\t\tmPos = i.getIntExtra(KEY_REFRESH_POS, -1);\n\t\tassert(uuid != null);\n\t\t\n\t\tmEntry = db.pm.entries.get(uuid);\n\t\tif (mEntry == null) {\n\t\t\tToast.makeText(this, R.string.entry_not_found, Toast.LENGTH_LONG).show();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Refresh Menu contents in case onCreateMenuOptions was called before mEntry was set\n        this.invalidateOptionsMenu();\n\n\t\t// Update last access time.\n\t\tmEntry.touch(false, false);\n\t\t\n\t\tfillData(false);\n\n\t\tsetupEditButtons();\n\t\t\n\t\t// Notification Manager\n        NotificationUtil.createChannels(getApplicationContext());\n\t\tmNM = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\t\n\t\tif ( mEntry.getPassword().length() > 0 ) {\n\t\t\t// only show notification if password is available\n\t\t\tNotification password = getNotification(Intents.COPY_PASSWORD, R.string.copy_password);\n\t\t\tmNM.notify(NOTIFY_PASSWORD, password);\n\t\t}\n\t\t\n\t\tif ( mEntry.getUsername().length() > 0 ) {\n\t\t\t// only show notification if username is available\n\t\t\tNotification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);\n\t\t\tmNM.notify(NOTIFY_USERNAME, username);\n\t\t}\n\t\t\t\n\t\tmIntentReceiver = new BroadcastReceiver() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\tString action = intent.getAction();\n\n\t\t\t\tif ( action.equals(Intents.COPY_USERNAME) ) {\n\t\t\t\t\tString username = mEntry.getUsername();\n\t\t\t\t\tif ( username.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_username), username);\n\t\t\t\t\t}\n\t\t\t\t} else if ( action.equals(Intents.COPY_PASSWORD) ) {\n\t\t\t\t\tString password = new String(mEntry.getPassword());\n\t\t\t\t\tif ( password.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_login_pass),\n\t\t\t\t\t\t\t\tnew String(mEntry.getPassword()), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tIntentFilter filter = new IntentFilter();\n\t\tfilter.addAction(Intents.COPY_USERNAME);\n\t\tfilter.addAction(Intents.COPY_PASSWORD);\n\t\tregisterReceiver(mIntentReceiver, filter);\n\t}\n\t\n\t@Override\n\tprotected void onDestroy() {\n\t\t// These members might never get initialized if the app timed out\n\t\tif ( mIntentReceiver != null ) {\n\t\t\tunregisterReceiver(mIntentReceiver);\n\t\t}\n\t\t\n\t\tif ( mNM != null ) {\n\t\t\ttry {\n\t\t\t    mNM.cancelAll();\n\t\t\t} catch (SecurityException e) {\n\t\t\t\t// Some android devices give a SecurityException when trying to cancel notifications without the WAKE_LOCK permission,\n\t\t\t\t// we'll ignore these.\n\t\t\t}\n\t\t}\n\t\t\n\t\tsuper.onDestroy();\n\t}\n\n\tprivate Notification getNotification(String intentText, int descResId) {\n\t\tString desc = getString(descResId);\n\n\t\tIntent intent = new Intent(intentText);\n\t\tPendingIntent pending = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n\n\t\tNotificationCompat.Builder builder = new NotificationCompat.Builder(this,\n\t\t\t\tNotificationUtil.COPY_CHANNEL_ID);\n\t\tNotification notify = builder.setContentIntent(pending).setContentText(desc).setContentTitle(getString(R.string.app_name))\n\t\t\t\t.setSmallIcon(R.drawable.notify).setTicker(desc).setWhen(System.currentTimeMillis()).build();\n\n\t\treturn notify;\n\t}\n\t\n\tprivate String getDateTime(Date dt) {\n\t\treturn dateFormat.format(dt) + \" \" + timeFormat.format(dt);\n\t\t\n\t}\n\t\n\tprotected void fillData(boolean trimList) {\n\t\tImageView iv = (ImageView) findViewById(R.id.entry_icon);\n\t\tDatabase db = App.getDB();\n\t\tdb.drawFactory.assignDrawableTo(iv, getResources(), mEntry.getIcon());\n\t\t\n\t\tPwDatabase pm = db.pm;\n\n\t\tpopulateText(R.id.entry_title, mEntry.getTitle(true, pm));\n\t\tpopulateText(R.id.entry_user_name, mEntry.getUsername(true, pm));\n\t\t\n\t\tpopulateText(R.id.entry_url, mEntry.getUrl(true, pm));\n\t\tpopulateText(R.id.entry_password, mEntry.getPassword(true, pm));\n\t\tsetPasswordStyle();\n\t\t\n\t\tpopulateText(R.id.entry_created, getDateTime(mEntry.getCreationTime()));\n\t\tpopulateText(R.id.entry_modified, getDateTime(mEntry.getLastModificationTime()));\n\t\tpopulateText(R.id.entry_accessed, getDateTime(mEntry.getLastAccessTime()));\n\t\t\n\t\tDate expires = mEntry.getExpiryTime();\n\t\tif ( mEntry.expires() ) {\n\t\t\tpopulateText(R.id.entry_expires, getDateTime(expires));\n\t\t} else {\n\t\t\tpopulateText(R.id.entry_expires, R.string.never);\n\t\t}\n\t\tpopulateText(R.id.entry_comment, mEntry.getNotes(true, pm));\n\n\t}\n\t\n\tprivate void populateText(int viewId, int resId) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(resId);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\tfillData(true);\n\t\t\tif ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\t\tIntent ret = new Intent();\n\t\t\t\tret.putExtra(KEY_REFRESH_POS, mPos);\n\t\t\t\tsetResult(KeePass.EXIT_REFRESH, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.entry, menu);\n\t\t\n\t\tMenuItem togglePassword = menu.findItem(R.id.menu_toggle_pass);\n\t\tif ( mShowPassword ) {\n\t\t\ttogglePassword.setTitle(R.string.menu_hide_password);\n\t\t} else {\n\t\t\ttogglePassword.setTitle(R.string.menu_showpass);\n\t\t}\n\t\t\n\t\tMenuItem gotoUrl = menu.findItem(R.id.menu_goto_url);\n\t\tMenuItem copyUser = menu.findItem(R.id.menu_copy_user);\n\t\tMenuItem copyPass = menu.findItem(R.id.menu_copy_pass);\n\t\t\n\t\t// In API >= 11 onCreateOptionsMenu may be called before onCreate completes\n\t\t// so mEntry may not be set\n\t\tif (mEntry == null) {\n\t\t\tgotoUrl.setVisible(false);\n\t\t\tcopyUser.setVisible(false);\n\t\t\tcopyPass.setVisible(false);\n\t\t}\n\t\telse {\n\t\t\tString url = mEntry.getUrl();\n\t\t\tif (EmptyUtils.isNullOrEmpty(url)) {\n\t\t\t\t// disable button if url is not available\n\t\t\t\tgotoUrl.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getUsername().length() == 0 ) {\n\t\t\t\t// disable button if username is not available\n\t\t\t\tcopyUser.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getPassword().length() == 0 ) {\n\t\t\t\t// disable button if password is not available\n\t\t\t\tcopyPass.setVisible(false);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t} else {\n\t\t\tpassword.setTransformationMethod(PasswordTransformationMethod.getInstance());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase R.id.menu_donate:\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, R.string.donate_url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\tcase R.id.menu_toggle_pass:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_showpass);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_goto_url:\n\t\t\tString url;\n\t\t\turl = mEntry.getUrl();\n\t\t\t\n\t\t\t// Default http:// if no protocol specified\n\t\t\tif ( ! url.contains(\"://\") ) {\n\t\t\t\turl = \"http://\" + url;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.no_url_handler, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_user:\n\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_username), mEntry.getUsername(true, App.getDB().pm));\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_pass:\n\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_login_pass),\n\t\t\t\t\tnew String(mEntry.getPassword(true, App.getDB().pm)), true);\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_lock:\n\t\t\tApp.setShutdown();\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate void timeoutCopyToClipboard(String label, String text) {\n\t\ttimeoutCopyToClipboard(label, text, false);\n\t}\n\n\tprivate void timeoutCopyToClipboard(String label, String text, boolean sensitive) {\n\t\ttry {\n\t\t\tUtil.copyToClipboard(this, label, text, sensitive);\n\t\t} catch (SamsungClipboardException e) {\n\t\t\tshowSamsungDialog();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tString sClipClear = prefs.getString(getString(R.string.clipboard_timeout_key), getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong clipClearTime = Long.parseLong(sClipClear);\n\t\t\n\t\tif ( clipClearTime > 0 ) {\n\t\t\tmTimer.schedule(new ClearClipboardTask(this, text), clipClearTime);\n\t\t}\n\t}\n\t\n\n\t// Setup to allow the toast to happen in the foreground\n\tfinal Handler uiThreadCallback = new Handler();\n\n\t// Task which clears the clipboard, and sends a toast to the foreground.\n\tprivate class ClearClipboardTask extends TimerTask {\n\t\t\n\t\tprivate final String mClearText;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tClearClipboardTask(Context ctx, String clearText) {\n\t\t\tmClearText = clearText;\n\t\t\tmCtx = ctx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tString currentClip = Util.getClipboard(mCtx);\n\t\t\t\n\t\t\tif ( currentClip.equals(mClearText) ) {\n\t\t\t\ttry {\n\t\t\t\t\tUtil.copyToClipboard(mCtx, \"\", \"\");\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));\n\t\t\t\t} catch (SamsungClipboardException e) {\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.clipboard_error_clear));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void showSamsungDialog() {\n\t\tString text = getString(R.string.clipboard_error).concat(System.getProperty(\"line.separator\")).concat(getString(R.string.clipboard_error_url));\n\t\tSpannableString s = new SpannableString(text);\n\t\tTextView tv = new TextView(this);\n\t\ttv.setText(s);\n\t\ttv.setAutoLinkMask(RESULT_OK);\n\t\ttv.setMovementMethod(LinkMovementMethod.getInstance());\n\t\tLinkify.addLinks(s, Linkify.WEB_URLS);\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.clipboard_error_title)\n\t\t\t.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.setView(tv)\n\t\t\t.show();\n\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * \n * Copyright 2009-2022 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.UUID;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\n\nimport androidx.appcompat.widget.Toolbar;\nimport androidx.core.app.NotificationCompat;\nimport android.text.SpannableString;\nimport android.text.method.LinkMovementMethod;\nimport android.text.method.PasswordTransformationMethod;\nimport android.text.util.Linkify;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.exception.SamsungClipboardException;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.NotificationUtil;\nimport com.keepassdroid.utils.Types;\nimport com.keepassdroid.utils.Util;\n\npublic class EntryActivity extends LockCloseHideActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_REFRESH_POS = \"refresh_pos\";\n\n\tpublic static final int NOTIFY_USERNAME = 1;\n\tpublic static final int NOTIFY_PASSWORD = 2;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw, int pos) {\n\t\tIntent i;\n\t\t\n\t\tif ( pw instanceof PwEntryV4 ) {\n\t\t\ti = new Intent(act, EntryActivityV4.class);\n\t\t} else {\n\t\t\ti = new Intent(act, EntryActivity.class);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_ENTRY, Types.UUIDtoBytes(pw.getUUID()));\n\t\ti.putExtra(KEY_REFRESH_POS, pos);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\tprotected PwEntry mEntry;\n\tprivate Timer mTimer = new Timer();\n\tprivate boolean mShowPassword;\n\tprivate int mPos;\n\tprivate NotificationManager mNM;\n\tprivate BroadcastReceiver mIntentReceiver;\n\tprotected boolean readOnly = false;\n\t\n\tprivate DateFormat dateFormat;\n\tprivate DateFormat timeFormat;\n\t\n\tprotected void setEntryView() {\n\t\tsetContentView(R.layout.entry_view);\n\t}\n\t\n\tprotected void setupEditButtons() {\n\t\tButton edit = (Button) findViewById(R.id.entry_edit);\n\t\tedit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity.Launch(EntryActivity.this, mEntry);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tif (readOnly) {\n\t\t\tedit.setVisibility(View.GONE);\n\t\t\t\n\t\t\tView divider = findViewById(R.id.entry_divider2);\n\t\t\tdivider.setVisibility(View.GONE);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tmShowPassword = ! prefs.getBoolean(getString(R.string.maskpass_key), getResources().getBoolean(R.bool.maskpass_default));\n\t\t\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetEntryView();\n\t\tToolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n\t\tsetSupportActionBar(toolbar);\n\n\t\tContext appCtx = getApplicationContext();\n\t\tdateFormat = android.text.format.DateFormat.getDateFormat(appCtx);\n\t\ttimeFormat = android.text.format.DateFormat.getTimeFormat(appCtx);\n\n\t\tDatabase db = App.getDB();\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( ! db.Loaded() ) {\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t\treadOnly = db.readOnly;\n\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\n\t\tIntent i = getIntent();\n\t\tUUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));\n\t\tmPos = i.getIntExtra(KEY_REFRESH_POS, -1);\n\t\tassert(uuid != null);\n\t\t\n\t\tmEntry = db.pm.entries.get(uuid);\n\t\tif (mEntry == null) {\n\t\t\tToast.makeText(this, R.string.entry_not_found, Toast.LENGTH_LONG).show();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Refresh Menu contents in case onCreateMenuOptions was called before mEntry was set\n        this.invalidateOptionsMenu();\n\n\t\t// Update last access time.\n\t\tmEntry.touch(false, false);\n\t\t\n\t\tfillData(false);\n\n\t\tsetupEditButtons();\n\t\t\n\t\t// Notification Manager\n        NotificationUtil.createChannels(getApplicationContext());\n\t\tmNM = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\t\n\t\tif ( mEntry.getPassword().length() > 0 ) {\n\t\t\t// only show notification if password is available\n\t\t\tNotification password = getNotification(Intents.COPY_PASSWORD, R.string.copy_password);\n\t\t\tmNM.notify(NOTIFY_PASSWORD, password);\n\t\t}\n\t\t\n\t\tif ( mEntry.getUsername().length() > 0 ) {\n\t\t\t// only show notification if username is available\n\t\t\tNotification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);\n\t\t\tmNM.notify(NOTIFY_USERNAME, username);\n\t\t}\n\t\t\t\n\t\tmIntentReceiver = new BroadcastReceiver() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\tString action = intent.getAction();\n\n\t\t\t\tif ( action.equals(Intents.COPY_USERNAME) ) {\n\t\t\t\t\tString username = mEntry.getUsername();\n\t\t\t\t\tif ( username.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_username), username);\n\t\t\t\t\t}\n\t\t\t\t} else if ( action.equals(Intents.COPY_PASSWORD) ) {\n\t\t\t\t\tString password = new String(mEntry.getPassword());\n\t\t\t\t\tif ( password.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_login_pass),\n\t\t\t\t\t\t\t\tnew String(mEntry.getPassword()), true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tIntentFilter filter = new IntentFilter();\n\t\tfilter.addAction(Intents.COPY_USERNAME);\n\t\tfilter.addAction(Intents.COPY_PASSWORD);\n\t\tregisterReceiver(mIntentReceiver, filter);\n\t}\n\t\n\t@Override\n\tprotected void onDestroy() {\n\t\t// These members might never get initialized if the app timed out\n\t\tif ( mIntentReceiver != null ) {\n\t\t\tunregisterReceiver(mIntentReceiver);\n\t\t}\n\t\t\n\t\tif ( mNM != null ) {\n\t\t\ttry {\n\t\t\t    mNM.cancelAll();\n\t\t\t} catch (SecurityException e) {\n\t\t\t\t// Some android devices give a SecurityException when trying to cancel notifications without the WAKE_LOCK permission,\n\t\t\t\t// we'll ignore these.\n\t\t\t}\n\t\t}\n\t\t\n\t\tsuper.onDestroy();\n\t}\n\n\tprivate Notification getNotification(String intentText, int descResId) {\n\t\tString desc = getString(descResId);\n\n\t\tIntent intent = new Intent(intentText);\n\t\tint flags = PendingIntent.FLAG_CANCEL_CURRENT;\n\t\tif (Build.VERSION.SDK_INT >= 23) {\n\t\t\tflags |= PendingIntent.FLAG_IMMUTABLE;\n\t\t}\n\t\tPendingIntent pending = PendingIntent.getBroadcast(this, 0, intent, flags);\n\n\t\tNotificationCompat.Builder builder = new NotificationCompat.Builder(this,\n\t\t\t\tNotificationUtil.COPY_CHANNEL_ID);\n\t\tNotification notify = builder.setContentIntent(pending).setContentText(desc).setContentTitle(getString(R.string.app_name))\n\t\t\t\t.setSmallIcon(R.drawable.notify).setTicker(desc).setWhen(System.currentTimeMillis()).build();\n\n\t\treturn notify;\n\t}\n\t\n\tprivate String getDateTime(Date dt) {\n\t\treturn dateFormat.format(dt) + \" \" + timeFormat.format(dt);\n\t\t\n\t}\n\t\n\tprotected void fillData(boolean trimList) {\n\t\tImageView iv = (ImageView) findViewById(R.id.entry_icon);\n\t\tDatabase db = App.getDB();\n\t\tdb.drawFactory.assignDrawableTo(iv, getResources(), mEntry.getIcon());\n\t\t\n\t\tPwDatabase pm = db.pm;\n\n\t\tpopulateText(R.id.entry_title, mEntry.getTitle(true, pm));\n\t\tpopulateText(R.id.entry_user_name, mEntry.getUsername(true, pm));\n\t\t\n\t\tpopulateText(R.id.entry_url, mEntry.getUrl(true, pm));\n\t\tpopulateText(R.id.entry_password, mEntry.getPassword(true, pm));\n\t\tsetPasswordStyle();\n\t\t\n\t\tpopulateText(R.id.entry_created, getDateTime(mEntry.getCreationTime()));\n\t\tpopulateText(R.id.entry_modified, getDateTime(mEntry.getLastModificationTime()));\n\t\tpopulateText(R.id.entry_accessed, getDateTime(mEntry.getLastAccessTime()));\n\t\t\n\t\tDate expires = mEntry.getExpiryTime();\n\t\tif ( mEntry.expires() ) {\n\t\t\tpopulateText(R.id.entry_expires, getDateTime(expires));\n\t\t} else {\n\t\t\tpopulateText(R.id.entry_expires, R.string.never);\n\t\t}\n\t\tpopulateText(R.id.entry_comment, mEntry.getNotes(true, pm));\n\n\t}\n\t\n\tprivate void populateText(int viewId, int resId) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(resId);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\tfillData(true);\n\t\t\tif ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\t\tIntent ret = new Intent();\n\t\t\t\tret.putExtra(KEY_REFRESH_POS, mPos);\n\t\t\t\tsetResult(KeePass.EXIT_REFRESH, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.entry, menu);\n\t\t\n\t\tMenuItem togglePassword = menu.findItem(R.id.menu_toggle_pass);\n\t\tif ( mShowPassword ) {\n\t\t\ttogglePassword.setTitle(R.string.menu_hide_password);\n\t\t} else {\n\t\t\ttogglePassword.setTitle(R.string.menu_showpass);\n\t\t}\n\t\t\n\t\tMenuItem gotoUrl = menu.findItem(R.id.menu_goto_url);\n\t\tMenuItem copyUser = menu.findItem(R.id.menu_copy_user);\n\t\tMenuItem copyPass = menu.findItem(R.id.menu_copy_pass);\n\t\t\n\t\t// In API >= 11 onCreateOptionsMenu may be called before onCreate completes\n\t\t// so mEntry may not be set\n\t\tif (mEntry == null) {\n\t\t\tgotoUrl.setVisible(false);\n\t\t\tcopyUser.setVisible(false);\n\t\t\tcopyPass.setVisible(false);\n\t\t}\n\t\telse {\n\t\t\tString url = mEntry.getUrl();\n\t\t\tif (EmptyUtils.isNullOrEmpty(url)) {\n\t\t\t\t// disable button if url is not available\n\t\t\t\tgotoUrl.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getUsername().length() == 0 ) {\n\t\t\t\t// disable button if username is not available\n\t\t\t\tcopyUser.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getPassword().length() == 0 ) {\n\t\t\t\t// disable button if password is not available\n\t\t\t\tcopyPass.setVisible(false);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t} else {\n\t\t\tpassword.setTransformationMethod(PasswordTransformationMethod.getInstance());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase R.id.menu_donate:\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, R.string.donate_url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\tcase R.id.menu_toggle_pass:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_showpass);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_goto_url:\n\t\t\tString url;\n\t\t\turl = mEntry.getUrl();\n\t\t\t\n\t\t\t// Default http:// if no protocol specified\n\t\t\tif ( ! url.contains(\"://\") ) {\n\t\t\t\turl = \"http://\" + url;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.no_url_handler, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_user:\n\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_username), mEntry.getUsername(true, App.getDB().pm));\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_pass:\n\t\t\ttimeoutCopyToClipboard(getString(R.string.hint_login_pass),\n\t\t\t\t\tnew String(mEntry.getPassword(true, App.getDB().pm)), true);\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_lock:\n\t\t\tApp.setShutdown();\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate void timeoutCopyToClipboard(String label, String text) {\n\t\ttimeoutCopyToClipboard(label, text, false);\n\t}\n\n\tprivate void timeoutCopyToClipboard(String label, String text, boolean sensitive) {\n\t\ttry {\n\t\t\tUtil.copyToClipboard(this, label, text, sensitive);\n\t\t} catch (SamsungClipboardException e) {\n\t\t\tshowSamsungDialog();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tString sClipClear = prefs.getString(getString(R.string.clipboard_timeout_key), getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong clipClearTime = Long.parseLong(sClipClear);\n\t\t\n\t\tif ( clipClearTime > 0 ) {\n\t\t\tmTimer.schedule(new ClearClipboardTask(this, text), clipClearTime);\n\t\t}\n\t}\n\t\n\n\t// Setup to allow the toast to happen in the foreground\n\tfinal Handler uiThreadCallback = new Handler();\n\n\t// Task which clears the clipboard, and sends a toast to the foreground.\n\tprivate class ClearClipboardTask extends TimerTask {\n\t\t\n\t\tprivate final String mClearText;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tClearClipboardTask(Context ctx, String clearText) {\n\t\t\tmClearText = clearText;\n\t\t\tmCtx = ctx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tString currentClip = Util.getClipboard(mCtx);\n\t\t\t\n\t\t\tif ( currentClip.equals(mClearText) ) {\n\t\t\t\ttry {\n\t\t\t\t\tUtil.copyToClipboard(mCtx, \"\", \"\");\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));\n\t\t\t\t} catch (SamsungClipboardException e) {\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.clipboard_error_clear));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void showSamsungDialog() {\n\t\tString text = getString(R.string.clipboard_error).concat(System.getProperty(\"line.separator\")).concat(getString(R.string.clipboard_error_url));\n\t\tSpannableString s = new SpannableString(text);\n\t\tTextView tv = new TextView(this);\n\t\ttv.setText(s);\n\t\ttv.setAutoLinkMask(RESULT_OK);\n\t\ttv.setMovementMethod(LinkMovementMethod.getInstance());\n\t\tLinkify.addLinks(s, Linkify.WEB_URLS);\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.clipboard_error_title)\n\t\t\t.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.setView(tv)\n\t\t\t.show();\n\t\t\n\t}\n}\n","lineNo":241}
{"Smelly Sample":"/*\n * Copyright 2012-2019 Brian Pellin.\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.timers;\n\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.intents.Intents;\n\npublic class Timeout {\n\tprivate static final int REQUEST_ID = 0;\n\tprivate static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;  // 5 minutes\n\tprivate static String TAG = \"KeePass Timeout\";\n\n\tprivate static PendingIntent buildIntent(Context ctx) {\n\t\tIntent intent = new Intent(Intents.TIMEOUT);\n\t\tPendingIntent sender = PendingIntent.getBroadcast(ctx, REQUEST_ID, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n\n\t\treturn sender;\n\t}\n\t\n\tpublic static void start(Context ctx) {\n\n\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n\t\tString sTimeout = prefs.getString(ctx.getString(R.string.app_timeout_key), ctx.getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong timeout;\n\t\ttry {\n\t\t\ttimeout = Long.parseLong(sTimeout);\n\t\t} catch (NumberFormatException e) {\n\t\t\ttimeout = DEFAULT_TIMEOUT;\n\t\t}\n\t\t\n\t\tif ( timeout == -1 ) {\n\t\t\t// No timeout don't start timeout service\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong triggerTime = System.currentTimeMillis() + timeout;\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout start\");\n\t\tam.set(AlarmManager.RTC, triggerTime, buildIntent(ctx));\n\t}\n\t\n\tpublic static void cancel(Context ctx) {\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout cancel\");\n\t\tam.cancel(buildIntent(ctx));\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2012-2019 Brian Pellin.\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.timers;\n\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.os.Build;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.intents.Intents;\n\npublic class Timeout {\n\tprivate static final int REQUEST_ID = 0;\n\tprivate static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;  // 5 minutes\n\tprivate static String TAG = \"KeePass Timeout\";\n\n\tprivate static PendingIntent buildIntent(Context ctx) {\n\t\tIntent intent = new Intent(Intents.TIMEOUT);\n\t\tintent.setPackage(\"com.android.keepass\");\n\t\tint flags = PendingIntent.FLAG_CANCEL_CURRENT;\n\t\tif (Build.VERSION.SDK_INT >= 23) {\n\t\t\tflags |= PendingIntent.FLAG_IMMUTABLE;\n\t\t}\n\t\tPendingIntent sender = PendingIntent.getBroadcast(ctx, REQUEST_ID, intent, flags);\n\n\t\treturn sender;\n\t}\n\t\n\tpublic static void start(Context ctx) {\n\n\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n\t\tString sTimeout = prefs.getString(ctx.getString(R.string.app_timeout_key), ctx.getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong timeout;\n\t\ttry {\n\t\t\ttimeout = Long.parseLong(sTimeout);\n\t\t} catch (NumberFormatException e) {\n\t\t\ttimeout = DEFAULT_TIMEOUT;\n\t\t}\n\t\t\n\t\tif ( timeout == -1 ) {\n\t\t\t// No timeout don't start timeout service\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong triggerTime = System.currentTimeMillis() + timeout;\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout start\");\n\t\tam.set(AlarmManager.RTC, triggerTime, buildIntent(ctx));\n\t}\n\t\n\tpublic static void cancel(Context ctx) {\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout cancel\");\n\t\tam.cancel(buildIntent(ctx));\n\t}\n\n}\n","lineNo":43}
{"Smelly Sample":"/*\n * Copyright 2009-2015 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport com.keepassdroid.database.exception.SamsungClipboardException;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.text.ClipboardManager;\nimport android.widget.TextView;\n\npublic class Util {\n\tpublic static String getClipboard(Context context) {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tCharSequence csText = clipboard.getText();\n\t\tif (csText == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\treturn csText.toString();\n\t}\n\t\n\tpublic static void copyToClipboard(Context context, String text) throws SamsungClipboardException {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\t\n\t\ttry {\n\t\t\tclipboard.setText(text);\n\t\t} catch (NullPointerException e) {\n\t\t\tthrow new SamsungClipboardException(e);\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, String url) throws ActivityNotFoundException {\n\t\tif ( url != null && url.length() > 0 ) {\n\t\t\tUri uri = Uri.parse(url);\n\t\t\tcontext.startActivity(new Intent(Intent.ACTION_VIEW, uri));\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, int resId) throws ActivityNotFoundException {\n\t\tgotoUrl(context, context.getString(resId));\n\t}\n\n\tpublic static String getEditText(Activity act, int resId) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tpublic static void setEditText(Activity act, int resId, String str) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\tprivate static final int MAX_BUF_SIZE = 1024;\n\tpublic static void copyStream(InputStream in, OutputStream out) throws IOException {\n\t\tbyte[] buf = new byte[MAX_BUF_SIZE];\n\t\tint read;\n\t\twhile ((read = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, read);\n\t\t}\n\t}\n\n\tpublic static int copyStream(InputStream in, OutputStream out, int maxBytes) throws IOException {\n\t    if (maxBytes <= 0) return 0;\n\n\t\tint bufSize = Math.min(maxBytes, MAX_BUF_SIZE);\n\t\tbyte[] buf = new byte[bufSize];\n\t\tint origMax = maxBytes;\n\n\t\tint read;\n\t\tdo {\n\t\t\tassert(maxBytes > 0);\n\t\t\tif (maxBytes >= buf.length) {\n\t\t\t\tread = in.read(buf);\n\t\t\t} else {\n\t\t\t\tread = in.read(buf, 0, maxBytes);\n\t\t\t}\n\t\t\tif (read == -1) { break; }\n\n\t\t\tout.write(buf, 0 , read);\n\t\t\tmaxBytes -= read;\n\n\t\t} while (maxBytes > 0);\n\n\t\t// return total amonut read\n\t\treturn origMax - maxBytes;\n\t}\n\n\t\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2022 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport com.keepassdroid.compat.ClipDataCompat;\nimport com.keepassdroid.database.exception.SamsungClipboardException;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.ClipData;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.content.ClipboardManager;\nimport android.widget.TextView;\n\npublic class Util {\n\tpublic static String getClipboard(Context context) {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tCharSequence csText = clipboard.getText();\n\t\tif (csText == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\treturn csText.toString();\n\t}\n\n\tpublic static void copyToClipboard(Context context, String label, String text) throws SamsungClipboardException {\n\t\tcopyToClipboard(context, label, text, false);\n\t}\n\tpublic static void copyToClipboard(Context context, String label, String text, boolean sensitive) throws SamsungClipboardException {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\n\t\tClipData clip = ClipData.newPlainText(label, text);\n\t\tif (sensitive) {\n\t\t\tClipDataCompat.markSensitive(clip);\n\t\t}\n\n\t\ttry {\n\t\t\tclipboard.setPrimaryClip(clip);\n\t\t} catch (NullPointerException e) {\n\t\t\tthrow new SamsungClipboardException(e);\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, String url) throws ActivityNotFoundException {\n\t\tif ( url != null && url.length() > 0 ) {\n\t\t\tUri uri = Uri.parse(url);\n\t\t\tcontext.startActivity(new Intent(Intent.ACTION_VIEW, uri));\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, int resId) throws ActivityNotFoundException {\n\t\tgotoUrl(context, context.getString(resId));\n\t}\n\n\tpublic static String getEditText(Activity act, int resId) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tpublic static void setEditText(Activity act, int resId, String str) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\tprivate static final int MAX_BUF_SIZE = 1024;\n\tpublic static void copyStream(InputStream in, OutputStream out) throws IOException {\n\t\tbyte[] buf = new byte[MAX_BUF_SIZE];\n\t\tint read;\n\t\twhile ((read = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, read);\n\t\t}\n\t}\n\n\tpublic static int copyStream(InputStream in, OutputStream out, int maxBytes) throws IOException {\n\t    if (maxBytes <= 0) return 0;\n\n\t\tint bufSize = Math.min(maxBytes, MAX_BUF_SIZE);\n\t\tbyte[] buf = new byte[bufSize];\n\t\tint origMax = maxBytes;\n\n\t\tint read;\n\t\tdo {\n\t\t\tassert(maxBytes > 0);\n\t\t\tif (maxBytes >= buf.length) {\n\t\t\t\tread = in.read(buf);\n\t\t\t} else {\n\t\t\t\tread = in.read(buf, 0, maxBytes);\n\t\t\t}\n\t\t\tif (read == -1) { break; }\n\n\t\t\tout.write(buf, 0 , read);\n\t\t\tmaxBytes -= read;\n\n\t\t} while (maxBytes > 0);\n\n\t\t// return total amonut read\n\t\treturn origMax - maxBytes;\n\t}\n\n\t\n\t\n}\n","lineNo":55}
{"Smelly Sample":"/*\n * Copyright 2017 Brian Pellin.\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.crypto.keyDerivation;\n\nimport com.keepassdroid.collections.VariantDictionary;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.utils.Types;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.UUID;\n\npublic class KdfParameters extends VariantDictionary {\n\n    public UUID kdfUUID;\n\n    private static final String ParamUUID = \"$UUID\";\n\n    public KdfParameters(UUID uuid) {\n        kdfUUID = uuid;\n        this.setByteArray(ParamUUID, Types.UUIDtoBytes(uuid));\n    }\n\n    public static KdfParameters deserialize(byte[] data) throws IOException {\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        LEDataInputStream lis = new LEDataInputStream(bis);\n\n        VariantDictionary d = VariantDictionary.deserialize(lis);\n        if (d == null) {\n            assert(false);\n            return null;\n        }\n\n        UUID uuid = Types.bytestoUUID(d.getByteArray(ParamUUID));\n        if (uuid == null) {\n            assert(false);\n            return null;\n        }\n\n        KdfParameters kdfP = new KdfParameters(uuid);\n        kdfP.copyTo(d);\n        return kdfP;\n\n    }\n\n    public static byte[] serialize(KdfParameters kdf) throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        LEDataOutputStream los = new LEDataOutputStream(bos);\n\n        KdfParameters.serialize(kdf, los);\n\n        return bos.toByteArray();\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2017 Brian Pellin.\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.crypto.keyDerivation;\n\nimport com.keepassdroid.collections.VariantDictionary;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.utils.Types;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.util.UUID;\n\npublic class KdfParameters extends VariantDictionary {\n\n    public UUID kdfUUID;\n\n    private static final String ParamUUID = \"$UUID\";\n\n    public KdfParameters(UUID uuid) {\n        kdfUUID = uuid;\n        this.setByteArray(ParamUUID, Types.UUIDtoBytes(uuid));\n    }\n\n    public static KdfParameters deserialize(byte[] data) throws IOException {\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        LEDataInputStream lis = new LEDataInputStream(bis);\n\n        VariantDictionary d = VariantDictionary.deserialize(lis);\n        if (d == null) {\n            assert(false);\n            return null;\n        }\n\n        byte[] uuidBytes = d.getByteArray((ParamUUID));\n        UUID uuid;\n        if (uuidBytes != null) {\n            uuid = Types.bytestoUUID(uuidBytes);\n        } else {\n            // Correct issue where prior versions were writing empty UUIDs for AES\n            uuid = AesKdf.CIPHER_UUID;\n        }\n\n        if (uuid == null) {\n            assert(false);\n            return null;\n        }\n\n        KdfParameters kdfP = new KdfParameters(uuid);\n        kdfP.copyTo(d);\n        return kdfP;\n\n    }\n\n    public static byte[] serialize(KdfParameters kdf) throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n        LEDataOutputStream los = new LEDataOutputStream(bos);\n\n        KdfParameters.serialize(kdf, los);\n\n        return bos.toByteArray();\n    }\n\n}\n","lineNo":53}
{"Smelly Sample":"/*\n * Copyright 2013-2020 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport android.util.Base64;\nimport android.util.Xml;\n\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfFactory;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.EntryHandler;\nimport com.keepassdroid.database.GroupHandler;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4.MemoryProtectionConfig;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDefsV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwEntryV4.AutoType;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.HashedBlockOutputStream;\nimport com.keepassdroid.stream.HmacBlockOutputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.utils.DateUtil;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\nimport org.joda.time.DateTime;\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrCompressed;\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrId;\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrProtected;\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrRef;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoType;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeDefaultSeq;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeEnabled;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeItem;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeObfuscation;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemBgColor;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemBinaries;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemBinary;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCreationTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomData;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconID;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconItem;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconItemData;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconItemID;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIcons;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbColor;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDefaultUser;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDefaultUserChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDesc;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDescChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbKeyChangeForce;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbKeyChangeRec;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbKeyChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbMntncHistoryDays;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbName;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbNameChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDeletedObject;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDeletedObjects;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDeletionTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDocNode;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEnableAutoType;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEnableSearching;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEntry;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEntryTemplatesGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEntryTemplatesGroupChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemExpires;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemExpiryTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemFgColor;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemGenerator;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemGroupDefaultAutoTypeSeq;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHeaderHash;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHistory;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHistoryMaxItems;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHistoryMaxSize;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemIcon;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemIsExpanded;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemKey;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemKeystrokeSequence;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastAccessTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastModTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastSelectedGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastTopVisibleEntry;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastTopVisibleGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLocationChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemMemoryProt;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemMeta;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemName;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemNotes;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemOverrideUrl;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtNotes;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtPassword;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtTitle;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtURL;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtUserName;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRecycleBinChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRecycleBinEnabled;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRecycleBinUuid;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRoot;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemString;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemStringDictExItem;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemTags;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemTimes;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemUsageCount;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemUuid;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemValue;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemWindow;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ValFalse;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ValTrue;\n\npublic class PwDbV4Output extends PwDbOutput {\n\n\tPwDatabaseV4 mPM;\n\tprivate StreamCipher randomStream;\n\tprivate XmlSerializer xml;\n\tprivate PwDbHeaderV4 header;\n\tprivate byte[] hashOfHeader;\n\tprivate byte[] headerHmac;\n    private CipherEngine engine = null;\n\n\tprotected PwDbV4Output(PwDatabaseV4 pm, OutputStream os) {\n\t\tsuper(os);\n\t\t\n\t\tmPM = pm;\n\t}\n\n\t@Override\n\tpublic void output() throws PwDbOutputException {\n\n        try {\n\t\t\ttry {\n\t\t\t\tengine = CipherFactory.getInstance(mPM.dataCipher);\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwDbOutputException(\"No such cipher\", e);\n\t\t\t}\n\n\t\t\theader = (PwDbHeaderV4) outputHeader(mOS);\n\n\t\t\tOutputStream osPlain;\n\t\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\t\tCipherOutputStream cos = attachStreamEncryptor(header, mOS);\n\t\t\t\tcos.write(header.streamStartBytes);\n\n\t\t\t\tHashedBlockOutputStream hashed = new HashedBlockOutputStream(cos);\n\t\t\t\tosPlain = hashed;\n\t\t\t} else {\n\t\t\t\tmOS.write(hashOfHeader);\n\t\t\t\tmOS.write(headerHmac);\n\n\t\t\t\tHmacBlockOutputStream hbos = new HmacBlockOutputStream(mOS, mPM.hmacKey);\n\t\t\t\tosPlain = attachStreamEncryptor(header, hbos);\n\t\t\t}\n\n\t\t\tOutputStream osXml;\n\t\t\ttry {\n\n\n\t\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\t\tosXml = new GZIPOutputStream(osPlain);\n\t\t\t\t} else {\n\t\t\t\t\tosXml = osPlain;\n\t\t\t\t}\n\n\t\t\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\t\t\tPwDbInnerHeaderOutputV4 ihOut =  new PwDbInnerHeaderOutputV4((PwDatabaseV4)mPM, header, osXml);\n                    ihOut.output();\n\t\t\t\t}\n\n\n\t\t\t\toutputDatabase(osXml);\n\t\t\t\tosXml.close();\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new PwDbOutputException(e);\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new PwDbOutputException(e);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t}\n\t}\n\t\n\tprivate class GroupWriter extends GroupHandler<PwGroup> {\n\t\tprivate Stack<PwGroupV4> groupStack;\n\t\t\n\t\tpublic GroupWriter(Stack<PwGroupV4> gs) {\n\t\t\tgroupStack = gs;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean operate(PwGroup g) {\n\t\t\tPwGroupV4 group = (PwGroupV4) g;\n\t\t\tassert(group != null);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (group.parent == groupStack.peek()) {\n\t\t\t\t\t\tgroupStack.push(group);\n\t\t\t\t\t\tstartGroup(group);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\tif (groupStack.size() <= 0) return false;\n\t\t\t\t\t\tendGroup();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate class EntryWriter extends EntryHandler<PwEntry> {\n\n\t\t@Override\n\t\tpublic boolean operate(PwEntry e) {\n\t\t\tPwEntryV4 entry = (PwEntryV4) e;\n\t\t\tassert(entry != null);\n\t\t\t\n\t\t\ttry {\n\t\t\t\twriteEntry(entry, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void outputDatabase(OutputStream os) throws IllegalArgumentException, IllegalStateException, IOException {\n\n\t\txml = Xml.newSerializer();\n\t\t\n\t\txml.setOutput(os, \"UTF-8\");\n\t\txml.startDocument(\"UTF-8\", true);\n\t\t\n\t\txml.startTag(null, ElemDocNode);\n\t\t\n\t\twriteMeta();\n\t\t\n\t\tPwGroupV4 root = (PwGroupV4) mPM.rootGroup;\n\t\txml.startTag(null, ElemRoot);\n\t\tstartGroup(root);\n\t\tStack<PwGroupV4> groupStack = new Stack<PwGroupV4>();\n\t\tgroupStack.push(root);\n\t\t\n\t\tif (!root.preOrderTraverseTree(new GroupWriter(groupStack), new EntryWriter())) throw new RuntimeException(\"Writing groups failed\");\n\t\t\n\t\twhile (groupStack.size() > 1) {\n\t\t\txml.endTag(null, ElemGroup);\n\t\t\tgroupStack.pop();\n\t\t}\n\t\t\n\t\tendGroup();\n\t\t\n\t\twriteList(ElemDeletedObjects, mPM.deletedObjects);\n\t\t\n\t\txml.endTag(null, ElemRoot);\n\t\t\n\t\txml.endTag(null, ElemDocNode);\n\t\txml.endDocument();\n\t\t\n\t}\n\t\n\tprivate void writeMeta() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemMeta);\n\t\t\n\t\twriteObject(ElemGenerator, mPM.localizedAppName);\n\t\t\n\t\tif (hashOfHeader != null) {\n\t\t\twriteObject(ElemHeaderHash, Base64.encodeToString(hashOfHeader, Base64.NO_WRAP));\n\t\t}\n\t\t\n\t\twriteObject(ElemDbName, mPM.name, true);\n\t\twriteObject(ElemDbNameChanged, mPM.nameChanged);\n\t\twriteObject(ElemDbDesc, mPM.description, true);\n\t\twriteObject(ElemDbDescChanged, mPM.descriptionChanged);\n\t\twriteObject(ElemDbDefaultUser, mPM.defaultUserName, true);\n\t\twriteObject(ElemDbDefaultUserChanged, mPM.defaultUserNameChanged);\n\t\twriteObject(ElemDbMntncHistoryDays, mPM.maintenanceHistoryDays);\n\t\twriteObject(ElemDbColor, mPM.color);\n\t\twriteObject(ElemDbKeyChanged, mPM.keyLastChanged);\n\t\twriteObject(ElemDbKeyChangeRec, mPM.keyChangeRecDays);\n\t\twriteObject(ElemDbKeyChangeForce, mPM.keyChangeForceDays);\n\t\t\n\t\t\n\t\twriteList(ElemMemoryProt, mPM.memoryProtection);\n\t\t\n\t\twriteCustomIconList();\n\t\t\n\t\twriteObject(ElemRecycleBinEnabled, mPM.recycleBinEnabled);\n\t\twriteObject(ElemRecycleBinUuid, mPM.recycleBinUUID);\n\t\twriteObject(ElemRecycleBinChanged, mPM.recycleBinChanged);\n\t\twriteObject(ElemEntryTemplatesGroup, mPM.entryTemplatesGroup);\n\t\twriteObject(ElemEntryTemplatesGroupChanged, mPM.entryTemplatesGroupChanged);\n\t\twriteObject(ElemHistoryMaxItems, mPM.historyMaxItems);\n\t\twriteObject(ElemHistoryMaxSize, mPM.historyMaxSize);\n\t\twriteObject(ElemLastSelectedGroup, mPM.lastSelectedGroup);\n\t\twriteObject(ElemLastTopVisibleGroup, mPM.lastTopVisibleGroup);\n\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\twriteBinPool();\n\t\t}\n\t\twriteList(ElemCustomData, mPM.customData);\n\t\t\n\t\txml.endTag(null, ElemMeta);\n\t\t\n\t}\n\t\n\tprivate CipherOutputStream attachStreamEncryptor(PwDbHeaderV4 header, OutputStream os) throws PwDbOutputException {\n\t\tCipher cipher;\n\t\ttry {\n\t\t\t//mPM.makeFinalKey(header.masterSeed, mPM.kdfParameters);\n\n\t\t\tcipher = engine.getCipher(Cipher.ENCRYPT_MODE, mPM.finalKey, header.encryptionIV);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwDbOutputException(\"Invalid algorithm.\", e);\n\t\t}\n\t\t\n\t\tCipherOutputStream cos = new CipherOutputStream(os, cipher);\n\t\t\n\t\treturn cos;\n\t}\n\n\t@Override\n\tprotected SecureRandom setIVs(PwDbHeader header) throws PwDbOutputException {\n\t\tSecureRandom random = super.setIVs(header);\n\t\t\n\t\tPwDbHeaderV4 h = (PwDbHeaderV4) header;\n\t\trandom.nextBytes(h.masterSeed);\n\n\t\tint ivLength = engine.ivLength();\n\t\tif (ivLength != h.encryptionIV.length) {\n\t\t\th.encryptionIV = new byte[ivLength];\n\t\t}\n\t\trandom.nextBytes(h.encryptionIV);\n\n\t\tUUID kdfUUID = mPM.kdfParameters.kdfUUID;\n\t\tKdfEngine kdf = KdfFactory.get(kdfUUID);\n\t\tkdf.randomize(mPM.kdfParameters);\n\n\t\tif (h.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\th.innerRandomStream = CrsAlgorithm.Salsa20;\n            h.innerRandomStreamKey = new byte[32];\n\t\t} else {\n\t\t\th.innerRandomStream = CrsAlgorithm.ChaCha20;\n\t\t\th.innerRandomStreamKey = new byte[64];\n\t\t}\n\t\trandom.nextBytes(h.innerRandomStreamKey);\n\n\t\trandomStream = PwStreamCipherFactory.getInstance(h.innerRandomStream, h.innerRandomStreamKey);\n\t\tif (randomStream == null) {\n\t\t\tthrow new PwDbOutputException(\"Invalid random cipher\");\n\t\t}\n\n\t\tif ( h.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\trandom.nextBytes(h.streamStartBytes);\n\t\t}\n\t\t\n\t\treturn random;\n\t}\n\t\n\t@Override\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwDbOutputException {\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(mPM);\n\t\tsetIVs(header);\n\n\t\tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4(mPM, header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(\"Failed to output the header.\", e);\n\t\t}\n\t\t\n\t\thashOfHeader = pho.getHashOfHeader();\n\t\theaderHmac = pho.headerHmac;\n\t\t\n\t\treturn header;\n\t}\n\t\n\tprivate void startGroup(PwGroupV4 group) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemGroup);\n\t\twriteObject(ElemUuid, group.uuid);\n\t\twriteObject(ElemName, group.name);\n\t\twriteObject(ElemNotes, group.notes);\n\t\twriteObject(ElemIcon, group.icon.iconId);\n\t\t\n\t\tif (!group.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, group.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteList(ElemTimes, group);\n\t\twriteObject(ElemIsExpanded, group.isExpanded);\n\t\twriteObject(ElemGroupDefaultAutoTypeSeq, group.defaultAutoTypeSequence);\n\t\twriteObject(ElemEnableAutoType, group.enableAutoType);\n\t\twriteObject(ElemEnableSearching, group.enableSearching);\n\t\twriteObject(ElemLastTopVisibleEntry, group.lastTopVisibleEntry);\n\t\t\n\t}\n\t\n\tprivate void endGroup() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.endTag(null, ElemGroup);\n\t}\n\t\n\tprivate void writeEntry(PwEntryV4 entry, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(entry != null);\n\t\t\n\t\txml.startTag(null, ElemEntry);\n\t\t\n\t\twriteObject(ElemUuid, entry.uuid);\n\t\twriteObject(ElemIcon, entry.icon.iconId);\n\t\t\n\t\tif (!entry.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, entry.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteObject(ElemFgColor, entry.foregroundColor);\n\t\twriteObject(ElemBgColor, entry.backgroupColor);\n\t\twriteObject(ElemOverrideUrl, entry.overrideURL);\n\t\twriteObject(ElemTags, entry.tags);\n\t\t\n\t\twriteList(ElemTimes, entry);\n\t\t\n\t\twriteList(entry.strings, true);\n\t\twriteList(entry.binaries);\n\t\twriteList(ElemAutoType, entry.autoType);\n\t\t\n\t\tif (!isHistory) {\n\t\t\twriteList(ElemHistory, entry.history, true);\n\t\t} else {\n\t\t\tassert(entry.history.size() == 0);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemEntry);\n\t}\n\t\n\n\tprivate void writeObject(String key, ProtectedBinary value, boolean allowRef) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key != null && value != null);\n\t\t\n\t\txml.startTag(null, ElemBinary);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tString strRef = null;\n\t\tif (allowRef) {\n\t\t\tint ref = mPM.binPool.poolFind(value);\n\t\t\tstrRef = Integer.toString(ref);\n\t\t}\n\t\t\n\t\tif (strRef != null) {\n\t\t\txml.attribute(null, AttrRef, strRef);\n\t\t}\n\t\telse {\n\t\t\tsubWriteValue(value);\n\t\t}\n\t\txml.endTag(null, ElemValue);\n\t\t\n\t\txml.endTag(null, ElemBinary);\n\t}\n\t\n\tprivate void subWriteValue(ProtectedBinary value) throws IllegalArgumentException, IllegalStateException, IOException {\n\n\t\tint valLength = (int) value.length();\n\t\tif (valLength > 0) {\n\t\t\tbyte[] buffer = new byte[valLength];\n\t\t\tvalue.getData().read(buffer, 0, valLength);\n\n\t\t\tif (value.isProtected()) {\n\t\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(buffer, 0, valLength, encoded, 0);\n\t\t\t\txml.text(Base64.encodeToString(encoded, Base64.NO_WRAP));\n\n\t\t\t} else {\n\t\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\t\txml.attribute(null, AttrCompressed, ValTrue);\n\t\t\t\t\tbyte[] compressData = MemUtil.compress(buffer);\n\t\t\t\t\txml.text(Base64.encodeToString(compressData, Base64.NO_WRAP));\n\t\t\t\t} else {\n\t\t\t\t\txml.text(Base64.encodeToString(buffer, Base64.NO_WRAP));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void writeObject(String name, String value, boolean filterXmlChars) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tif (filterXmlChars) {\n\t\t\tvalue = safeXmlString(value);\n\t\t}\n\t\t\n\t\txml.text(value);\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeObject(String name, String value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, value, false);\n\t}\n\t\n\tprivate void writeObject(String name, Date value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\twriteObject(name, PwDatabaseV4XML.dateFormatter.get().format(value));\n\t\t} else {\n\t\t\tDateTime dt = new DateTime(value);\n\t\t\tlong seconds = DateUtil.convertDateToKDBX4Time(dt);\n\t\t\tbyte[] buf = LEDataOutputStream.writeLongBuf(seconds);\n\t\t\tString b64 = Base64.encodeToString(buf, Base64.NO_WRAP);\n\t\t\twriteObject(name, b64);\n\t\t}\n\n\t}\n\t\n\tprivate void writeObject(String name, long value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, String.valueOf(value));\n\t}\n\t\n\tprivate void writeObject(String name, Boolean value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tString text;\n\t\tif (value == null) {\n\t\t\ttext = \"null\";\n\t\t}\n\t\telse if (value) {\n\t\t\ttext = ValTrue;\n\t\t}\n\t\telse {\n\t\t\ttext = ValFalse;\n\t\t}\n\t\t\n\t\twriteObject(name, text);\n\t}\n\t\n\tprivate void writeObject(String name, UUID uuid) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbyte[] data = Types.UUIDtoBytes(uuid);\n\t\twriteObject(name, Base64.encodeToString(data, Base64.NO_WRAP));\n\t}\n\t\n\tprivate void writeObject(String name, String keyName, String keyValue, String valueName, String valueValue) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, name);\n\t\t\n\t\txml.startTag(null, keyName);\n\t\txml.text(safeXmlString(keyValue));\n\t\txml.endTag(null, keyName);\n\t\t\n\t\txml.startTag(null, valueName);\n\t\txml.text(safeXmlString(valueValue));\n\t\txml.endTag(null, valueName);\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeList(String name, AutoType autoType) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && autoType != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemAutoTypeEnabled, autoType.enabled);\n\t\twriteObject(ElemAutoTypeObfuscation, autoType.obfuscationOptions);\n\t\t\n\t\tif (autoType.defaultSequence.length() > 0) {\n\t\t\twriteObject(ElemAutoTypeDefaultSeq, autoType.defaultSequence, true);\n\t\t}\n\t\t\n\t\tfor (Entry<String, String> pair : autoType.entrySet()) {\n\t\t\twriteObject(ElemAutoTypeItem, ElemWindow, pair.getKey(), ElemKeystrokeSequence, pair.getValue());\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(Map<String, ProtectedString> strings, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert (strings != null);\n\t\t\n\t\tfor (Entry<String, ProtectedString> pair : strings.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), isEntryString);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate void writeObject(String key, ProtectedString value, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key !=null && value != null);\n\t\t\n\t\txml.startTag(null, ElemString);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tboolean protect = value.isProtected();\n\t\tif (isEntryString) {\n\t\t\tif (key.equals(PwDefsV4.TITLE_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectTitle;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.USERNAME_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUserName;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.PASSWORD_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectPassword;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.URL_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUrl;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.NOTES_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectNotes;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (protect) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tbyte[] data = value.toString().getBytes(\"UTF-8\");\n\t\t\tint valLength = data.length;\n\t\t\t\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(data, 0, valLength, encoded, 0);\n\t\t\t\txml.text(Base64.encodeToString(encoded, Base64.NO_WRAP));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txml.text(safeXmlString(value.toString()));\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemValue);\n\t\txml.endTag(null, ElemString);\n\t\t\n\t}\n\n\tprivate void writeObject(String name, PwDeletedObject value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemUuid, value.uuid);\n\t\twriteObject(ElemDeletionTime, value.getDeletionTime());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(Map<String, ProtectedBinary> binaries) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(binaries != null);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binaries.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), true);\n\t\t}\n\t}\n\n\n\tprivate void writeList(String name, List<PwDeletedObject> value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwDeletedObject pdo : value) {\n\t\t\twriteObject(ElemDeletedObject, pdo);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(String name, MemoryProtectionConfig value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemProtTitle, value.protectTitle);\n\t\twriteObject(ElemProtUserName, value.protectUserName);\n\t\twriteObject(ElemProtPassword, value.protectPassword);\n\t\twriteObject(ElemProtURL, value.protectUrl);\n\t\twriteObject(ElemProtNotes, value.protectNotes);\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, Map<String, String> customData) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && customData != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (Entry<String, String> pair : customData.entrySet()) {\n\t\t\twriteObject(ElemStringDictExItem, ElemKey, pair.getKey(), ElemValue, pair.getValue());\n\t\t\t  \n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, ITimeLogger it) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && it != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemLastModTime, it.getLastModificationTime());\n\t\twriteObject(ElemCreationTime, it.getCreationTime());\n\t\twriteObject(ElemLastAccessTime, it.getLastAccessTime());\n\t\twriteObject(ElemExpiryTime, it.getExpiryTime());\n\t\twriteObject(ElemExpires, it.expires());\n\t\twriteObject(ElemUsageCount, it.getUsageCount());\n\t\twriteObject(ElemLocationChanged, it.getLocationChanged());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(String name, List<PwEntryV4> value, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwEntryV4 entry : value) {\n\t\t\twriteEntry(entry, isHistory);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeCustomIconList() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tList<PwIconCustom> customIcons = mPM.customIcons;\n\t\tif (customIcons.size() == 0) return;\n\t\t\n\t\txml.startTag(null, ElemCustomIcons);\n\t\t\n\t\tfor (PwIconCustom icon : customIcons) {\n\t\t\txml.startTag(null, ElemCustomIconItem);\n\t\t\t\n\t\t\twriteObject(ElemCustomIconItemID, icon.uuid);\n\t\t\twriteObject(ElemCustomIconItemData, Base64.encodeToString(icon.imageData, Base64.NO_WRAP));\n\t\t\t\n\t\t\txml.endTag(null, ElemCustomIconItem);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemCustomIcons);\n\t}\n\t\n\tprivate void writeBinPool() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemBinaries);\n\t\t\n\t\tfor (Entry<Integer, ProtectedBinary> pair : mPM.binPool.entrySet()) {\n\t\t\txml.startTag(null, ElemBinary);\n\t\t\txml.attribute(null, AttrId, Integer.toString(pair.getKey()));\n\t\t\t\n\t\t\tsubWriteValue(pair.getValue());\n\t\t\t\n\t\t\txml.endTag(null, ElemBinary);\n\t\t\t\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemBinaries);\n\t\t\n\t}\n\n\tprivate String safeXmlString(String text) {\n\t\tif (EmptyUtils.isNullOrEmpty(text)) {\n\t\t\treturn text;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar ch;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tch = text.charAt(i);\n\t\t\t\n\t\t\tif(((ch >= 0x20) && (ch <= 0xD7FF)) ||              \n\t\t\t        (ch == 0x9) || (ch == 0xA) || (ch == 0xD) ||\n\t\t\t        ((ch >= 0xE000) && (ch <= 0xFFFD))) {\n\t\t\t\t\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2013-2020 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport android.util.Base64;\nimport android.util.Xml;\n\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfFactory;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.EntryHandler;\nimport com.keepassdroid.database.GroupHandler;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwCustomData;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4.MemoryProtectionConfig;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDefsV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwEntryV4.AutoType;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.HashedBlockOutputStream;\nimport com.keepassdroid.stream.HmacBlockOutputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.utils.DateUtil;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\nimport org.joda.time.DateTime;\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrCompressed;\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrId;\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrProtected;\nimport static com.keepassdroid.database.PwDatabaseV4XML.AttrRef;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoType;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeDefaultSeq;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeEnabled;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeItem;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemAutoTypeObfuscation;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemBgColor;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemBinaries;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemBinary;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCreationTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomData;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconID;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconItem;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconItemData;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIconItemID;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemCustomIcons;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbColor;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDefaultUser;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDefaultUserChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDesc;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbDescChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbKeyChangeForce;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbKeyChangeRec;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbKeyChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbMntncHistoryDays;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbName;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDbNameChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDeletedObject;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDeletedObjects;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDeletionTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemDocNode;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEnableAutoType;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEnableSearching;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEntry;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEntryTemplatesGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemEntryTemplatesGroupChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemExpires;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemExpiryTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemFgColor;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemGenerator;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemGroupDefaultAutoTypeSeq;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHeaderHash;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHistory;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHistoryMaxItems;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemHistoryMaxSize;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemIcon;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemIsExpanded;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemKey;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemKeystrokeSequence;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastAccessTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastModTime;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastSelectedGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastTopVisibleEntry;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLastTopVisibleGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemLocationChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemMemoryProt;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemMeta;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemName;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemNotes;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemOverrideUrl;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemPreviousParentGroup;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtNotes;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtPassword;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtTitle;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtURL;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemProtUserName;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemQualityCheck;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRecycleBinChanged;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRecycleBinEnabled;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRecycleBinUuid;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemRoot;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemString;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemStringDictExItem;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemTags;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemTimes;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemUsageCount;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemUuid;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemValue;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ElemWindow;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ValFalse;\nimport static com.keepassdroid.database.PwDatabaseV4XML.ValTrue;\n\npublic class PwDbV4Output extends PwDbOutput {\n\n\tPwDatabaseV4 mPM;\n\tprivate StreamCipher randomStream;\n\tprivate XmlSerializer xml;\n\tprivate PwDbHeaderV4 header;\n\tprivate byte[] hashOfHeader;\n\tprivate byte[] headerHmac;\n    private CipherEngine engine = null;\n\n\tprotected PwDbV4Output(PwDatabaseV4 pm, OutputStream os) {\n\t\tsuper(os);\n\t\t\n\t\tmPM = pm;\n\t}\n\n\t@Override\n\tpublic void output() throws PwDbOutputException {\n\n        try {\n\t\t\ttry {\n\t\t\t\tengine = CipherFactory.getInstance(mPM.dataCipher);\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwDbOutputException(\"No such cipher\", e);\n\t\t\t}\n\n\t\t\theader = (PwDbHeaderV4) outputHeader(mOS);\n\n\t\t\tOutputStream osPlain;\n\t\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\t\tCipherOutputStream cos = attachStreamEncryptor(header, mOS);\n\t\t\t\tcos.write(header.streamStartBytes);\n\n\t\t\t\tHashedBlockOutputStream hashed = new HashedBlockOutputStream(cos);\n\t\t\t\tosPlain = hashed;\n\t\t\t} else {\n\t\t\t\tmOS.write(hashOfHeader);\n\t\t\t\tmOS.write(headerHmac);\n\n\t\t\t\tHmacBlockOutputStream hbos = new HmacBlockOutputStream(mOS, mPM.hmacKey);\n\t\t\t\tosPlain = attachStreamEncryptor(header, hbos);\n\t\t\t}\n\n\t\t\tOutputStream osXml;\n\t\t\ttry {\n\n\n\t\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\t\tosXml = new GZIPOutputStream(osPlain);\n\t\t\t\t} else {\n\t\t\t\t\tosXml = osPlain;\n\t\t\t\t}\n\n\t\t\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\t\t\tPwDbInnerHeaderOutputV4 ihOut =  new PwDbInnerHeaderOutputV4((PwDatabaseV4)mPM, header, osXml);\n                    ihOut.output();\n\t\t\t\t}\n\n\n\t\t\t\toutputDatabase(osXml);\n\t\t\t\tosXml.close();\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new PwDbOutputException(e);\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new PwDbOutputException(e);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t}\n\t}\n\t\n\tprivate class GroupWriter extends GroupHandler<PwGroup> {\n\t\tprivate Stack<PwGroupV4> groupStack;\n\t\t\n\t\tpublic GroupWriter(Stack<PwGroupV4> gs) {\n\t\t\tgroupStack = gs;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean operate(PwGroup g) {\n\t\t\tPwGroupV4 group = (PwGroupV4) g;\n\t\t\tassert(group != null);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (group.parent == groupStack.peek()) {\n\t\t\t\t\t\tgroupStack.push(group);\n\t\t\t\t\t\tstartGroup(group);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\tif (groupStack.size() <= 0) return false;\n\t\t\t\t\t\tendGroup();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate class EntryWriter extends EntryHandler<PwEntry> {\n\n\t\t@Override\n\t\tpublic boolean operate(PwEntry e) {\n\t\t\tPwEntryV4 entry = (PwEntryV4) e;\n\t\t\tassert(entry != null);\n\t\t\t\n\t\t\ttry {\n\t\t\t\twriteEntry(entry, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void outputDatabase(OutputStream os) throws IllegalArgumentException, IllegalStateException, IOException {\n\n\t\txml = Xml.newSerializer();\n\t\t\n\t\txml.setOutput(os, \"UTF-8\");\n\t\txml.startDocument(\"UTF-8\", true);\n\t\t\n\t\txml.startTag(null, ElemDocNode);\n\t\t\n\t\twriteMeta();\n\t\t\n\t\tPwGroupV4 root = (PwGroupV4) mPM.rootGroup;\n\t\txml.startTag(null, ElemRoot);\n\t\tstartGroup(root);\n\t\tStack<PwGroupV4> groupStack = new Stack<PwGroupV4>();\n\t\tgroupStack.push(root);\n\t\t\n\t\tif (!root.preOrderTraverseTree(new GroupWriter(groupStack), new EntryWriter())) throw new RuntimeException(\"Writing groups failed\");\n\t\t\n\t\twhile (groupStack.size() > 1) {\n\t\t\txml.endTag(null, ElemGroup);\n\t\t\tgroupStack.pop();\n\t\t}\n\t\t\n\t\tendGroup();\n\t\t\n\t\twriteList(ElemDeletedObjects, mPM.deletedObjects);\n\t\t\n\t\txml.endTag(null, ElemRoot);\n\t\t\n\t\txml.endTag(null, ElemDocNode);\n\t\txml.endDocument();\n\t\t\n\t}\n\t\n\tprivate void writeMeta() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemMeta);\n\t\t\n\t\twriteObject(ElemGenerator, mPM.localizedAppName);\n\t\t\n\t\tif (hashOfHeader != null) {\n\t\t\twriteObject(ElemHeaderHash, Base64.encodeToString(hashOfHeader, Base64.NO_WRAP));\n\t\t}\n\t\t\n\t\twriteObject(ElemDbName, mPM.name, true);\n\t\twriteObject(ElemDbNameChanged, mPM.nameChanged);\n\t\twriteObject(ElemDbDesc, mPM.description, true);\n\t\twriteObject(ElemDbDescChanged, mPM.descriptionChanged);\n\t\twriteObject(ElemDbDefaultUser, mPM.defaultUserName, true);\n\t\twriteObject(ElemDbDefaultUserChanged, mPM.defaultUserNameChanged);\n\t\twriteObject(ElemDbMntncHistoryDays, mPM.maintenanceHistoryDays);\n\t\twriteObject(ElemDbColor, mPM.color);\n\t\twriteObject(ElemDbKeyChanged, mPM.keyLastChanged);\n\t\twriteObject(ElemDbKeyChangeRec, mPM.keyChangeRecDays);\n\t\twriteObject(ElemDbKeyChangeForce, mPM.keyChangeForceDays);\n\t\t\n\t\t\n\t\twriteList(ElemMemoryProt, mPM.memoryProtection);\n\t\t\n\t\twriteCustomIconList();\n\t\t\n\t\twriteObject(ElemRecycleBinEnabled, mPM.recycleBinEnabled);\n\t\twriteObject(ElemRecycleBinUuid, mPM.recycleBinUUID);\n\t\twriteObject(ElemRecycleBinChanged, mPM.recycleBinChanged);\n\t\twriteObject(ElemEntryTemplatesGroup, mPM.entryTemplatesGroup);\n\t\twriteObject(ElemEntryTemplatesGroupChanged, mPM.entryTemplatesGroupChanged);\n\t\twriteObject(ElemHistoryMaxItems, mPM.historyMaxItems);\n\t\twriteObject(ElemHistoryMaxSize, mPM.historyMaxSize);\n\t\twriteObject(ElemLastSelectedGroup, mPM.lastSelectedGroup);\n\t\twriteObject(ElemLastTopVisibleGroup, mPM.lastTopVisibleGroup);\n\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\twriteBinPool();\n\t\t}\n\t\twriteList(ElemCustomData, mPM.customData);\n\t\t\n\t\txml.endTag(null, ElemMeta);\n\t\t\n\t}\n\t\n\tprivate CipherOutputStream attachStreamEncryptor(PwDbHeaderV4 header, OutputStream os) throws PwDbOutputException {\n\t\tCipher cipher;\n\t\ttry {\n\t\t\t//mPM.makeFinalKey(header.masterSeed, mPM.kdfParameters);\n\n\t\t\tcipher = engine.getCipher(Cipher.ENCRYPT_MODE, mPM.finalKey, header.encryptionIV);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwDbOutputException(\"Invalid algorithm.\", e);\n\t\t}\n\t\t\n\t\tCipherOutputStream cos = new CipherOutputStream(os, cipher);\n\t\t\n\t\treturn cos;\n\t}\n\n\t@Override\n\tprotected SecureRandom setIVs(PwDbHeader header) throws PwDbOutputException {\n\t\tSecureRandom random = super.setIVs(header);\n\t\t\n\t\tPwDbHeaderV4 h = (PwDbHeaderV4) header;\n\t\trandom.nextBytes(h.masterSeed);\n\n\t\tint ivLength = engine.ivLength();\n\t\tif (ivLength != h.encryptionIV.length) {\n\t\t\th.encryptionIV = new byte[ivLength];\n\t\t}\n\t\trandom.nextBytes(h.encryptionIV);\n\n\t\tUUID kdfUUID = mPM.kdfParameters.kdfUUID;\n\t\tKdfEngine kdf = KdfFactory.get(kdfUUID);\n\t\tkdf.randomize(mPM.kdfParameters);\n\n\t\tif (h.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\th.innerRandomStream = CrsAlgorithm.Salsa20;\n            h.innerRandomStreamKey = new byte[32];\n\t\t} else {\n\t\t\th.innerRandomStream = CrsAlgorithm.ChaCha20;\n\t\t\th.innerRandomStreamKey = new byte[64];\n\t\t}\n\t\trandom.nextBytes(h.innerRandomStreamKey);\n\n\t\trandomStream = PwStreamCipherFactory.getInstance(h.innerRandomStream, h.innerRandomStreamKey);\n\t\tif (randomStream == null) {\n\t\t\tthrow new PwDbOutputException(\"Invalid random cipher\");\n\t\t}\n\n\t\tif ( h.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\trandom.nextBytes(h.streamStartBytes);\n\t\t}\n\t\t\n\t\treturn random;\n\t}\n\t\n\t@Override\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwDbOutputException {\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(mPM);\n\t\tsetIVs(header);\n\n\t\tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4(mPM, header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(\"Failed to output the header.\", e);\n\t\t}\n\t\t\n\t\thashOfHeader = pho.getHashOfHeader();\n\t\theaderHmac = pho.headerHmac;\n\t\t\n\t\treturn header;\n\t}\n\t\n\tprivate void startGroup(PwGroupV4 group) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemGroup);\n\t\twriteObject(ElemUuid, group.uuid);\n\t\twriteObject(ElemName, group.name);\n\t\twriteObject(ElemNotes, group.notes);\n\t\twriteObject(ElemIcon, group.icon.iconId);\n\t\t\n\t\tif (!group.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, group.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteList(ElemTimes, group);\n\t\twriteObject(ElemIsExpanded, group.isExpanded);\n\t\twriteObject(ElemGroupDefaultAutoTypeSeq, group.defaultAutoTypeSequence);\n\t\twriteObject(ElemEnableAutoType, group.enableAutoType);\n\t\twriteObject(ElemEnableSearching, group.enableSearching);\n\t\twriteObject(ElemLastTopVisibleEntry, group.lastTopVisibleEntry);\n\n\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4_1) {\n\t\t\tif (!group.prevParentGroup.equals(PwDatabaseV4.UUID_ZERO)) {\n\t\t\t\twriteObject(ElemPreviousParentGroup, group.prevParentGroup);\n\t\t\t}\n\n\t\t\tif (!EmptyUtils.isNullOrEmpty(group.tags)) {\n\t\t\t\twriteObject(ElemTags, group.tags);\n\t\t\t}\n\t\t}\n\n\t}\n\t\n\tprivate void endGroup() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.endTag(null, ElemGroup);\n\t}\n\t\n\tprivate void writeEntry(PwEntryV4 entry, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(entry != null);\n\t\t\n\t\txml.startTag(null, ElemEntry);\n\t\t\n\t\twriteObject(ElemUuid, entry.uuid);\n\t\twriteObject(ElemIcon, entry.icon.iconId);\n\t\t\n\t\tif (!entry.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, entry.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteObject(ElemFgColor, entry.foregroundColor);\n\t\twriteObject(ElemBgColor, entry.backgroupColor);\n\t\twriteObject(ElemOverrideUrl, entry.overrideURL);\n\n\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4_1 && !entry.qualityCheck) {\n\t\t\twriteObject(ElemQualityCheck, false);\n\t\t}\n\n\t\twriteObject(ElemTags, entry.tags);\n\n\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4_1 &&\n\t\t\t\t!entry.prevParentGroup.equals(PwDatabaseV4.UUID_ZERO)) {\n\t\t\twriteObject(ElemPreviousParentGroup, entry.prevParentGroup);\n\t\t}\n\n\t\twriteList(ElemTimes, entry);\n\t\t\n\t\twriteList(entry.strings, true);\n\t\twriteList(entry.binaries);\n\t\twriteList(ElemAutoType, entry.autoType);\n\t\t\n\t\tif (!isHistory) {\n\t\t\twriteList(ElemHistory, entry.history, true);\n\t\t} else {\n\t\t\tassert(entry.history.size() == 0);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemEntry);\n\t}\n\t\n\n\tprivate void writeObject(String key, ProtectedBinary value, boolean allowRef) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key != null && value != null);\n\t\t\n\t\txml.startTag(null, ElemBinary);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tString strRef = null;\n\t\tif (allowRef) {\n\t\t\tint ref = mPM.binPool.poolFind(value);\n\t\t\tstrRef = Integer.toString(ref);\n\t\t}\n\t\t\n\t\tif (strRef != null) {\n\t\t\txml.attribute(null, AttrRef, strRef);\n\t\t}\n\t\telse {\n\t\t\tsubWriteValue(value);\n\t\t}\n\t\txml.endTag(null, ElemValue);\n\t\t\n\t\txml.endTag(null, ElemBinary);\n\t}\n\t\n\tprivate void subWriteValue(ProtectedBinary value) throws IllegalArgumentException, IllegalStateException, IOException {\n\n\t\tint valLength = (int) value.length();\n\t\tif (valLength > 0) {\n\t\t\tbyte[] buffer = new byte[valLength];\n\t\t\tvalue.getData().read(buffer, 0, valLength);\n\n\t\t\tif (value.isProtected()) {\n\t\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(buffer, 0, valLength, encoded, 0);\n\t\t\t\txml.text(Base64.encodeToString(encoded, Base64.NO_WRAP));\n\n\t\t\t} else {\n\t\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\t\txml.attribute(null, AttrCompressed, ValTrue);\n\t\t\t\t\tbyte[] compressData = MemUtil.compress(buffer);\n\t\t\t\t\txml.text(Base64.encodeToString(compressData, Base64.NO_WRAP));\n\t\t\t\t} else {\n\t\t\t\t\txml.text(Base64.encodeToString(buffer, Base64.NO_WRAP));\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void writeObject(String name, String value, boolean filterXmlChars) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tif (filterXmlChars) {\n\t\t\tvalue = safeXmlString(value);\n\t\t}\n\t\t\n\t\txml.text(value);\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeObject(String name, String value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, value, false);\n\t}\n\t\n\tprivate void writeObject(String name, Date value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\twriteObject(name, PwDatabaseV4XML.dateFormatter.get().format(value));\n\t\t} else {\n\t\t\tDateTime dt = new DateTime(value);\n\t\t\tlong seconds = DateUtil.convertDateToKDBX4Time(dt);\n\t\t\tbyte[] buf = LEDataOutputStream.writeLongBuf(seconds);\n\t\t\tString b64 = Base64.encodeToString(buf, Base64.NO_WRAP);\n\t\t\twriteObject(name, b64);\n\t\t}\n\n\t}\n\t\n\tprivate void writeObject(String name, long value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, String.valueOf(value));\n\t}\n\t\n\tprivate void writeObject(String name, Boolean value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tString text;\n\t\tif (value == null) {\n\t\t\ttext = \"null\";\n\t\t}\n\t\telse if (value) {\n\t\t\ttext = ValTrue;\n\t\t}\n\t\telse {\n\t\t\ttext = ValFalse;\n\t\t}\n\t\t\n\t\twriteObject(name, text);\n\t}\n\t\n\tprivate void writeObject(String name, UUID uuid) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbyte[] data = Types.UUIDtoBytes(uuid);\n\t\twriteObject(name, Base64.encodeToString(data, Base64.NO_WRAP));\n\t}\n\t\n\tprivate void writeObject(String name, String keyName, String keyValue, String valueName,\n\t\t\t\t\t\t\t String valueValue, Date lastMod)\n\t\t\tthrows IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, name);\n\t\t\n\t\txml.startTag(null, keyName);\n\t\txml.text(safeXmlString(keyValue));\n\t\txml.endTag(null, keyName);\n\t\t\n\t\txml.startTag(null, valueName);\n\t\txml.text(safeXmlString(valueValue));\n\t\txml.endTag(null, valueName);\n\n\t\tif (lastMod != null) {\n\t\t\twriteObject(ElemLastModTime, lastMod);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeList(String name, AutoType autoType) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && autoType != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemAutoTypeEnabled, autoType.enabled);\n\t\twriteObject(ElemAutoTypeObfuscation, autoType.obfuscationOptions);\n\t\t\n\t\tif (autoType.defaultSequence.length() > 0) {\n\t\t\twriteObject(ElemAutoTypeDefaultSeq, autoType.defaultSequence, true);\n\t\t}\n\t\t\n\t\tfor (Entry<String, String> pair : autoType.entrySet()) {\n\t\t\twriteObject(ElemAutoTypeItem, ElemWindow, pair.getKey(), ElemKeystrokeSequence,\n\t\t\t\t\tpair.getValue(), null);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(Map<String, ProtectedString> strings, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert (strings != null);\n\t\t\n\t\tfor (Entry<String, ProtectedString> pair : strings.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), isEntryString);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate void writeObject(String key, ProtectedString value, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key !=null && value != null);\n\t\t\n\t\txml.startTag(null, ElemString);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tboolean protect = value.isProtected();\n\t\tif (isEntryString) {\n\t\t\tif (key.equals(PwDefsV4.TITLE_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectTitle;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.USERNAME_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUserName;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.PASSWORD_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectPassword;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.URL_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUrl;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.NOTES_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectNotes;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (protect) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tbyte[] data = value.toString().getBytes(\"UTF-8\");\n\t\t\tint valLength = data.length;\n\t\t\t\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(data, 0, valLength, encoded, 0);\n\t\t\t\txml.text(Base64.encodeToString(encoded, Base64.NO_WRAP));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txml.text(safeXmlString(value.toString()));\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemValue);\n\t\txml.endTag(null, ElemString);\n\t\t\n\t}\n\n\tprivate void writeObject(String name, PwDeletedObject value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemUuid, value.uuid);\n\t\twriteObject(ElemDeletionTime, value.getDeletionTime());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(Map<String, ProtectedBinary> binaries) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(binaries != null);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binaries.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), true);\n\t\t}\n\t}\n\n\n\tprivate void writeList(String name, List<PwDeletedObject> value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwDeletedObject pdo : value) {\n\t\t\twriteObject(ElemDeletedObject, pdo);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(String name, MemoryProtectionConfig value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemProtTitle, value.protectTitle);\n\t\twriteObject(ElemProtUserName, value.protectUserName);\n\t\twriteObject(ElemProtPassword, value.protectPassword);\n\t\twriteObject(ElemProtURL, value.protectUrl);\n\t\twriteObject(ElemProtNotes, value.protectNotes);\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, PwCustomData customData) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && customData != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (Entry<String, String> pair : customData.entrySet()) {\n\t\t\tString key = pair.getKey();\n\n\t\t\tDate lastMod = null;\n\t\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4_1) {\n\t\t\t\tlastMod = customData.getLastMod(key);\n\t\t\t}\n\n\t\t\twriteObject(ElemStringDictExItem, ElemKey, key, ElemValue, pair.getValue(), lastMod);\n\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, ITimeLogger it) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && it != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemLastModTime, it.getLastModificationTime());\n\t\twriteObject(ElemCreationTime, it.getCreationTime());\n\t\twriteObject(ElemLastAccessTime, it.getLastAccessTime());\n\t\twriteObject(ElemExpiryTime, it.getExpiryTime());\n\t\twriteObject(ElemExpires, it.expires());\n\t\twriteObject(ElemUsageCount, it.getUsageCount());\n\t\twriteObject(ElemLocationChanged, it.getLocationChanged());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(String name, List<PwEntryV4> value, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwEntryV4 entry : value) {\n\t\t\twriteEntry(entry, isHistory);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeCustomIconList() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tList<PwIconCustom> customIcons = mPM.customIcons;\n\t\tif (customIcons.size() == 0) return;\n\t\t\n\t\txml.startTag(null, ElemCustomIcons);\n\t\t\n\t\tfor (PwIconCustom icon : customIcons) {\n\t\t\txml.startTag(null, ElemCustomIconItem);\n\t\t\t\n\t\t\twriteObject(ElemCustomIconItemID, icon.uuid);\n\t\t\twriteObject(ElemCustomIconItemData, Base64.encodeToString(icon.imageData, Base64.NO_WRAP));\n\n\t\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4_1) {\n\t\t\t\tif (!EmptyUtils.isNullOrEmpty(icon.name)) {\n\t\t\t\t\twriteObject(ElemName, icon.name, true);\n\t\t\t\t}\n\n\t\t\t\tif (icon.lastMod != null) {\n\t\t\t\t\twriteObject(ElemLastModTime, icon.lastMod);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\txml.endTag(null, ElemCustomIconItem);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemCustomIcons);\n\t}\n\t\n\tprivate void writeBinPool() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemBinaries);\n\t\t\n\t\tfor (Entry<Integer, ProtectedBinary> pair : mPM.binPool.entrySet()) {\n\t\t\txml.startTag(null, ElemBinary);\n\t\t\txml.attribute(null, AttrId, Integer.toString(pair.getKey()));\n\t\t\t\n\t\t\tsubWriteValue(pair.getValue());\n\t\t\t\n\t\t\txml.endTag(null, ElemBinary);\n\t\t\t\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemBinaries);\n\t\t\n\t}\n\n\tprivate String safeXmlString(String text) {\n\t\tif (EmptyUtils.isNullOrEmpty(text)) {\n\t\t\treturn text;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar ch;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tch = text.charAt(i);\n\t\t\t\n\t\t\tif(((ch >= 0x20) && (ch <= 0xD7FF)) ||              \n\t\t\t        (ch == 0x9) || (ch == 0xA) || (ch == 0xD) ||\n\t\t\t        ((ch >= 0xE000) && (ch <= 0xFFFD))) {\n\t\t\t\t\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\n}\n","lineNo":775}
{"Smelly Sample":"/*\n * Copyright 2009-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.database.edit.FileOnFinish;\nimport com.keepassdroid.database.edit.OnFinish;\nimport com.keepassdroid.database.edit.SetPassword;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.UriUtil;\n\npublic class SetPasswordDialog extends CancelDialog {\n\n\tprivate byte[] masterKey;\n\tprivate Uri mKeyfile;\n\tprivate FileOnFinish mFinish;\n\t\t\n\tpublic SetPasswordDialog(Context context) {\n\t\tsuper(context);\n\t}\n\t\n\tpublic SetPasswordDialog(Context context, FileOnFinish finish) {\n\t\tsuper(context);\n\t\tmFinish = finish;\n\t}\n\t\n\tpublic byte[] getKey() {\n\t\treturn masterKey;\n\t}\n\t\n\tpublic Uri keyfile() {\n\t\treturn mKeyfile;\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.set_password);\n\t\t\n\t\tsetTitle(R.string.password_title);\n\t\t\n\t\t// Ok button\n\t\tButton okButton = (Button) findViewById(R.id.ok);\n\t\tokButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tTextView passView = (TextView) findViewById(R.id.pass_password);\n\t\t\t\tString pass = passView.getText().toString();\n\t\t\t\tTextView passConfView = (TextView) findViewById(R.id.pass_conf_password);\n\t\t\t\tString confpass = passConfView.getText().toString();\n\t\t\t\t\n\t\t\t\t// Verify that passwords match\n\t\t\t\tif ( ! pass.equals(confpass) ) {\n\t\t\t\t\t// Passwords do not match\n\t\t\t\t\tToast.makeText(getContext(), R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tTextView keyfileView = (TextView) findViewById(R.id.pass_keyfile);\n\t\t\t\tUri keyfile = UriUtil.parseDefaultFile(keyfileView.getText().toString());\n\t\t\t\tmKeyfile = keyfile;\n\t\t\t\t\n\t\t\t\t// Verify that a password or keyfile is set\n\t\t\t\tif ( pass.length() == 0 && EmptyUtils.isNullOrEmpty(keyfile)) {\n\t\t\t\t\tToast.makeText(getContext(), R.string.error_nopass, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSetPassword sp = new SetPassword(getContext(), App.getDB(), pass, keyfile, new AfterSave(mFinish, new Handler()));\n\t\t\t\tfinal ProgressTask pt = new ProgressTask(getOwnerActivity(), sp, R.string.saving_database);\n\t\t\t\tboolean valid = sp.validatePassword(getContext(), new OnClickListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tpt.run();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (valid) {\n\t\t\t\t    pt.run();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tcancel();\n\t\t\t\tif ( mFinish != null ) {\n\t\t\t\t\tmFinish.run();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate class AfterSave extends OnFinish {\n\t\tprivate FileOnFinish mFinish;\n\t\t\n\t\tpublic AfterSave(FileOnFinish finish, Handler handler) {\n\t\t\tsuper(finish, handler);\n\t\t\tmFinish = finish;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tif ( mFinish != null ) {\n\t\t\t\t\tmFinish.setFilename(mKeyfile);\n\t\t\t\t}\n\t\t\t\tdismiss();\n\t\t\t} else {\n\t\t\t\tdisplayMessage(getContext());\n\t\t\t}\n\t\t\tsuper.run();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2020 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.database.edit.FileOnFinish;\nimport com.keepassdroid.database.edit.OnFinish;\nimport com.keepassdroid.database.edit.SetPassword;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.UriUtil;\n\npublic class SetPasswordDialog extends CancelDialog {\n\n\tprivate byte[] masterKey;\n\tprivate Uri mKeyfile;\n\tprivate FileOnFinish mFinish;\n\t\t\n\tpublic SetPasswordDialog(Activity act) {\n\t\tsuper(act);\n\n\t\tsetOwnerActivity(act);\n\t}\n\t\n\tpublic SetPasswordDialog(Activity act, FileOnFinish finish) {\n\t\tthis(act);\n\t\tmFinish = finish;\n\t}\n\t\n\tpublic byte[] getKey() {\n\t\treturn masterKey;\n\t}\n\t\n\tpublic Uri keyfile() {\n\t\treturn mKeyfile;\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.set_password);\n\t\t\n\t\tsetTitle(R.string.password_title);\n\t\t\n\t\t// Ok button\n\t\tButton okButton = (Button) findViewById(R.id.ok);\n\t\tokButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tTextView passView = (TextView) findViewById(R.id.pass_password);\n\t\t\t\tString pass = passView.getText().toString();\n\t\t\t\tTextView passConfView = (TextView) findViewById(R.id.pass_conf_password);\n\t\t\t\tString confpass = passConfView.getText().toString();\n\t\t\t\t\n\t\t\t\t// Verify that passwords match\n\t\t\t\tif ( ! pass.equals(confpass) ) {\n\t\t\t\t\t// Passwords do not match\n\t\t\t\t\tToast.makeText(getContext(), R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tTextView keyfileView = (TextView) findViewById(R.id.pass_keyfile);\n\t\t\t\tUri keyfile = UriUtil.parseDefaultFile(keyfileView.getText().toString());\n\t\t\t\tmKeyfile = keyfile;\n\t\t\t\t\n\t\t\t\t// Verify that a password or keyfile is set\n\t\t\t\tif ( pass.length() == 0 && EmptyUtils.isNullOrEmpty(keyfile)) {\n\t\t\t\t\tToast.makeText(getContext(), R.string.error_nopass, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSetPassword sp = new SetPassword(getContext(), App.getDB(), pass, keyfile, new AfterSave(mFinish, new Handler()));\n\t\t\t\tActivity act = getOwnerActivity();\n\t\t\t\tfinal ProgressTask pt = new ProgressTask(act, sp, R.string.saving_database);\n\t\t\t\tboolean valid = sp.validatePassword(getContext(), new OnClickListener() {\n\t\t\t\t\t\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\t\tpt.run();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t\n\t\t\t\tif (valid) {\n\t\t\t\t    pt.run();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tcancel();\n\t\t\t\tif ( mFinish != null ) {\n\t\t\t\t\tmFinish.run();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate class AfterSave extends OnFinish {\n\t\tprivate FileOnFinish mFinish;\n\t\t\n\t\tpublic AfterSave(FileOnFinish finish, Handler handler) {\n\t\t\tsuper(finish, handler);\n\t\t\tmFinish = finish;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tif ( mFinish != null ) {\n\t\t\t\t\tmFinish.setFilename(mKeyfile);\n\t\t\t\t}\n\t\t\t\tdismiss();\n\t\t\t} else {\n\t\t\t\tdisplayMessage(getContext());\n\t\t\t}\n\t\t\tsuper.run();\n\t\t}\n\t}\n}\n","lineNo":102}
{"Smelly Sample":"/*\n * Copyright 2020 Brian Pellin\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.fragments;\n\nimport android.app.Activity;\nimport android.app.backup.BackupManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.text.InputType;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.biometric.BiometricManager;\nimport androidx.biometric.BiometricPrompt;\nimport androidx.core.content.ContextCompat;\nimport androidx.fragment.app.Fragment;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.AboutDialog;\nimport com.keepassdroid.Database;\nimport com.keepassdroid.GroupActivity;\nimport com.keepassdroid.PasswordActivity;\nimport com.keepassdroid.ProgressTask;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.compat.ClipDataCompat;\nimport com.keepassdroid.compat.StorageAF;\nimport com.keepassdroid.database.edit.LoadDB;\nimport com.keepassdroid.database.edit.OnFinish;\nimport com.keepassdroid.dialog.PasswordEncodingDialogHelper;\nimport com.keepassdroid.fileselect.BrowserDialog;\nimport com.keepassdroid.biometric.BiometricHelper;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.settings.AppSettingsActivity;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.Interaction;\nimport com.keepassdroid.utils.PermissionUtil;\nimport com.keepassdroid.utils.UriUtil;\nimport com.keepassdroid.utils.Util;\n\nimport java.io.File;\nimport java.util.concurrent.Executor;\n\nimport javax.crypto.Cipher;\n\npublic class PasswordFragment extends Fragment implements BiometricHelper.BiometricCallback {\n    private static final int FILE_BROWSE = 256;\n    public static final int GET_CONTENT = 257;\n    private static final int OPEN_DOC = 258;\n\n    private static final String KEY_PASSWORD = \"password\";\n    private static final String KEY_LAUNCH_IMMEDIATELY = \"launchImmediately\";\n    private static final String VIEW_INTENT = \"android.intent.action.VIEW\";\n\n    private static final int PERMISSION_REQUEST_ID = 1;\n\n    private Uri mDbUri = null;\n    private Uri mKeyUri = null;\n    private boolean mRememberKeyfile;\n    SharedPreferences prefs;\n    SharedPreferences prefsNoBackup;\n\n    private Uri storedKeyUri = null;\n    private String storedPassword = null;\n    private int mode;\n    private static final String PREF_KEY_VALUE_PREFIX = \"valueFor_\"; // key is a combination of db file name and this prefix\n    private static final String PREF_KEY_IV_PREFIX = \"ivFor_\"; // key is a combination of db file name and this prefix\n    private View mView;\n\n    private CheckBox biometricCheck;\n    private EditText passwordView;\n    private Button biometricOpen;\n    private Button biometricClear;\n    private View divider3;\n    private Button confirmButton;\n    private boolean biometricsAvailable = false;\n    private BiometricPrompt biometricSavePrompt;\n    private BiometricPrompt biometricOpenPrompt;\n    private BiometricPrompt.PromptInfo savePrompt;\n    private BiometricPrompt.PromptInfo loadPrompt;\n    private BiometricHelper biometricHelper;\n\n    private Activity mActivity;\n\n    private boolean afterOnCreateBeforeEndOfOnResume = false;\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setHasOptionsMenu(true);\n        setRetainInstance(true);\n        afterOnCreateBeforeEndOfOnResume = true;\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        super.onCreateView(inflater, container, savedInstanceState);\n\n        mView = inflater.inflate(R.layout.password, container, false);\n        return mView;\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        Context context = getContext();\n\n        prefs = PreferenceManager.getDefaultSharedPreferences(mActivity);\n        prefsNoBackup = mActivity.getSharedPreferences(\"nobackup\", Context.MODE_PRIVATE);\n\n        mRememberKeyfile = prefs.getBoolean(getString(R.string.keyfile_key), getResources().getBoolean(R.bool.keyfile_default));\n        confirmButton = (Button) view.findViewById(R.id.pass_ok);\n        passwordView = (EditText) view.findViewById(R.id.password);\n        biometricOpen = (Button) view.findViewById(R.id.open_biometric);\n        biometricClear = (Button) view.findViewById(R.id.clear_biometric);\n        divider3 = view.findViewById(R.id.divider3);\n        biometricCheck = (CheckBox) view.findViewById(R.id.save_password);\n\n        biometricOpen.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                biometricLogin();\n            }\n        });\n\n        biometricClear.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                clearStoredCredentials();\n            }\n        });\n    }\n\n    private void biometricLogin() {\n        if (!initDecryptData()) {\n            return;\n        }\n\n        biometricCheck.setChecked(false);\n\n        Cipher cipher = biometricHelper.getCipher();\n        biometricOpenPrompt.authenticate(loadPrompt, new BiometricPrompt.CryptoObject(cipher));\n    }\n\n    @Override\n    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {\n        super.onCreateOptionsMenu(menu, inflater);\n\n        MenuInflater inflate = mActivity.getMenuInflater();\n        inflate.inflate(R.menu.password, menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Context context = getContext();\n        switch (item.getItemId()) {\n            case R.id.menu_about:\n                AboutDialog dialog = new AboutDialog(context);\n                dialog.show();\n                return true;\n\n            case R.id.menu_app_settings:\n                AppSettingsActivity.Launch(context);\n                return true;\n        }\n\n        return super.onContextItemSelected(item);\n    }\n\n    @Override\n    public void onAttach(@NonNull Context context) {\n        super.onAttach(context);\n\n        if (context instanceof Activity) {\n            mActivity = (Activity) context;\n        }\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n\n        mActivity = null;\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        mActivity = null;\n    }\n\n    private void setFingerPrintVisibilty() {\n        if (biometricsAvailable) {\n            biometricCheck.setVisibility(View.VISIBLE);\n        } else {\n            biometricCheck.setVisibility(View.GONE);\n        }\n\n        biometricOpenUpdateVisibility();\n    }\n\n    private void biometricOpenUpdateVisibility() {\n        int visibility;\n        boolean autoOpen = false;\n        BiometricManager biometricManager = BiometricManager.from(mActivity);\n        int auth = biometricManager.canAuthenticate();\n        if (biometricsAvailable && auth != BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED) {\n            String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null);\n            String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null);\n\n            boolean hasStoredKey = encryptedValue != null && ivSpecValue != null;\n            if (hasStoredKey) {\n                // Check key value\n                visibility = View.VISIBLE;\n                autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key),\n                        getResources().getBoolean(R.bool.biometric_autoscan))\n                        && afterOnCreateBeforeEndOfOnResume;\n            } else {\n                visibility = View.GONE;\n            }\n\n        } else {\n            visibility = View.GONE;\n        }\n\n        biometricOpen.setVisibility(visibility);\n        biometricClear.setVisibility(visibility);\n        divider3.setVisibility(visibility);\n\n        if (autoOpen) {\n            Thread delayThread = new Thread() {\n                @Override\n                public void run() {\n                    try {\n                        Thread.sleep(100);\n                    } catch (InterruptedException e) {\n                        // Ignore\n                    }\n\n                    mActivity.runOnUiThread(new Runnable() {\n                        @Override\n                        public void run() {\n                            biometricLogin();\n                        }\n                    });\n                }\n            };\n            delayThread.start();\n        }\n    }\n\n    private void initBiometrics() {\n        final Context context = getContext();\n        biometricsAvailable = true;\n\n        biometricHelper = new BiometricHelper(context, this);\n\n        Executor executor = ContextCompat.getMainExecutor(context);\n\n        BiometricPrompt.AuthenticationCallback saveCallback =\n                new BiometricPrompt.AuthenticationCallback() {\n                    @Override\n                    public void onAuthenticationFailed() {\n                        super.onAuthenticationFailed();\n                        Toast.makeText(context, R.string.biometric_auth_failed_store, Toast.LENGTH_LONG).show();\n                        GroupActivity.Launch(mActivity);\n                    }\n\n                    @Override\n                    public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {\n                        super.onAuthenticationSucceeded(result);\n\n                        // newly store the entered password in encrypted way\n                        final String password = passwordView.getText().toString();\n                        biometricHelper.encryptData(password);\n                        GroupActivity.Launch(mActivity);\n\n                    }\n\n                    @Override\n                    public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {\n                        super.onAuthenticationError(errorCode, errString);\n                        if (!canceledBiometricAuth(errorCode)) {\n                            Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show();\n                        }\n                        GroupActivity.Launch(mActivity);\n                    }\n                };\n\n        BiometricPrompt.AuthenticationCallback openCallback =\n                new BiometricPrompt.AuthenticationCallback() {\n                    @Override\n                    public void onAuthenticationFailed() {\n                        super.onAuthenticationFailed();\n                        Toast.makeText(context, R.string.biometric_auth_failed, Toast.LENGTH_LONG).show();\n                    }\n\n                    @Override\n                    public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {\n                        super.onAuthenticationSucceeded(result);\n\n                        // retrieve the encrypted value from preferences\n                        final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null);\n                        if (encryptedValue != null) {\n                            biometricHelper.decryptData(encryptedValue);\n                        }\n                    }\n\n                    @Override\n                    public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {\n                        super.onAuthenticationError(errorCode, errString);\n\n                        if (!canceledBiometricAuth(errorCode)) {\n                            Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show();\n                        }\n                    }\n                };\n\n        biometricSavePrompt = new BiometricPrompt(this, executor, saveCallback);\n        BiometricPrompt.PromptInfo.Builder saveBuilder = new BiometricPrompt.PromptInfo.Builder();\n        savePrompt = saveBuilder.setDescription(getString(R.string.biometric_auth_to_store))\n                .setConfirmationRequired(false)\n                .setTitle(getString(R.string.biometric_save_password))\n                .setNegativeButtonText(getString(android.R.string.cancel))\n                .build();\n\n        biometricOpenPrompt = new BiometricPrompt(this, executor, openCallback);\n        BiometricPrompt.PromptInfo.Builder openBuilder = new BiometricPrompt.PromptInfo.Builder();\n        loadPrompt = openBuilder.setDescription(getString(R.string.biometric_auth_to_open))\n                .setConfirmationRequired(false)\n                .setTitle(getString(R.string.biometric_open_db))\n                .setNegativeButtonText(getString(android.R.string.cancel))\n                .build();\n\n\n        setFingerPrintVisibilty();\n    }\n\n    private boolean canceledBiometricAuth(int errorCode) {\n        switch (errorCode) {\n            case BiometricPrompt.ERROR_CANCELED:\n            case BiometricPrompt.ERROR_USER_CANCELED:\n            case BiometricPrompt.ERROR_NEGATIVE_BUTTON:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n\n    private boolean initDecryptData() {\n        final String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null);\n\n        return biometricHelper.initDecryptData(ivSpecValue);\n    }\n\n\n    @Override\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n\n        Intent i = mActivity.getIntent();\n        new InitTask().execute(i);\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        Activity activity = mActivity;\n\n        switch (requestCode) {\n\n            case KeePass.EXIT_NORMAL:\n                setEditText(R.id.password, \"\");\n                App.getDB().clear(activity.getApplicationContext());\n                break;\n\n            case KeePass.EXIT_LOCK:\n                activity.setResult(KeePass.EXIT_LOCK);\n                setEditText(R.id.password, \"\");\n                activity.finish();\n                App.getDB().clear(activity.getApplicationContext());\n                break;\n            case FILE_BROWSE:\n                if (resultCode == Activity.RESULT_OK) {\n                    String filename = data.getDataString();\n                    if (filename != null) {\n                        EditText fn = (EditText) mView.findViewById(R.id.pass_keyfile);\n                        fn.setText(filename);\n                        mKeyUri = UriUtil.parseDefaultFile(filename);\n                    }\n                }\n                break;\n            case GET_CONTENT:\n            case OPEN_DOC:\n                if (resultCode == Activity.RESULT_OK) {\n                    if (data != null) {\n                        Uri uri = data.getData();\n                        if (uri != null) {\n                            if (requestCode == GET_CONTENT) {\n                                uri = UriUtil.translate(activity, uri);\n                            }\n                            String path = uri.toString();\n                            if (path != null) {\n                                EditText fn = (EditText) mView.findViewById(R.id.pass_keyfile);\n                                fn.setText(path);\n\n                            }\n                            mKeyUri = uri;\n                        }\n                    }\n                }\n                break;\n        }\n\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        // If the application was shutdown make sure to clear the password field, if it\n        // was saved in the instance state\n        if (App.isShutdown()) {\n            TextView password = (TextView) mView.findViewById(R.id.password);\n            password.setText(\"\");\n        }\n\n        // Clear the shutdown flag\n        App.clearShutdown();\n\n        BiometricManager biometricManager = BiometricManager.from(mActivity);\n        int auth = biometricManager.canAuthenticate();\n        if (auth == BiometricManager.BIOMETRIC_SUCCESS){\n            initBiometrics();\n        } else {\n            biometricsAvailable = false;\n            setFingerPrintVisibilty();\n        }\n\n        afterOnCreateBeforeEndOfOnResume = false;\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n\n        if (requestCode == PERMISSION_REQUEST_ID &&\n                grantResults[0] == PackageManager.PERMISSION_GRANTED &&\n                grantResults[1] == PackageManager.PERMISSION_GRANTED){\n\n            loadDatabaseWithPermission();\n        } else {\n            errorMessage(R.string.no_external_permissions);\n        }\n    }\n\n    private String getPreferenceKeyValue() {\n        // makes it possible to store passwords uniqly per database\n        return PREF_KEY_VALUE_PREFIX + (mDbUri != null ? mDbUri.getPath() : \"\");\n    }\n\n    private String getPreferenceKeyIvSpec() {\n        return PREF_KEY_IV_PREFIX + (mDbUri != null ? mDbUri.getPath() : \"\");\n    }\n\n    private class InitTask extends AsyncTask<Intent, Void, Integer> {\n\n        String password = \"\";\n        boolean launch_immediately = false;\n\n        @Override\n        protected Integer doInBackground(Intent... args) {\n            Intent i = args[0];\n            String action = i.getAction();\n            ;\n            if (action != null && action.equals(VIEW_INTENT)) {\n                Uri incoming = i.getData();\n                mDbUri = incoming;\n\n                mKeyUri = ClipDataCompat.getUriFromIntent(i, PasswordActivity.KEY_KEYFILE);\n\n                if (incoming == null) {\n                    return R.string.error_can_not_handle_uri;\n                } else if (incoming.getScheme().equals(\"file\")) {\n                    String fileName = incoming.getPath();\n\n                    if (fileName.length() == 0) {\n                        // No file name\n                        return R.string.FileNotFound;\n                    }\n\n                    File dbFile = new File(fileName);\n                    if (!dbFile.exists()) {\n                        // File does not exist\n                        return R.string.FileNotFound;\n                    }\n\n                    if (mKeyUri == null) {\n                        mKeyUri = getKeyFile(mDbUri);\n                    }\n                } else if (incoming.getScheme().equals(\"content\")) {\n                    if (mKeyUri == null) {\n                        mKeyUri = getKeyFile(mDbUri);\n                    }\n                } else {\n                    return R.string.error_can_not_handle_uri;\n                }\n                password = i.getStringExtra(KEY_PASSWORD);\n                launch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false);\n\n            } else {\n                mDbUri = UriUtil.parseDefaultFile(i.getStringExtra(PasswordActivity.KEY_FILENAME));\n                mKeyUri = UriUtil.parseDefaultFile(i.getStringExtra(PasswordActivity.KEY_KEYFILE));\n                password = i.getStringExtra(KEY_PASSWORD);\n                launch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false);\n\n                if (mKeyUri == null || mKeyUri.toString().length() == 0) {\n                    mKeyUri = getKeyFile(mDbUri);\n                }\n            }\n\n            biometricOpenUpdateVisibility();\n\n            return null;\n        }\n\n        public void onPostExecute(Integer result) {\n            if (result != null) {\n                Toast.makeText(mActivity, result, Toast.LENGTH_LONG).show();\n                mActivity.finish();\n                return;\n            }\n\n            populateView();\n\n            confirmButton.setOnClickListener(new OkClickHandler());\n\n            CheckBox checkBox = (CheckBox) mView.findViewById(R.id.show_password);\n            // Show or hide password\n            checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\n                public void onCheckedChanged(\n                        CompoundButton buttonView,\n                        boolean isChecked) {\n                    TextView password = (TextView) mView.findViewById(R.id.password);\n\n                    if (isChecked) {\n                        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD);\n                    } else {\n                        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n                    }\n                }\n\n            });\n\n            if (password != null) {\n                TextView tv_password = (TextView) mView.findViewById(R.id.password);\n                tv_password.setText(password);\n            }\n\n            CheckBox defaultCheck = (CheckBox) mView.findViewById(R.id.default_database);\n            defaultCheck.setOnCheckedChangeListener(new DefaultCheckChange());\n\n            ImageButton browse = (ImageButton) mView.findViewById(R.id.browse_button);\n            browse.setOnClickListener(new View.OnClickListener() {\n\n                public void onClick(View v) {\n                    if (StorageAF.useStorageFramework(mActivity)) {\n                        Intent i = new Intent(StorageAF.ACTION_OPEN_DOCUMENT);\n                        i.addCategory(Intent.CATEGORY_OPENABLE);\n                        i.setType(\"*/*\");\n                        startActivityForResult(i, OPEN_DOC);\n                    } else {\n                        Intent i = new Intent(Intent.ACTION_GET_CONTENT);\n                        i.addCategory(Intent.CATEGORY_OPENABLE);\n                        i.setType(\"*/*\");\n\n                        try {\n                            startActivityForResult(i, GET_CONTENT);\n                        } catch (ActivityNotFoundException e) {\n                            lookForOpenIntentsFilePicker();\n                        }\n                    }\n                }\n\n                private void lookForOpenIntentsFilePicker() {\n                    if (Interaction.isIntentAvailable(mActivity, Intents.OPEN_INTENTS_FILE_BROWSE)) {\n                        Intent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);\n\n                        // Get file path parent if possible\n                        try {\n                            if (mDbUri != null && mDbUri.toString().length() > 0) {\n                                if (mDbUri.getScheme().equals(\"file\")) {\n                                    File keyfile = new File(mDbUri.getPath());\n                                    File parent = keyfile.getParentFile();\n                                    if (parent != null) {\n                                        i.setData(Uri.parse(\"file://\" + parent.getAbsolutePath()));\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            // Ignore\n                        }\n\n                        try {\n                            startActivityForResult(i, FILE_BROWSE);\n                        } catch (ActivityNotFoundException e) {\n                            showBrowserDialog();\n                        }\n                    } else {\n                        showBrowserDialog();\n                    }\n                }\n\n                private void showBrowserDialog() {\n                    BrowserDialog diag = new BrowserDialog(mActivity);\n                    diag.show();\n                }\n            });\n\n            retrieveSettings();\n\n            if (launch_immediately) {\n                loadDatabase(password, mKeyUri);\n            }\n        }\n    }\n\n    private class DefaultCheckChange implements CompoundButton.OnCheckedChangeListener {\n\n        @Override\n        public void onCheckedChanged(\n                CompoundButton buttonView,\n                boolean isChecked) {\n\n            String newDefaultFileName;\n\n            if (isChecked) {\n                newDefaultFileName = mDbUri.toString();\n            } else {\n                newDefaultFileName = \"\";\n            }\n\n            SharedPreferences.Editor editor = prefs.edit();\n            editor.putString(PasswordActivity.KEY_DEFAULT_FILENAME, newDefaultFileName);\n            editor.apply();\n\n            BackupManager backupManager = new BackupManager(getContext());\n            backupManager.dataChanged();\n\n        }\n\n    }\n\n    private void retrieveSettings() {\n        String defaultFilename = prefs.getString(PasswordActivity.KEY_DEFAULT_FILENAME, \"\");\n        if (!EmptyUtils.isNullOrEmpty(mDbUri.getPath()) && UriUtil.equalsDefaultfile(mDbUri, defaultFilename)) {\n            CheckBox checkbox = (CheckBox) mView.findViewById(R.id.default_database);\n            checkbox.setChecked(true);\n        }\n    }\n\n    private Uri getKeyFile(Uri dbUri) {\n        if (mRememberKeyfile) {\n\n            return App.getFileHistory().getFileByName(dbUri);\n        } else {\n            return null;\n        }\n    }\n\n    private void populateView() {\n        String db = (mDbUri == null) ? \"\" : mDbUri.toString();\n        setEditText(R.id.filename, db);\n\n        String key = (mKeyUri == null) ? \"\" : mKeyUri.toString();\n        setEditText(R.id.pass_keyfile, key);\n    }\n\n    private void errorMessage(int resId) {\n        Toast.makeText(mActivity, resId, Toast.LENGTH_LONG).show();\n    }\n\n    private void setEditText(\n            int resId,\n            String str) {\n\n        TextView te = (TextView) mView.findViewById(resId);\n        assert (te == null);\n\n        if (te != null) {\n            te.setText(str);\n        }\n    }\n    private void loadDatabase(\n            String pass,\n            Uri keyfile) {\n        if (pass.length() == 0 && (keyfile == null || keyfile.toString().length() == 0)) {\n            errorMessage(R.string.error_nopass);\n            return;\n        }\n\n        storedPassword = pass;\n        storedKeyUri = keyfile;\n\n        if (checkFilePermissions(mDbUri, keyfile)) {\n            loadDatabaseWithPermission();\n        }\n    }\n\n    private void loadDatabaseWithPermission() {\n        String pass = storedPassword;\n        storedPassword = null;\n        Uri keyfile = storedKeyUri;\n        storedKeyUri = null;\n        Activity activity = mActivity;\n\n\n        // Clear before we load\n        Database db = App.getDB();\n        db.clear(activity.getApplicationContext());\n\n        // Clear the shutdown flag\n        App.clearShutdown();\n\n        Handler handler = new Handler();\n        LoadDB task = new LoadDB(db, activity, mDbUri, pass, keyfile, new PasswordFragment.AfterLoad(handler, db));\n        ProgressTask pt = new ProgressTask(activity, task, R.string.loading_database);\n        pt.run();\n    }\n\n    private String getEditText(int resId) {\n        return Util.getEditText(mActivity, resId);\n    }\n    private final class AfterLoad extends OnFinish {\n\n        private Database db;\n\n        public AfterLoad(\n                Handler handler,\n                Database db) {\n            super(handler);\n\n            this.db = db;\n        }\n\n        @Override\n        public void run() {\n            final Activity activity = mActivity;\n            if (db.passwordEncodingError) {\n                PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper();\n                dialog.show(activity, new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(\n                            DialogInterface dialog,\n                            int which) {\n                        GroupActivity.Launch(activity);\n                    }\n\n                });\n            } else if (mSuccess) {\n                if (biometricCheck.isChecked()) {\n                    if (!biometricHelper.initEncryptData()) {\n                        return;\n                    }\n                    Cipher cipher = biometricHelper.getCipher();\n\n                    biometricSavePrompt.authenticate(savePrompt, new BiometricPrompt.CryptoObject(cipher));\n\n                }\n                else {\n                    GroupActivity.Launch(activity);\n                }\n            } else {\n                displayMessage(activity);\n            }\n        }\n    }\n\n    private class OkClickHandler implements View.OnClickListener {\n\n        public void onClick(View view) {\n            String pass = getEditText(R.id.password);\n            String key = getEditText(R.id.pass_keyfile);\n\n            loadDatabase(pass, key);\n        }\n    }\n\n    private void loadDatabase(\n            String pass,\n            String keyfile) {\n\n        loadDatabase(pass, UriUtil.parseDefaultFile(keyfile));\n    }\n\n    private boolean hasFileUri(Uri uri) {\n        try {\n            if (uri == null) { return false; }\n\n            return uri.getScheme().equalsIgnoreCase(\"file\");\n        } catch (Exception e) {\n            return false;\n        }\n\n    }\n\n    private void clearStoredCredentials() {\n        prefsNoBackup.edit()\n                .remove(getPreferenceKeyValue())\n                .remove(getPreferenceKeyIvSpec())\n                .commit();\n        setFingerPrintVisibilty();\n    }\n\n    @Override\n    public void handleEncryptedResult(String value, String ivSpec) {\n        prefsNoBackup.edit()\n                .putString(getPreferenceKeyValue(), value)\n                .putString(getPreferenceKeyIvSpec(), ivSpec)\n                .commit();\n        // and remove visual input to reset UI\n        Toast.makeText(getContext(), R.string.encrypted_value_stored, Toast.LENGTH_SHORT).show();\n\n    }\n\n    @Override\n    public void handleDecryptedResult(String value) {\n        // on decrypt enter it for the purchase/login action\n        passwordView.setText(value);\n        confirmButton.performClick();\n    }\n\n    @Override\n    public void onInvalidKeyException() {\n        Toast.makeText(getContext(), R.string.fingerprint_invalid_key, Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void onException() {\n        onException(true);\n    }\n\n    @Override\n    public void onException(boolean showWarningMessage) {\n        if (showWarningMessage) {\n            onException(R.string.biometric_error);\n        }\n    }\n\n    @Override\n    public void onException(CharSequence message) {\n        Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void onException(int resId) {\n        Toast.makeText(getContext(), resId, Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void onKeyInvalidated() {\n        clearStoredCredentials();\n        Toast.makeText(getContext(), R.string.biometric_invalidated, Toast.LENGTH_LONG).show();\n    }\n\n    private boolean checkFilePermissions(Uri db, Uri keyfile) {\n        boolean hasFileUri = hasFileUri(db) ||\n                hasFileUri(keyfile);\n\n        if (!hasFileUri) return true;\n\n        return PermissionUtil.checkAndRequest(this.mActivity, PERMISSION_REQUEST_ID);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2020 Brian Pellin\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.fragments;\n\nimport android.app.Activity;\nimport android.app.backup.BackupManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.content.pm.PackageManager;\nimport android.net.Uri;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.text.InputType;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport androidx.annotation.NonNull;\nimport androidx.annotation.Nullable;\nimport androidx.biometric.BiometricManager;\nimport androidx.biometric.BiometricPrompt;\nimport androidx.core.content.ContextCompat;\nimport androidx.fragment.app.Fragment;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.AboutDialog;\nimport com.keepassdroid.Database;\nimport com.keepassdroid.GroupActivity;\nimport com.keepassdroid.PasswordActivity;\nimport com.keepassdroid.ProgressTask;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.compat.ClipDataCompat;\nimport com.keepassdroid.compat.StorageAF;\nimport com.keepassdroid.database.edit.LoadDB;\nimport com.keepassdroid.database.edit.OnFinish;\nimport com.keepassdroid.dialog.PasswordEncodingDialogHelper;\nimport com.keepassdroid.fileselect.BrowserDialog;\nimport com.keepassdroid.biometric.BiometricHelper;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.settings.AppSettingsActivity;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.Interaction;\nimport com.keepassdroid.utils.PermissionUtil;\nimport com.keepassdroid.utils.UriUtil;\nimport com.keepassdroid.utils.Util;\n\nimport java.io.File;\nimport java.util.concurrent.Executor;\n\nimport javax.crypto.Cipher;\n\npublic class PasswordFragment extends Fragment implements BiometricHelper.BiometricCallback {\n    private static final int FILE_BROWSE = 256;\n    public static final int GET_CONTENT = 257;\n    private static final int OPEN_DOC = 258;\n\n    private static final String KEY_PASSWORD = \"password\";\n    private static final String KEY_LAUNCH_IMMEDIATELY = \"launchImmediately\";\n    private static final String VIEW_INTENT = \"android.intent.action.VIEW\";\n\n    private static final int PERMISSION_REQUEST_ID = 1;\n\n    private Uri mDbUri = null;\n    private Uri mKeyUri = null;\n    private boolean mRememberKeyfile;\n    SharedPreferences prefs;\n    SharedPreferences prefsNoBackup;\n\n    private Uri storedKeyUri = null;\n    private String storedPassword = null;\n    private int mode;\n    private static final String PREF_KEY_VALUE_PREFIX = \"valueFor_\"; // key is a combination of db file name and this prefix\n    private static final String PREF_KEY_IV_PREFIX = \"ivFor_\"; // key is a combination of db file name and this prefix\n    private View mView;\n\n    private CheckBox biometricCheck;\n    private EditText passwordView;\n    private Button biometricOpen;\n    private Button biometricClear;\n    private View divider3;\n    private Button confirmButton;\n    private boolean biometricsAvailable = false;\n    private BiometricPrompt biometricSavePrompt;\n    private BiometricPrompt biometricOpenPrompt;\n    private BiometricPrompt.PromptInfo savePrompt;\n    private BiometricPrompt.PromptInfo loadPrompt;\n    private BiometricHelper biometricHelper;\n\n    private Activity mActivity;\n\n    private boolean afterOnCreateBeforeEndOfOnResume = false;\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setHasOptionsMenu(true);\n        setRetainInstance(true);\n        afterOnCreateBeforeEndOfOnResume = true;\n    }\n\n    @Override\n    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        super.onCreateView(inflater, container, savedInstanceState);\n\n        mView = inflater.inflate(R.layout.password, container, false);\n        return mView;\n    }\n\n    @Override\n    public void onViewCreated(@NonNull View view, @Nullable Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        Context context = getContext();\n\n        prefs = PreferenceManager.getDefaultSharedPreferences(mActivity);\n        prefsNoBackup = mActivity.getSharedPreferences(\"nobackup\", Context.MODE_PRIVATE);\n\n        mRememberKeyfile = prefs.getBoolean(getString(R.string.keyfile_key), getResources().getBoolean(R.bool.keyfile_default));\n        confirmButton = (Button) view.findViewById(R.id.pass_ok);\n        passwordView = (EditText) view.findViewById(R.id.password);\n        biometricOpen = (Button) view.findViewById(R.id.open_biometric);\n        biometricClear = (Button) view.findViewById(R.id.clear_biometric);\n        divider3 = view.findViewById(R.id.divider3);\n        biometricCheck = (CheckBox) view.findViewById(R.id.save_password);\n\n        biometricOpen.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                biometricLogin();\n            }\n        });\n\n        biometricClear.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                clearStoredCredentials();\n            }\n        });\n    }\n\n    private void biometricLogin() {\n        if (!initDecryptData()) {\n            return;\n        }\n\n        biometricCheck.setChecked(false);\n\n        Cipher cipher = biometricHelper.getCipher();\n        biometricOpenPrompt.authenticate(loadPrompt, new BiometricPrompt.CryptoObject(cipher));\n    }\n\n    @Override\n    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {\n        super.onCreateOptionsMenu(menu, inflater);\n\n        MenuInflater inflate = mActivity.getMenuInflater();\n        inflate.inflate(R.menu.password, menu);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        Context context = getContext();\n        switch (item.getItemId()) {\n            case R.id.menu_about:\n                AboutDialog dialog = new AboutDialog(context);\n                dialog.show();\n                return true;\n\n            case R.id.menu_app_settings:\n                AppSettingsActivity.Launch(context);\n                return true;\n        }\n\n        return super.onContextItemSelected(item);\n    }\n\n    @Override\n    public void onAttach(@NonNull Context context) {\n        super.onAttach(context);\n\n        if (context instanceof Activity) {\n            mActivity = (Activity) context;\n        }\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n\n        mActivity = null;\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n\n        mActivity = null;\n    }\n\n    private void setFingerPrintVisibilty() {\n        if (biometricsAvailable) {\n            biometricCheck.setVisibility(View.VISIBLE);\n        } else {\n            biometricCheck.setVisibility(View.GONE);\n        }\n\n        biometricOpenUpdateVisibility();\n    }\n\n    private void biometricOpenUpdateVisibility() {\n        int visibility;\n        boolean autoOpen = false;\n        BiometricManager biometricManager = BiometricManager.from(mActivity);\n        int auth = biometricManager.canAuthenticate();\n        if (biometricsAvailable && auth != BiometricManager.BIOMETRIC_ERROR_NONE_ENROLLED) {\n            String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null);\n            String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null);\n\n            boolean hasStoredKey = encryptedValue != null && ivSpecValue != null;\n            if (hasStoredKey) {\n                // Check key value\n                visibility = View.VISIBLE;\n                autoOpen = prefs.getBoolean(getString(R.string.biometric_autoscan_key),\n                        getResources().getBoolean(R.bool.biometric_autoscan))\n                        && afterOnCreateBeforeEndOfOnResume;\n            } else {\n                visibility = View.GONE;\n            }\n\n        } else {\n            visibility = View.GONE;\n        }\n\n        biometricOpen.setVisibility(visibility);\n        biometricClear.setVisibility(visibility);\n        divider3.setVisibility(visibility);\n\n        if (autoOpen) {\n            biometricLogin();\n        }\n    }\n\n    private void initBiometrics() {\n        final Context context = getContext();\n        biometricsAvailable = true;\n\n        biometricHelper = new BiometricHelper(context, this);\n\n        Executor executor = ContextCompat.getMainExecutor(context);\n\n        BiometricPrompt.AuthenticationCallback saveCallback =\n                new BiometricPrompt.AuthenticationCallback() {\n                    @Override\n                    public void onAuthenticationFailed() {\n                        super.onAuthenticationFailed();\n                        Toast.makeText(context, R.string.biometric_auth_failed_store, Toast.LENGTH_LONG).show();\n                        GroupActivity.Launch(mActivity);\n                    }\n\n                    @Override\n                    public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {\n                        super.onAuthenticationSucceeded(result);\n\n                        // newly store the entered password in encrypted way\n                        final String password = passwordView.getText().toString();\n                        biometricHelper.encryptData(password);\n                        GroupActivity.Launch(mActivity);\n\n                    }\n\n                    @Override\n                    public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {\n                        super.onAuthenticationError(errorCode, errString);\n                        if (!canceledBiometricAuth(errorCode)) {\n                            Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show();\n                        }\n                        GroupActivity.Launch(mActivity);\n                    }\n                };\n\n        BiometricPrompt.AuthenticationCallback openCallback =\n                new BiometricPrompt.AuthenticationCallback() {\n                    @Override\n                    public void onAuthenticationFailed() {\n                        super.onAuthenticationFailed();\n                        Toast.makeText(context, R.string.biometric_auth_failed, Toast.LENGTH_LONG).show();\n                    }\n\n                    @Override\n                    public void onAuthenticationSucceeded(@NonNull BiometricPrompt.AuthenticationResult result) {\n                        super.onAuthenticationSucceeded(result);\n\n                        // retrieve the encrypted value from preferences\n                        final String encryptedValue = prefsNoBackup.getString(getPreferenceKeyValue(), null);\n                        if (encryptedValue != null) {\n                            biometricHelper.decryptData(encryptedValue);\n                        }\n                    }\n\n                    @Override\n                    public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) {\n                        super.onAuthenticationError(errorCode, errString);\n\n                        if (!canceledBiometricAuth(errorCode)) {\n                            Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show();\n                        }\n                    }\n                };\n\n        biometricSavePrompt = new BiometricPrompt(this, executor, saveCallback);\n        BiometricPrompt.PromptInfo.Builder saveBuilder = new BiometricPrompt.PromptInfo.Builder();\n        savePrompt = saveBuilder.setDescription(getString(R.string.biometric_auth_to_store))\n                .setConfirmationRequired(false)\n                .setTitle(getString(R.string.biometric_save_password))\n                .setNegativeButtonText(getString(android.R.string.cancel))\n                .build();\n\n        biometricOpenPrompt = new BiometricPrompt(this, executor, openCallback);\n        BiometricPrompt.PromptInfo.Builder openBuilder = new BiometricPrompt.PromptInfo.Builder();\n        loadPrompt = openBuilder.setDescription(getString(R.string.biometric_auth_to_open))\n                .setConfirmationRequired(false)\n                .setTitle(getString(R.string.biometric_open_db))\n                .setNegativeButtonText(getString(android.R.string.cancel))\n                .build();\n\n\n        setFingerPrintVisibilty();\n    }\n\n    private boolean canceledBiometricAuth(int errorCode) {\n        switch (errorCode) {\n            case BiometricPrompt.ERROR_CANCELED:\n            case BiometricPrompt.ERROR_USER_CANCELED:\n            case BiometricPrompt.ERROR_NEGATIVE_BUTTON:\n                return true;\n            default:\n                return false;\n        }\n    }\n\n\n    private boolean initDecryptData() {\n        final String ivSpecValue = prefsNoBackup.getString(getPreferenceKeyIvSpec(), null);\n\n        return biometricHelper.initDecryptData(ivSpecValue);\n    }\n\n\n    @Override\n    public void onActivityCreated(@Nullable Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n\n        Intent i = mActivity.getIntent();\n        InitTask task = new InitTask();\n        task.onPostExecute(task.doInBackground(i));\n    }\n\n    @Override\n    public void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {\n        super.onActivityResult(requestCode, resultCode, data);\n\n        Activity activity = mActivity;\n\n        switch (requestCode) {\n\n            case KeePass.EXIT_NORMAL:\n                setEditText(R.id.password, \"\");\n                App.getDB().clear(activity.getApplicationContext());\n                break;\n\n            case KeePass.EXIT_LOCK:\n                activity.setResult(KeePass.EXIT_LOCK);\n                setEditText(R.id.password, \"\");\n                activity.finish();\n                App.getDB().clear(activity.getApplicationContext());\n                break;\n            case FILE_BROWSE:\n                if (resultCode == Activity.RESULT_OK) {\n                    String filename = data.getDataString();\n                    if (filename != null) {\n                        EditText fn = (EditText) mView.findViewById(R.id.pass_keyfile);\n                        fn.setText(filename);\n                        mKeyUri = UriUtil.parseDefaultFile(filename);\n                    }\n                }\n                break;\n            case GET_CONTENT:\n            case OPEN_DOC:\n                if (resultCode == Activity.RESULT_OK) {\n                    if (data != null) {\n                        Uri uri = data.getData();\n                        if (uri != null) {\n                            if (requestCode == GET_CONTENT) {\n                                uri = UriUtil.translate(activity, uri);\n                            }\n                            String path = uri.toString();\n                            if (path != null) {\n                                EditText fn = (EditText) mView.findViewById(R.id.pass_keyfile);\n                                fn.setText(path);\n\n                            }\n                            mKeyUri = uri;\n                        }\n                    }\n                }\n                break;\n        }\n\n    }\n\n    @Override\n    public void onResume() {\n        super.onResume();\n\n        // If the application was shutdown make sure to clear the password field, if it\n        // was saved in the instance state\n        if (App.isShutdown()) {\n            TextView password = (TextView) mView.findViewById(R.id.password);\n            password.setText(\"\");\n        }\n\n        // Clear the shutdown flag\n        App.clearShutdown();\n\n        BiometricManager biometricManager = BiometricManager.from(mActivity);\n        int auth = biometricManager.canAuthenticate();\n        if (auth == BiometricManager.BIOMETRIC_SUCCESS){\n            initBiometrics();\n        } else {\n            biometricsAvailable = false;\n            setFingerPrintVisibilty();\n        }\n\n        afterOnCreateBeforeEndOfOnResume = false;\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults);\n\n        if (requestCode == PERMISSION_REQUEST_ID &&\n                grantResults[0] == PackageManager.PERMISSION_GRANTED &&\n                grantResults[1] == PackageManager.PERMISSION_GRANTED){\n\n            loadDatabaseWithPermission();\n        } else {\n            errorMessage(R.string.no_external_permissions);\n        }\n    }\n\n    private String getPreferenceKeyValue() {\n        // makes it possible to store passwords uniqly per database\n        return PREF_KEY_VALUE_PREFIX + (mDbUri != null ? mDbUri.getPath() : \"\");\n    }\n\n    private String getPreferenceKeyIvSpec() {\n        return PREF_KEY_IV_PREFIX + (mDbUri != null ? mDbUri.getPath() : \"\");\n    }\n\n    // Moved this to the foreground TOOD: Move this to a more typical pattern\n    private class InitTask {\n\n        String password = \"\";\n        boolean launch_immediately = false;\n\n        public Integer doInBackground(Intent... args) {\n            Intent i = args[0];\n            String action = i.getAction();\n            ;\n            if (action != null && action.equals(VIEW_INTENT)) {\n                Uri incoming = i.getData();\n                mDbUri = incoming;\n\n                mKeyUri = ClipDataCompat.getUriFromIntent(i, PasswordActivity.KEY_KEYFILE);\n\n                if (incoming == null) {\n                    return R.string.error_can_not_handle_uri;\n                } else if (incoming.getScheme().equals(\"file\")) {\n                    String fileName = incoming.getPath();\n\n                    if (fileName.length() == 0) {\n                        // No file name\n                        return R.string.FileNotFound;\n                    }\n\n                    File dbFile = new File(fileName);\n                    if (!dbFile.exists()) {\n                        // File does not exist\n                        return R.string.FileNotFound;\n                    }\n\n                    if (mKeyUri == null) {\n                        mKeyUri = getKeyFile(mDbUri);\n                    }\n                } else if (incoming.getScheme().equals(\"content\")) {\n                    if (mKeyUri == null) {\n                        mKeyUri = getKeyFile(mDbUri);\n                    }\n                } else {\n                    return R.string.error_can_not_handle_uri;\n                }\n                password = i.getStringExtra(KEY_PASSWORD);\n                launch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false);\n\n            } else {\n                mDbUri = UriUtil.parseDefaultFile(i.getStringExtra(PasswordActivity.KEY_FILENAME));\n                mKeyUri = UriUtil.parseDefaultFile(i.getStringExtra(PasswordActivity.KEY_KEYFILE));\n                password = i.getStringExtra(KEY_PASSWORD);\n                launch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false);\n\n                if (mKeyUri == null || mKeyUri.toString().length() == 0) {\n                    mKeyUri = getKeyFile(mDbUri);\n                }\n            }\n\n            biometricOpenUpdateVisibility();\n\n            return null;\n        }\n\n        public void onPostExecute(Integer result) {\n            if (result != null) {\n                Toast.makeText(mActivity, result, Toast.LENGTH_LONG).show();\n                mActivity.finish();\n                return;\n            }\n\n            populateView();\n\n            confirmButton.setOnClickListener(new OkClickHandler());\n\n            CheckBox checkBox = (CheckBox) mView.findViewById(R.id.show_password);\n            // Show or hide password\n            checkBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {\n\n                public void onCheckedChanged(\n                        CompoundButton buttonView,\n                        boolean isChecked) {\n                    TextView password = (TextView) mView.findViewById(R.id.password);\n\n                    if (isChecked) {\n                        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD);\n                    } else {\n                        password.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n                    }\n                }\n\n            });\n\n            if (password != null) {\n                TextView tv_password = (TextView) mView.findViewById(R.id.password);\n                tv_password.setText(password);\n            }\n\n            CheckBox defaultCheck = (CheckBox) mView.findViewById(R.id.default_database);\n            defaultCheck.setOnCheckedChangeListener(new DefaultCheckChange());\n\n            ImageButton browse = (ImageButton) mView.findViewById(R.id.browse_button);\n            browse.setOnClickListener(new View.OnClickListener() {\n\n                public void onClick(View v) {\n                    if (StorageAF.useStorageFramework(mActivity)) {\n                        Intent i = new Intent(StorageAF.ACTION_OPEN_DOCUMENT);\n                        i.addCategory(Intent.CATEGORY_OPENABLE);\n                        i.setType(\"*/*\");\n                        startActivityForResult(i, OPEN_DOC);\n                    } else {\n                        Intent i = new Intent(Intent.ACTION_GET_CONTENT);\n                        i.addCategory(Intent.CATEGORY_OPENABLE);\n                        i.setType(\"*/*\");\n\n                        try {\n                            startActivityForResult(i, GET_CONTENT);\n                        } catch (ActivityNotFoundException e) {\n                            lookForOpenIntentsFilePicker();\n                        }\n                    }\n                }\n\n                private void lookForOpenIntentsFilePicker() {\n                    if (Interaction.isIntentAvailable(mActivity, Intents.OPEN_INTENTS_FILE_BROWSE)) {\n                        Intent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);\n\n                        // Get file path parent if possible\n                        try {\n                            if (mDbUri != null && mDbUri.toString().length() > 0) {\n                                if (mDbUri.getScheme().equals(\"file\")) {\n                                    File keyfile = new File(mDbUri.getPath());\n                                    File parent = keyfile.getParentFile();\n                                    if (parent != null) {\n                                        i.setData(Uri.parse(\"file://\" + parent.getAbsolutePath()));\n                                    }\n                                }\n                            }\n                        } catch (Exception e) {\n                            // Ignore\n                        }\n\n                        try {\n                            startActivityForResult(i, FILE_BROWSE);\n                        } catch (ActivityNotFoundException e) {\n                            showBrowserDialog();\n                        }\n                    } else {\n                        showBrowserDialog();\n                    }\n                }\n\n                private void showBrowserDialog() {\n                    BrowserDialog diag = new BrowserDialog(mActivity);\n                    diag.show();\n                }\n            });\n\n            retrieveSettings();\n\n            if (launch_immediately) {\n                loadDatabase(password, mKeyUri);\n            }\n        }\n    }\n\n    private class DefaultCheckChange implements CompoundButton.OnCheckedChangeListener {\n\n        @Override\n        public void onCheckedChanged(\n                CompoundButton buttonView,\n                boolean isChecked) {\n\n            String newDefaultFileName;\n\n            if (isChecked) {\n                newDefaultFileName = mDbUri.toString();\n            } else {\n                newDefaultFileName = \"\";\n            }\n\n            SharedPreferences.Editor editor = prefs.edit();\n            editor.putString(PasswordActivity.KEY_DEFAULT_FILENAME, newDefaultFileName);\n            editor.apply();\n\n            BackupManager backupManager = new BackupManager(getContext());\n            backupManager.dataChanged();\n\n        }\n\n    }\n\n    private void retrieveSettings() {\n        String defaultFilename = prefs.getString(PasswordActivity.KEY_DEFAULT_FILENAME, \"\");\n        if (!EmptyUtils.isNullOrEmpty(mDbUri.getPath()) && UriUtil.equalsDefaultfile(mDbUri, defaultFilename)) {\n            CheckBox checkbox = (CheckBox) mView.findViewById(R.id.default_database);\n            checkbox.setChecked(true);\n        }\n    }\n\n    private Uri getKeyFile(Uri dbUri) {\n        if (mRememberKeyfile) {\n\n            return App.getFileHistory().getFileByName(dbUri);\n        } else {\n            return null;\n        }\n    }\n\n    private void populateView() {\n        String db = (mDbUri == null) ? \"\" : mDbUri.toString();\n        setEditText(R.id.filename, db);\n\n        String key = (mKeyUri == null) ? \"\" : mKeyUri.toString();\n        setEditText(R.id.pass_keyfile, key);\n    }\n\n    private void errorMessage(int resId) {\n        Toast.makeText(mActivity, resId, Toast.LENGTH_LONG).show();\n    }\n\n    private void setEditText(\n            int resId,\n            String str) {\n\n        TextView te = (TextView) mView.findViewById(resId);\n        assert (te == null);\n\n        if (te != null) {\n            te.setText(str);\n        }\n    }\n    private void loadDatabase(\n            String pass,\n            Uri keyfile) {\n        if (pass.length() == 0 && (keyfile == null || keyfile.toString().length() == 0)) {\n            errorMessage(R.string.error_nopass);\n            return;\n        }\n\n        storedPassword = pass;\n        storedKeyUri = keyfile;\n\n        if (checkFilePermissions(mDbUri, keyfile)) {\n            loadDatabaseWithPermission();\n        }\n    }\n\n    private void loadDatabaseWithPermission() {\n        String pass = storedPassword;\n        storedPassword = null;\n        Uri keyfile = storedKeyUri;\n        storedKeyUri = null;\n        Activity activity = mActivity;\n\n\n        // Clear before we load\n        Database db = App.getDB();\n        db.clear(activity.getApplicationContext());\n\n        // Clear the shutdown flag\n        App.clearShutdown();\n\n        Handler handler = new Handler();\n        LoadDB task = new LoadDB(db, activity, mDbUri, pass, keyfile, new PasswordFragment.AfterLoad(handler, db));\n        ProgressTask pt = new ProgressTask(activity, task, R.string.loading_database);\n        pt.run();\n    }\n\n    private String getEditText(int resId) {\n        return Util.getEditText(mActivity, resId);\n    }\n    private final class AfterLoad extends OnFinish {\n\n        private Database db;\n\n        public AfterLoad(\n                Handler handler,\n                Database db) {\n            super(handler);\n\n            this.db = db;\n        }\n\n        @Override\n        public void run() {\n            final Activity activity = mActivity;\n            if (db.passwordEncodingError) {\n                PasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper();\n                dialog.show(activity, new DialogInterface.OnClickListener() {\n\n                    @Override\n                    public void onClick(\n                            DialogInterface dialog,\n                            int which) {\n                        GroupActivity.Launch(activity);\n                    }\n\n                });\n            } else if (mSuccess) {\n                if (biometricCheck.isChecked()) {\n                    if (!biometricHelper.initEncryptData()) {\n                        return;\n                    }\n                    Cipher cipher = biometricHelper.getCipher();\n\n                    biometricSavePrompt.authenticate(savePrompt, new BiometricPrompt.CryptoObject(cipher));\n\n                }\n                else {\n                    GroupActivity.Launch(activity);\n                }\n            } else {\n                displayMessage(activity);\n            }\n        }\n    }\n\n    private class OkClickHandler implements View.OnClickListener {\n\n        public void onClick(View view) {\n            String pass = getEditText(R.id.password);\n            String key = getEditText(R.id.pass_keyfile);\n\n            loadDatabase(pass, key);\n        }\n    }\n\n    private void loadDatabase(\n            String pass,\n            String keyfile) {\n\n        loadDatabase(pass, UriUtil.parseDefaultFile(keyfile));\n    }\n\n    private boolean hasFileUri(Uri uri) {\n        try {\n            if (uri == null) { return false; }\n\n            return uri.getScheme().equalsIgnoreCase(\"file\");\n        } catch (Exception e) {\n            return false;\n        }\n\n    }\n\n    private void clearStoredCredentials() {\n        prefsNoBackup.edit()\n                .remove(getPreferenceKeyValue())\n                .remove(getPreferenceKeyIvSpec())\n                .commit();\n        setFingerPrintVisibilty();\n    }\n\n    @Override\n    public void handleEncryptedResult(String value, String ivSpec) {\n        prefsNoBackup.edit()\n                .putString(getPreferenceKeyValue(), value)\n                .putString(getPreferenceKeyIvSpec(), ivSpec)\n                .commit();\n        // and remove visual input to reset UI\n        Toast.makeText(getContext(), R.string.encrypted_value_stored, Toast.LENGTH_SHORT).show();\n\n    }\n\n    @Override\n    public void handleDecryptedResult(String value) {\n        // on decrypt enter it for the purchase/login action\n        passwordView.setText(value);\n        confirmButton.performClick();\n    }\n\n    @Override\n    public void onInvalidKeyException() {\n        Toast.makeText(getContext(), R.string.fingerprint_invalid_key, Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void onException() {\n        onException(true);\n    }\n\n    @Override\n    public void onException(boolean showWarningMessage) {\n        if (showWarningMessage) {\n            onException(R.string.biometric_error);\n        }\n    }\n\n    @Override\n    public void onException(CharSequence message) {\n        Toast.makeText(getContext(), message, Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void onException(int resId) {\n        Toast.makeText(getContext(), resId, Toast.LENGTH_SHORT).show();\n    }\n\n    @Override\n    public void onKeyInvalidated() {\n        clearStoredCredentials();\n        Toast.makeText(getContext(), R.string.biometric_invalidated, Toast.LENGTH_LONG).show();\n    }\n\n    private boolean checkFilePermissions(Uri db, Uri keyfile) {\n        boolean hasFileUri = hasFileUri(db) ||\n                hasFileUri(keyfile);\n\n        if (!hasFileUri) return true;\n\n        return PermissionUtil.checkAndRequest(this.mActivity, PERMISSION_REQUEST_ID);\n    }\n}\n","lineNo":388}
{"Smelly Sample":"/*\n * Copyright 2017 Brian Pellin.\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDbHeaderV4.KdbxBinaryFlags;\nimport com.keepassdroid.database.PwDbHeaderV4.PwDbInnerHeaderV4Fields;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.stream.LEDataOutputStream;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class PwDbInnerHeaderOutputV4 {\n    private PwDatabaseV4 db;\n    private PwDbHeaderV4 header;\n    private LEDataOutputStream los;\n\n    public PwDbInnerHeaderOutputV4(PwDatabaseV4 db, PwDbHeaderV4 header, OutputStream os) {\n        this.db = db;\n        this.header = header;\n\n        this.los = new LEDataOutputStream(os);\n    }\n\n    public void output() throws IOException {\n        los.write(PwDbInnerHeaderV4Fields.InnerRandomStreamID);\n        los.writeInt(4);\n        los.writeInt(header.innerRandomStream.id);\n\n        int streamKeySize = header.innerRandomStreamKey.length;\n        los.write(PwDbInnerHeaderV4Fields.InnerRandomstreamKey);\n        los.writeInt(streamKeySize);\n        los.write(header.innerRandomStreamKey);\n\n        for (ProtectedBinary bin : db.binPool.binaries()) {\n            byte flag = KdbxBinaryFlags.None;\n            if (bin.isProtected()) {\n                flag |= KdbxBinaryFlags.Protected;\n            }\n\n            los.write(PwDbInnerHeaderV4Fields.Binary);\n            los.writeInt((int) bin.length() + 1);\n            los.write(flag);\n\n            byte[] buffer = new byte[3 * 256];\n            InputStream fileInputStream = bin.getData();\n            // To create the last buffer who is smaller\n            long numberOfFullBuffer = bin.length() / buffer.length;\n            long sizeOfFullBuffers = numberOfFullBuffer * buffer.length;\n            int read = 0;\n            //if (protectedBinary.length() > 0) {\n            while (read < bin.length()) {\n                // Create the last smaller buffer\n                if (read >= sizeOfFullBuffers)\n                    buffer = new byte[(int) (bin.length() % buffer.length)];\n                read += fileInputStream.read(buffer, 0, buffer.length);\n                los.write(buffer);\n            }\n        }\n\n        los.write(PwDbInnerHeaderV4Fields.EndOfHeader);\n        los.writeInt(0);\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2017 Brian Pellin.\n *\n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDbHeaderV4.KdbxBinaryFlags;\nimport com.keepassdroid.database.PwDbHeaderV4.PwDbInnerHeaderV4Fields;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.utils.Util;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\npublic class PwDbInnerHeaderOutputV4 {\n    private PwDatabaseV4 db;\n    private PwDbHeaderV4 header;\n    private LEDataOutputStream los;\n\n    public PwDbInnerHeaderOutputV4(PwDatabaseV4 db, PwDbHeaderV4 header, OutputStream os) {\n        this.db = db;\n        this.header = header;\n\n        this.los = new LEDataOutputStream(os);\n    }\n\n    public void output() throws IOException {\n        los.write(PwDbInnerHeaderV4Fields.InnerRandomStreamID);\n        los.writeInt(4);\n        los.writeInt(header.innerRandomStream.id);\n\n        int streamKeySize = header.innerRandomStreamKey.length;\n        los.write(PwDbInnerHeaderV4Fields.InnerRandomstreamKey);\n        los.writeInt(streamKeySize);\n        los.write(header.innerRandomStreamKey);\n\n        for (ProtectedBinary bin : db.binPool.binaries()) {\n            byte flag = KdbxBinaryFlags.None;\n            if (bin.isProtected()) {\n                flag |= KdbxBinaryFlags.Protected;\n            }\n\n            los.write(PwDbInnerHeaderV4Fields.Binary);\n            los.writeInt((int) bin.length() + 1);\n            los.write(flag);\n\n            InputStream inputStream = bin.getData();\n            int binLength = bin.length();\n            Util.copyStream(inputStream, los);\n\n        }\n\n        los.write(PwDbInnerHeaderV4Fields.EndOfHeader);\n        los.writeInt(0);\n    }\n\n}\n","lineNo":67}
{"Smelly Sample":"/*\n * Copyright 2010-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.stream;\n\nimport com.keepassdroid.utils.Types;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.UUID;\n\n\n/** Little endian version of the DataInputStream\n * @author bpellin\n *\n */\npublic class LEDataInputStream extends InputStream {\n\n\tpublic static final long INT_TO_LONG_MASK = 0xffffffffL;\n\t\n\tprivate InputStream baseStream;\n\n\tpublic LEDataInputStream(InputStream in) {\n\t\tbaseStream = in;\n\t}\n\t\n\t/** Read a 32-bit value and return it as a long, so that it can\n\t *  be interpreted as an unsigned integer.\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic long readUInt() throws IOException {\n\t\treturn readUInt(baseStream);\n\t}\n\t\n\tpublic int readInt() throws IOException {\n\t\treturn readInt(baseStream);\n\t}\n\t\n\tpublic long readLong() throws IOException {\n\t\tbyte[] buf = readBytes(8);\n\t\t\n\t\treturn readLong(buf, 0);\n\t}\n\t\n\t@Override\n\tpublic int available() throws IOException {\n\t\treturn baseStream.available();\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tbaseStream.close();\n\t}\n\n\t@Override\n\tpublic void mark(int readlimit) {\n\t\tbaseStream.mark(readlimit);\n\t}\n\n\t@Override\n\tpublic boolean markSupported() {\n\t\treturn baseStream.markSupported();\n\t}\n\n\t@Override\n\tpublic int read() throws IOException {\n\t\treturn baseStream.read();\n\t}\n\n\t@Override\n\tpublic int read(byte[] b, int offset, int length) throws IOException {\n\t\treturn baseStream.read(b, offset, length);\n\t}\n\n\t@Override\n\tpublic int read(byte[] b) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\treturn super.read(b);\n\t}\n\n\t@Override\n\tpublic synchronized void reset() throws IOException {\n\t\tbaseStream.reset();\n\t}\n\n\t@Override\n\tpublic long skip(long n) throws IOException {\n\t\treturn baseStream.skip(n);\n\t}\n\n\tpublic byte[] readBytes(int length) throws IOException {\n\t\tbyte[] buf = new byte[length];\n\t\t\n\t\tint count = 0;\n\t\twhile ( count < length ) {\n\t\t\tint read = read(buf, count, length - count);\n\t\t\t\n\t\t\t// Reached end\n\t\t\tif ( read == -1 ) {\n\t\t\t\t// Stop early\n\t\t\t\tbyte[] early = new byte[count];\n\t\t\t\tSystem.arraycopy(buf, 0, early, 0, count);\n\t\t\t\treturn early;\n\t\t\t}\n\t\t\t\n\t\t\tcount += read;\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tpublic void readBytes(int length, ActionReadBytes actionReadBytes) throws IOException {\n\t\tbyte[] buffer = new byte[1024];\n\n\t\tint offset = 0;\n\t\tint read = 0;\n\t\twhile ( offset < length && read != -1) {\n\n\t\t\tint tempLength = buffer.length;\n\t\t\t// If buffer not needed\n\t\t\tif (length - offset < tempLength)\n\t\t\t\ttempLength = length - offset;\n\t\t\tread = read(buffer, 0, tempLength);\n\t\t\tactionReadBytes.doAction(buffer);\n\t\t\toffset += read;\n\t\t}\n\t}\n\n\tpublic interface ActionReadBytes {\n\t\t/**\n\t\t * Called after each buffer fill\n\t\t * @param buffer filled\n\t\t */\n\t\tvoid doAction(byte[] buffer) throws IOException;\n\t}\n\n\tpublic static int readUShort(InputStream is) throws IOException {\n\t\t  byte[] buf = new byte[2];\n\t\t  \n\t\t  is.read(buf, 0, 2);\n\t\t  \n\t\t  return readUShort(buf, 0); \n\t  }\n\t\n\tpublic int readUShort() throws IOException {\n\t\treturn readUShort(baseStream);\n\t}\n\n\t/**\n\t   * Read an unsigned 16-bit value.\n\t   * \n\t   * @param buf\n\t   * @param offset\n\t   * @return\n\t   */\n\t  public static int readUShort( byte[] buf, int offset ) {\n\t    return (buf[offset + 0] & 0xFF) + ((buf[offset + 1] & 0xFF) << 8);\n\t  }\n\n\tpublic static long readLong( byte buf[], int offset ) {\n\t\treturn ((long)buf[offset + 0] & 0xFF) + (((long)buf[offset + 1] & 0xFF) << 8) \n\t\t+ (((long)buf[offset + 2] & 0xFF) << 16) + (((long)buf[offset + 3] & 0xFF) << 24) \n\t\t+ (((long)buf[offset + 4] & 0xFF) << 32) + (((long)buf[offset + 5] & 0xFF) << 40) \n\t\t+ (((long)buf[offset + 6] & 0xFF) << 48) + (((long)buf[offset + 7] & 0xFF) << 56);\n\t}\n\n\tpublic static long readUInt( byte buf[], int offset ) {\n\t\t  return (readInt(buf, offset) & INT_TO_LONG_MASK);\n\t  }\n\n\tpublic static int readInt(InputStream is) throws IOException {\n\t\t  byte[] buf = new byte[4];\n\t\n\t\t  is.read(buf, 0, 4);\n\t\t  \n\t\t  return readInt(buf, 0);\n\t  }\n\n\tpublic static long readUInt(InputStream is) throws IOException {\n\t\t  return (readInt(is) & INT_TO_LONG_MASK);\n\t  }\n\n\t/**\n\t   * Read a 32-bit value.\n\t   * \n\t   * @param buf\n\t   * @param offset\n\t   * @return\n\t   */\n\t  public static int readInt( byte buf[], int offset ) {\n\t    return (buf[offset + 0] & 0xFF) + ((buf[offset + 1] & 0xFF) << 8) + ((buf[offset + 2] & 0xFF) << 16)\n\t           + ((buf[offset + 3] & 0xFF) << 24);\n\t  }\n\n\t  public UUID readUUID() throws IOException {\n\t\t  byte[] buf = readBytes(16);\n\n\t\t  return Types.bytestoUUID(buf);\n\t  }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2010-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.stream;\n\nimport com.keepassdroid.utils.Types;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.UUID;\n\n\n/** Little endian version of the DataInputStream\n * @author bpellin\n *\n */\npublic class LEDataInputStream extends InputStream {\n\n\tpublic static final long INT_TO_LONG_MASK = 0xffffffffL;\n\t\n\tprivate InputStream baseStream;\n\n\tpublic LEDataInputStream(InputStream in) {\n\t\tbaseStream = in;\n\t}\n\t\n\t/** Read a 32-bit value and return it as a long, so that it can\n\t *  be interpreted as an unsigned integer.\n\t * @return\n\t * @throws IOException\n\t */\n\tpublic long readUInt() throws IOException {\n\t\treturn readUInt(baseStream);\n\t}\n\t\n\tpublic int readInt() throws IOException {\n\t\treturn readInt(baseStream);\n\t}\n\t\n\tpublic long readLong() throws IOException {\n\t\tbyte[] buf = readBytes(8);\n\t\t\n\t\treturn readLong(buf, 0);\n\t}\n\t\n\t@Override\n\tpublic int available() throws IOException {\n\t\treturn baseStream.available();\n\t}\n\n\t@Override\n\tpublic void close() throws IOException {\n\t\tbaseStream.close();\n\t}\n\n\t@Override\n\tpublic void mark(int readlimit) {\n\t\tbaseStream.mark(readlimit);\n\t}\n\n\t@Override\n\tpublic boolean markSupported() {\n\t\treturn baseStream.markSupported();\n\t}\n\n\t@Override\n\tpublic int read() throws IOException {\n\t\treturn baseStream.read();\n\t}\n\n\t@Override\n\tpublic int read(byte[] b, int offset, int length) throws IOException {\n\t\treturn baseStream.read(b, offset, length);\n\t}\n\n\t@Override\n\tpublic int read(byte[] b) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\treturn super.read(b);\n\t}\n\n\t@Override\n\tpublic synchronized void reset() throws IOException {\n\t\tbaseStream.reset();\n\t}\n\n\t@Override\n\tpublic long skip(long n) throws IOException {\n\t\treturn baseStream.skip(n);\n\t}\n\n\tpublic byte[] readBytes(int length) throws IOException {\n\t\tbyte[] buf = new byte[length];\n\t\t\n\t\tint count = 0;\n\t\twhile ( count < length ) {\n\t\t\tint read = read(buf, count, length - count);\n\t\t\t\n\t\t\t// Reached end\n\t\t\tif ( read == -1 ) {\n\t\t\t\t// Stop early\n\t\t\t\tbyte[] early = new byte[count];\n\t\t\t\tSystem.arraycopy(buf, 0, early, 0, count);\n\t\t\t\treturn early;\n\t\t\t}\n\t\t\t\n\t\t\tcount += read;\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tpublic void readBytes(int length, ActionReadBytes actionReadBytes) throws IOException {\n\t\tint bufferSize = 256 * 3;\n\t\tbyte[] buffer = new byte[bufferSize];\n\n\t\tint offset = 0;\n\t\tint read = 0;\n\t\twhile ( offset < length && read != -1) {\n\n\t\t\t// To reduce the buffer for the last bytes reads\n\t\t\tif (length - offset < bufferSize) {\n\t\t\t\tbufferSize = length - offset;\n\t\t\t\tbuffer = new byte[bufferSize];\n\t\t\t}\n\t\t\tread = read(buffer, 0, bufferSize);\n\n\t\t\t// To get only the bytes read\n\t\t\tbyte[] optimizedBuffer;\n\t\t\tif (read >= 0 && buffer.length > read) {\n\t\t\t\toptimizedBuffer = Arrays.copyOf(buffer, read);\n\t\t\t} else {\n\t\t\t\toptimizedBuffer = buffer;\n\t\t\t}\n\t\t\tactionReadBytes.doAction(optimizedBuffer);\n\t\t\toffset += read;\n\t\t}\n\t}\n\n\tpublic static int readUShort(InputStream is) throws IOException {\n\t\t  byte[] buf = new byte[2];\n\t\t  \n\t\t  is.read(buf, 0, 2);\n\t\t  \n\t\t  return readUShort(buf, 0); \n\t  }\n\t\n\tpublic int readUShort() throws IOException {\n\t\treturn readUShort(baseStream);\n\t}\n\n\t/**\n\t   * Read an unsigned 16-bit value.\n\t   * \n\t   * @param buf\n\t   * @param offset\n\t   * @return\n\t   */\n\t  public static int readUShort( byte[] buf, int offset ) {\n\t    return (buf[offset + 0] & 0xFF) + ((buf[offset + 1] & 0xFF) << 8);\n\t  }\n\n\tpublic static long readLong( byte buf[], int offset ) {\n\t\treturn ((long)buf[offset + 0] & 0xFF) + (((long)buf[offset + 1] & 0xFF) << 8) \n\t\t+ (((long)buf[offset + 2] & 0xFF) << 16) + (((long)buf[offset + 3] & 0xFF) << 24) \n\t\t+ (((long)buf[offset + 4] & 0xFF) << 32) + (((long)buf[offset + 5] & 0xFF) << 40) \n\t\t+ (((long)buf[offset + 6] & 0xFF) << 48) + (((long)buf[offset + 7] & 0xFF) << 56);\n\t}\n\n\tpublic static long readUInt( byte buf[], int offset ) {\n\t\t  return (readInt(buf, offset) & INT_TO_LONG_MASK);\n\t  }\n\n\tpublic static int readInt(InputStream is) throws IOException {\n\t\t  byte[] buf = new byte[4];\n\t\n\t\t  is.read(buf, 0, 4);\n\t\t  \n\t\t  return readInt(buf, 0);\n\t  }\n\n\tpublic static long readUInt(InputStream is) throws IOException {\n\t\t  return (readInt(is) & INT_TO_LONG_MASK);\n\t  }\n\n\t/**\n\t   * Read a 32-bit value.\n\t   * \n\t   * @param buf\n\t   * @param offset\n\t   * @return\n\t   */\n\t  public static int readInt( byte buf[], int offset ) {\n\t    return (buf[offset + 0] & 0xFF) + ((buf[offset + 1] & 0xFF) << 8) + ((buf[offset + 2] & 0xFF) << 16)\n\t           + ((buf[offset + 3] & 0xFF) << 24);\n\t  }\n\n\t  public UUID readUUID() throws IOException {\n\t\t  byte[] buf = readBytes(16);\n\n\t\t  return Types.bytestoUUID(buf);\n\t  }\n\n}\n","lineNo":146}
{"Smelly Sample":"/*\n * Copyright 2010-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestInputStream;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.keepassdroid.crypto.keyDerivation.AesKdf;\nimport com.keepassdroid.crypto.keyDerivation.KdfParameters;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.stream.CopyInputStream;\nimport com.keepassdroid.stream.HmacBlockStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class PwDbHeaderV4 extends PwDbHeader {\n\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n    public static final int DBSIG_2               = 0xB54BFB67;\n    \n    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;\n    public static final int FILE_VERSION_32_3 =           0x00030001;\n\tpublic static final int FILE_VERSION_32_4 =           0x00040000;\n\tpublic static final int FILE_VERSION_32 =             FILE_VERSION_32_4;\n\n    public class PwDbHeaderV4Fields {\n        public static final byte EndOfHeader = 0;\n\t\tpublic static final byte Comment = 1;\n        public static final byte CipherID = 2;\n        public static final byte CompressionFlags = 3;\n        public static final byte MasterSeed = 4;\n        public static final byte TransformSeed = 5;\n        public static final byte TransformRounds = 6;\n        public static final byte EncryptionIV = 7;\n        public static final byte InnerRandomstreamKey = 8;\n        public static final byte StreamStartBytes = 9;\n        public static final byte InnerRandomStreamID = 10;\n\t\tpublic static final byte KdfParameters = 11;\n\t\tpublic static final byte PublicCustomData = 12;\n\n    }\n\n\tpublic class PwDbInnerHeaderV4Fields {\n\t\tpublic static final byte EndOfHeader = 0;\n\t\tpublic static final byte InnerRandomStreamID = 1;\n\t\tpublic static final byte InnerRandomstreamKey = 2;\n\t\tpublic static final byte Binary = 3;\n\t}\n\n\tpublic class KdbxBinaryFlags {\n\t\tpublic static final byte None = 0;\n\t\tpublic static final byte Protected = 1;\n\t}\n\n\tpublic class HeaderAndHash {\n\t\tpublic byte[] header;\n\t\tpublic byte[] hash;\n\n\t\tpublic HeaderAndHash (byte[] header, byte[] hash) {\n\t\t\tthis.header = header;\n\t\t\tthis.hash = hash;\n\t\t}\n\t}\n    \n    private PwDatabaseV4 db;\n    public byte[] innerRandomStreamKey = new byte[32];\n    public byte[] streamStartBytes = new byte[32];\n    public CrsAlgorithm innerRandomStream;\n\tpublic long version;\n\tpublic List<ProtectedBinary> binaries = new ArrayList<ProtectedBinary>();\n\n    public PwDbHeaderV4(PwDatabaseV4 d) {\n    \tdb = d;\n\t\tversion = d.getMinKdbxVersion();\n    \tmasterSeed = new byte[32];\n    }\n\n\t/** Assumes the input stream is at the beginning of the .kdbx file\n\t * @param is\n\t * @throws IOException \n\t * @throws InvalidDBVersionException \n\t */\n\tpublic HeaderAndHash loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 implementation\");\n\t\t}\n\t\t\n\t\tByteArrayOutputStream headerBOS = new ByteArrayOutputStream();\n\t\tCopyInputStream cis = new CopyInputStream(is, headerBOS);\n\t\tDigestInputStream dis = new DigestInputStream(cis, md);\n\t\tLEDataInputStream lis = new LEDataInputStream(dis);\n\n\t\tint sig1 = lis.readInt();\n\t\tint sig2 = lis.readInt();\n\t\t\n\t\tif ( ! matchesHeader(sig1, sig2) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tversion = lis.readUInt();\n\t\tif ( ! validVersion(version) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tboolean done = false;\n\t\twhile ( ! done ) {\n\t\t\tdone = readHeaderField(lis);\n\t\t}\n\n\t\tbyte[] hash = md.digest();\n\t\treturn new HeaderAndHash(headerBOS.toByteArray(), hash);\n\t}\n\t\n\tprivate boolean readHeaderField(LEDataInputStream dis) throws IOException {\n\t\tbyte fieldID = (byte) dis.read();\n\t\t\n\t\tint fieldSize;\n\t\tif (version < FILE_VERSION_32_4) {\n\t\t\tfieldSize = dis.readUShort();\n\t\t} else {\n\t\t\tfieldSize = dis.readInt();\n\t\t}\n\t\t\n\t\tbyte[] fieldData = null;\n\t\tif ( fieldSize > 0 ) {\n\t\t\tfieldData = new byte[fieldSize];\n\t\t\t\n\t\t\tint readSize = dis.read(fieldData);\n\t\t\tif ( readSize != fieldSize ) {\n\t\t\t\tthrow new IOException(\"Header ended early.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch ( fieldID ) {\n\t\t\tcase PwDbHeaderV4Fields.EndOfHeader:\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CipherID:\n\t\t\t\tsetCipher(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CompressionFlags:\n\t\t\t\tsetCompressionFlags(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.MasterSeed:\n\t\t\t\tmasterSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformSeed:\n\t\t\t\tassert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tAesKdf kdfS = new AesKdf();\n\t\t\t\tif (!db.kdfParameters.kdfUUID.equals(kdfS.uuid)) {\n\t\t\t\t\tdb.kdfParameters = kdfS.getDefaultParameters();\n\t\t\t\t}\n\n\t\t\t\tdb.kdfParameters.setByteArray(AesKdf.ParamSeed, fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformRounds:\n\t\t\t\tassert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tAesKdf kdfR = new AesKdf();\n\t\t\t\tif (!db.kdfParameters.kdfUUID.equals(kdfR.uuid)) {\n\t\t\t\t\tdb.kdfParameters = kdfR.getDefaultParameters();\n\t\t\t\t}\n\t\t\t\tdb.kdfParameters.setUInt64(AesKdf.ParamRounds, LEDataInputStream.readLong(fieldData, 0));\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.EncryptionIV:\n\t\t\t\tencryptionIV = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomstreamKey:\n\t\t\t    assert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tinnerRandomStreamKey = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.StreamStartBytes:\n\t\t\t\tstreamStartBytes = fieldData;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomStreamID:\n\t\t\t\tassert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tsetRandomStreamID(fieldData);\n\t\t\t\tbreak;\n\n\t\t\tcase PwDbHeaderV4Fields.KdfParameters:\n\t\t\t\tdb.kdfParameters = KdfParameters.deserialize(fieldData);\n\t\t\t\tbreak;\n\n\t\t\tcase PwDbHeaderV4Fields.PublicCustomData:\n\t\t\t\tdb.publicCustomData =  KdfParameters.deserialize(fieldData);\n\t\t\tdefault:\n\t\t\t\tthrow new IOException(\"Invalid header type: \" + fieldID);\n\t\t\t\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void setCipher(byte[] pbId) throws IOException {\n\t\tif ( pbId == null || pbId.length != 16 ) {\n\t\t\tthrow new IOException(\"Invalid cipher ID.\");\n\t\t}\n\t\t\n\t\tdb.dataCipher = Types.bytestoUUID(pbId);\n\t}\n\t\n\tprivate void setCompressionFlags(byte[] pbFlags) throws IOException {\n\t\tif ( pbFlags == null || pbFlags.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid compression flags.\");\n\t\t}\n\t\t\n\t\tint flag = LEDataInputStream.readInt(pbFlags, 0);\n\t\tif ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Unrecognized compression flag.\");\n\t\t}\n\t\t\n\t\tdb.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);\n\t\t\n\t}\n\t\n\tprivate void setTransformRounds(byte[] rounds) throws IOException {\n\t\tif ( rounds == null || rounds.length != 8 ) {\n\t\t\tthrow new IOException(\"Invalid rounds.\");\n\t\t}\n\t\t\n\t\tlong rnd = LEDataInputStream.readLong(rounds, 0);\n\t\t\n\t\tif ( rnd < 0 || rnd > Integer.MAX_VALUE ) {\n\t\t\t//TODO: Actually support really large numbers\n\t\t\tthrow new IOException(\"Rounds higher than \" + Integer.MAX_VALUE + \" are not currently supported.\");\n\t\t}\n\t\t\n\t\tdb.numKeyEncRounds = rnd;\n\t\t\n\t}\n\t\n\tpublic void setRandomStreamID(byte[] streamID) throws IOException {\n\t\tif ( streamID == null || streamID.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tint id = LEDataInputStream.readInt(streamID, 0);\n\t\tif ( id < 0 || id >= CrsAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tinnerRandomStream = CrsAlgorithm.fromId(id);\n\t}\n\t\n\t/** Determines if this is a supported version.\n\t * \n\t *  A long is needed here to represent the unsigned int since we perform\n\t *  arithmetic on it.\n\t * @param version\n\t * @return\n\t */\n\tprivate boolean validVersion(long version) {\n\t\t\n\t\treturn ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK));\n\t\t\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );\n\t}\n\n\tpublic static byte[] computeHeaderHmac(byte[] header, byte[] key) throws IOException{\n\t\tbyte[] headerHmac;\n\t\tbyte[] blockKey = HmacBlockStream.GetHmacKey64(key, Types.ULONG_MAX_VALUE);\n\n\t\tMac hmac;\n\t\ttry {\n\t\t\thmac = Mac.getInstance(\"HmacSHA256\");\n\t\t\tSecretKeySpec signingKey = new SecretKeySpec(blockKey, \"HmacSHA256\");\n\t\t\thmac.init(signingKey);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No HmacAlogirthm\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid Hmac Key\");\n\t\t}\n\n\t\treturn hmac.doFinal(header);\n\t}\n\n\tpublic byte[] getTransformSeed() {\n\t\tassert(version < FILE_VERSION_32_4);\n\n\t\treturn db.kdfParameters.getByteArray(AesKdf.ParamSeed);\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2010-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.security.DigestInputStream;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.keepassdroid.crypto.keyDerivation.AesKdf;\nimport com.keepassdroid.crypto.keyDerivation.KdfParameters;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.stream.CopyInputStream;\nimport com.keepassdroid.stream.HmacBlockStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\nimport javax.crypto.Mac;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class PwDbHeaderV4 extends PwDbHeader {\n\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n    public static final int DBSIG_2               = 0xB54BFB67;\n    \n    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;\n    public static final int FILE_VERSION_32_3 =           0x00030001;\n\tpublic static final int FILE_VERSION_32_4 =           0x00040000;\n\tpublic static final int FILE_VERSION_32 =             FILE_VERSION_32_4;\n\n    public class PwDbHeaderV4Fields {\n        public static final byte EndOfHeader = 0;\n\t\tpublic static final byte Comment = 1;\n        public static final byte CipherID = 2;\n        public static final byte CompressionFlags = 3;\n        public static final byte MasterSeed = 4;\n        public static final byte TransformSeed = 5;\n        public static final byte TransformRounds = 6;\n        public static final byte EncryptionIV = 7;\n        public static final byte InnerRandomstreamKey = 8;\n        public static final byte StreamStartBytes = 9;\n        public static final byte InnerRandomStreamID = 10;\n\t\tpublic static final byte KdfParameters = 11;\n\t\tpublic static final byte PublicCustomData = 12;\n\n    }\n\n\tpublic class PwDbInnerHeaderV4Fields {\n\t\tpublic static final byte EndOfHeader = 0;\n\t\tpublic static final byte InnerRandomStreamID = 1;\n\t\tpublic static final byte InnerRandomstreamKey = 2;\n\t\tpublic static final byte Binary = 3;\n\t}\n\n\tpublic class KdbxBinaryFlags {\n\t\tpublic static final byte None = 0;\n\t\tpublic static final byte Protected = 1;\n\t}\n\n\tpublic class HeaderAndHash {\n\t\tpublic byte[] header;\n\t\tpublic byte[] hash;\n\n\t\tpublic HeaderAndHash (byte[] header, byte[] hash) {\n\t\t\tthis.header = header;\n\t\t\tthis.hash = hash;\n\t\t}\n\t}\n    \n    private PwDatabaseV4 db;\n    public byte[] innerRandomStreamKey = new byte[32];\n    public byte[] streamStartBytes = new byte[32];\n    public CrsAlgorithm innerRandomStream;\n\tpublic long version;\n\tpublic List<ProtectedBinary> binaries = new ArrayList<ProtectedBinary>();\n\n    public PwDbHeaderV4(PwDatabaseV4 d) {\n    \tdb = d;\n\t\tversion = d.getMinKdbxVersion();\n    \tmasterSeed = new byte[32];\n    }\n\n\t/** Assumes the input stream is at the beginning of the .kdbx file\n\t * @param is\n\t * @throws IOException \n\t * @throws InvalidDBVersionException \n\t */\n\tpublic HeaderAndHash loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 implementation\");\n\t\t}\n\t\t\n\t\tByteArrayOutputStream headerBOS = new ByteArrayOutputStream();\n\t\tCopyInputStream cis = new CopyInputStream(is, headerBOS);\n\t\tDigestInputStream dis = new DigestInputStream(cis, md);\n\t\tLEDataInputStream lis = new LEDataInputStream(dis);\n\n\t\tint sig1 = lis.readInt();\n\t\tint sig2 = lis.readInt();\n\t\t\n\t\tif ( ! matchesHeader(sig1, sig2) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tversion = lis.readUInt();\n\t\tif ( ! validVersion(version) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tboolean done = false;\n\t\twhile ( ! done ) {\n\t\t\tdone = readHeaderField(lis);\n\t\t}\n\n\t\tbyte[] hash = md.digest();\n\t\treturn new HeaderAndHash(headerBOS.toByteArray(), hash);\n\t}\n\t\n\tprivate boolean readHeaderField(LEDataInputStream dis) throws IOException {\n\t\tbyte fieldID = (byte) dis.read();\n\t\t\n\t\tint fieldSize;\n\t\tif (version < FILE_VERSION_32_4) {\n\t\t\tfieldSize = dis.readUShort();\n\t\t} else {\n\t\t\tfieldSize = dis.readInt();\n\t\t}\n\t\t\n\t\tbyte[] fieldData = null;\n\t\tif ( fieldSize > 0 ) {\n\t\t\tfieldData = new byte[fieldSize];\n\t\t\t\n\t\t\tint readSize = dis.read(fieldData);\n\t\t\tif ( readSize != fieldSize ) {\n\t\t\t\tthrow new IOException(\"Header ended early.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch ( fieldID ) {\n\t\t\tcase PwDbHeaderV4Fields.EndOfHeader:\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CipherID:\n\t\t\t\tsetCipher(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CompressionFlags:\n\t\t\t\tsetCompressionFlags(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.MasterSeed:\n\t\t\t\tmasterSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformSeed:\n\t\t\t\tassert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tAesKdf kdfS = new AesKdf();\n\t\t\t\tif (!db.kdfParameters.kdfUUID.equals(kdfS.uuid)) {\n\t\t\t\t\tdb.kdfParameters = kdfS.getDefaultParameters();\n\t\t\t\t}\n\n\t\t\t\tdb.kdfParameters.setByteArray(AesKdf.ParamSeed, fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformRounds:\n\t\t\t\tassert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tAesKdf kdfR = new AesKdf();\n\t\t\t\tif (!db.kdfParameters.kdfUUID.equals(kdfR.uuid)) {\n\t\t\t\t\tdb.kdfParameters = kdfR.getDefaultParameters();\n\t\t\t\t}\n\t\t\t\tlong rounds = LEDataInputStream.readLong(fieldData, 0);\n\t\t\t\tdb.kdfParameters.setUInt64(AesKdf.ParamRounds, rounds);\n\t\t\t\tdb.numKeyEncRounds = rounds;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.EncryptionIV:\n\t\t\t\tencryptionIV = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomstreamKey:\n\t\t\t    assert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tinnerRandomStreamKey = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.StreamStartBytes:\n\t\t\t\tstreamStartBytes = fieldData;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomStreamID:\n\t\t\t\tassert(version < PwDbHeaderV4.FILE_VERSION_32_4);\n\t\t\t\tsetRandomStreamID(fieldData);\n\t\t\t\tbreak;\n\n\t\t\tcase PwDbHeaderV4Fields.KdfParameters:\n\t\t\t\tdb.kdfParameters = KdfParameters.deserialize(fieldData);\n\t\t\t\tbreak;\n\n\t\t\tcase PwDbHeaderV4Fields.PublicCustomData:\n\t\t\t\tdb.publicCustomData =  KdfParameters.deserialize(fieldData);\n\t\t\tdefault:\n\t\t\t\tthrow new IOException(\"Invalid header type: \" + fieldID);\n\t\t\t\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void setCipher(byte[] pbId) throws IOException {\n\t\tif ( pbId == null || pbId.length != 16 ) {\n\t\t\tthrow new IOException(\"Invalid cipher ID.\");\n\t\t}\n\t\t\n\t\tdb.dataCipher = Types.bytestoUUID(pbId);\n\t}\n\t\n\tprivate void setCompressionFlags(byte[] pbFlags) throws IOException {\n\t\tif ( pbFlags == null || pbFlags.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid compression flags.\");\n\t\t}\n\t\t\n\t\tint flag = LEDataInputStream.readInt(pbFlags, 0);\n\t\tif ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Unrecognized compression flag.\");\n\t\t}\n\t\t\n\t\tdb.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);\n\t\t\n\t}\n\t\n\tprivate void setTransformRounds(byte[] rounds) throws IOException {\n\t\tif ( rounds == null || rounds.length != 8 ) {\n\t\t\tthrow new IOException(\"Invalid rounds.\");\n\t\t}\n\t\t\n\t\tlong rnd = LEDataInputStream.readLong(rounds, 0);\n\t\t\n\t\tif ( rnd < 0 || rnd > Integer.MAX_VALUE ) {\n\t\t\t//TODO: Actually support really large numbers\n\t\t\tthrow new IOException(\"Rounds higher than \" + Integer.MAX_VALUE + \" are not currently supported.\");\n\t\t}\n\t\t\n\t\tdb.numKeyEncRounds = rnd;\n\t\t\n\t}\n\t\n\tpublic void setRandomStreamID(byte[] streamID) throws IOException {\n\t\tif ( streamID == null || streamID.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tint id = LEDataInputStream.readInt(streamID, 0);\n\t\tif ( id < 0 || id >= CrsAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tinnerRandomStream = CrsAlgorithm.fromId(id);\n\t}\n\t\n\t/** Determines if this is a supported version.\n\t * \n\t *  A long is needed here to represent the unsigned int since we perform\n\t *  arithmetic on it.\n\t * @param version\n\t * @return\n\t */\n\tprivate boolean validVersion(long version) {\n\t\t\n\t\treturn ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK));\n\t\t\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );\n\t}\n\n\tpublic static byte[] computeHeaderHmac(byte[] header, byte[] key) throws IOException{\n\t\tbyte[] headerHmac;\n\t\tbyte[] blockKey = HmacBlockStream.GetHmacKey64(key, Types.ULONG_MAX_VALUE);\n\n\t\tMac hmac;\n\t\ttry {\n\t\t\thmac = Mac.getInstance(\"HmacSHA256\");\n\t\t\tSecretKeySpec signingKey = new SecretKeySpec(blockKey, \"HmacSHA256\");\n\t\t\thmac.init(signingKey);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No HmacAlogirthm\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid Hmac Key\");\n\t\t}\n\n\t\treturn hmac.doFinal(header);\n\t}\n\n\tpublic byte[] getTransformSeed() {\n\t\tassert(version < FILE_VERSION_32_4);\n\n\t\treturn db.kdfParameters.getByteArray(AesKdf.ParamSeed);\n\t}\n}\n","lineNo":197}
{"Smelly Sample":"/*\n * Copyright 2013-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport android.util.Xml;\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfFactory;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.EntryHandler;\nimport com.keepassdroid.database.GroupHandler;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4.MemoryProtectionConfig;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDefsV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwEntryV4.AutoType;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.HashedBlockOutputStream;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbV4Output extends PwDbOutput {\n\n\tPwDatabaseV4 mPM;\n\tprivate StreamCipher randomStream;\n\tprivate BinaryPool binPool;\n\tprivate XmlSerializer xml;\n\tprivate PwDbHeaderV4 header;\n\tprivate byte[] hashOfHeader;\n\t\n\tprotected PwDbV4Output(PwDatabaseV4 pm, OutputStream os) {\n\t\tsuper(os);\n\t\t\n\t\tmPM = pm;\n\t}\n\n\t@Override\n\tpublic void output() throws PwDbOutputException {\n\n\n\t\theader = (PwDbHeaderV4) outputHeader(mOS);\n\t\t\n\t\tCipherOutputStream cos = attachStreamEncryptor(header, mOS);\n\t\t\n\t\tOutputStream compressed;\n\t\ttry {\n\t\t\tcos.write(header.streamStartBytes);\n\t\t\t\n\t\t\tHashedBlockOutputStream hashed = new HashedBlockOutputStream(cos);\n\t\t\t\n\t\t\tif ( mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\t\tcompressed = new GZIPOutputStream(hashed); \n\t\t\t} else {\n\t\t\t\tcompressed = hashed;\n\t\t\t}\n\n\t\n\t\t\toutputDatabase(compressed);\n\t\t\tcompressed.close();\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t} catch (IllegalStateException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t}\n\t}\n\t\n\tprivate class GroupWriter extends GroupHandler<PwGroup> {\n\t\tprivate Stack<PwGroupV4> groupStack;\n\t\t\n\t\tpublic GroupWriter(Stack<PwGroupV4> gs) {\n\t\t\tgroupStack = gs;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean operate(PwGroup g) {\n\t\t\tPwGroupV4 group = (PwGroupV4) g;\n\t\t\tassert(group != null);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (group.parent == groupStack.peek()) {\n\t\t\t\t\t\tgroupStack.push(group);\n\t\t\t\t\t\tstartGroup(group);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\tif (groupStack.size() <= 0) return false;\n\t\t\t\t\t\tendGroup();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate class EntryWriter extends EntryHandler<PwEntry> {\n\n\t\t@Override\n\t\tpublic boolean operate(PwEntry e) {\n\t\t\tPwEntryV4 entry = (PwEntryV4) e;\n\t\t\tassert(entry != null);\n\t\t\t\n\t\t\ttry {\n\t\t\t\twriteEntry(entry, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void outputDatabase(OutputStream os) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbinPool = new BinaryPool((PwGroupV4)mPM.rootGroup);\n\t\t\n\t\txml = Xml.newSerializer();\n\t\t\n\t\txml.setOutput(os, \"UTF-8\");\n\t\txml.startDocument(\"UTF-8\", true);\n\t\t\n\t\txml.startTag(null, ElemDocNode);\n\t\t\n\t\twriteMeta();\n\t\t\n\t\tPwGroupV4 root = (PwGroupV4) mPM.rootGroup;\n\t\txml.startTag(null, ElemRoot);\n\t\tstartGroup(root);\n\t\tStack<PwGroupV4> groupStack = new Stack<PwGroupV4>();\n\t\tgroupStack.push(root);\n\t\t\n\t\tif (!root.preOrderTraverseTree(new GroupWriter(groupStack), new EntryWriter())) throw new RuntimeException(\"Writing groups failed\");\n\t\t\n\t\twhile (groupStack.size() > 1) {\n\t\t\txml.endTag(null, ElemGroup);\n\t\t\tgroupStack.pop();\n\t\t}\n\t\t\n\t\tendGroup();\n\t\t\n\t\twriteList(ElemDeletedObjects, mPM.deletedObjects);\n\t\t\n\t\txml.endTag(null, ElemRoot);\n\t\t\n\t\txml.endTag(null, ElemDocNode);\n\t\txml.endDocument();\n\t\t\n\t}\n\t\n\tprivate void writeMeta() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemMeta);\n\t\t\n\t\twriteObject(ElemGenerator, mPM.localizedAppName);\n\t\t\n\t\tif (hashOfHeader != null) {\n\t\t\twriteObject(ElemHeaderHash, String.valueOf(Base64Coder.encode(hashOfHeader)));\n\t\t}\n\t\t\n\t\twriteObject(ElemDbName, mPM.name, true);\n\t\twriteObject(ElemDbNameChanged, mPM.nameChanged);\n\t\twriteObject(ElemDbDesc, mPM.description, true);\n\t\twriteObject(ElemDbDescChanged, mPM.descriptionChanged);\n\t\twriteObject(ElemDbDefaultUser, mPM.defaultUserName, true);\n\t\twriteObject(ElemDbDefaultUserChanged, mPM.defaultUserNameChanged);\n\t\twriteObject(ElemDbMntncHistoryDays, mPM.maintenanceHistoryDays);\n\t\twriteObject(ElemDbColor, mPM.color);\n\t\twriteObject(ElemDbKeyChanged, mPM.keyLastChanged);\n\t\twriteObject(ElemDbKeyChangeRec, mPM.keyChangeRecDays);\n\t\twriteObject(ElemDbKeyChangeForce, mPM.keyChangeForceDays);\n\t\t\n\t\t\n\t\twriteList(ElemMemoryProt, mPM.memoryProtection);\n\t\t\n\t\twriteCustomIconList();\n\t\t\n\t\twriteObject(ElemRecycleBinEnabled, mPM.recycleBinEnabled);\n\t\twriteObject(ElemRecycleBinUuid, mPM.recycleBinUUID);\n\t\twriteObject(ElemRecycleBinChanged, mPM.recycleBinChanged);\n\t\twriteObject(ElemEntryTemplatesGroup, mPM.entryTemplatesGroup);\n\t\twriteObject(ElemEntryTemplatesGroupChanged, mPM.entryTemplatesGroupChanged);\n\t\twriteObject(ElemHistoryMaxItems, mPM.historyMaxItems);\n\t\twriteObject(ElemHistoryMaxSize, mPM.historyMaxSize);\n\t\twriteObject(ElemLastSelectedGroup, mPM.lastSelectedGroup);\n\t\twriteObject(ElemLastTopVisibleGroup, mPM.lastTopVisibleGroup);\n\t\t\n\t\twriteBinPool();\n\t\twriteList(ElemCustomData, mPM.customData);\n\t\t\n\t\txml.endTag(null, ElemMeta);\n\t\t\n\t}\n\t\n\tprivate CipherOutputStream attachStreamEncryptor(PwDbHeaderV4 header, OutputStream os) throws PwDbOutputException {\n\t\tCipher cipher;\n\t\tCipherEngine engine;\n\t\ttry {\n\t\t\tmPM.makeFinalKey(header.masterSeed, header.getTransformSeed(), (int)mPM.numKeyEncRounds);\n\n\t\t\tengine = CipherFactory.getInstance(mPM.dataCipher);\n\t\t\tcipher = engine.getCipher(Cipher.ENCRYPT_MODE, mPM.finalKey, header.encryptionIV);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwDbOutputException(\"Invalid algorithm.\", e);\n\t\t}\n\t\t\n\t\tCipherOutputStream cos = new CipherOutputStream(os, cipher);\n\t\t\n\t\treturn cos;\n\t}\n\n\t@Override\n\tprotected SecureRandom setIVs(PwDbHeader header) throws PwDbOutputException {\n\t\tSecureRandom random = super.setIVs(header);\n\t\t\n\t\tPwDbHeaderV4 h = (PwDbHeaderV4) header;\n\t\trandom.nextBytes(h.masterSeed);\n\t\trandom.nextBytes(h.encryptionIV);\n\n\t\tUUID kdfUUID = mPM.kdfParameters.kdfUUID;\n\t\tKdfEngine kdf = KdfFactory.get(kdfUUID);\n\t\tkdf.randomize(mPM.kdfParameters);\n\n\t\trandom.nextBytes(h.protectedStreamKey);\n\t\th.innerRandomStream = CrsAlgorithm.Salsa20;\n\t\trandomStream = PwStreamCipherFactory.getInstance(h.innerRandomStream, h.protectedStreamKey);\n\t\tif (randomStream == null) {\n\t\t\tthrow new PwDbOutputException(\"Invalid random cipher\");\n\t\t}\n\t\trandom.nextBytes(h.streamStartBytes);\n\t\t\n\t\treturn random;\n\t}\n\t\n\t@Override\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwDbOutputException {\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(mPM);\n\t\tsetIVs(header);\n\t\t\n\t\tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4(mPM, header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(\"Failed to output the header.\", e);\n\t\t}\n\t\t\n\t\thashOfHeader = pho.getHashOfHeader();\n\t\t\n\t\treturn header;\n\t}\n\t\n\tprivate void startGroup(PwGroupV4 group) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemGroup);\n\t\twriteObject(ElemUuid, group.uuid);\n\t\twriteObject(ElemName, group.name);\n\t\twriteObject(ElemNotes, group.notes);\n\t\twriteObject(ElemIcon, group.icon.iconId);\n\t\t\n\t\tif (!group.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, group.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteList(ElemTimes, group);\n\t\twriteObject(ElemIsExpanded, group.isExpanded);\n\t\twriteObject(ElemGroupDefaultAutoTypeSeq, group.defaultAutoTypeSequence);\n\t\twriteObject(ElemEnableAutoType, group.enableAutoType);\n\t\twriteObject(ElemEnableSearching, group.enableSearching);\n\t\twriteObject(ElemLastTopVisibleEntry, group.lastTopVisibleEntry);\n\t\t\n\t}\n\t\n\tprivate void endGroup() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.endTag(null, ElemGroup);\n\t}\n\t\n\tprivate void writeEntry(PwEntryV4 entry, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(entry != null);\n\t\t\n\t\txml.startTag(null, ElemEntry);\n\t\t\n\t\twriteObject(ElemUuid, entry.uuid);\n\t\twriteObject(ElemIcon, entry.icon.iconId);\n\t\t\n\t\tif (!entry.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, entry.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteObject(ElemFgColor, entry.foregroundColor);\n\t\twriteObject(ElemBgColor, entry.backgroupColor);\n\t\twriteObject(ElemOverrideUrl, entry.overrideURL);\n\t\twriteObject(ElemTags, entry.tags);\n\t\t\n\t\twriteList(ElemTimes, entry);\n\t\t\n\t\twriteList(entry.strings, true);\n\t\twriteList(entry.binaries);\n\t\twriteList(ElemAutoType, entry.autoType);\n\t\t\n\t\tif (!isHistory) {\n\t\t\twriteList(ElemHistory, entry.history, true);\n\t\t} else {\n\t\t\tassert(entry.history.size() == 0);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemEntry);\n\t}\n\t\n\n\tprivate void writeObject(String key, ProtectedBinary value, boolean allowRef) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key != null && value != null);\n\t\t\n\t\txml.startTag(null, ElemBinary);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tString strRef = null;\n\t\tif (allowRef) {\n\t\t\tint ref = binPool.poolFind(value);\n\t\t\tstrRef = Integer.toString(ref);\n\t\t}\n\t\t\n\t\tif (strRef != null) {\n\t\t\txml.attribute(null, AttrRef, strRef);\n\t\t}\n\t\telse {\n\t\t\tsubWriteValue(value);\n\t\t}\n\t\txml.endTag(null, ElemValue);\n\t\t\n\t\txml.endTag(null, ElemBinary);\n\t}\n\t\n\tprivate void subWriteValue(ProtectedBinary value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (value.isProtected()) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tint valLength = value.length();\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(value.getData(), 0, valLength, encoded, 0);\n\t\t\t\t\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\txml.attribute(null, AttrCompressed, ValTrue);\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\tbyte[] compressed = MemUtil.compress(raw);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(compressed)));\n\t\t\t} else {\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(raw)));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tprivate void writeObject(String name, String value, boolean filterXmlChars) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tif (filterXmlChars) {\n\t\t\tvalue = safeXmlString(value);\n\t\t}\n\t\t\n\t\txml.text(value);\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeObject(String name, String value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, value, false);\n\t}\n\t\n\tprivate void writeObject(String name, Date value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, PwDatabaseV4XML.dateFormat.format(value));\n\t}\n\t\n\tprivate void writeObject(String name, long value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, String.valueOf(value));\n\t}\n\t\n\tprivate void writeObject(String name, Boolean value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tString text;\n\t\tif (value == null) {\n\t\t\ttext = \"null\";\n\t\t}\n\t\telse if (value) {\n\t\t\ttext = ValTrue;\n\t\t}\n\t\telse {\n\t\t\ttext = ValFalse;\n\t\t}\n\t\t\n\t\twriteObject(name, text);\n\t}\n\t\n\tprivate void writeObject(String name, UUID uuid) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbyte[] data = Types.UUIDtoBytes(uuid);\n\t\twriteObject(name, String.valueOf(Base64Coder.encode(data)));\n\t}\n\t\n\tprivate void writeObject(String name, String keyName, String keyValue, String valueName, String valueValue) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, name);\n\t\t\n\t\txml.startTag(null, keyName);\n\t\txml.text(safeXmlString(keyValue));\n\t\txml.endTag(null, keyName);\n\t\t\n\t\txml.startTag(null, valueName);\n\t\txml.text(safeXmlString(valueValue));\n\t\txml.endTag(null, valueName);\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeList(String name, AutoType autoType) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && autoType != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemAutoTypeEnabled, autoType.enabled);\n\t\twriteObject(ElemAutoTypeObfuscation, autoType.obfuscationOptions);\n\t\t\n\t\tif (autoType.defaultSequence.length() > 0) {\n\t\t\twriteObject(ElemAutoTypeDefaultSeq, autoType.defaultSequence, true);\n\t\t}\n\t\t\n\t\tfor (Entry<String, String> pair : autoType.entrySet()) {\n\t\t\twriteObject(ElemAutoTypeItem, ElemWindow, pair.getKey(), ElemKeystrokeSequence, pair.getValue());\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(Map<String, ProtectedString> strings, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert (strings != null);\n\t\t\n\t\tfor (Entry<String, ProtectedString> pair : strings.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), isEntryString);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate void writeObject(String key, ProtectedString value, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key !=null && value != null);\n\t\t\n\t\txml.startTag(null, ElemString);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tboolean protect = value.isProtected();\n\t\tif (isEntryString) {\n\t\t\tif (key.equals(PwDefsV4.TITLE_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectTitle;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.USERNAME_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUserName;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.PASSWORD_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectPassword;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.URL_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUrl;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.NOTES_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectNotes;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (protect) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tbyte[] data = value.toString().getBytes(\"UTF-8\");\n\t\t\tint valLength = data.length;\n\t\t\t\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(data, 0, valLength, encoded, 0);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txml.text(safeXmlString(value.toString()));\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemValue);\n\t\txml.endTag(null, ElemString);\n\t\t\n\t}\n\n\tprivate void writeObject(String name, PwDeletedObject value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemUuid, value.uuid);\n\t\twriteObject(ElemDeletionTime, value.getDeletionTime());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(Map<String, ProtectedBinary> binaries) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(binaries != null);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binaries.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), true);\n\t\t}\n\t}\n\n\n\tprivate void writeList(String name, List<PwDeletedObject> value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwDeletedObject pdo : value) {\n\t\t\twriteObject(ElemDeletedObject, pdo);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(String name, MemoryProtectionConfig value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemProtTitle, value.protectTitle);\n\t\twriteObject(ElemProtUserName, value.protectUserName);\n\t\twriteObject(ElemProtPassword, value.protectPassword);\n\t\twriteObject(ElemProtURL, value.protectUrl);\n\t\twriteObject(ElemProtNotes, value.protectNotes);\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, Map<String, String> customData) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && customData != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (Entry<String, String> pair : customData.entrySet()) {\n\t\t\twriteObject(ElemStringDictExItem, ElemKey, pair.getKey(), ElemValue, pair.getValue());\n\t\t\t  \n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, ITimeLogger it) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && it != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemLastModTime, it.getLastModificationTime());\n\t\twriteObject(ElemCreationTime, it.getCreationTime());\n\t\twriteObject(ElemLastAccessTime, it.getLastAccessTime());\n\t\twriteObject(ElemExpiryTime, it.getExpiryTime());\n\t\twriteObject(ElemExpires, it.expires());\n\t\twriteObject(ElemUsageCount, it.getUsageCount());\n\t\twriteObject(ElemLocationChanged, it.getLocationChanged());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(String name, List<PwEntryV4> value, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwEntryV4 entry : value) {\n\t\t\twriteEntry(entry, isHistory);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeCustomIconList() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tList<PwIconCustom> customIcons = mPM.customIcons;\n\t\tif (customIcons.size() == 0) return;\n\t\t\n\t\txml.startTag(null, ElemCustomIcons);\n\t\t\n\t\tfor (PwIconCustom icon : customIcons) {\n\t\t\txml.startTag(null, ElemCustomIconItem);\n\t\t\t\n\t\t\twriteObject(ElemCustomIconItemID, icon.uuid);\n\t\t\twriteObject(ElemCustomIconItemData, String.valueOf(Base64Coder.encode(icon.imageData)));\n\t\t\t\n\t\t\txml.endTag(null, ElemCustomIconItem);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemCustomIcons);\n\t}\n\t\n\tprivate void writeBinPool() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemBinaries);\n\t\t\n\t\tfor (Entry<Integer, ProtectedBinary> pair : binPool.entrySet()) {\n\t\t\txml.startTag(null, ElemBinary);\n\t\t\txml.attribute(null, AttrId, Integer.toString(pair.getKey()));\n\t\t\t\n\t\t\tsubWriteValue(pair.getValue());\n\t\t\t\n\t\t\txml.endTag(null, ElemBinary);\n\t\t\t\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemBinaries);\n\t\t\n\t}\n\n\tprivate String safeXmlString(String text) {\n\t\tif (EmptyUtils.isNullOrEmpty(text)) {\n\t\t\treturn text;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar ch;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tch = text.charAt(i);\n\t\t\t\n\t\t\tif(((ch >= 0x20) && (ch <= 0xD7FF)) ||              \n\t\t\t        (ch == 0x9) || (ch == 0xA) || (ch == 0xD) ||\n\t\t\t        ((ch >= 0xE000) && (ch <= 0xFFFD))) {\n\t\t\t\t\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2013-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\n\nimport org.joda.time.DateTime;\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport android.util.Xml;\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfFactory;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.EntryHandler;\nimport com.keepassdroid.database.GroupHandler;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4.MemoryProtectionConfig;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDefsV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwEntryV4.AutoType;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.HashedBlockOutputStream;\nimport com.keepassdroid.stream.HmacBlockOutputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.utils.DateUtil;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbV4Output extends PwDbOutput {\n\n\tPwDatabaseV4 mPM;\n\tprivate StreamCipher randomStream;\n\tprivate BinaryPool binPool;\n\tprivate XmlSerializer xml;\n\tprivate PwDbHeaderV4 header;\n\tprivate byte[] hashOfHeader;\n\tprivate byte[] headerHmac;\n    private CipherEngine engine = null;\n\n\tprotected PwDbV4Output(PwDatabaseV4 pm, OutputStream os) {\n\t\tsuper(os);\n\t\t\n\t\tmPM = pm;\n\t}\n\n\t@Override\n\tpublic void output() throws PwDbOutputException {\n\n        try {\n\t\t\ttry {\n\t\t\t\tengine = CipherFactory.getInstance(mPM.dataCipher);\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwDbOutputException(\"No such cipher\", e);\n\t\t\t}\n\n\t\t\theader = (PwDbHeaderV4) outputHeader(mOS);\n\n\t\t\tOutputStream osPlain;\n\t\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\t\tCipherOutputStream cos = attachStreamEncryptor(header, mOS);\n\t\t\t\tcos.write(header.streamStartBytes);\n\n\t\t\t\tHashedBlockOutputStream hashed = new HashedBlockOutputStream(cos);\n\t\t\t\tosPlain = hashed;\n\t\t\t} else {\n\t\t\t\tmOS.write(hashOfHeader);\n\t\t\t\tmOS.write(headerHmac);\n\n\t\t\t\tHmacBlockOutputStream hbos = new HmacBlockOutputStream(mOS, mPM.hmacKey);\n\t\t\t\tosPlain = attachStreamEncryptor(header, hbos);\n\t\t\t}\n\n\t\t\tOutputStream osXml;\n\t\t\ttry {\n\n\n\t\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\t\tosXml = new GZIPOutputStream(osPlain);\n\t\t\t\t} else {\n\t\t\t\t\tosXml = osPlain;\n\t\t\t\t}\n\n\t\t\t\tif (header.version >= PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\t\t\tPwDbInnerHeaderOutputV4 ihOut =  new PwDbInnerHeaderOutputV4((PwDatabaseV4)mPM, header, osXml);\n                    ihOut.output();\n\t\t\t\t}\n\n\n\t\t\t\toutputDatabase(osXml);\n\t\t\t\tosXml.close();\n\t\t\t} catch (IllegalArgumentException e) {\n\t\t\t\tthrow new PwDbOutputException(e);\n\t\t\t} catch (IllegalStateException e) {\n\t\t\t\tthrow new PwDbOutputException(e);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t}\n\t}\n\t\n\tprivate class GroupWriter extends GroupHandler<PwGroup> {\n\t\tprivate Stack<PwGroupV4> groupStack;\n\t\t\n\t\tpublic GroupWriter(Stack<PwGroupV4> gs) {\n\t\t\tgroupStack = gs;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean operate(PwGroup g) {\n\t\t\tPwGroupV4 group = (PwGroupV4) g;\n\t\t\tassert(group != null);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (group.parent == groupStack.peek()) {\n\t\t\t\t\t\tgroupStack.push(group);\n\t\t\t\t\t\tstartGroup(group);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\tif (groupStack.size() <= 0) return false;\n\t\t\t\t\t\tendGroup();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate class EntryWriter extends EntryHandler<PwEntry> {\n\n\t\t@Override\n\t\tpublic boolean operate(PwEntry e) {\n\t\t\tPwEntryV4 entry = (PwEntryV4) e;\n\t\t\tassert(entry != null);\n\t\t\t\n\t\t\ttry {\n\t\t\t\twriteEntry(entry, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void outputDatabase(OutputStream os) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbinPool = new BinaryPool((PwGroupV4)mPM.rootGroup);\n\t\t\n\t\txml = Xml.newSerializer();\n\t\t\n\t\txml.setOutput(os, \"UTF-8\");\n\t\txml.startDocument(\"UTF-8\", true);\n\t\t\n\t\txml.startTag(null, ElemDocNode);\n\t\t\n\t\twriteMeta();\n\t\t\n\t\tPwGroupV4 root = (PwGroupV4) mPM.rootGroup;\n\t\txml.startTag(null, ElemRoot);\n\t\tstartGroup(root);\n\t\tStack<PwGroupV4> groupStack = new Stack<PwGroupV4>();\n\t\tgroupStack.push(root);\n\t\t\n\t\tif (!root.preOrderTraverseTree(new GroupWriter(groupStack), new EntryWriter())) throw new RuntimeException(\"Writing groups failed\");\n\t\t\n\t\twhile (groupStack.size() > 1) {\n\t\t\txml.endTag(null, ElemGroup);\n\t\t\tgroupStack.pop();\n\t\t}\n\t\t\n\t\tendGroup();\n\t\t\n\t\twriteList(ElemDeletedObjects, mPM.deletedObjects);\n\t\t\n\t\txml.endTag(null, ElemRoot);\n\t\t\n\t\txml.endTag(null, ElemDocNode);\n\t\txml.endDocument();\n\t\t\n\t}\n\t\n\tprivate void writeMeta() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemMeta);\n\t\t\n\t\twriteObject(ElemGenerator, mPM.localizedAppName);\n\t\t\n\t\tif (hashOfHeader != null) {\n\t\t\twriteObject(ElemHeaderHash, String.valueOf(Base64Coder.encode(hashOfHeader)));\n\t\t}\n\t\t\n\t\twriteObject(ElemDbName, mPM.name, true);\n\t\twriteObject(ElemDbNameChanged, mPM.nameChanged);\n\t\twriteObject(ElemDbDesc, mPM.description, true);\n\t\twriteObject(ElemDbDescChanged, mPM.descriptionChanged);\n\t\twriteObject(ElemDbDefaultUser, mPM.defaultUserName, true);\n\t\twriteObject(ElemDbDefaultUserChanged, mPM.defaultUserNameChanged);\n\t\twriteObject(ElemDbMntncHistoryDays, mPM.maintenanceHistoryDays);\n\t\twriteObject(ElemDbColor, mPM.color);\n\t\twriteObject(ElemDbKeyChanged, mPM.keyLastChanged);\n\t\twriteObject(ElemDbKeyChangeRec, mPM.keyChangeRecDays);\n\t\twriteObject(ElemDbKeyChangeForce, mPM.keyChangeForceDays);\n\t\t\n\t\t\n\t\twriteList(ElemMemoryProt, mPM.memoryProtection);\n\t\t\n\t\twriteCustomIconList();\n\t\t\n\t\twriteObject(ElemRecycleBinEnabled, mPM.recycleBinEnabled);\n\t\twriteObject(ElemRecycleBinUuid, mPM.recycleBinUUID);\n\t\twriteObject(ElemRecycleBinChanged, mPM.recycleBinChanged);\n\t\twriteObject(ElemEntryTemplatesGroup, mPM.entryTemplatesGroup);\n\t\twriteObject(ElemEntryTemplatesGroupChanged, mPM.entryTemplatesGroupChanged);\n\t\twriteObject(ElemHistoryMaxItems, mPM.historyMaxItems);\n\t\twriteObject(ElemHistoryMaxSize, mPM.historyMaxSize);\n\t\twriteObject(ElemLastSelectedGroup, mPM.lastSelectedGroup);\n\t\twriteObject(ElemLastTopVisibleGroup, mPM.lastTopVisibleGroup);\n\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\twriteBinPool();\n\t\t}\n\t\twriteList(ElemCustomData, mPM.customData);\n\t\t\n\t\txml.endTag(null, ElemMeta);\n\t\t\n\t}\n\t\n\tprivate CipherOutputStream attachStreamEncryptor(PwDbHeaderV4 header, OutputStream os) throws PwDbOutputException {\n\t\tCipher cipher;\n\t\ttry {\n\t\t\t//mPM.makeFinalKey(header.masterSeed, mPM.kdfParameters);\n\n\t\t\tcipher = engine.getCipher(Cipher.ENCRYPT_MODE, mPM.finalKey, header.encryptionIV);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwDbOutputException(\"Invalid algorithm.\", e);\n\t\t}\n\t\t\n\t\tCipherOutputStream cos = new CipherOutputStream(os, cipher);\n\t\t\n\t\treturn cos;\n\t}\n\n\t@Override\n\tprotected SecureRandom setIVs(PwDbHeader header) throws PwDbOutputException {\n\t\tSecureRandom random = super.setIVs(header);\n\t\t\n\t\tPwDbHeaderV4 h = (PwDbHeaderV4) header;\n\t\trandom.nextBytes(h.masterSeed);\n\n\t\tint ivLength = engine.ivLength();\n\t\tif (ivLength != h.encryptionIV.length) {\n\t\t\th.encryptionIV = new byte[ivLength];\n\t\t}\n\t\trandom.nextBytes(h.encryptionIV);\n\n\t\tUUID kdfUUID = mPM.kdfParameters.kdfUUID;\n\t\tKdfEngine kdf = KdfFactory.get(kdfUUID);\n\t\tkdf.randomize(mPM.kdfParameters);\n\n\t\tif (h.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\th.innerRandomStream = CrsAlgorithm.Salsa20;\n            h.innerRandomStreamKey = new byte[32];\n\t\t} else {\n\t\t\th.innerRandomStream = CrsAlgorithm.ChaCha20;\n\t\t\th.innerRandomStreamKey = new byte[64];\n\t\t}\n\t\trandom.nextBytes(h.innerRandomStreamKey);\n\n\t\trandomStream = PwStreamCipherFactory.getInstance(h.innerRandomStream, h.innerRandomStreamKey);\n\t\tif (randomStream == null) {\n\t\t\tthrow new PwDbOutputException(\"Invalid random cipher\");\n\t\t}\n\n\t\tif ( h.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\trandom.nextBytes(h.streamStartBytes);\n\t\t}\n\t\t\n\t\treturn random;\n\t}\n\t\n\t@Override\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwDbOutputException {\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(mPM);\n\t\tsetIVs(header);\n\n\t\tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4(mPM, header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(\"Failed to output the header.\", e);\n\t\t}\n\t\t\n\t\thashOfHeader = pho.getHashOfHeader();\n\t\theaderHmac = pho.headerHmac;\n\t\t\n\t\treturn header;\n\t}\n\t\n\tprivate void startGroup(PwGroupV4 group) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemGroup);\n\t\twriteObject(ElemUuid, group.uuid);\n\t\twriteObject(ElemName, group.name);\n\t\twriteObject(ElemNotes, group.notes);\n\t\twriteObject(ElemIcon, group.icon.iconId);\n\t\t\n\t\tif (!group.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, group.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteList(ElemTimes, group);\n\t\twriteObject(ElemIsExpanded, group.isExpanded);\n\t\twriteObject(ElemGroupDefaultAutoTypeSeq, group.defaultAutoTypeSequence);\n\t\twriteObject(ElemEnableAutoType, group.enableAutoType);\n\t\twriteObject(ElemEnableSearching, group.enableSearching);\n\t\twriteObject(ElemLastTopVisibleEntry, group.lastTopVisibleEntry);\n\t\t\n\t}\n\t\n\tprivate void endGroup() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.endTag(null, ElemGroup);\n\t}\n\t\n\tprivate void writeEntry(PwEntryV4 entry, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(entry != null);\n\t\t\n\t\txml.startTag(null, ElemEntry);\n\t\t\n\t\twriteObject(ElemUuid, entry.uuid);\n\t\twriteObject(ElemIcon, entry.icon.iconId);\n\t\t\n\t\tif (!entry.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, entry.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteObject(ElemFgColor, entry.foregroundColor);\n\t\twriteObject(ElemBgColor, entry.backgroupColor);\n\t\twriteObject(ElemOverrideUrl, entry.overrideURL);\n\t\twriteObject(ElemTags, entry.tags);\n\t\t\n\t\twriteList(ElemTimes, entry);\n\t\t\n\t\twriteList(entry.strings, true);\n\t\twriteList(entry.binaries);\n\t\twriteList(ElemAutoType, entry.autoType);\n\t\t\n\t\tif (!isHistory) {\n\t\t\twriteList(ElemHistory, entry.history, true);\n\t\t} else {\n\t\t\tassert(entry.history.size() == 0);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemEntry);\n\t}\n\t\n\n\tprivate void writeObject(String key, ProtectedBinary value, boolean allowRef) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key != null && value != null);\n\t\t\n\t\txml.startTag(null, ElemBinary);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tString strRef = null;\n\t\tif (allowRef) {\n\t\t\tint ref = binPool.poolFind(value);\n\t\t\tstrRef = Integer.toString(ref);\n\t\t}\n\t\t\n\t\tif (strRef != null) {\n\t\t\txml.attribute(null, AttrRef, strRef);\n\t\t}\n\t\telse {\n\t\t\tsubWriteValue(value);\n\t\t}\n\t\txml.endTag(null, ElemValue);\n\t\t\n\t\txml.endTag(null, ElemBinary);\n\t}\n\t\n\tprivate void subWriteValue(ProtectedBinary value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (value.isProtected()) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tint valLength = value.length();\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(value.getData(), 0, valLength, encoded, 0);\n\t\t\t\t\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\txml.attribute(null, AttrCompressed, ValTrue);\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\tbyte[] compressed = MemUtil.compress(raw);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(compressed)));\n\t\t\t} else {\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(raw)));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tprivate void writeObject(String name, String value, boolean filterXmlChars) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tif (filterXmlChars) {\n\t\t\tvalue = safeXmlString(value);\n\t\t}\n\t\t\n\t\txml.text(value);\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeObject(String name, String value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, value, false);\n\t}\n\t\n\tprivate void writeObject(String name, Date value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\twriteObject(name, PwDatabaseV4XML.dateFormat.format(value));\n\t\t} else {\n\t\t\tDateTime dt = new DateTime(value);\n\t\t\tlong seconds = DateUtil.convertDateToKDBX4Time(dt);\n\t\t\tbyte[] buf = LEDataOutputStream.writeLongBuf(seconds);\n\t\t\tString b64 = new String(Base64Coder.encode(buf));\n\t\t\twriteObject(name, b64);\n\t\t}\n\n\t}\n\t\n\tprivate void writeObject(String name, long value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, String.valueOf(value));\n\t}\n\t\n\tprivate void writeObject(String name, Boolean value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tString text;\n\t\tif (value == null) {\n\t\t\ttext = \"null\";\n\t\t}\n\t\telse if (value) {\n\t\t\ttext = ValTrue;\n\t\t}\n\t\telse {\n\t\t\ttext = ValFalse;\n\t\t}\n\t\t\n\t\twriteObject(name, text);\n\t}\n\t\n\tprivate void writeObject(String name, UUID uuid) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbyte[] data = Types.UUIDtoBytes(uuid);\n\t\twriteObject(name, String.valueOf(Base64Coder.encode(data)));\n\t}\n\t\n\tprivate void writeObject(String name, String keyName, String keyValue, String valueName, String valueValue) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, name);\n\t\t\n\t\txml.startTag(null, keyName);\n\t\txml.text(safeXmlString(keyValue));\n\t\txml.endTag(null, keyName);\n\t\t\n\t\txml.startTag(null, valueName);\n\t\txml.text(safeXmlString(valueValue));\n\t\txml.endTag(null, valueName);\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeList(String name, AutoType autoType) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && autoType != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemAutoTypeEnabled, autoType.enabled);\n\t\twriteObject(ElemAutoTypeObfuscation, autoType.obfuscationOptions);\n\t\t\n\t\tif (autoType.defaultSequence.length() > 0) {\n\t\t\twriteObject(ElemAutoTypeDefaultSeq, autoType.defaultSequence, true);\n\t\t}\n\t\t\n\t\tfor (Entry<String, String> pair : autoType.entrySet()) {\n\t\t\twriteObject(ElemAutoTypeItem, ElemWindow, pair.getKey(), ElemKeystrokeSequence, pair.getValue());\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(Map<String, ProtectedString> strings, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert (strings != null);\n\t\t\n\t\tfor (Entry<String, ProtectedString> pair : strings.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), isEntryString);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate void writeObject(String key, ProtectedString value, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key !=null && value != null);\n\t\t\n\t\txml.startTag(null, ElemString);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tboolean protect = value.isProtected();\n\t\tif (isEntryString) {\n\t\t\tif (key.equals(PwDefsV4.TITLE_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectTitle;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.USERNAME_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUserName;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.PASSWORD_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectPassword;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.URL_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUrl;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.NOTES_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectNotes;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (protect) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tbyte[] data = value.toString().getBytes(\"UTF-8\");\n\t\t\tint valLength = data.length;\n\t\t\t\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(data, 0, valLength, encoded, 0);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txml.text(safeXmlString(value.toString()));\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemValue);\n\t\txml.endTag(null, ElemString);\n\t\t\n\t}\n\n\tprivate void writeObject(String name, PwDeletedObject value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemUuid, value.uuid);\n\t\twriteObject(ElemDeletionTime, value.getDeletionTime());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(Map<String, ProtectedBinary> binaries) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(binaries != null);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binaries.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), true);\n\t\t}\n\t}\n\n\n\tprivate void writeList(String name, List<PwDeletedObject> value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwDeletedObject pdo : value) {\n\t\t\twriteObject(ElemDeletedObject, pdo);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(String name, MemoryProtectionConfig value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemProtTitle, value.protectTitle);\n\t\twriteObject(ElemProtUserName, value.protectUserName);\n\t\twriteObject(ElemProtPassword, value.protectPassword);\n\t\twriteObject(ElemProtURL, value.protectUrl);\n\t\twriteObject(ElemProtNotes, value.protectNotes);\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, Map<String, String> customData) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && customData != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (Entry<String, String> pair : customData.entrySet()) {\n\t\t\twriteObject(ElemStringDictExItem, ElemKey, pair.getKey(), ElemValue, pair.getValue());\n\t\t\t  \n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, ITimeLogger it) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && it != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemLastModTime, it.getLastModificationTime());\n\t\twriteObject(ElemCreationTime, it.getCreationTime());\n\t\twriteObject(ElemLastAccessTime, it.getLastAccessTime());\n\t\twriteObject(ElemExpiryTime, it.getExpiryTime());\n\t\twriteObject(ElemExpires, it.expires());\n\t\twriteObject(ElemUsageCount, it.getUsageCount());\n\t\twriteObject(ElemLocationChanged, it.getLocationChanged());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(String name, List<PwEntryV4> value, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwEntryV4 entry : value) {\n\t\t\twriteEntry(entry, isHistory);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeCustomIconList() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tList<PwIconCustom> customIcons = mPM.customIcons;\n\t\tif (customIcons.size() == 0) return;\n\t\t\n\t\txml.startTag(null, ElemCustomIcons);\n\t\t\n\t\tfor (PwIconCustom icon : customIcons) {\n\t\t\txml.startTag(null, ElemCustomIconItem);\n\t\t\t\n\t\t\twriteObject(ElemCustomIconItemID, icon.uuid);\n\t\t\twriteObject(ElemCustomIconItemData, String.valueOf(Base64Coder.encode(icon.imageData)));\n\t\t\t\n\t\t\txml.endTag(null, ElemCustomIconItem);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemCustomIcons);\n\t}\n\t\n\tprivate void writeBinPool() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemBinaries);\n\t\t\n\t\tfor (Entry<Integer, ProtectedBinary> pair : binPool.entrySet()) {\n\t\t\txml.startTag(null, ElemBinary);\n\t\t\txml.attribute(null, AttrId, Integer.toString(pair.getKey()));\n\t\t\t\n\t\t\tsubWriteValue(pair.getValue());\n\t\t\t\n\t\t\txml.endTag(null, ElemBinary);\n\t\t\t\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemBinaries);\n\t\t\n\t}\n\n\tprivate String safeXmlString(String text) {\n\t\tif (EmptyUtils.isNullOrEmpty(text)) {\n\t\t\treturn text;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar ch;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tch = text.charAt(i);\n\t\t\t\n\t\t\tif(((ch >= 0x20) && (ch <= 0xD7FF)) ||              \n\t\t\t        (ch == 0x9) || (ch == 0xA) || (ch == 0xD) ||\n\t\t\t        ((ch >= 0xE000) && (ch <= 0xFFFD))) {\n\t\t\t\t\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\n}\n","lineNo":110}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.ArcFourException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.HmacBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class ImporterV4 extends Importer {\n\t\n\tprivate StreamCipher randomStream;\n\tprivate PwDatabaseV4 db;\n\tprivate BinaryPool binPool = new BinaryPool();\n\n    private byte[] hashOfHeader = null;\n\tprivate byte[] pbHeader = null;\n\t\n\tprotected PwDatabaseV4 createDB() {\n\t\treturn new PwDatabaseV4();\n\n\t}\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream) throws IOException, InvalidDBException {\n\n\t\treturn openDatabase(inStream, password, keyInputStream, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream, UpdateStatus status) throws IOException,\n\t\t\tInvalidDBException {\n\n\t\tdb = createDB();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\n\t\tPwDbHeaderV4.HeaderAndHash hh = header.loadFromFile(inStream);\n\n\t\thashOfHeader = hh.hash;\n\t\tpbHeader = hh.header;\n\t\t\t\n\t\tdb.setMasterKey(password, keyInputStream);\n\t\tdb.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);\n\n\t\tInputStream isPlain;\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\n\t\t\t// Attach decryptor\n\t\t\tCipherEngine engine;\n\t\t\tCipher cipher;\n\t\t\ttry {\n\t\t\t\tengine = CipherFactory.getInstance(db.dataCipher);\n\t\t\t\tdb.dataEngine = engine;\n\t\t\t\tcipher = engine.getCipher(Cipher.DECRYPT_MODE, db.finalKey, header.encryptionIV);\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t} catch (NoSuchPaddingException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t} catch (InvalidKeyException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t}\n\n\t\t\tInputStream decrypted = new BetterCipherInputStream(inStream, cipher, 50 * 1024);\n\t\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\t\tbyte[] storedStartBytes = null;\n\t\t\ttry {\n\t\t\t\tstoredStartBytes = dataDecrypted.readBytes(32);\n\t\t\t\tif (storedStartBytes == null || storedStartBytes.length != 32) {\n\t\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tif (!Arrays.equals(storedStartBytes, header.streamStartBytes)) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tisPlain = new HashedBlockInputStream(dataDecrypted);\n\t\t}\n\t\telse { // KDBX 4\n\t\t\tLEDataInputStream isData = new LEDataInputStream(inStream);\n\t\t\tbyte[] storedHash = isData.readBytes(32);\n\t\t\tif (!Arrays.equals(storedHash,hashOfHeader)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tbyte[] hmacKey = db.hmacKey;\n\t\t\tbyte[] headerHmac = PwDbHeaderV4.computeHeaderHmac(pbHeader, hmacKey);\n\t\t\tbyte[] storedHmac = isData.readBytes(32);\n\t\t\tif (storedHmac == null || storedHmac.length != 32) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\t\t\t// Mac doesn't match\n\t\t\tif (! Arrays.equals(headerHmac, storedHmac)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tHmacBlockInputStream hmIs = new HmacBlockInputStream(isData, true, hmacKey);\n\n\t\t\tisPlain = null;\n\n\t\t}\n\n\t\tInputStream isXml;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tisXml = new GZIPInputStream(isPlain);\n\t\t} else {\n\t\t\tisXml = isPlain;\n\t\t}\n\t\t\n\t\tif ( header.protectedStreamKey == null ) {\n\t\t\tassert(false);\n\t\t\tthrow new IOException(\"Invalid stream key.\");\n\t\t}\n\t\t\n\t\trandomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);\n\t\t\n\t\tif ( randomStream == null ) {\n\t\t\tthrow new ArcFourException();\n\t\t}\n\t\t\n\t\tReadXmlStreamed(isXml);\n\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\t\n\tprivate enum KdbContext {\n        Null,\n        KeePassFile,\n        Meta,\n        Root,\n        MemoryProtection,\n        CustomIcons,\n        CustomIcon,\n        CustomData,\n        CustomDataItem,\n        RootDeletedObjects,\n        DeletedObject,\n        Group,\n        GroupTimes,\n        Entry,\n        EntryTimes,\n        EntryString,\n        EntryBinary,\n        EntryAutoType,\n        EntryAutoTypeItem,\n        EntryHistory,\n        Binaries\n\t}\n\t\n    \n    private static final long DEFAULT_HISTORY_DAYS = 365;\n\t\n\tprivate boolean readNextNode = true;\n\tprivate Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();\n\tprivate PwGroupV4 ctxGroup = null;\n\tprivate PwEntryV4 ctxEntry = null;\n\tprivate String ctxStringName = null;\n\tprivate ProtectedString ctxStringValue = null;\n\tprivate String ctxBinaryName = null;\n\tprivate ProtectedBinary ctxBinaryValue = null;\n\tprivate String ctxATName = null;\n\tprivate String ctxATSeq = null;\n\tprivate boolean entryInHistory = false;\n\tprivate PwEntryV4 ctxHistoryBase = null;\n\tprivate PwDeletedObject ctxDeletedObject = null;\n\tprivate UUID customIconID = PwDatabaseV4.UUID_ZERO;\n\tprivate byte[] customIconData;\n\tprivate String customDataKey = null;\n\tprivate String customDataValue = null;\n\t\n\tprivate void ReadXmlStreamed(InputStream readerStream) throws IOException, InvalidDBException {\n\t\t\n\t\t\ttry {\n\t\t\t\tReadDocumentStreamed(CreatePullParser(readerStream));\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t}\n\t\n\tprivate static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {\n\t\tXmlPullParserFactory xppf = XmlPullParserFactory.newInstance();\n\t\txppf.setNamespaceAware(false);\n\t\t\n\t\tXmlPullParser xpp = xppf.newPullParser();\n\t\txpp.setInput(readerStream, null);\n\t\t\n\t\treturn xpp;\n\t}\n\n\tprivate void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\n\t\tctxGroups.clear();\n\t\t\n\t\tKdbContext ctx = KdbContext.Null;\n\t\t\n\t\treadNextNode = true;\n\t\t\n\t\twhile (true) {\n\t\t\tif ( readNextNode ) {\n\t\t\t\tif( xpp.next() == XmlPullParser.END_DOCUMENT ) break;\n\t\t\t} else {\n\t\t\t\treadNextNode = true;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ( xpp.getEventType() ) {\n\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\tctx = ReadXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase XmlPullParser.END_TAG:\n\t\t\t\tctx = EndXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Error checks\n\t\tif ( ctx != KdbContext.Null ) throw new IOException(\"Malformed\");\n\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Malformed\");\n\t}\n\n\n\tprivate KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\t\tString name = xpp.getName();\n\t\tswitch (ctx) {\n\t\tcase Null:\n\t\t\tif ( name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.KeePassFile, xpp);\n\t\t\t} else ReadUnknown(xpp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase KeePassFile:\n\t\t\tif ( name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Meta, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Root, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Meta:\n\t\t\tif ( name.equalsIgnoreCase(ElemGenerator) ) {\n\t\t\t\tReadString(xpp); // Ignore\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHeaderHash) ) {\n\t\t\t\tString encodedHash = ReadString(xpp);\n\t\t\t\tif (!EmptyUtils.isNullOrEmpty(encodedHash) && (hashOfHeader != null)) {\n\t\t\t\t\tbyte[] hash = Base64Coder.decode(encodedHash);\n\t\t\t\t\tif (!Arrays.equals(hash, hashOfHeader)) {\n\t\t\t\t\t\tthrow new InvalidDBException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbName) ) {\n\t\t\t\tdb.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {\n\t\t\t\tdb.nameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {\n\t\t\t\tdb.description = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {\n\t\t\t\tdb.descriptionChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {\n\t\t\t\tdb.defaultUserName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {\n\t\t\t\tdb.defaultUserNameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbColor)) {\n\t\t\t\t// TODO: Add support to interpret the color if we want to allow changing the database color\n\t\t\t\tdb.color = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {\n\t\t\t\tdb.keyChangeRecDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {\n\t\t\t\tdb.keyChangeForceDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.MemoryProtection, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcons, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {\n\t\t\t\tdb.recycleBinEnabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {\n\t\t\t\tdb.recycleBinUUID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {\n\t\t\t\tdb.recycleBinChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {\n\t\t\t\tdb.entryTemplatesGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxItems) ) {\n\t\t\t\tdb.historyMaxItems = ReadInt(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxSize) ) {\n\t\t\t\tdb.historyMaxSize = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {\n\t\t\t\tdb.lastSelectedGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {\n\t\t\t\tdb.lastTopVisibleGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Binaries, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomData, xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MemoryProtection:\n\t\t\tif ( name.equalsIgnoreCase(ElemProtTitle) ) {\n\t\t\t\tdb.memoryProtection.protectTitle = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {\n\t\t\t\tdb.memoryProtection.protectUserName = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {\n\t\t\t\tdb.memoryProtection.protectPassword = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtURL) ) {\n\t\t\t\tdb.memoryProtection.protectUrl = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {\n\t\t\t\tdb.memoryProtection.protectNotes = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {\n\t\t\t\tdb.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcons:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcon, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcon:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {\n\t\t\t\tcustomIconID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {\n\t\t\t\tString strData = ReadString(xpp);\n\t\t\t\tif ( strData != null && strData.length() > 0 ) {\n\t\t\t\t\tcustomIconData = Base64Coder.decode(strData);\n\t\t\t\t} else {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Binaries:\n\t\t\tif ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\tString key = xpp.getAttributeValue(null, AttrId);\n\t\t\t\tif ( key != null ) {\n\t\t\t\t\tProtectedBinary pbData = ReadProtectedBinary(xpp);\n\t\t\t\t\tbinPool.put(key, pbData);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase CustomData:\n\t\t\tif ( name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomDataItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tcustomDataKey = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tcustomDataValue = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Root:\n\t\t\tif ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tassert(ctxGroups.size() == 0);\n\t\t\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Group list should be empty.\");\n\t\t\t\t\n\t\t\t\tdb.rootGroup = new PwGroupV4();\n\t\t\t\tctxGroups.push((PwGroupV4)db.rootGroup);\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Group:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxGroup.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemName) ) {\n\t\t\t\tctxGroup.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemNotes) ) {\n\t\t\t\tctxGroup.notes = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxGroup.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxGroup.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {\n\t\t\t\tctxGroup.isExpanded = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {\n\t\t\t\tctxGroup.defaultAutoTypeSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {\n\t\t\t\tctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {\n\t\t\t\tctxGroup.enableSearching = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {\n\t\t\t\tctxGroup.lastTopVisibleEntry = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tctxGroup = new PwGroupV4();\n\t\t\t\tctxGroups.peek().AddGroup(ctxGroup, true);\n\t\t\t\tctxGroups.push(ctxGroup);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxGroup.AddEntry(ctxEntry, true);\n\t\t\t\t\n\t\t\t\tentryInHistory = false;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Entry:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxEntry.setUUID(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxEntry.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxEntry.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemFgColor) ) {\n\t\t\t\tctxEntry.foregroundColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBgColor) ) {\n\t\t\t\tctxEntry.backgroupColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {\n\t\t\t\tctxEntry.overrideURL = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTags) ) {\n\t\t\t\tctxEntry.tags = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemString) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryString, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryBinary, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoType, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\t\tassert(!entryInHistory);\n\t\t\t\t\n\t\t\t\tif ( ! entryInHistory ) {\n\t\t\t\t\tctxHistoryBase = ctxEntry;\n\t\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryHistory, xpp);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase GroupTimes:\n\t\tcase EntryTimes:\n\t\t\tITimeLogger tl;\n\t\t\tif ( ctx == KdbContext.GroupTimes ) {\n\t\t\t\ttl = ctxGroup;\n\t\t\t} else {\n\t\t\t\ttl = ctxEntry;\n\t\t\t}\n\t\t\t\n\t\t\tif ( name.equalsIgnoreCase(ElemLastModTime) ) {\n\t\t\t\ttl.setLastModificationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {\n\t\t\t\ttl.setCreationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {\n\t\t\t\ttl.setLastAccessTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {\n\t\t\t\ttl.setExpiryTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpires) ) {\n\t\t\t\ttl.setExpires(ReadBool(xpp, false));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {\n\t\t\t\ttl.setUsageCount(ReadULong(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {\n\t\t\t\ttl.setLocationChanged(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryString:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxStringName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxStringValue = ReadProtectedString(xpp); \n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryBinary:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxBinaryName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxBinaryValue = ReadProtectedBinary(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoType:\n\t\t\tif ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {\n\t\t\t\tctxEntry.autoType.enabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {\n\t\t\t\tctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {\n\t\t\t\tctxEntry.autoType.defaultSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoTypeItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemWindow) ) {\n\t\t\t\tctxATName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {\n\t\t\t\tctxATSeq = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryHistory:\n\t\t\tif ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxHistoryBase.history.add(ctxEntry);\n\t\t\t\t\n\t\t\t\tentryInHistory = true;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase RootDeletedObjects:\n\t\t\tif ( name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\t\tctxDeletedObject = new PwDeletedObject();\n\t\t\t\tdb.deletedObjects.add(ctxDeletedObject);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.DeletedObject, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase DeletedObject:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxDeletedObject.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {\n\t\t\t\tctxDeletedObject.setDeletionTime(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tReadUnknown(xpp);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ctx;\n\t}\n\n\tprivate KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {\n\t\tassert(xpp.getEventType() == XmlPullParser.END_TAG);\n\t\t\n\t\tString name = xpp.getName();\n\t\tif ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\treturn KdbContext.Null;\n\t\t} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\tif ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tPwIconCustom icon = new PwIconCustom(customIconID, customIconData);\n\t\t\t\tdb.customIcons.add(icon);\n\t\t\t\tdb.iconFactory.put(icon);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomIconID = PwDatabaseV4.UUID_ZERO;\n\t\t\tcustomIconData = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomIcons;\n\t\t} else if ( ctx == KdbContext.Binaries && name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\tif ( customDataKey != null && customDataValue != null) {\n\t\t\t\tdb.customData.put(customDataKey, customDataValue);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomDataKey = null;\n\t\t\tcustomDataValue = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomData;\n\t\t} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\tif ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxGroup.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tctxGroups.pop();\n\t\t\t\n\t\t\tif ( ctxGroups.size() == 0 ) {\n\t\t\t\tctxGroup = null;\n\t\t\t\treturn KdbContext.Root;\n\t\t\t} else {\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\treturn KdbContext.Group;\n\t\t\t}\n\t\t} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\tif ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxEntry.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tif ( entryInHistory ) {\n\t\t\t\tctxEntry = ctxHistoryBase;\n\t\t\t\treturn KdbContext.EntryHistory;\n\t\t\t}\n\t\t\t\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {\n\t\t\tctxEntry.strings.put(ctxStringName, ctxStringValue);\n\t\t\tctxStringName = null;\n\t\t\tctxStringValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\tctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);\n\t\t\tctxBinaryName = null;\n\t\t\tctxBinaryValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\tctxEntry.autoType.put(ctxATName, ctxATSeq);\n\t\t\tctxATName = null;\n\t\t\tctxATSeq = null;\n\t\t\t\n\t\t\treturn KdbContext.EntryAutoType;\n\t\t} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\tentryInHistory = false;\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\treturn KdbContext.Root;\n\t\t} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\tctxDeletedObject = null;\n\t\t\treturn KdbContext.RootDeletedObjects;\n\t\t} else {\n\t\t\tassert(false);\n\n\t\t\tString contextName = \"\";\n\t\t\tif (ctx != null) {\n\t\t\t\tcontextName = ctx.name();\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"Invalid end element: Context \" +  contextName + \"End element: \" + name);\n\t\t}\n\t}\n\t\n\tprivate Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString sDate = ReadString(xpp);\n\t\t\n\t\tDate utcDate = null;\n\t\ttry {\n\t\t\tutcDate = PwDatabaseV4XML.dateFormat.parse(sDate);\n\t\t} catch (ParseException e) {\n\t\t\t// Catch with null test below\n\t\t}\n\t\t\n\t\tif (utcDate == null) {\n\t\t\tutcDate = new Date(0L);\n\t\t}\n\t\t\n\t\treturn utcDate;\n\t\t\n\t}\n\n\tprivate void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(false);\n\t\t\n\t\tif ( xpp.isEmptyElementTag() ) return;\n\t\t\n\t\tString unknownName = xpp.getName();\n\t\tProcessNode(xpp);\n\t\t\n\t\twhile (xpp.next() != XmlPullParser.END_DOCUMENT ) {\n\t\t\tif ( xpp.getEventType() == XmlPullParser.END_TAG ) break;\n\t\t\tif ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;\n\t\t\t\n\t\t\tReadUnknown(xpp);\n\t\t}\n\t\t\n\t\tassert(xpp.getName() == unknownName);\n\t\t\n\t}\n\t\n\tprivate boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tif ( str.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( str.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn bDefault;\n\t\t}\n\t}\n\t\n\tprivate UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString encoded = ReadString(xpp);\n\t\t\n\t\tif (encoded == null || encoded.length() == 0 ) {\n\t\t\treturn PwDatabaseV4.UUID_ZERO;\n\t\t}\n\t\t\n\t\t// TODO: Switch to framework Base64 once API level 8 is the minimum\n\t\tbyte[] buf = Base64Coder.decode(encoded);\n\t\t\n\t\treturn Types.bytestoUUID(buf);\n\t}\n\t\n\tprivate int ReadInt(XmlPullParser xpp, int def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tint u;\n\t\ttry {\n\t\t\tu = Integer.parseInt(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate static final long MAX_UINT = 4294967296L; // 2^32\n\tprivate long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u;\n\t\t\n\t\tu = ReadULong(xpp, uDefault);\n\t\tif ( u < 0 || u > MAX_UINT ) {\n\t\t\tthrow new NumberFormatException(\"Outside of the uint size\");\n\t\t}\n\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tlong u;\n\t\ttry {\n\t\t\tu = Long.parseLong(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u = ReadLong(xpp, uDefault);\n\t\t\n\t\tif ( u < 0 ) {\n\t\t\tu = uDefault;\n\t\t}\n\t\t\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate ProtectedString ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null) {\n\t\t\ttry {\n\t\t\t\treturn new ProtectedString(true, new String(buf, \"UTF-8\"));\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t} \n\t\t}\n\t\t\n\t\treturn new ProtectedString(false, ReadString(xpp));\n\t}\n\t\n\tprivate ProtectedBinary ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tString ref = xpp.getAttributeValue(null, AttrRef);\n\t\tif (ref != null) {\n\t\t\txpp.next(); // Consume end tag\n\t\t\t\n\t\t\treturn binPool.get(ref);\n\t\t} \n\t\t\n\t\tboolean compressed = false;\n\t\tString comp = xpp.getAttributeValue(null, AttrCompressed);\n\t\tif (comp != null) {\n\t\t\tcompressed = comp.equalsIgnoreCase(ValTrue);\n\t\t}\n\t\t\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) return new ProtectedBinary(true, buf);\n\t\t\n\t\tString base64 = ReadString(xpp);\n\t\tif ( base64.length() == 0 ) return ProtectedBinary.EMPTY;\n\t\t\n\t\tbyte[] data = Base64Coder.decode(base64);\n\t\t\n\t\tif (compressed) {\n\t\t\tdata = MemUtil.decompress(data);\n\t\t}\n\t\t\n\t\treturn new ProtectedBinary(false, data);\n\t}\n\t\n\tprivate String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t\t\n\t}\n\t\n\tprivate String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t}\n\n\tprivate byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(xpp.getEventType() == XmlPullParser.START_TAG);\n\t\t\n\t\tbyte[] buf = null;\n\t\t\n\t\tif ( xpp.getAttributeCount() > 0 ) {\n\t\t\tString protect = xpp.getAttributeValue(null, AttrProtected);\n\t\t\tif ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {\n\t\t\t\tString encrypted = ReadStringRaw(xpp);\n\t\t\t\t\n\t\t\t\tif ( encrypted.length() > 0 ) {\n\t\t\t\t\tbuf = Base64Coder.decode(encrypted);\n\t\t\t\t\tbyte[] plainText = new byte[buf.length];\n\t\t\t\t\t\n\t\t\t\t\trandomStream.processBytes(buf, 0, buf.length, plainText, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn plainText;\n\t\t\t\t} else {\n\t\t\t\t\tbuf = new byte[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tprivate KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,\n\t\t\tXmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tif ( xpp.isEmptyElementTag() ) {\n\t\t\txpp.next();  // Consume the end tag\n\t\t\treturn ctxCurrent;\n\t\t}\n\t\treturn ctxNew;\n\t}\n\n\n\tprivate Boolean StringToBoolean(String str) {\n\t\tif ( str == null || str.length() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString trimmed = str.trim();\n\t\tif ( trimmed.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( trimmed.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Stack;\nimport java.util.TimeZone;\nimport java.util.UUID;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.spongycastle.util.encoders.Base64Encoder;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.ArcFourException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.HmacBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.DateUtil;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class ImporterV4 extends Importer {\n\t\n\tprivate StreamCipher randomStream;\n\tprivate PwDatabaseV4 db;\n\tprivate BinaryPool binPool = new BinaryPool();\n\n    private byte[] hashOfHeader = null;\n\tprivate byte[] pbHeader = null;\n\tprivate long version;\n\tCalendar utcCal;\n\n\tpublic ImporterV4() {\n\t\tutcCal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n\t}\n\t\n\tprotected PwDatabaseV4 createDB() {\n\t\treturn new PwDatabaseV4();\n\n\t}\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream) throws IOException, InvalidDBException {\n\n\t\treturn openDatabase(inStream, password, keyInputStream, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream, UpdateStatus status) throws IOException,\n\t\t\tInvalidDBException {\n\n\t\tdb = createDB();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\n\t\tPwDbHeaderV4.HeaderAndHash hh = header.loadFromFile(inStream);\n        version = header.version;\n\n\t\thashOfHeader = hh.hash;\n\t\tpbHeader = hh.header;\n\t\t\t\n\t\tdb.setMasterKey(password, keyInputStream);\n\t\tdb.makeFinalKey(header.masterSeed, db.kdfParameters);\n\n\t\tCipherEngine engine;\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tengine = CipherFactory.getInstance(db.dataCipher);\n\t\t\tdb.dataEngine = engine;\n\t\t\tcipher = engine.getCipher(Cipher.DECRYPT_MODE, db.finalKey, header.encryptionIV);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t}\n\n\t\tInputStream isPlain;\n\t\tif (version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\n\t\t\tInputStream decrypted = AttachCipherStream(inStream, cipher);\n\t\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\t\tbyte[] storedStartBytes = null;\n\t\t\ttry {\n\t\t\t\tstoredStartBytes = dataDecrypted.readBytes(32);\n\t\t\t\tif (storedStartBytes == null || storedStartBytes.length != 32) {\n\t\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tif (!Arrays.equals(storedStartBytes, header.streamStartBytes)) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tisPlain = new HashedBlockInputStream(dataDecrypted);\n\t\t}\n\t\telse { // KDBX 4\n\t\t\tLEDataInputStream isData = new LEDataInputStream(inStream);\n\t\t\tbyte[] storedHash = isData.readBytes(32);\n\t\t\tif (!Arrays.equals(storedHash,hashOfHeader)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tbyte[] hmacKey = db.hmacKey;\n\t\t\tbyte[] headerHmac = PwDbHeaderV4.computeHeaderHmac(pbHeader, hmacKey);\n\t\t\tbyte[] storedHmac = isData.readBytes(32);\n\t\t\tif (storedHmac == null || storedHmac.length != 32) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\t\t\t// Mac doesn't match\n\t\t\tif (! Arrays.equals(headerHmac, storedHmac)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tHmacBlockInputStream hmIs = new HmacBlockInputStream(isData, true, hmacKey);\n\n\t\t\tisPlain = AttachCipherStream(hmIs, cipher);\n\t\t}\n\n\t\tInputStream isXml;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tisXml = new GZIPInputStream(isPlain);\n\t\t} else {\n\t\t\tisXml = isPlain;\n\t\t}\n\n\t\tif (version >= header.FILE_VERSION_32_4) {\n\t\t\tLoadInnerHeader(isXml, header);\n\t\t}\n\t\t\n\t\tif ( header.protectedStreamKey == null ) {\n\t\t\tassert(false);\n\t\t\tthrow new IOException(\"Invalid stream key.\");\n\t\t}\n\t\t\n\t\trandomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);\n\t\t\n\t\tif ( randomStream == null ) {\n\t\t\tthrow new ArcFourException();\n\t\t}\n\t\t\n\t\tReadXmlStreamed(isXml);\n\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\n\tprivate InputStream AttachCipherStream(InputStream is, Cipher cipher) {\n\t\treturn new BetterCipherInputStream(is, cipher, 50 * 1024);\n\t}\n\n\tprivate void LoadInnerHeader(InputStream is, PwDbHeaderV4 header) throws IOException {\n\t\tLEDataInputStream lis = new LEDataInputStream(is);\n\n\t\twhile(true) {\n\t\t\tif (!ReadInnerHeader(lis, header)) break;\n\t\t}\n\n\t}\n\n\tprivate boolean ReadInnerHeader(LEDataInputStream lis, PwDbHeaderV4 header) throws IOException {\n\t\tbyte fieldId = (byte)lis.read();\n\n\t\tint size = lis.readInt();\n\t\tif (size < 0) throw new IOException(\"Corrupted file\");\n\n\t\tbyte[] data = new byte[0];\n\t\tif (size > 0) {\n\t\t\tdata = lis.readBytes(size);\n\t\t}\n\n\t\tboolean result = true;\n\t\tswitch(fieldId) {\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.EndOfHeader:\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.InnerRandomStreamID:\n\t\t\t    header.setRandomStreamID(data);\n\t\t\t\tbreak;\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.InnerRandomstreamKey:\n\t\t\t    header.protectedStreamKey = data;\n\t\t\t\tbreak;\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.Binary:\n\t\t\t    if (data.length < 1) throw new IOException(\"Invalid binary format\");\n\t\t\t\tbyte flag = data[0];\n\t\t\t\tboolean prot = (flag & PwDbHeaderV4.KdbxBinaryFlags.Protected) !=\n\t\t\t\t\t\tPwDbHeaderV4.KdbxBinaryFlags.None;\n\n\t\t\t\tbyte[] bin = new byte[data.length - 1];\n\t\t\t\tSystem.arraycopy(data, 1, bin, 0, data.length-1);\n\t\t\t\tProtectedBinary pb = new ProtectedBinary(prot, bin);\n\n\t\t\t\tif (prot) {\n\t\t\t\t\tArrays.fill(data, (byte)0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate enum KdbContext {\n        Null,\n        KeePassFile,\n        Meta,\n        Root,\n        MemoryProtection,\n        CustomIcons,\n        CustomIcon,\n        CustomData,\n        CustomDataItem,\n        RootDeletedObjects,\n        DeletedObject,\n        Group,\n        GroupTimes,\n\t\tGroupCustomData,\n\t\tGroupCustomDataItem,\n        Entry,\n        EntryTimes,\n        EntryString,\n        EntryBinary,\n        EntryAutoType,\n        EntryAutoTypeItem,\n        EntryHistory,\n\t\tEntryCustomData,\n\t\tEntryCustomDataItem,\n        Binaries\n\t}\n\n    private static final long DEFAULT_HISTORY_DAYS = 365;\n\t\n\tprivate boolean readNextNode = true;\n\tprivate Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();\n\tprivate PwGroupV4 ctxGroup = null;\n\tprivate PwEntryV4 ctxEntry = null;\n\tprivate String ctxStringName = null;\n\tprivate ProtectedString ctxStringValue = null;\n\tprivate String ctxBinaryName = null;\n\tprivate ProtectedBinary ctxBinaryValue = null;\n\tprivate String ctxATName = null;\n\tprivate String ctxATSeq = null;\n\tprivate boolean entryInHistory = false;\n\tprivate PwEntryV4 ctxHistoryBase = null;\n\tprivate PwDeletedObject ctxDeletedObject = null;\n\tprivate UUID customIconID = PwDatabaseV4.UUID_ZERO;\n\tprivate byte[] customIconData;\n\tprivate String customDataKey = null;\n\tprivate String customDataValue = null;\n\tprivate String groupCustomDataKey = null;\n\tprivate String groupCustomDataValue = null;\n\tprivate String entryCustomDataKey = null;\n\tprivate String entryCustomDataValue = null;\n\n\tprivate void ReadXmlStreamed(InputStream readerStream) throws IOException, InvalidDBException {\n\t\t\n\t\t\ttry {\n\t\t\t\tReadDocumentStreamed(CreatePullParser(readerStream));\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t}\n\t\n\tprivate static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {\n\t\tXmlPullParserFactory xppf = XmlPullParserFactory.newInstance();\n\t\txppf.setNamespaceAware(false);\n\t\t\n\t\tXmlPullParser xpp = xppf.newPullParser();\n\t\txpp.setInput(readerStream, null);\n\t\t\n\t\treturn xpp;\n\t}\n\n\tprivate void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\n\t\tctxGroups.clear();\n\t\t\n\t\tKdbContext ctx = KdbContext.Null;\n\t\t\n\t\treadNextNode = true;\n\t\t\n\t\twhile (true) {\n\t\t\tif ( readNextNode ) {\n\t\t\t\tif( xpp.next() == XmlPullParser.END_DOCUMENT ) break;\n\t\t\t} else {\n\t\t\t\treadNextNode = true;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ( xpp.getEventType() ) {\n\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\tctx = ReadXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase XmlPullParser.END_TAG:\n\t\t\t\tctx = EndXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Error checks\n\t\tif ( ctx != KdbContext.Null ) throw new IOException(\"Malformed\");\n\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Malformed\");\n\t}\n\n\n\tprivate KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\t\tString name = xpp.getName();\n\t\tswitch (ctx) {\n\t\tcase Null:\n\t\t\tif ( name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.KeePassFile, xpp);\n\t\t\t} else ReadUnknown(xpp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase KeePassFile:\n\t\t\tif ( name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Meta, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Root, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Meta:\n\t\t\tif ( name.equalsIgnoreCase(ElemGenerator) ) {\n\t\t\t\tReadString(xpp); // Ignore\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHeaderHash) ) {\n\t\t\t\tString encodedHash = ReadString(xpp);\n\t\t\t\tif (!EmptyUtils.isNullOrEmpty(encodedHash) && (hashOfHeader != null)) {\n\t\t\t\t\tbyte[] hash = Base64Coder.decode(encodedHash);\n\t\t\t\t\tif (!Arrays.equals(hash, hashOfHeader)) {\n\t\t\t\t\t\tthrow new InvalidDBException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (name.equalsIgnoreCase(ElemSettingsChanged)) {\n\t\t\t\tdb.settingsChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbName) ) {\n\t\t\t\tdb.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {\n\t\t\t\tdb.nameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {\n\t\t\t\tdb.description = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {\n\t\t\t\tdb.descriptionChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {\n\t\t\t\tdb.defaultUserName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {\n\t\t\t\tdb.defaultUserNameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbColor)) {\n\t\t\t\t// TODO: Add support to interpret the color if we want to allow changing the database color\n\t\t\t\tdb.color = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {\n\t\t\t\tdb.keyChangeRecDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {\n\t\t\t\tdb.keyChangeForceDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForceOnce) ) {\n\t\t\t\tdb.keyChangeForceOnce = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.MemoryProtection, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcons, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {\n\t\t\t\tdb.recycleBinEnabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {\n\t\t\t\tdb.recycleBinUUID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {\n\t\t\t\tdb.recycleBinChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {\n\t\t\t\tdb.entryTemplatesGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxItems) ) {\n\t\t\t\tdb.historyMaxItems = ReadInt(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxSize) ) {\n\t\t\t\tdb.historyMaxSize = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {\n\t\t\t\tdb.lastSelectedGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {\n\t\t\t\tdb.lastTopVisibleGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Binaries, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomData, xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MemoryProtection:\n\t\t\tif ( name.equalsIgnoreCase(ElemProtTitle) ) {\n\t\t\t\tdb.memoryProtection.protectTitle = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {\n\t\t\t\tdb.memoryProtection.protectUserName = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {\n\t\t\t\tdb.memoryProtection.protectPassword = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtURL) ) {\n\t\t\t\tdb.memoryProtection.protectUrl = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {\n\t\t\t\tdb.memoryProtection.protectNotes = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {\n\t\t\t\tdb.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcons:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcon, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcon:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {\n\t\t\t\tcustomIconID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {\n\t\t\t\tString strData = ReadString(xpp);\n\t\t\t\tif ( strData != null && strData.length() > 0 ) {\n\t\t\t\t\tcustomIconData = Base64Coder.decode(strData);\n\t\t\t\t} else {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Binaries:\n\t\t\tif ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\tString key = xpp.getAttributeValue(null, AttrId);\n\t\t\t\tif ( key != null ) {\n\t\t\t\t\tProtectedBinary pbData = ReadProtectedBinary(xpp);\n\t\t\t\t\tint id = Integer.parseInt(key);\n\t\t\t\t\tbinPool.put(id, pbData);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase CustomData:\n\t\t\tif ( name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomDataItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tcustomDataKey = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tcustomDataValue = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Root:\n\t\t\tif ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tassert(ctxGroups.size() == 0);\n\t\t\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Group list should be empty.\");\n\t\t\t\t\n\t\t\t\tdb.rootGroup = new PwGroupV4();\n\t\t\t\tctxGroups.push((PwGroupV4)db.rootGroup);\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Group:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxGroup.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemName) ) {\n\t\t\t\tctxGroup.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemNotes) ) {\n\t\t\t\tctxGroup.notes = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxGroup.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxGroup.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {\n\t\t\t\tctxGroup.isExpanded = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {\n\t\t\t\tctxGroup.defaultAutoTypeSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {\n\t\t\t\tctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {\n\t\t\t\tctxGroup.enableSearching = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {\n\t\t\t\tctxGroup.lastTopVisibleEntry = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n                return SwitchContext(ctx, KdbContext.GroupCustomData, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tctxGroup = new PwGroupV4();\n\t\t\t\tctxGroups.peek().AddGroup(ctxGroup, true);\n\t\t\t\tctxGroups.push(ctxGroup);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxGroup.AddEntry(ctxEntry, true);\n\t\t\t\t\n\t\t\t\tentryInHistory = false;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n        case GroupCustomData:\n        \tif (name.equalsIgnoreCase(ElemStringDictExItem)) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupCustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n            break;\n        case GroupCustomDataItem:\n        \tif (name.equalsIgnoreCase(ElemKey)) {\n\t\t\t\tgroupCustomDataKey = ReadString(xpp);\n\t\t\t} else if (name.equalsIgnoreCase(ElemValue)) {\n\t\t\t\tgroupCustomDataValue = ReadString(xpp);\n            } else {\n                ReadUnknown(xpp);\n            }\n            break;\n\n\t\t\t\n\t\tcase Entry:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxEntry.setUUID(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxEntry.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxEntry.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemFgColor) ) {\n\t\t\t\tctxEntry.foregroundColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBgColor) ) {\n\t\t\t\tctxEntry.backgroupColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {\n\t\t\t\tctxEntry.overrideURL = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTags) ) {\n\t\t\t\tctxEntry.tags = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemString) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryString, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryBinary, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoType, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData)) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryCustomData, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\t\tassert(!entryInHistory);\n\t\t\t\t\n\t\t\t\tif ( ! entryInHistory ) {\n\t\t\t\t\tctxHistoryBase = ctxEntry;\n\t\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryHistory, xpp);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n        case EntryCustomData:\n            if (name.equalsIgnoreCase(ElemStringDictExItem)) {\n                return SwitchContext(ctx, KdbContext.EntryCustomDataItem, xpp);\n            } else {\n                ReadUnknown(xpp);\n            }\n            break;\n        case EntryCustomDataItem:\n            if (name.equalsIgnoreCase(ElemKey)) {\n                entryCustomDataKey = ReadString(xpp);\n            } else if (name.equalsIgnoreCase(ElemValue)) {\n                entryCustomDataValue = ReadString(xpp);\n            } else {\n                ReadUnknown(xpp);\n            }\n            break;\n\n\t\tcase GroupTimes:\n\t\tcase EntryTimes:\n\t\t\tITimeLogger tl;\n\t\t\tif ( ctx == KdbContext.GroupTimes ) {\n\t\t\t\ttl = ctxGroup;\n\t\t\t} else {\n\t\t\t\ttl = ctxEntry;\n\t\t\t}\n\t\t\t\n\t\t\tif ( name.equalsIgnoreCase(ElemLastModTime) ) {\n\t\t\t\ttl.setLastModificationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {\n\t\t\t\ttl.setCreationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {\n\t\t\t\ttl.setLastAccessTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {\n\t\t\t\ttl.setExpiryTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpires) ) {\n\t\t\t\ttl.setExpires(ReadBool(xpp, false));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {\n\t\t\t\ttl.setUsageCount(ReadULong(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {\n\t\t\t\ttl.setLocationChanged(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryString:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxStringName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxStringValue = ReadProtectedString(xpp); \n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryBinary:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxBinaryName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxBinaryValue = ReadProtectedBinary(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoType:\n\t\t\tif ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {\n\t\t\t\tctxEntry.autoType.enabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {\n\t\t\t\tctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {\n\t\t\t\tctxEntry.autoType.defaultSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoTypeItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemWindow) ) {\n\t\t\t\tctxATName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {\n\t\t\t\tctxATSeq = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryHistory:\n\t\t\tif ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxHistoryBase.history.add(ctxEntry);\n\t\t\t\t\n\t\t\t\tentryInHistory = true;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase RootDeletedObjects:\n\t\t\tif ( name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\t\tctxDeletedObject = new PwDeletedObject();\n\t\t\t\tdb.deletedObjects.add(ctxDeletedObject);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.DeletedObject, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase DeletedObject:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxDeletedObject.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {\n\t\t\t\tctxDeletedObject.setDeletionTime(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tReadUnknown(xpp);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ctx;\n\t}\n\n\tprivate KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {\n\t\tassert(xpp.getEventType() == XmlPullParser.END_TAG);\n\t\t\n\t\tString name = xpp.getName();\n\t\tif ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\treturn KdbContext.Null;\n\t\t} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\tif ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tPwIconCustom icon = new PwIconCustom(customIconID, customIconData);\n\t\t\t\tdb.customIcons.add(icon);\n\t\t\t\tdb.iconFactory.put(icon);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomIconID = PwDatabaseV4.UUID_ZERO;\n\t\t\tcustomIconData = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomIcons;\n\t\t} else if ( ctx == KdbContext.Binaries && name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\tif ( customDataKey != null && customDataValue != null) {\n\t\t\t\tdb.customData.put(customDataKey, customDataValue);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomDataKey = null;\n\t\t\tcustomDataValue = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomData;\n\t\t} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\tif ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxGroup.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tctxGroups.pop();\n\t\t\t\n\t\t\tif ( ctxGroups.size() == 0 ) {\n\t\t\t\tctxGroup = null;\n\t\t\t\treturn KdbContext.Root;\n\t\t\t} else {\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\treturn KdbContext.Group;\n\t\t\t}\n\t\t} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.GroupCustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.GroupCustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem)) {\n\t\t\tif (groupCustomDataKey != null && groupCustomDataValue != null) {\n\t\t\t\tctxGroup.customData.put(groupCustomDataKey, groupCustomDataKey);\n\t\t\t} else {\n\t\t\t\tassert(false);\n\t\t\t}\n\n\t\t\tgroupCustomDataKey = null;\n\t\t\tgroupCustomDataValue = null;\n\n\t\t\treturn KdbContext.GroupCustomData;\n\n\t\t} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\tif ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxEntry.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tif ( entryInHistory ) {\n\t\t\t\tctxEntry = ctxHistoryBase;\n\t\t\t\treturn KdbContext.EntryHistory;\n\t\t\t}\n\t\t\t\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {\n\t\t\tctxEntry.strings.put(ctxStringName, ctxStringValue);\n\t\t\tctxStringName = null;\n\t\t\tctxStringValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\tctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);\n\t\t\tctxBinaryName = null;\n\t\t\tctxBinaryValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\tctxEntry.autoType.put(ctxATName, ctxATSeq);\n\t\t\tctxATName = null;\n\t\t\tctxATSeq = null;\n\n\t\t\treturn KdbContext.EntryAutoType;\n\t\t} else if ( ctx == KdbContext.EntryCustomData && name.equalsIgnoreCase(ElemCustomData)) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryCustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem)) {\n\t\t\tif (entryCustomDataKey != null && entryCustomDataValue != null) {\n\t\t\t\tctxEntry.customData.put(entryCustomDataKey, entryCustomDataValue);\n\t\t\t} else {\n\t\t\t\tassert(false);\n\t\t\t}\n\n\t\t\tentryCustomDataKey = null;\n\t\t\tentryCustomDataValue = null;\n\n\t\t\treturn KdbContext.EntryCustomData;\n\t\t} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\tentryInHistory = false;\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\treturn KdbContext.Root;\n\t\t} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\tctxDeletedObject = null;\n\t\t\treturn KdbContext.RootDeletedObjects;\n\t\t} else {\n\t\t\tassert(false);\n\n\t\t\tString contextName = \"\";\n\t\t\tif (ctx != null) {\n\t\t\t\tcontextName = ctx.name();\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"Invalid end element: Context \" +  contextName + \"End element: \" + name);\n\t\t}\n\t}\n\t\n\tprivate Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString sDate = ReadString(xpp);\n\t\tDate utcDate = null;\n\n\t\tif (version >= PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\tbyte[] buf = Base64Coder.decode(sDate);\n\t\t\tif (buf.length != 8) {\n\t\t\t\tbyte[] buf8 = new byte[8];\n\t\t\t\tSystem.arraycopy(buf, 0, buf8, 0, buf.length);\n\t\t\t\tbuf = buf8;\n\t\t\t}\n\n\t\t\tlong seconds = LEDataInputStream.readLong(buf, 0);\n\t\t\tutcDate = DateUtil.convertKDBX4Time(seconds);\n\n\t\t} else {\n\n\t\t\ttry {\n\t\t\t\tutcDate = PwDatabaseV4XML.dateFormat.parse(sDate);\n\t\t\t} catch (ParseException e) {\n\t\t\t\t// Catch with null test below\n\t\t\t}\n\n\t\t\tif (utcDate == null) {\n\t\t\t\tutcDate = new Date(0L);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn utcDate;\n\t\t\n\t}\n\n\tprivate void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(false);\n\t\t\n\t\tif ( xpp.isEmptyElementTag() ) return;\n\t\t\n\t\tString unknownName = xpp.getName();\n\t\tProcessNode(xpp);\n\t\t\n\t\twhile (xpp.next() != XmlPullParser.END_DOCUMENT ) {\n\t\t\tif ( xpp.getEventType() == XmlPullParser.END_TAG ) break;\n\t\t\tif ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;\n\t\t\t\n\t\t\tReadUnknown(xpp);\n\t\t}\n\t\t\n\t\tassert(xpp.getName() == unknownName);\n\t\t\n\t}\n\t\n\tprivate boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tif ( str.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( str.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn bDefault;\n\t\t}\n\t}\n\t\n\tprivate UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString encoded = ReadString(xpp);\n\t\t\n\t\tif (encoded == null || encoded.length() == 0 ) {\n\t\t\treturn PwDatabaseV4.UUID_ZERO;\n\t\t}\n\t\t\n\t\t// TODO: Switch to framework Base64 once API level 8 is the minimum\n\t\tbyte[] buf = Base64Coder.decode(encoded);\n\t\t\n\t\treturn Types.bytestoUUID(buf);\n\t}\n\t\n\tprivate int ReadInt(XmlPullParser xpp, int def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tint u;\n\t\ttry {\n\t\t\tu = Integer.parseInt(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate static final long MAX_UINT = 4294967296L; // 2^32\n\tprivate long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u;\n\t\t\n\t\tu = ReadULong(xpp, uDefault);\n\t\tif ( u < 0 || u > MAX_UINT ) {\n\t\t\tthrow new NumberFormatException(\"Outside of the uint size\");\n\t\t}\n\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tlong u;\n\t\ttry {\n\t\t\tu = Long.parseLong(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u = ReadLong(xpp, uDefault);\n\t\t\n\t\tif ( u < 0 ) {\n\t\t\tu = uDefault;\n\t\t}\n\t\t\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate ProtectedString ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null) {\n\t\t\ttry {\n\t\t\t\treturn new ProtectedString(true, new String(buf, \"UTF-8\"));\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t} \n\t\t}\n\t\t\n\t\treturn new ProtectedString(false, ReadString(xpp));\n\t}\n\t\n\tprivate ProtectedBinary ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tString ref = xpp.getAttributeValue(null, AttrRef);\n\t\tif (ref != null) {\n\t\t\txpp.next(); // Consume end tag\n\n\t\t\tint id = Integer.parseInt(ref);\n\t\t\treturn binPool.get(id);\n\t\t} \n\t\t\n\t\tboolean compressed = false;\n\t\tString comp = xpp.getAttributeValue(null, AttrCompressed);\n\t\tif (comp != null) {\n\t\t\tcompressed = comp.equalsIgnoreCase(ValTrue);\n\t\t}\n\t\t\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) return new ProtectedBinary(true, buf);\n\t\t\n\t\tString base64 = ReadString(xpp);\n\t\tif ( base64.length() == 0 ) return ProtectedBinary.EMPTY;\n\t\t\n\t\tbyte[] data = Base64Coder.decode(base64);\n\t\t\n\t\tif (compressed) {\n\t\t\tdata = MemUtil.decompress(data);\n\t\t}\n\t\t\n\t\treturn new ProtectedBinary(false, data);\n\t}\n\t\n\tprivate String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t\t\n\t}\n\t\n\tprivate String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t}\n\n\tprivate byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(xpp.getEventType() == XmlPullParser.START_TAG);\n\t\t\n\t\tbyte[] buf = null;\n\t\t\n\t\tif ( xpp.getAttributeCount() > 0 ) {\n\t\t\tString protect = xpp.getAttributeValue(null, AttrProtected);\n\t\t\tif ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {\n\t\t\t\tString encrypted = ReadStringRaw(xpp);\n\t\t\t\t\n\t\t\t\tif ( encrypted.length() > 0 ) {\n\t\t\t\t\tbuf = Base64Coder.decode(encrypted);\n\t\t\t\t\tbyte[] plainText = new byte[buf.length];\n\t\t\t\t\t\n\t\t\t\t\trandomStream.processBytes(buf, 0, buf.length, plainText, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn plainText;\n\t\t\t\t} else {\n\t\t\t\t\tbuf = new byte[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tprivate KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,\n\t\t\tXmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tif ( xpp.isEmptyElementTag() ) {\n\t\t\txpp.next();  // Consume the end tag\n\t\t\treturn ctxCurrent;\n\t\t}\n\t\treturn ctxNew;\n\t}\n\n\n\tprivate Boolean StringToBoolean(String str) {\n\t\tif ( str == null || str.length() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString trimmed = str.trim();\n\t\tif ( trimmed.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( trimmed.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n}\n","lineNo":514}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.ArcFourException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.HmacBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class ImporterV4 extends Importer {\n\t\n\tprivate StreamCipher randomStream;\n\tprivate PwDatabaseV4 db;\n\tprivate BinaryPool binPool = new BinaryPool();\n\n    private byte[] hashOfHeader = null;\n\tprivate byte[] pbHeader = null;\n\t\n\tprotected PwDatabaseV4 createDB() {\n\t\treturn new PwDatabaseV4();\n\n\t}\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream) throws IOException, InvalidDBException {\n\n\t\treturn openDatabase(inStream, password, keyInputStream, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream, UpdateStatus status) throws IOException,\n\t\t\tInvalidDBException {\n\n\t\tdb = createDB();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\n\t\tPwDbHeaderV4.HeaderAndHash hh = header.loadFromFile(inStream);\n\n\t\thashOfHeader = hh.hash;\n\t\tpbHeader = hh.header;\n\t\t\t\n\t\tdb.setMasterKey(password, keyInputStream);\n\t\tdb.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);\n\n\t\tInputStream isPlain;\n\t\tif (header.version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\n\t\t\t// Attach decryptor\n\t\t\tCipherEngine engine;\n\t\t\tCipher cipher;\n\t\t\ttry {\n\t\t\t\tengine = CipherFactory.getInstance(db.dataCipher);\n\t\t\t\tdb.dataEngine = engine;\n\t\t\t\tcipher = engine.getCipher(Cipher.DECRYPT_MODE, db.finalKey, header.encryptionIV);\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t} catch (NoSuchPaddingException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t} catch (InvalidKeyException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t\t}\n\n\t\t\tInputStream decrypted = new BetterCipherInputStream(inStream, cipher, 50 * 1024);\n\t\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\t\tbyte[] storedStartBytes = null;\n\t\t\ttry {\n\t\t\t\tstoredStartBytes = dataDecrypted.readBytes(32);\n\t\t\t\tif (storedStartBytes == null || storedStartBytes.length != 32) {\n\t\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tif (!Arrays.equals(storedStartBytes, header.streamStartBytes)) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tisPlain = new HashedBlockInputStream(dataDecrypted);\n\t\t}\n\t\telse { // KDBX 4\n\t\t\tLEDataInputStream isData = new LEDataInputStream(inStream);\n\t\t\tbyte[] storedHash = isData.readBytes(32);\n\t\t\tif (!Arrays.equals(storedHash,hashOfHeader)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tbyte[] hmacKey = db.hmacKey;\n\t\t\tbyte[] headerHmac = PwDbHeaderV4.computeHeaderHmac(pbHeader, hmacKey);\n\t\t\tbyte[] storedHmac = isData.readBytes(32);\n\t\t\tif (storedHmac == null || storedHmac.length != 32) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\t\t\t// Mac doesn't match\n\t\t\tif (! Arrays.equals(headerHmac, storedHmac)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tHmacBlockInputStream hmIs = new HmacBlockInputStream(isData, true, hmacKey);\n\n\t\t\tisPlain = null;\n\n\t\t}\n\n\t\tInputStream isXml;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tisXml = new GZIPInputStream(isPlain);\n\t\t} else {\n\t\t\tisXml = isPlain;\n\t\t}\n\t\t\n\t\tif ( header.protectedStreamKey == null ) {\n\t\t\tassert(false);\n\t\t\tthrow new IOException(\"Invalid stream key.\");\n\t\t}\n\t\t\n\t\trandomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);\n\t\t\n\t\tif ( randomStream == null ) {\n\t\t\tthrow new ArcFourException();\n\t\t}\n\t\t\n\t\tReadXmlStreamed(isXml);\n\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\t\n\tprivate enum KdbContext {\n        Null,\n        KeePassFile,\n        Meta,\n        Root,\n        MemoryProtection,\n        CustomIcons,\n        CustomIcon,\n        CustomData,\n        CustomDataItem,\n        RootDeletedObjects,\n        DeletedObject,\n        Group,\n        GroupTimes,\n        Entry,\n        EntryTimes,\n        EntryString,\n        EntryBinary,\n        EntryAutoType,\n        EntryAutoTypeItem,\n        EntryHistory,\n        Binaries\n\t}\n\t\n    \n    private static final long DEFAULT_HISTORY_DAYS = 365;\n\t\n\tprivate boolean readNextNode = true;\n\tprivate Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();\n\tprivate PwGroupV4 ctxGroup = null;\n\tprivate PwEntryV4 ctxEntry = null;\n\tprivate String ctxStringName = null;\n\tprivate ProtectedString ctxStringValue = null;\n\tprivate String ctxBinaryName = null;\n\tprivate ProtectedBinary ctxBinaryValue = null;\n\tprivate String ctxATName = null;\n\tprivate String ctxATSeq = null;\n\tprivate boolean entryInHistory = false;\n\tprivate PwEntryV4 ctxHistoryBase = null;\n\tprivate PwDeletedObject ctxDeletedObject = null;\n\tprivate UUID customIconID = PwDatabaseV4.UUID_ZERO;\n\tprivate byte[] customIconData;\n\tprivate String customDataKey = null;\n\tprivate String customDataValue = null;\n\t\n\tprivate void ReadXmlStreamed(InputStream readerStream) throws IOException, InvalidDBException {\n\t\t\n\t\t\ttry {\n\t\t\t\tReadDocumentStreamed(CreatePullParser(readerStream));\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t}\n\t\n\tprivate static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {\n\t\tXmlPullParserFactory xppf = XmlPullParserFactory.newInstance();\n\t\txppf.setNamespaceAware(false);\n\t\t\n\t\tXmlPullParser xpp = xppf.newPullParser();\n\t\txpp.setInput(readerStream, null);\n\t\t\n\t\treturn xpp;\n\t}\n\n\tprivate void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\n\t\tctxGroups.clear();\n\t\t\n\t\tKdbContext ctx = KdbContext.Null;\n\t\t\n\t\treadNextNode = true;\n\t\t\n\t\twhile (true) {\n\t\t\tif ( readNextNode ) {\n\t\t\t\tif( xpp.next() == XmlPullParser.END_DOCUMENT ) break;\n\t\t\t} else {\n\t\t\t\treadNextNode = true;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ( xpp.getEventType() ) {\n\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\tctx = ReadXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase XmlPullParser.END_TAG:\n\t\t\t\tctx = EndXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Error checks\n\t\tif ( ctx != KdbContext.Null ) throw new IOException(\"Malformed\");\n\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Malformed\");\n\t}\n\n\n\tprivate KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\t\tString name = xpp.getName();\n\t\tswitch (ctx) {\n\t\tcase Null:\n\t\t\tif ( name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.KeePassFile, xpp);\n\t\t\t} else ReadUnknown(xpp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase KeePassFile:\n\t\t\tif ( name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Meta, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Root, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Meta:\n\t\t\tif ( name.equalsIgnoreCase(ElemGenerator) ) {\n\t\t\t\tReadString(xpp); // Ignore\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHeaderHash) ) {\n\t\t\t\tString encodedHash = ReadString(xpp);\n\t\t\t\tif (!EmptyUtils.isNullOrEmpty(encodedHash) && (hashOfHeader != null)) {\n\t\t\t\t\tbyte[] hash = Base64Coder.decode(encodedHash);\n\t\t\t\t\tif (!Arrays.equals(hash, hashOfHeader)) {\n\t\t\t\t\t\tthrow new InvalidDBException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbName) ) {\n\t\t\t\tdb.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {\n\t\t\t\tdb.nameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {\n\t\t\t\tdb.description = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {\n\t\t\t\tdb.descriptionChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {\n\t\t\t\tdb.defaultUserName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {\n\t\t\t\tdb.defaultUserNameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbColor)) {\n\t\t\t\t// TODO: Add support to interpret the color if we want to allow changing the database color\n\t\t\t\tdb.color = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {\n\t\t\t\tdb.keyChangeRecDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {\n\t\t\t\tdb.keyChangeForceDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.MemoryProtection, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcons, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {\n\t\t\t\tdb.recycleBinEnabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {\n\t\t\t\tdb.recycleBinUUID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {\n\t\t\t\tdb.recycleBinChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {\n\t\t\t\tdb.entryTemplatesGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxItems) ) {\n\t\t\t\tdb.historyMaxItems = ReadInt(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxSize) ) {\n\t\t\t\tdb.historyMaxSize = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {\n\t\t\t\tdb.lastSelectedGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {\n\t\t\t\tdb.lastTopVisibleGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Binaries, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomData, xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MemoryProtection:\n\t\t\tif ( name.equalsIgnoreCase(ElemProtTitle) ) {\n\t\t\t\tdb.memoryProtection.protectTitle = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {\n\t\t\t\tdb.memoryProtection.protectUserName = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {\n\t\t\t\tdb.memoryProtection.protectPassword = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtURL) ) {\n\t\t\t\tdb.memoryProtection.protectUrl = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {\n\t\t\t\tdb.memoryProtection.protectNotes = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {\n\t\t\t\tdb.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcons:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcon, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcon:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {\n\t\t\t\tcustomIconID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {\n\t\t\t\tString strData = ReadString(xpp);\n\t\t\t\tif ( strData != null && strData.length() > 0 ) {\n\t\t\t\t\tcustomIconData = Base64Coder.decode(strData);\n\t\t\t\t} else {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Binaries:\n\t\t\tif ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\tString key = xpp.getAttributeValue(null, AttrId);\n\t\t\t\tif ( key != null ) {\n\t\t\t\t\tProtectedBinary pbData = ReadProtectedBinary(xpp);\n\t\t\t\t\tbinPool.put(key, pbData);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase CustomData:\n\t\t\tif ( name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomDataItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tcustomDataKey = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tcustomDataValue = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Root:\n\t\t\tif ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tassert(ctxGroups.size() == 0);\n\t\t\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Group list should be empty.\");\n\t\t\t\t\n\t\t\t\tdb.rootGroup = new PwGroupV4();\n\t\t\t\tctxGroups.push((PwGroupV4)db.rootGroup);\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Group:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxGroup.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemName) ) {\n\t\t\t\tctxGroup.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemNotes) ) {\n\t\t\t\tctxGroup.notes = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxGroup.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxGroup.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {\n\t\t\t\tctxGroup.isExpanded = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {\n\t\t\t\tctxGroup.defaultAutoTypeSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {\n\t\t\t\tctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {\n\t\t\t\tctxGroup.enableSearching = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {\n\t\t\t\tctxGroup.lastTopVisibleEntry = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tctxGroup = new PwGroupV4();\n\t\t\t\tctxGroups.peek().AddGroup(ctxGroup, true);\n\t\t\t\tctxGroups.push(ctxGroup);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxGroup.AddEntry(ctxEntry, true);\n\t\t\t\t\n\t\t\t\tentryInHistory = false;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Entry:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxEntry.setUUID(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxEntry.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxEntry.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemFgColor) ) {\n\t\t\t\tctxEntry.foregroundColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBgColor) ) {\n\t\t\t\tctxEntry.backgroupColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {\n\t\t\t\tctxEntry.overrideURL = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTags) ) {\n\t\t\t\tctxEntry.tags = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemString) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryString, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryBinary, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoType, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\t\tassert(!entryInHistory);\n\t\t\t\t\n\t\t\t\tif ( ! entryInHistory ) {\n\t\t\t\t\tctxHistoryBase = ctxEntry;\n\t\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryHistory, xpp);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase GroupTimes:\n\t\tcase EntryTimes:\n\t\t\tITimeLogger tl;\n\t\t\tif ( ctx == KdbContext.GroupTimes ) {\n\t\t\t\ttl = ctxGroup;\n\t\t\t} else {\n\t\t\t\ttl = ctxEntry;\n\t\t\t}\n\t\t\t\n\t\t\tif ( name.equalsIgnoreCase(ElemLastModTime) ) {\n\t\t\t\ttl.setLastModificationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {\n\t\t\t\ttl.setCreationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {\n\t\t\t\ttl.setLastAccessTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {\n\t\t\t\ttl.setExpiryTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpires) ) {\n\t\t\t\ttl.setExpires(ReadBool(xpp, false));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {\n\t\t\t\ttl.setUsageCount(ReadULong(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {\n\t\t\t\ttl.setLocationChanged(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryString:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxStringName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxStringValue = ReadProtectedString(xpp); \n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryBinary:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxBinaryName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxBinaryValue = ReadProtectedBinary(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoType:\n\t\t\tif ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {\n\t\t\t\tctxEntry.autoType.enabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {\n\t\t\t\tctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {\n\t\t\t\tctxEntry.autoType.defaultSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoTypeItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemWindow) ) {\n\t\t\t\tctxATName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {\n\t\t\t\tctxATSeq = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryHistory:\n\t\t\tif ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxHistoryBase.history.add(ctxEntry);\n\t\t\t\t\n\t\t\t\tentryInHistory = true;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase RootDeletedObjects:\n\t\t\tif ( name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\t\tctxDeletedObject = new PwDeletedObject();\n\t\t\t\tdb.deletedObjects.add(ctxDeletedObject);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.DeletedObject, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase DeletedObject:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxDeletedObject.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {\n\t\t\t\tctxDeletedObject.setDeletionTime(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tReadUnknown(xpp);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ctx;\n\t}\n\n\tprivate KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {\n\t\tassert(xpp.getEventType() == XmlPullParser.END_TAG);\n\t\t\n\t\tString name = xpp.getName();\n\t\tif ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\treturn KdbContext.Null;\n\t\t} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\tif ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tPwIconCustom icon = new PwIconCustom(customIconID, customIconData);\n\t\t\t\tdb.customIcons.add(icon);\n\t\t\t\tdb.iconFactory.put(icon);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomIconID = PwDatabaseV4.UUID_ZERO;\n\t\t\tcustomIconData = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomIcons;\n\t\t} else if ( ctx == KdbContext.Binaries && name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\tif ( customDataKey != null && customDataValue != null) {\n\t\t\t\tdb.customData.put(customDataKey, customDataValue);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomDataKey = null;\n\t\t\tcustomDataValue = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomData;\n\t\t} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\tif ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxGroup.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tctxGroups.pop();\n\t\t\t\n\t\t\tif ( ctxGroups.size() == 0 ) {\n\t\t\t\tctxGroup = null;\n\t\t\t\treturn KdbContext.Root;\n\t\t\t} else {\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\treturn KdbContext.Group;\n\t\t\t}\n\t\t} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\tif ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxEntry.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tif ( entryInHistory ) {\n\t\t\t\tctxEntry = ctxHistoryBase;\n\t\t\t\treturn KdbContext.EntryHistory;\n\t\t\t}\n\t\t\t\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {\n\t\t\tctxEntry.strings.put(ctxStringName, ctxStringValue);\n\t\t\tctxStringName = null;\n\t\t\tctxStringValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\tctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);\n\t\t\tctxBinaryName = null;\n\t\t\tctxBinaryValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\tctxEntry.autoType.put(ctxATName, ctxATSeq);\n\t\t\tctxATName = null;\n\t\t\tctxATSeq = null;\n\t\t\t\n\t\t\treturn KdbContext.EntryAutoType;\n\t\t} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\tentryInHistory = false;\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\treturn KdbContext.Root;\n\t\t} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\tctxDeletedObject = null;\n\t\t\treturn KdbContext.RootDeletedObjects;\n\t\t} else {\n\t\t\tassert(false);\n\n\t\t\tString contextName = \"\";\n\t\t\tif (ctx != null) {\n\t\t\t\tcontextName = ctx.name();\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"Invalid end element: Context \" +  contextName + \"End element: \" + name);\n\t\t}\n\t}\n\t\n\tprivate Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString sDate = ReadString(xpp);\n\t\t\n\t\tDate utcDate = null;\n\t\ttry {\n\t\t\tutcDate = PwDatabaseV4XML.dateFormat.parse(sDate);\n\t\t} catch (ParseException e) {\n\t\t\t// Catch with null test below\n\t\t}\n\t\t\n\t\tif (utcDate == null) {\n\t\t\tutcDate = new Date(0L);\n\t\t}\n\t\t\n\t\treturn utcDate;\n\t\t\n\t}\n\n\tprivate void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(false);\n\t\t\n\t\tif ( xpp.isEmptyElementTag() ) return;\n\t\t\n\t\tString unknownName = xpp.getName();\n\t\tProcessNode(xpp);\n\t\t\n\t\twhile (xpp.next() != XmlPullParser.END_DOCUMENT ) {\n\t\t\tif ( xpp.getEventType() == XmlPullParser.END_TAG ) break;\n\t\t\tif ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;\n\t\t\t\n\t\t\tReadUnknown(xpp);\n\t\t}\n\t\t\n\t\tassert(xpp.getName() == unknownName);\n\t\t\n\t}\n\t\n\tprivate boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tif ( str.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( str.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn bDefault;\n\t\t}\n\t}\n\t\n\tprivate UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString encoded = ReadString(xpp);\n\t\t\n\t\tif (encoded == null || encoded.length() == 0 ) {\n\t\t\treturn PwDatabaseV4.UUID_ZERO;\n\t\t}\n\t\t\n\t\t// TODO: Switch to framework Base64 once API level 8 is the minimum\n\t\tbyte[] buf = Base64Coder.decode(encoded);\n\t\t\n\t\treturn Types.bytestoUUID(buf);\n\t}\n\t\n\tprivate int ReadInt(XmlPullParser xpp, int def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tint u;\n\t\ttry {\n\t\t\tu = Integer.parseInt(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate static final long MAX_UINT = 4294967296L; // 2^32\n\tprivate long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u;\n\t\t\n\t\tu = ReadULong(xpp, uDefault);\n\t\tif ( u < 0 || u > MAX_UINT ) {\n\t\t\tthrow new NumberFormatException(\"Outside of the uint size\");\n\t\t}\n\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tlong u;\n\t\ttry {\n\t\t\tu = Long.parseLong(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u = ReadLong(xpp, uDefault);\n\t\t\n\t\tif ( u < 0 ) {\n\t\t\tu = uDefault;\n\t\t}\n\t\t\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate ProtectedString ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null) {\n\t\t\ttry {\n\t\t\t\treturn new ProtectedString(true, new String(buf, \"UTF-8\"));\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t} \n\t\t}\n\t\t\n\t\treturn new ProtectedString(false, ReadString(xpp));\n\t}\n\t\n\tprivate ProtectedBinary ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tString ref = xpp.getAttributeValue(null, AttrRef);\n\t\tif (ref != null) {\n\t\t\txpp.next(); // Consume end tag\n\t\t\t\n\t\t\treturn binPool.get(ref);\n\t\t} \n\t\t\n\t\tboolean compressed = false;\n\t\tString comp = xpp.getAttributeValue(null, AttrCompressed);\n\t\tif (comp != null) {\n\t\t\tcompressed = comp.equalsIgnoreCase(ValTrue);\n\t\t}\n\t\t\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) return new ProtectedBinary(true, buf);\n\t\t\n\t\tString base64 = ReadString(xpp);\n\t\tif ( base64.length() == 0 ) return ProtectedBinary.EMPTY;\n\t\t\n\t\tbyte[] data = Base64Coder.decode(base64);\n\t\t\n\t\tif (compressed) {\n\t\t\tdata = MemUtil.decompress(data);\n\t\t}\n\t\t\n\t\treturn new ProtectedBinary(false, data);\n\t}\n\t\n\tprivate String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t\t\n\t}\n\t\n\tprivate String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t}\n\n\tprivate byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(xpp.getEventType() == XmlPullParser.START_TAG);\n\t\t\n\t\tbyte[] buf = null;\n\t\t\n\t\tif ( xpp.getAttributeCount() > 0 ) {\n\t\t\tString protect = xpp.getAttributeValue(null, AttrProtected);\n\t\t\tif ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {\n\t\t\t\tString encrypted = ReadStringRaw(xpp);\n\t\t\t\t\n\t\t\t\tif ( encrypted.length() > 0 ) {\n\t\t\t\t\tbuf = Base64Coder.decode(encrypted);\n\t\t\t\t\tbyte[] plainText = new byte[buf.length];\n\t\t\t\t\t\n\t\t\t\t\trandomStream.processBytes(buf, 0, buf.length, plainText, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn plainText;\n\t\t\t\t} else {\n\t\t\t\t\tbuf = new byte[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tprivate KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,\n\t\t\tXmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tif ( xpp.isEmptyElementTag() ) {\n\t\t\txpp.next();  // Consume the end tag\n\t\t\treturn ctxCurrent;\n\t\t}\n\t\treturn ctxNew;\n\t}\n\n\n\tprivate Boolean StringToBoolean(String str) {\n\t\tif ( str == null || str.length() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString trimmed = str.trim();\n\t\tif ( trimmed.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( trimmed.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.util.Arrays;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Stack;\nimport java.util.TimeZone;\nimport java.util.UUID;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.spongycastle.util.encoders.Base64Encoder;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.ArcFourException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.HmacBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.DateUtil;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class ImporterV4 extends Importer {\n\t\n\tprivate StreamCipher randomStream;\n\tprivate PwDatabaseV4 db;\n\tprivate BinaryPool binPool = new BinaryPool();\n\n    private byte[] hashOfHeader = null;\n\tprivate byte[] pbHeader = null;\n\tprivate long version;\n\tCalendar utcCal;\n\n\tpublic ImporterV4() {\n\t\tutcCal = Calendar.getInstance(TimeZone.getTimeZone(\"UTC\"));\n\t}\n\t\n\tprotected PwDatabaseV4 createDB() {\n\t\treturn new PwDatabaseV4();\n\n\t}\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream) throws IOException, InvalidDBException {\n\n\t\treturn openDatabase(inStream, password, keyInputStream, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tInputStream keyInputStream, UpdateStatus status) throws IOException,\n\t\t\tInvalidDBException {\n\n\t\tdb = createDB();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\n\t\tPwDbHeaderV4.HeaderAndHash hh = header.loadFromFile(inStream);\n        version = header.version;\n\n\t\thashOfHeader = hh.hash;\n\t\tpbHeader = hh.header;\n\t\t\t\n\t\tdb.setMasterKey(password, keyInputStream);\n\t\tdb.makeFinalKey(header.masterSeed, db.kdfParameters);\n\n\t\tCipherEngine engine;\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tengine = CipherFactory.getInstance(db.dataCipher);\n\t\t\tdb.dataEngine = engine;\n\t\t\tcipher = engine.getCipher(Cipher.DECRYPT_MODE, db.finalKey, header.encryptionIV);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t}\n\n\t\tInputStream isPlain;\n\t\tif (version < PwDbHeaderV4.FILE_VERSION_32_4) {\n\n\t\t\tInputStream decrypted = AttachCipherStream(inStream, cipher);\n\t\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\t\tbyte[] storedStartBytes = null;\n\t\t\ttry {\n\t\t\t\tstoredStartBytes = dataDecrypted.readBytes(32);\n\t\t\t\tif (storedStartBytes == null || storedStartBytes.length != 32) {\n\t\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t\t}\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tif (!Arrays.equals(storedStartBytes, header.streamStartBytes)) {\n\t\t\t\tthrow new InvalidPasswordException();\n\t\t\t}\n\n\t\t\tisPlain = new HashedBlockInputStream(dataDecrypted);\n\t\t}\n\t\telse { // KDBX 4\n\t\t\tLEDataInputStream isData = new LEDataInputStream(inStream);\n\t\t\tbyte[] storedHash = isData.readBytes(32);\n\t\t\tif (!Arrays.equals(storedHash,hashOfHeader)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tbyte[] hmacKey = db.hmacKey;\n\t\t\tbyte[] headerHmac = PwDbHeaderV4.computeHeaderHmac(pbHeader, hmacKey);\n\t\t\tbyte[] storedHmac = isData.readBytes(32);\n\t\t\tif (storedHmac == null || storedHmac.length != 32) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\t\t\t// Mac doesn't match\n\t\t\tif (! Arrays.equals(headerHmac, storedHmac)) {\n\t\t\t\tthrow new InvalidDBException();\n\t\t\t}\n\n\t\t\tHmacBlockInputStream hmIs = new HmacBlockInputStream(isData, true, hmacKey);\n\n\t\t\tisPlain = AttachCipherStream(hmIs, cipher);\n\t\t}\n\n\t\tInputStream isXml;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tisXml = new GZIPInputStream(isPlain);\n\t\t} else {\n\t\t\tisXml = isPlain;\n\t\t}\n\n\t\tif (version >= header.FILE_VERSION_32_4) {\n\t\t\tLoadInnerHeader(isXml, header);\n\t\t}\n\t\t\n\t\tif ( header.protectedStreamKey == null ) {\n\t\t\tassert(false);\n\t\t\tthrow new IOException(\"Invalid stream key.\");\n\t\t}\n\t\t\n\t\trandomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);\n\t\t\n\t\tif ( randomStream == null ) {\n\t\t\tthrow new ArcFourException();\n\t\t}\n\t\t\n\t\tReadXmlStreamed(isXml);\n\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\n\tprivate InputStream AttachCipherStream(InputStream is, Cipher cipher) {\n\t\treturn new BetterCipherInputStream(is, cipher, 50 * 1024);\n\t}\n\n\tprivate void LoadInnerHeader(InputStream is, PwDbHeaderV4 header) throws IOException {\n\t\tLEDataInputStream lis = new LEDataInputStream(is);\n\n\t\twhile(true) {\n\t\t\tif (!ReadInnerHeader(lis, header)) break;\n\t\t}\n\n\t}\n\n\tprivate boolean ReadInnerHeader(LEDataInputStream lis, PwDbHeaderV4 header) throws IOException {\n\t\tbyte fieldId = (byte)lis.read();\n\n\t\tint size = lis.readInt();\n\t\tif (size < 0) throw new IOException(\"Corrupted file\");\n\n\t\tbyte[] data = new byte[0];\n\t\tif (size > 0) {\n\t\t\tdata = lis.readBytes(size);\n\t\t}\n\n\t\tboolean result = true;\n\t\tswitch(fieldId) {\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.EndOfHeader:\n\t\t\t\tresult = false;\n\t\t\t\tbreak;\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.InnerRandomStreamID:\n\t\t\t    header.setRandomStreamID(data);\n\t\t\t\tbreak;\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.InnerRandomstreamKey:\n\t\t\t    header.protectedStreamKey = data;\n\t\t\t\tbreak;\n\t\t\tcase PwDbHeaderV4.PwDbInnerHeaderV4Fields.Binary:\n\t\t\t    if (data.length < 1) throw new IOException(\"Invalid binary format\");\n\t\t\t\tbyte flag = data[0];\n\t\t\t\tboolean prot = (flag & PwDbHeaderV4.KdbxBinaryFlags.Protected) !=\n\t\t\t\t\t\tPwDbHeaderV4.KdbxBinaryFlags.None;\n\n\t\t\t\tbyte[] bin = new byte[data.length - 1];\n\t\t\t\tSystem.arraycopy(data, 1, bin, 0, data.length-1);\n\t\t\t\tProtectedBinary pb = new ProtectedBinary(prot, bin);\n\n\t\t\t\tif (prot) {\n\t\t\t\t\tArrays.fill(data, (byte)0);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprivate enum KdbContext {\n        Null,\n        KeePassFile,\n        Meta,\n        Root,\n        MemoryProtection,\n        CustomIcons,\n        CustomIcon,\n        CustomData,\n        CustomDataItem,\n        RootDeletedObjects,\n        DeletedObject,\n        Group,\n        GroupTimes,\n\t\tGroupCustomData,\n\t\tGroupCustomDataItem,\n        Entry,\n        EntryTimes,\n        EntryString,\n        EntryBinary,\n        EntryAutoType,\n        EntryAutoTypeItem,\n        EntryHistory,\n\t\tEntryCustomData,\n\t\tEntryCustomDataItem,\n        Binaries\n\t}\n\n    private static final long DEFAULT_HISTORY_DAYS = 365;\n\t\n\tprivate boolean readNextNode = true;\n\tprivate Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();\n\tprivate PwGroupV4 ctxGroup = null;\n\tprivate PwEntryV4 ctxEntry = null;\n\tprivate String ctxStringName = null;\n\tprivate ProtectedString ctxStringValue = null;\n\tprivate String ctxBinaryName = null;\n\tprivate ProtectedBinary ctxBinaryValue = null;\n\tprivate String ctxATName = null;\n\tprivate String ctxATSeq = null;\n\tprivate boolean entryInHistory = false;\n\tprivate PwEntryV4 ctxHistoryBase = null;\n\tprivate PwDeletedObject ctxDeletedObject = null;\n\tprivate UUID customIconID = PwDatabaseV4.UUID_ZERO;\n\tprivate byte[] customIconData;\n\tprivate String customDataKey = null;\n\tprivate String customDataValue = null;\n\tprivate String groupCustomDataKey = null;\n\tprivate String groupCustomDataValue = null;\n\tprivate String entryCustomDataKey = null;\n\tprivate String entryCustomDataValue = null;\n\n\tprivate void ReadXmlStreamed(InputStream readerStream) throws IOException, InvalidDBException {\n\t\t\n\t\t\ttry {\n\t\t\t\tReadDocumentStreamed(CreatePullParser(readerStream));\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t}\n\t\n\tprivate static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {\n\t\tXmlPullParserFactory xppf = XmlPullParserFactory.newInstance();\n\t\txppf.setNamespaceAware(false);\n\t\t\n\t\tXmlPullParser xpp = xppf.newPullParser();\n\t\txpp.setInput(readerStream, null);\n\t\t\n\t\treturn xpp;\n\t}\n\n\tprivate void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\n\t\tctxGroups.clear();\n\t\t\n\t\tKdbContext ctx = KdbContext.Null;\n\t\t\n\t\treadNextNode = true;\n\t\t\n\t\twhile (true) {\n\t\t\tif ( readNextNode ) {\n\t\t\t\tif( xpp.next() == XmlPullParser.END_DOCUMENT ) break;\n\t\t\t} else {\n\t\t\t\treadNextNode = true;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ( xpp.getEventType() ) {\n\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\tctx = ReadXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase XmlPullParser.END_TAG:\n\t\t\t\tctx = EndXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Error checks\n\t\tif ( ctx != KdbContext.Null ) throw new IOException(\"Malformed\");\n\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Malformed\");\n\t}\n\n\n\tprivate KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException, InvalidDBException {\n\t\tString name = xpp.getName();\n\t\tswitch (ctx) {\n\t\tcase Null:\n\t\t\tif ( name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.KeePassFile, xpp);\n\t\t\t} else ReadUnknown(xpp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase KeePassFile:\n\t\t\tif ( name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Meta, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Root, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Meta:\n\t\t\tif ( name.equalsIgnoreCase(ElemGenerator) ) {\n\t\t\t\tReadString(xpp); // Ignore\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHeaderHash) ) {\n\t\t\t\tString encodedHash = ReadString(xpp);\n\t\t\t\tif (!EmptyUtils.isNullOrEmpty(encodedHash) && (hashOfHeader != null)) {\n\t\t\t\t\tbyte[] hash = Base64Coder.decode(encodedHash);\n\t\t\t\t\tif (!Arrays.equals(hash, hashOfHeader)) {\n\t\t\t\t\t\tthrow new InvalidDBException();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (name.equalsIgnoreCase(ElemSettingsChanged)) {\n\t\t\t\tdb.settingsChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbName) ) {\n\t\t\t\tdb.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {\n\t\t\t\tdb.nameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {\n\t\t\t\tdb.description = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {\n\t\t\t\tdb.descriptionChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {\n\t\t\t\tdb.defaultUserName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {\n\t\t\t\tdb.defaultUserNameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbColor)) {\n\t\t\t\t// TODO: Add support to interpret the color if we want to allow changing the database color\n\t\t\t\tdb.color = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {\n\t\t\t\tdb.keyChangeRecDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {\n\t\t\t\tdb.keyChangeForceDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForceOnce) ) {\n\t\t\t\tdb.keyChangeForceOnce = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.MemoryProtection, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcons, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {\n\t\t\t\tdb.recycleBinEnabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {\n\t\t\t\tdb.recycleBinUUID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {\n\t\t\t\tdb.recycleBinChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {\n\t\t\t\tdb.entryTemplatesGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxItems) ) {\n\t\t\t\tdb.historyMaxItems = ReadInt(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistoryMaxSize) ) {\n\t\t\t\tdb.historyMaxSize = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {\n\t\t\t\tdb.lastSelectedGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {\n\t\t\t\tdb.lastTopVisibleGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Binaries, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomData, xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MemoryProtection:\n\t\t\tif ( name.equalsIgnoreCase(ElemProtTitle) ) {\n\t\t\t\tdb.memoryProtection.protectTitle = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {\n\t\t\t\tdb.memoryProtection.protectUserName = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {\n\t\t\t\tdb.memoryProtection.protectPassword = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtURL) ) {\n\t\t\t\tdb.memoryProtection.protectUrl = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {\n\t\t\t\tdb.memoryProtection.protectNotes = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {\n\t\t\t\tdb.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcons:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcon, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcon:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {\n\t\t\t\tcustomIconID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {\n\t\t\t\tString strData = ReadString(xpp);\n\t\t\t\tif ( strData != null && strData.length() > 0 ) {\n\t\t\t\t\tcustomIconData = Base64Coder.decode(strData);\n\t\t\t\t} else {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Binaries:\n\t\t\tif ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\tString key = xpp.getAttributeValue(null, AttrId);\n\t\t\t\tif ( key != null ) {\n\t\t\t\t\tProtectedBinary pbData = ReadProtectedBinary(xpp);\n\t\t\t\t\tint id = Integer.parseInt(key);\n\t\t\t\t\tbinPool.put(id, pbData);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\t\n\t\t\tbreak;\n\n\t\tcase CustomData:\n\t\t\tif ( name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomDataItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tcustomDataKey = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tcustomDataValue = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Root:\n\t\t\tif ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tassert(ctxGroups.size() == 0);\n\t\t\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Group list should be empty.\");\n\t\t\t\t\n\t\t\t\tdb.rootGroup = new PwGroupV4();\n\t\t\t\tctxGroups.push((PwGroupV4)db.rootGroup);\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Group:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxGroup.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemName) ) {\n\t\t\t\tctxGroup.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemNotes) ) {\n\t\t\t\tctxGroup.notes = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxGroup.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxGroup.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {\n\t\t\t\tctxGroup.isExpanded = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {\n\t\t\t\tctxGroup.defaultAutoTypeSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {\n\t\t\t\tctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {\n\t\t\t\tctxGroup.enableSearching = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {\n\t\t\t\tctxGroup.lastTopVisibleEntry = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n                return SwitchContext(ctx, KdbContext.GroupCustomData, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tctxGroup = new PwGroupV4();\n\t\t\t\tctxGroups.peek().AddGroup(ctxGroup, true);\n\t\t\t\tctxGroups.push(ctxGroup);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxGroup.AddEntry(ctxEntry, true);\n\t\t\t\t\n\t\t\t\tentryInHistory = false;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n        case GroupCustomData:\n        \tif (name.equalsIgnoreCase(ElemStringDictExItem)) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupCustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n            break;\n        case GroupCustomDataItem:\n        \tif (name.equalsIgnoreCase(ElemKey)) {\n\t\t\t\tgroupCustomDataKey = ReadString(xpp);\n\t\t\t} else if (name.equalsIgnoreCase(ElemValue)) {\n\t\t\t\tgroupCustomDataValue = ReadString(xpp);\n            } else {\n                ReadUnknown(xpp);\n            }\n            break;\n\n\t\t\t\n\t\tcase Entry:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxEntry.setUUID(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxEntry.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxEntry.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemFgColor) ) {\n\t\t\t\tctxEntry.foregroundColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBgColor) ) {\n\t\t\t\tctxEntry.backgroupColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {\n\t\t\t\tctxEntry.overrideURL = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTags) ) {\n\t\t\t\tctxEntry.tags = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemString) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryString, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryBinary, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoType, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData)) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryCustomData, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\t\tassert(!entryInHistory);\n\t\t\t\t\n\t\t\t\tif ( ! entryInHistory ) {\n\t\t\t\t\tctxHistoryBase = ctxEntry;\n\t\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryHistory, xpp);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n        case EntryCustomData:\n            if (name.equalsIgnoreCase(ElemStringDictExItem)) {\n                return SwitchContext(ctx, KdbContext.EntryCustomDataItem, xpp);\n            } else {\n                ReadUnknown(xpp);\n            }\n            break;\n        case EntryCustomDataItem:\n            if (name.equalsIgnoreCase(ElemKey)) {\n                entryCustomDataKey = ReadString(xpp);\n            } else if (name.equalsIgnoreCase(ElemValue)) {\n                entryCustomDataValue = ReadString(xpp);\n            } else {\n                ReadUnknown(xpp);\n            }\n            break;\n\n\t\tcase GroupTimes:\n\t\tcase EntryTimes:\n\t\t\tITimeLogger tl;\n\t\t\tif ( ctx == KdbContext.GroupTimes ) {\n\t\t\t\ttl = ctxGroup;\n\t\t\t} else {\n\t\t\t\ttl = ctxEntry;\n\t\t\t}\n\t\t\t\n\t\t\tif ( name.equalsIgnoreCase(ElemLastModTime) ) {\n\t\t\t\ttl.setLastModificationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {\n\t\t\t\ttl.setCreationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {\n\t\t\t\ttl.setLastAccessTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {\n\t\t\t\ttl.setExpiryTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpires) ) {\n\t\t\t\ttl.setExpires(ReadBool(xpp, false));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {\n\t\t\t\ttl.setUsageCount(ReadULong(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {\n\t\t\t\ttl.setLocationChanged(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryString:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxStringName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxStringValue = ReadProtectedString(xpp); \n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryBinary:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxBinaryName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxBinaryValue = ReadProtectedBinary(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoType:\n\t\t\tif ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {\n\t\t\t\tctxEntry.autoType.enabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {\n\t\t\t\tctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {\n\t\t\t\tctxEntry.autoType.defaultSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoTypeItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemWindow) ) {\n\t\t\t\tctxATName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {\n\t\t\t\tctxATSeq = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryHistory:\n\t\t\tif ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxHistoryBase.history.add(ctxEntry);\n\t\t\t\t\n\t\t\t\tentryInHistory = true;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase RootDeletedObjects:\n\t\t\tif ( name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\t\tctxDeletedObject = new PwDeletedObject();\n\t\t\t\tdb.deletedObjects.add(ctxDeletedObject);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.DeletedObject, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase DeletedObject:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxDeletedObject.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {\n\t\t\t\tctxDeletedObject.setDeletionTime(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tReadUnknown(xpp);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ctx;\n\t}\n\n\tprivate KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {\n\t\tassert(xpp.getEventType() == XmlPullParser.END_TAG);\n\t\t\n\t\tString name = xpp.getName();\n\t\tif ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\treturn KdbContext.Null;\n\t\t} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\tif ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tPwIconCustom icon = new PwIconCustom(customIconID, customIconData);\n\t\t\t\tdb.customIcons.add(icon);\n\t\t\t\tdb.iconFactory.put(icon);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomIconID = PwDatabaseV4.UUID_ZERO;\n\t\t\tcustomIconData = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomIcons;\n\t\t} else if ( ctx == KdbContext.Binaries && name.equalsIgnoreCase(ElemBinaries) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\tif ( customDataKey != null && customDataValue != null) {\n\t\t\t\tdb.customData.put(customDataKey, customDataValue);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomDataKey = null;\n\t\t\tcustomDataValue = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomData;\n\t\t} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\tif ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxGroup.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tctxGroups.pop();\n\t\t\t\n\t\t\tif ( ctxGroups.size() == 0 ) {\n\t\t\t\tctxGroup = null;\n\t\t\t\treturn KdbContext.Root;\n\t\t\t} else {\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\treturn KdbContext.Group;\n\t\t\t}\n\t\t} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.GroupCustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.GroupCustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem)) {\n\t\t\tif (groupCustomDataKey != null && groupCustomDataValue != null) {\n\t\t\t\tctxGroup.customData.put(groupCustomDataKey, groupCustomDataKey);\n\t\t\t} else {\n\t\t\t\tassert(false);\n\t\t\t}\n\n\t\t\tgroupCustomDataKey = null;\n\t\t\tgroupCustomDataValue = null;\n\n\t\t\treturn KdbContext.GroupCustomData;\n\n\t\t} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\tif ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxEntry.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tif ( entryInHistory ) {\n\t\t\t\tctxEntry = ctxHistoryBase;\n\t\t\t\treturn KdbContext.EntryHistory;\n\t\t\t}\n\t\t\t\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {\n\t\t\tctxEntry.strings.put(ctxStringName, ctxStringValue);\n\t\t\tctxStringName = null;\n\t\t\tctxStringValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\tctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);\n\t\t\tctxBinaryName = null;\n\t\t\tctxBinaryValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\tctxEntry.autoType.put(ctxATName, ctxATSeq);\n\t\t\tctxATName = null;\n\t\t\tctxATSeq = null;\n\n\t\t\treturn KdbContext.EntryAutoType;\n\t\t} else if ( ctx == KdbContext.EntryCustomData && name.equalsIgnoreCase(ElemCustomData)) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryCustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem)) {\n\t\t\tif (entryCustomDataKey != null && entryCustomDataValue != null) {\n\t\t\t\tctxEntry.customData.put(entryCustomDataKey, entryCustomDataValue);\n\t\t\t} else {\n\t\t\t\tassert(false);\n\t\t\t}\n\n\t\t\tentryCustomDataKey = null;\n\t\t\tentryCustomDataValue = null;\n\n\t\t\treturn KdbContext.EntryCustomData;\n\t\t} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\tentryInHistory = false;\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\treturn KdbContext.Root;\n\t\t} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\tctxDeletedObject = null;\n\t\t\treturn KdbContext.RootDeletedObjects;\n\t\t} else {\n\t\t\tassert(false);\n\n\t\t\tString contextName = \"\";\n\t\t\tif (ctx != null) {\n\t\t\t\tcontextName = ctx.name();\n\t\t\t}\n\t\t\tthrow new RuntimeException(\"Invalid end element: Context \" +  contextName + \"End element: \" + name);\n\t\t}\n\t}\n\t\n\tprivate Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString sDate = ReadString(xpp);\n\t\tDate utcDate = null;\n\n\t\tif (version >= PwDbHeaderV4.FILE_VERSION_32_4) {\n\t\t\tbyte[] buf = Base64Coder.decode(sDate);\n\t\t\tif (buf.length != 8) {\n\t\t\t\tbyte[] buf8 = new byte[8];\n\t\t\t\tSystem.arraycopy(buf, 0, buf8, 0, buf.length);\n\t\t\t\tbuf = buf8;\n\t\t\t}\n\n\t\t\tlong seconds = LEDataInputStream.readLong(buf, 0);\n\t\t\tutcDate = DateUtil.convertKDBX4Time(seconds);\n\n\t\t} else {\n\n\t\t\ttry {\n\t\t\t\tutcDate = PwDatabaseV4XML.dateFormat.parse(sDate);\n\t\t\t} catch (ParseException e) {\n\t\t\t\t// Catch with null test below\n\t\t\t}\n\n\t\t\tif (utcDate == null) {\n\t\t\t\tutcDate = new Date(0L);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn utcDate;\n\t\t\n\t}\n\n\tprivate void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(false);\n\t\t\n\t\tif ( xpp.isEmptyElementTag() ) return;\n\t\t\n\t\tString unknownName = xpp.getName();\n\t\tProcessNode(xpp);\n\t\t\n\t\twhile (xpp.next() != XmlPullParser.END_DOCUMENT ) {\n\t\t\tif ( xpp.getEventType() == XmlPullParser.END_TAG ) break;\n\t\t\tif ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;\n\t\t\t\n\t\t\tReadUnknown(xpp);\n\t\t}\n\t\t\n\t\tassert(xpp.getName() == unknownName);\n\t\t\n\t}\n\t\n\tprivate boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tif ( str.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( str.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn bDefault;\n\t\t}\n\t}\n\t\n\tprivate UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString encoded = ReadString(xpp);\n\t\t\n\t\tif (encoded == null || encoded.length() == 0 ) {\n\t\t\treturn PwDatabaseV4.UUID_ZERO;\n\t\t}\n\t\t\n\t\t// TODO: Switch to framework Base64 once API level 8 is the minimum\n\t\tbyte[] buf = Base64Coder.decode(encoded);\n\t\t\n\t\treturn Types.bytestoUUID(buf);\n\t}\n\t\n\tprivate int ReadInt(XmlPullParser xpp, int def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tint u;\n\t\ttry {\n\t\t\tu = Integer.parseInt(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate static final long MAX_UINT = 4294967296L; // 2^32\n\tprivate long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u;\n\t\t\n\t\tu = ReadULong(xpp, uDefault);\n\t\tif ( u < 0 || u > MAX_UINT ) {\n\t\t\tthrow new NumberFormatException(\"Outside of the uint size\");\n\t\t}\n\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tlong u;\n\t\ttry {\n\t\t\tu = Long.parseLong(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u = ReadLong(xpp, uDefault);\n\t\t\n\t\tif ( u < 0 ) {\n\t\t\tu = uDefault;\n\t\t}\n\t\t\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate ProtectedString ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null) {\n\t\t\ttry {\n\t\t\t\treturn new ProtectedString(true, new String(buf, \"UTF-8\"));\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t} \n\t\t}\n\t\t\n\t\treturn new ProtectedString(false, ReadString(xpp));\n\t}\n\t\n\tprivate ProtectedBinary ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tString ref = xpp.getAttributeValue(null, AttrRef);\n\t\tif (ref != null) {\n\t\t\txpp.next(); // Consume end tag\n\n\t\t\tint id = Integer.parseInt(ref);\n\t\t\treturn binPool.get(id);\n\t\t} \n\t\t\n\t\tboolean compressed = false;\n\t\tString comp = xpp.getAttributeValue(null, AttrCompressed);\n\t\tif (comp != null) {\n\t\t\tcompressed = comp.equalsIgnoreCase(ValTrue);\n\t\t}\n\t\t\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) return new ProtectedBinary(true, buf);\n\t\t\n\t\tString base64 = ReadString(xpp);\n\t\tif ( base64.length() == 0 ) return ProtectedBinary.EMPTY;\n\t\t\n\t\tbyte[] data = Base64Coder.decode(base64);\n\t\t\n\t\tif (compressed) {\n\t\t\tdata = MemUtil.decompress(data);\n\t\t}\n\t\t\n\t\treturn new ProtectedBinary(false, data);\n\t}\n\t\n\tprivate String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t\t\n\t}\n\t\n\tprivate String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t}\n\n\tprivate byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(xpp.getEventType() == XmlPullParser.START_TAG);\n\t\t\n\t\tbyte[] buf = null;\n\t\t\n\t\tif ( xpp.getAttributeCount() > 0 ) {\n\t\t\tString protect = xpp.getAttributeValue(null, AttrProtected);\n\t\t\tif ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {\n\t\t\t\tString encrypted = ReadStringRaw(xpp);\n\t\t\t\t\n\t\t\t\tif ( encrypted.length() > 0 ) {\n\t\t\t\t\tbuf = Base64Coder.decode(encrypted);\n\t\t\t\t\tbyte[] plainText = new byte[buf.length];\n\t\t\t\t\t\n\t\t\t\t\trandomStream.processBytes(buf, 0, buf.length, plainText, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn plainText;\n\t\t\t\t} else {\n\t\t\t\t\tbuf = new byte[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tprivate KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,\n\t\t\tXmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tif ( xpp.isEmptyElementTag() ) {\n\t\t\txpp.next();  // Consume the end tag\n\t\t\treturn ctxCurrent;\n\t\t}\n\t\treturn ctxNew;\n\t}\n\n\n\tprivate Boolean StringToBoolean(String str) {\n\t\tif ( str == null || str.length() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString trimmed = str.trim();\n\t\tif ( trimmed.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( trimmed.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n}\n","lineNo":1064}
{"Smelly Sample":"/*\n * Copyright 2013-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport android.util.Xml;\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.EntryHandler;\nimport com.keepassdroid.database.GroupHandler;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4.MemoryProtectionConfig;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDefsV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwEntryV4.AutoType;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.HashedBlockOutputStream;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbV4Output extends PwDbOutput {\n\n\tPwDatabaseV4 mPM;\n\tprivate StreamCipher randomStream;\n\tprivate BinaryPool binPool;\n\tprivate XmlSerializer xml;\n\tprivate PwDbHeaderV4 header;\n\tprivate byte[] hashOfHeader;\n\t\n\tprotected PwDbV4Output(PwDatabaseV4 pm, OutputStream os) {\n\t\tsuper(os);\n\t\t\n\t\tmPM = pm;\n\t}\n\n\t@Override\n\tpublic void output() throws PwDbOutputException {\n\t\theader = (PwDbHeaderV4 ) outputHeader(mOS);\n\t\t\n\t\tCipherOutputStream cos = attachStreamEncryptor(header, mOS);\n\t\t\n\t\tOutputStream compressed;\n\t\ttry {\n\t\t\tcos.write(header.streamStartBytes);\n\t\t\t\n\t\t\tHashedBlockOutputStream hashed = new HashedBlockOutputStream(cos);\n\t\t\t\n\t\t\tif ( mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\t\tcompressed = new GZIPOutputStream(hashed); \n\t\t\t} else {\n\t\t\t\tcompressed = hashed;\n\t\t\t}\n\t\n\t\t\toutputDatabase(compressed);\n\t\t\tcompressed.close();\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t} catch (IllegalStateException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t}\n\t}\n\t\n\tprivate class GroupWriter extends GroupHandler<PwGroup> {\n\t\tprivate Stack<PwGroupV4> groupStack;\n\t\t\n\t\tpublic GroupWriter(Stack<PwGroupV4> gs) {\n\t\t\tgroupStack = gs;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean operate(PwGroup g) {\n\t\t\tPwGroupV4 group = (PwGroupV4) g;\n\t\t\tassert(group != null);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (group.parent == groupStack.peek()) {\n\t\t\t\t\t\tgroupStack.push(group);\n\t\t\t\t\t\tstartGroup(group);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\tif (groupStack.size() <= 0) return false;\n\t\t\t\t\t\tendGroup();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate class EntryWriter extends EntryHandler<PwEntry> {\n\n\t\t@Override\n\t\tpublic boolean operate(PwEntry e) {\n\t\t\tPwEntryV4 entry = (PwEntryV4) e;\n\t\t\tassert(entry != null);\n\t\t\t\n\t\t\ttry {\n\t\t\t\twriteEntry(entry, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void outputDatabase(OutputStream os) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbinPool = new BinaryPool((PwGroupV4)mPM.rootGroup);\n\t\t\n\t\txml = Xml.newSerializer();\n\t\t\n\t\txml.setOutput(os, \"UTF-8\");\n\t\txml.startDocument(\"UTF-8\", true);\n\t\t\n\t\txml.startTag(null, ElemDocNode);\n\t\t\n\t\twriteMeta();\n\t\t\n\t\tPwGroupV4 root = (PwGroupV4) mPM.rootGroup;\n\t\txml.startTag(null, ElemRoot);\n\t\tstartGroup(root);\n\t\tStack<PwGroupV4> groupStack = new Stack<PwGroupV4>();\n\t\tgroupStack.push(root);\n\t\t\n\t\tif (!root.preOrderTraverseTree(new GroupWriter(groupStack), new EntryWriter())) throw new RuntimeException(\"Writing groups failed\");\n\t\t\n\t\twhile (groupStack.size() > 1) {\n\t\t\txml.endTag(null, ElemGroup);\n\t\t\tgroupStack.pop();\n\t\t}\n\t\t\n\t\tendGroup();\n\t\t\n\t\twriteList(ElemDeletedObjects, mPM.deletedObjects);\n\t\t\n\t\txml.endTag(null, ElemRoot);\n\t\t\n\t\txml.endTag(null, ElemDocNode);\n\t\txml.endDocument();\n\t\t\n\t}\n\t\n\tprivate void writeMeta() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemMeta);\n\t\t\n\t\twriteObject(ElemGenerator, mPM.localizedAppName);\n\t\t\n\t\tif (hashOfHeader != null) {\n\t\t\twriteObject(ElemHeaderHash, String.valueOf(Base64Coder.encode(hashOfHeader)));\n\t\t}\n\t\t\n\t\twriteObject(ElemDbName, mPM.name, true);\n\t\twriteObject(ElemDbNameChanged, mPM.nameChanged);\n\t\twriteObject(ElemDbDesc, mPM.description, true);\n\t\twriteObject(ElemDbDescChanged, mPM.descriptionChanged);\n\t\twriteObject(ElemDbDefaultUser, mPM.defaultUserName, true);\n\t\twriteObject(ElemDbDefaultUserChanged, mPM.defaultUserNameChanged);\n\t\twriteObject(ElemDbMntncHistoryDays, mPM.maintenanceHistoryDays);\n\t\twriteObject(ElemDbColor, mPM.color);\n\t\twriteObject(ElemDbKeyChanged, mPM.keyLastChanged);\n\t\twriteObject(ElemDbKeyChangeRec, mPM.keyChangeRecDays);\n\t\twriteObject(ElemDbKeyChangeForce, mPM.keyChangeForceDays);\n\t\t\n\t\t\n\t\twriteList(ElemMemoryProt, mPM.memoryProtection);\n\t\t\n\t\twriteCustomIconList();\n\t\t\n\t\twriteObject(ElemRecycleBinEnabled, mPM.recycleBinEnabled);\n\t\twriteObject(ElemRecycleBinUuid, mPM.recycleBinUUID);\n\t\twriteObject(ElemRecycleBinChanged, mPM.recycleBinChanged);\n\t\twriteObject(ElemEntryTemplatesGroup, mPM.entryTemplatesGroup);\n\t\twriteObject(ElemEntryTemplatesGroupChanged, mPM.entryTemplatesGroupChanged);\n\t\twriteObject(ElemHistoryMaxItems, mPM.historyMaxItems);\n\t\twriteObject(ElemHistoryMaxSize, mPM.historyMaxSize);\n\t\twriteObject(ElemLastSelectedGroup, mPM.lastSelectedGroup);\n\t\twriteObject(ElemLastTopVisibleGroup, mPM.lastTopVisibleGroup);\n\t\t\n\t\twriteBinPool();\n\t\twriteList(ElemCustomData, mPM.customData);\n\t\t\n\t\txml.endTag(null, ElemMeta);\n\t\t\n\t}\n\t\n\tprivate CipherOutputStream attachStreamEncryptor(PwDbHeaderV4 header, OutputStream os) throws PwDbOutputException {\n\t\tCipher cipher;\n\t\tCipherEngine engine;\n\t\ttry {\n\t\t\tmPM.makeFinalKey(header.masterSeed, header.transformSeed, (int)mPM.numKeyEncRounds);\n\n\t\t\tengine = CipherFactory.getInstance(mPM.dataCipher);\n\t\t\tcipher = engine.getCipher(Cipher.ENCRYPT_MODE, mPM.finalKey, header.encryptionIV);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwDbOutputException(\"Invalid algorithm.\", e);\n\t\t}\n\t\t\n\t\tCipherOutputStream cos = new CipherOutputStream(os, cipher);\n\t\t\n\t\treturn cos;\n\t}\n\n\t@Override\n\tprotected SecureRandom setIVs(PwDbHeader header) throws PwDbOutputException {\n\t\tSecureRandom random = super.setIVs(header);\n\t\t\n\t\tPwDbHeaderV4 h = (PwDbHeaderV4) header;\n\t\trandom.nextBytes(h.masterSeed);\n\t\trandom.nextBytes(h.transformSeed);\n\t\trandom.nextBytes(h.encryptionIV);\n\t\t\n\t\trandom.nextBytes(h.protectedStreamKey);\n\t\th.innerRandomStream = CrsAlgorithm.Salsa20;\n\t\trandomStream = PwStreamCipherFactory.getInstance(h.innerRandomStream, h.protectedStreamKey);\n\t\tif (randomStream == null) {\n\t\t\tthrow new PwDbOutputException(\"Invalid random cipher\");\n\t\t}\n\t\trandom.nextBytes(h.streamStartBytes);\n\t\t\n\t\treturn random;\n\t}\n\t\n\t@Override\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwDbOutputException {\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(mPM);\n\t\tsetIVs(header);\n\t\t\n\t\tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4(mPM, header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(\"Failed to output the header.\", e);\n\t\t}\n\t\t\n\t\thashOfHeader = pho.getHashOfHeader();\n\t\t\n\t\treturn header;\n\t}\n\t\n\tprivate void startGroup(PwGroupV4 group) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemGroup);\n\t\twriteObject(ElemUuid, group.uuid);\n\t\twriteObject(ElemName, group.name);\n\t\twriteObject(ElemNotes, group.notes);\n\t\twriteObject(ElemIcon, group.icon.iconId);\n\t\t\n\t\tif (!group.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, group.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteList(ElemTimes, group);\n\t\twriteObject(ElemIsExpanded, group.isExpanded);\n\t\twriteObject(ElemGroupDefaultAutoTypeSeq, group.defaultAutoTypeSequence);\n\t\twriteObject(ElemEnableAutoType, group.enableAutoType);\n\t\twriteObject(ElemEnableSearching, group.enableSearching);\n\t\twriteObject(ElemLastTopVisibleEntry, group.lastTopVisibleEntry);\n\t\t\n\t}\n\t\n\tprivate void endGroup() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.endTag(null, ElemGroup);\n\t}\n\t\n\tprivate void writeEntry(PwEntryV4 entry, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(entry != null);\n\t\t\n\t\txml.startTag(null, ElemEntry);\n\t\t\n\t\twriteObject(ElemUuid, entry.uuid);\n\t\twriteObject(ElemIcon, entry.icon.iconId);\n\t\t\n\t\tif (!entry.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, entry.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteObject(ElemFgColor, entry.foregroundColor);\n\t\twriteObject(ElemBgColor, entry.backgroupColor);\n\t\twriteObject(ElemOverrideUrl, entry.overrideURL);\n\t\twriteObject(ElemTags, entry.tags);\n\t\t\n\t\twriteList(ElemTimes, entry);\n\t\t\n\t\twriteList(entry.strings, true);\n\t\twriteList(entry.binaries);\n\t\twriteList(ElemAutoType, entry.autoType);\n\t\t\n\t\tif (!isHistory) {\n\t\t\twriteList(ElemHistory, entry.history, true);\n\t\t} else {\n\t\t\tassert(entry.history.size() == 0);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemEntry);\n\t}\n\t\n\n\tprivate void writeObject(String key, ProtectedBinary value, boolean allowRef) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key != null && value != null);\n\t\t\n\t\txml.startTag(null, ElemBinary);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tString strRef = null;\n\t\tif (allowRef) {\n\t\t\tstrRef = binPool.poolFind(value);\n\t\t}\n\t\t\n\t\tif (strRef != null) {\n\t\t\txml.attribute(null, AttrRef, strRef);\n\t\t}\n\t\telse {\n\t\t\tsubWriteValue(value);\n\t\t}\n\t\txml.endTag(null, ElemValue);\n\t\t\n\t\txml.endTag(null, ElemBinary);\n\t}\n\t\n\tprivate void subWriteValue(ProtectedBinary value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (value.isProtected()) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tint valLength = value.length();\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(value.getData(), 0, valLength, encoded, 0);\n\t\t\t\t\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\txml.attribute(null, AttrCompressed, ValTrue);\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\tbyte[] compressed = MemUtil.compress(raw);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(compressed)));\n\t\t\t} else {\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(raw)));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tprivate void writeObject(String name, String value, boolean filterXmlChars) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tif (filterXmlChars) {\n\t\t\tvalue = safeXmlString(value);\n\t\t}\n\t\t\n\t\txml.text(value);\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeObject(String name, String value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, value, false);\n\t}\n\t\n\tprivate void writeObject(String name, Date value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, PwDatabaseV4XML.dateFormat.format(value));\n\t}\n\t\n\tprivate void writeObject(String name, long value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, String.valueOf(value));\n\t}\n\t\n\tprivate void writeObject(String name, Boolean value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tString text;\n\t\tif (value == null) {\n\t\t\ttext = \"null\";\n\t\t}\n\t\telse if (value) {\n\t\t\ttext = ValTrue;\n\t\t}\n\t\telse {\n\t\t\ttext = ValFalse;\n\t\t}\n\t\t\n\t\twriteObject(name, text);\n\t}\n\t\n\tprivate void writeObject(String name, UUID uuid) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbyte[] data = Types.UUIDtoBytes(uuid);\n\t\twriteObject(name, String.valueOf(Base64Coder.encode(data)));\n\t}\n\t\n\tprivate void writeObject(String name, String keyName, String keyValue, String valueName, String valueValue) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, name);\n\t\t\n\t\txml.startTag(null, keyName);\n\t\txml.text(safeXmlString(keyValue));\n\t\txml.endTag(null, keyName);\n\t\t\n\t\txml.startTag(null, valueName);\n\t\txml.text(safeXmlString(valueValue));\n\t\txml.endTag(null, valueName);\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeList(String name, AutoType autoType) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && autoType != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemAutoTypeEnabled, autoType.enabled);\n\t\twriteObject(ElemAutoTypeObfuscation, autoType.obfuscationOptions);\n\t\t\n\t\tif (autoType.defaultSequence.length() > 0) {\n\t\t\twriteObject(ElemAutoTypeDefaultSeq, autoType.defaultSequence, true);\n\t\t}\n\t\t\n\t\tfor (Entry<String, String> pair : autoType.entrySet()) {\n\t\t\twriteObject(ElemAutoTypeItem, ElemWindow, pair.getKey(), ElemKeystrokeSequence, pair.getValue());\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(Map<String, ProtectedString> strings, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert (strings != null);\n\t\t\n\t\tfor (Entry<String, ProtectedString> pair : strings.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), isEntryString);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate void writeObject(String key, ProtectedString value, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key !=null && value != null);\n\t\t\n\t\txml.startTag(null, ElemString);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tboolean protect = value.isProtected();\n\t\tif (isEntryString) {\n\t\t\tif (key.equals(PwDefsV4.TITLE_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectTitle;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.USERNAME_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUserName;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.PASSWORD_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectPassword;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.URL_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUrl;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.NOTES_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectNotes;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (protect) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tbyte[] data = value.toString().getBytes(\"UTF-8\");\n\t\t\tint valLength = data.length;\n\t\t\t\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(data, 0, valLength, encoded, 0);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txml.text(safeXmlString(value.toString()));\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemValue);\n\t\txml.endTag(null, ElemString);\n\t\t\n\t}\n\n\tprivate void writeObject(String name, PwDeletedObject value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemUuid, value.uuid);\n\t\twriteObject(ElemDeletionTime, value.getDeletionTime());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(Map<String, ProtectedBinary> binaries) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(binaries != null);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binaries.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), true);\n\t\t}\n\t}\n\n\n\tprivate void writeList(String name, List<PwDeletedObject> value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwDeletedObject pdo : value) {\n\t\t\twriteObject(ElemDeletedObject, pdo);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(String name, MemoryProtectionConfig value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemProtTitle, value.protectTitle);\n\t\twriteObject(ElemProtUserName, value.protectUserName);\n\t\twriteObject(ElemProtPassword, value.protectPassword);\n\t\twriteObject(ElemProtURL, value.protectUrl);\n\t\twriteObject(ElemProtNotes, value.protectNotes);\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, Map<String, String> customData) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && customData != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (Entry<String, String> pair : customData.entrySet()) {\n\t\t\twriteObject(ElemStringDictExItem, ElemKey, pair.getKey(), ElemValue, pair.getValue());\n\t\t\t  \n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, ITimeLogger it) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && it != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemLastModTime, it.getLastModificationTime());\n\t\twriteObject(ElemCreationTime, it.getCreationTime());\n\t\twriteObject(ElemLastAccessTime, it.getLastAccessTime());\n\t\twriteObject(ElemExpiryTime, it.getExpiryTime());\n\t\twriteObject(ElemExpires, it.expires());\n\t\twriteObject(ElemUsageCount, it.getUsageCount());\n\t\twriteObject(ElemLocationChanged, it.getLocationChanged());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(String name, List<PwEntryV4> value, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwEntryV4 entry : value) {\n\t\t\twriteEntry(entry, isHistory);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeCustomIconList() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tList<PwIconCustom> customIcons = mPM.customIcons;\n\t\tif (customIcons.size() == 0) return;\n\t\t\n\t\txml.startTag(null, ElemCustomIcons);\n\t\t\n\t\tfor (PwIconCustom icon : customIcons) {\n\t\t\txml.startTag(null, ElemCustomIconItem);\n\t\t\t\n\t\t\twriteObject(ElemCustomIconItemID, icon.uuid);\n\t\t\twriteObject(ElemCustomIconItemData, String.valueOf(Base64Coder.encode(icon.imageData)));\n\t\t\t\n\t\t\txml.endTag(null, ElemCustomIconItem);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemCustomIcons);\n\t}\n\t\n\tprivate void writeBinPool() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemBinaries);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binPool.entrySet()) {\n\t\t\txml.startTag(null, ElemBinary);\n\t\t\txml.attribute(null, AttrId, pair.getKey());\n\t\t\t\n\t\t\tsubWriteValue(pair.getValue());\n\t\t\t\n\t\t\txml.endTag(null, ElemBinary);\n\t\t\t\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemBinaries);\n\t\t\n\t}\n\n\tprivate String safeXmlString(String text) {\n\t\tif (EmptyUtils.isNullOrEmpty(text)) {\n\t\t\treturn text;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar ch;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tch = text.charAt(i);\n\t\t\t\n\t\t\tif(((ch >= 0x20) && (ch <= 0xD7FF)) ||              \n\t\t\t        (ch == 0x9) || (ch == 0xA) || (ch == 0xD) ||\n\t\t\t        ((ch >= 0xE000) && (ch <= 0xFFFD))) {\n\t\t\t\t\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2013-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport static com.keepassdroid.database.PwDatabaseV4XML.*;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.SecureRandom;\nimport java.util.Date;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPOutputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\n\nimport org.spongycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlSerializer;\n\nimport android.util.Xml;\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.crypto.engine.CipherEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfEngine;\nimport com.keepassdroid.crypto.keyDerivation.KdfFactory;\nimport com.keepassdroid.database.BinaryPool;\nimport com.keepassdroid.database.CrsAlgorithm;\nimport com.keepassdroid.database.EntryHandler;\nimport com.keepassdroid.database.GroupHandler;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDatabaseV4.MemoryProtectionConfig;\nimport com.keepassdroid.database.PwDatabaseV4XML;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDefsV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwEntryV4.AutoType;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.security.ProtectedBinary;\nimport com.keepassdroid.database.security.ProtectedString;\nimport com.keepassdroid.stream.HashedBlockOutputStream;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.MemUtil;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbV4Output extends PwDbOutput {\n\n\tPwDatabaseV4 mPM;\n\tprivate StreamCipher randomStream;\n\tprivate BinaryPool binPool;\n\tprivate XmlSerializer xml;\n\tprivate PwDbHeaderV4 header;\n\tprivate byte[] hashOfHeader;\n\t\n\tprotected PwDbV4Output(PwDatabaseV4 pm, OutputStream os) {\n\t\tsuper(os);\n\t\t\n\t\tmPM = pm;\n\t}\n\n\t@Override\n\tpublic void output() throws PwDbOutputException {\n\n\n\t\theader = (PwDbHeaderV4) outputHeader(mOS);\n\t\t\n\t\tCipherOutputStream cos = attachStreamEncryptor(header, mOS);\n\t\t\n\t\tOutputStream compressed;\n\t\ttry {\n\t\t\tcos.write(header.streamStartBytes);\n\t\t\t\n\t\t\tHashedBlockOutputStream hashed = new HashedBlockOutputStream(cos);\n\t\t\t\n\t\t\tif ( mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\t\tcompressed = new GZIPOutputStream(hashed); \n\t\t\t} else {\n\t\t\t\tcompressed = hashed;\n\t\t\t}\n\n\t\n\t\t\toutputDatabase(compressed);\n\t\t\tcompressed.close();\n\t\t} catch (IllegalArgumentException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t} catch (IllegalStateException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(e);\n\t\t}\n\t}\n\t\n\tprivate class GroupWriter extends GroupHandler<PwGroup> {\n\t\tprivate Stack<PwGroupV4> groupStack;\n\t\t\n\t\tpublic GroupWriter(Stack<PwGroupV4> gs) {\n\t\t\tgroupStack = gs;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean operate(PwGroup g) {\n\t\t\tPwGroupV4 group = (PwGroupV4) g;\n\t\t\tassert(group != null);\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\ttry {\n\t\t\t\t\tif (group.parent == groupStack.peek()) {\n\t\t\t\t\t\tgroupStack.push(group);\n\t\t\t\t\t\tstartGroup(group);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tgroupStack.pop();\n\t\t\t\t\t\tif (groupStack.size() <= 0) return false;\n\t\t\t\t\t\tendGroup();\n\t\t\t\t\t}\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate class EntryWriter extends EntryHandler<PwEntry> {\n\n\t\t@Override\n\t\tpublic boolean operate(PwEntry e) {\n\t\t\tPwEntryV4 entry = (PwEntryV4) e;\n\t\t\tassert(entry != null);\n\t\t\t\n\t\t\ttry {\n\t\t\t\twriteEntry(entry, false);\n\t\t\t} catch (IOException ex) {\n\t\t\t\tthrow new RuntimeException(ex);\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void outputDatabase(OutputStream os) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbinPool = new BinaryPool((PwGroupV4)mPM.rootGroup);\n\t\t\n\t\txml = Xml.newSerializer();\n\t\t\n\t\txml.setOutput(os, \"UTF-8\");\n\t\txml.startDocument(\"UTF-8\", true);\n\t\t\n\t\txml.startTag(null, ElemDocNode);\n\t\t\n\t\twriteMeta();\n\t\t\n\t\tPwGroupV4 root = (PwGroupV4) mPM.rootGroup;\n\t\txml.startTag(null, ElemRoot);\n\t\tstartGroup(root);\n\t\tStack<PwGroupV4> groupStack = new Stack<PwGroupV4>();\n\t\tgroupStack.push(root);\n\t\t\n\t\tif (!root.preOrderTraverseTree(new GroupWriter(groupStack), new EntryWriter())) throw new RuntimeException(\"Writing groups failed\");\n\t\t\n\t\twhile (groupStack.size() > 1) {\n\t\t\txml.endTag(null, ElemGroup);\n\t\t\tgroupStack.pop();\n\t\t}\n\t\t\n\t\tendGroup();\n\t\t\n\t\twriteList(ElemDeletedObjects, mPM.deletedObjects);\n\t\t\n\t\txml.endTag(null, ElemRoot);\n\t\t\n\t\txml.endTag(null, ElemDocNode);\n\t\txml.endDocument();\n\t\t\n\t}\n\t\n\tprivate void writeMeta() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemMeta);\n\t\t\n\t\twriteObject(ElemGenerator, mPM.localizedAppName);\n\t\t\n\t\tif (hashOfHeader != null) {\n\t\t\twriteObject(ElemHeaderHash, String.valueOf(Base64Coder.encode(hashOfHeader)));\n\t\t}\n\t\t\n\t\twriteObject(ElemDbName, mPM.name, true);\n\t\twriteObject(ElemDbNameChanged, mPM.nameChanged);\n\t\twriteObject(ElemDbDesc, mPM.description, true);\n\t\twriteObject(ElemDbDescChanged, mPM.descriptionChanged);\n\t\twriteObject(ElemDbDefaultUser, mPM.defaultUserName, true);\n\t\twriteObject(ElemDbDefaultUserChanged, mPM.defaultUserNameChanged);\n\t\twriteObject(ElemDbMntncHistoryDays, mPM.maintenanceHistoryDays);\n\t\twriteObject(ElemDbColor, mPM.color);\n\t\twriteObject(ElemDbKeyChanged, mPM.keyLastChanged);\n\t\twriteObject(ElemDbKeyChangeRec, mPM.keyChangeRecDays);\n\t\twriteObject(ElemDbKeyChangeForce, mPM.keyChangeForceDays);\n\t\t\n\t\t\n\t\twriteList(ElemMemoryProt, mPM.memoryProtection);\n\t\t\n\t\twriteCustomIconList();\n\t\t\n\t\twriteObject(ElemRecycleBinEnabled, mPM.recycleBinEnabled);\n\t\twriteObject(ElemRecycleBinUuid, mPM.recycleBinUUID);\n\t\twriteObject(ElemRecycleBinChanged, mPM.recycleBinChanged);\n\t\twriteObject(ElemEntryTemplatesGroup, mPM.entryTemplatesGroup);\n\t\twriteObject(ElemEntryTemplatesGroupChanged, mPM.entryTemplatesGroupChanged);\n\t\twriteObject(ElemHistoryMaxItems, mPM.historyMaxItems);\n\t\twriteObject(ElemHistoryMaxSize, mPM.historyMaxSize);\n\t\twriteObject(ElemLastSelectedGroup, mPM.lastSelectedGroup);\n\t\twriteObject(ElemLastTopVisibleGroup, mPM.lastTopVisibleGroup);\n\t\t\n\t\twriteBinPool();\n\t\twriteList(ElemCustomData, mPM.customData);\n\t\t\n\t\txml.endTag(null, ElemMeta);\n\t\t\n\t}\n\t\n\tprivate CipherOutputStream attachStreamEncryptor(PwDbHeaderV4 header, OutputStream os) throws PwDbOutputException {\n\t\tCipher cipher;\n\t\tCipherEngine engine;\n\t\ttry {\n\t\t\tmPM.makeFinalKey(header.masterSeed, header.getTransformSeed(), (int)mPM.numKeyEncRounds);\n\n\t\t\tengine = CipherFactory.getInstance(mPM.dataCipher);\n\t\t\tcipher = engine.getCipher(Cipher.ENCRYPT_MODE, mPM.finalKey, header.encryptionIV);\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwDbOutputException(\"Invalid algorithm.\", e);\n\t\t}\n\t\t\n\t\tCipherOutputStream cos = new CipherOutputStream(os, cipher);\n\t\t\n\t\treturn cos;\n\t}\n\n\t@Override\n\tprotected SecureRandom setIVs(PwDbHeader header) throws PwDbOutputException {\n\t\tSecureRandom random = super.setIVs(header);\n\t\t\n\t\tPwDbHeaderV4 h = (PwDbHeaderV4) header;\n\t\trandom.nextBytes(h.masterSeed);\n\t\trandom.nextBytes(h.encryptionIV);\n\n\t\tUUID kdfUUID = mPM.kdfParameters.kdfUUID;\n\t\tKdfEngine kdf = KdfFactory.get(kdfUUID);\n\t\tkdf.randomize(mPM.kdfParameters);\n\n\t\trandom.nextBytes(h.protectedStreamKey);\n\t\th.innerRandomStream = CrsAlgorithm.Salsa20;\n\t\trandomStream = PwStreamCipherFactory.getInstance(h.innerRandomStream, h.protectedStreamKey);\n\t\tif (randomStream == null) {\n\t\t\tthrow new PwDbOutputException(\"Invalid random cipher\");\n\t\t}\n\t\trandom.nextBytes(h.streamStartBytes);\n\t\t\n\t\treturn random;\n\t}\n\t\n\t@Override\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwDbOutputException {\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(mPM);\n\t\tsetIVs(header);\n\t\t\n\t\tPwDbHeaderOutputV4 pho = new PwDbHeaderOutputV4(mPM, header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwDbOutputException(\"Failed to output the header.\", e);\n\t\t}\n\t\t\n\t\thashOfHeader = pho.getHashOfHeader();\n\t\t\n\t\treturn header;\n\t}\n\t\n\tprivate void startGroup(PwGroupV4 group) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemGroup);\n\t\twriteObject(ElemUuid, group.uuid);\n\t\twriteObject(ElemName, group.name);\n\t\twriteObject(ElemNotes, group.notes);\n\t\twriteObject(ElemIcon, group.icon.iconId);\n\t\t\n\t\tif (!group.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, group.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteList(ElemTimes, group);\n\t\twriteObject(ElemIsExpanded, group.isExpanded);\n\t\twriteObject(ElemGroupDefaultAutoTypeSeq, group.defaultAutoTypeSequence);\n\t\twriteObject(ElemEnableAutoType, group.enableAutoType);\n\t\twriteObject(ElemEnableSearching, group.enableSearching);\n\t\twriteObject(ElemLastTopVisibleEntry, group.lastTopVisibleEntry);\n\t\t\n\t}\n\t\n\tprivate void endGroup() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.endTag(null, ElemGroup);\n\t}\n\t\n\tprivate void writeEntry(PwEntryV4 entry, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(entry != null);\n\t\t\n\t\txml.startTag(null, ElemEntry);\n\t\t\n\t\twriteObject(ElemUuid, entry.uuid);\n\t\twriteObject(ElemIcon, entry.icon.iconId);\n\t\t\n\t\tif (!entry.customIcon.equals(PwIconCustom.ZERO)) {\n\t\t\twriteObject(ElemCustomIconID, entry.customIcon.uuid);\n\t\t}\n\t\t\n\t\twriteObject(ElemFgColor, entry.foregroundColor);\n\t\twriteObject(ElemBgColor, entry.backgroupColor);\n\t\twriteObject(ElemOverrideUrl, entry.overrideURL);\n\t\twriteObject(ElemTags, entry.tags);\n\t\t\n\t\twriteList(ElemTimes, entry);\n\t\t\n\t\twriteList(entry.strings, true);\n\t\twriteList(entry.binaries);\n\t\twriteList(ElemAutoType, entry.autoType);\n\t\t\n\t\tif (!isHistory) {\n\t\t\twriteList(ElemHistory, entry.history, true);\n\t\t} else {\n\t\t\tassert(entry.history.size() == 0);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemEntry);\n\t}\n\t\n\n\tprivate void writeObject(String key, ProtectedBinary value, boolean allowRef) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key != null && value != null);\n\t\t\n\t\txml.startTag(null, ElemBinary);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tString strRef = null;\n\t\tif (allowRef) {\n\t\t\tint ref = binPool.poolFind(value);\n\t\t\tstrRef = Integer.toString(ref);\n\t\t}\n\t\t\n\t\tif (strRef != null) {\n\t\t\txml.attribute(null, AttrRef, strRef);\n\t\t}\n\t\telse {\n\t\t\tsubWriteValue(value);\n\t\t}\n\t\txml.endTag(null, ElemValue);\n\t\t\n\t\txml.endTag(null, ElemBinary);\n\t}\n\t\n\tprivate void subWriteValue(ProtectedBinary value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tif (value.isProtected()) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tint valLength = value.length();\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(value.getData(), 0, valLength, encoded, 0);\n\t\t\t\t\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t\t\n\t\t} else {\n\t\t\tif (mPM.compressionAlgorithm == PwCompressionAlgorithm.Gzip) {\n\t\t\t\txml.attribute(null, AttrCompressed, ValTrue);\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\tbyte[] compressed = MemUtil.compress(raw);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(compressed)));\n\t\t\t} else {\n\t\t\t\tbyte[] raw = value.getData();\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(raw)));\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\t\n\tprivate void writeObject(String name, String value, boolean filterXmlChars) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tif (filterXmlChars) {\n\t\t\tvalue = safeXmlString(value);\n\t\t}\n\t\t\n\t\txml.text(value);\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeObject(String name, String value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, value, false);\n\t}\n\t\n\tprivate void writeObject(String name, Date value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, PwDatabaseV4XML.dateFormat.format(value));\n\t}\n\t\n\tprivate void writeObject(String name, long value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\twriteObject(name, String.valueOf(value));\n\t}\n\t\n\tprivate void writeObject(String name, Boolean value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tString text;\n\t\tif (value == null) {\n\t\t\ttext = \"null\";\n\t\t}\n\t\telse if (value) {\n\t\t\ttext = ValTrue;\n\t\t}\n\t\telse {\n\t\t\ttext = ValFalse;\n\t\t}\n\t\t\n\t\twriteObject(name, text);\n\t}\n\t\n\tprivate void writeObject(String name, UUID uuid) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tbyte[] data = Types.UUIDtoBytes(uuid);\n\t\twriteObject(name, String.valueOf(Base64Coder.encode(data)));\n\t}\n\t\n\tprivate void writeObject(String name, String keyName, String keyValue, String valueName, String valueValue) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, name);\n\t\t\n\t\txml.startTag(null, keyName);\n\t\txml.text(safeXmlString(keyValue));\n\t\txml.endTag(null, keyName);\n\t\t\n\t\txml.startTag(null, valueName);\n\t\txml.text(safeXmlString(valueValue));\n\t\txml.endTag(null, valueName);\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\t\n\tprivate void writeList(String name, AutoType autoType) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && autoType != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemAutoTypeEnabled, autoType.enabled);\n\t\twriteObject(ElemAutoTypeObfuscation, autoType.obfuscationOptions);\n\t\t\n\t\tif (autoType.defaultSequence.length() > 0) {\n\t\t\twriteObject(ElemAutoTypeDefaultSeq, autoType.defaultSequence, true);\n\t\t}\n\t\t\n\t\tfor (Entry<String, String> pair : autoType.entrySet()) {\n\t\t\twriteObject(ElemAutoTypeItem, ElemWindow, pair.getKey(), ElemKeystrokeSequence, pair.getValue());\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(Map<String, ProtectedString> strings, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert (strings != null);\n\t\t\n\t\tfor (Entry<String, ProtectedString> pair : strings.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), isEntryString);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n\tprivate void writeObject(String key, ProtectedString value, boolean isEntryString) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(key !=null && value != null);\n\t\t\n\t\txml.startTag(null, ElemString);\n\t\txml.startTag(null, ElemKey);\n\t\txml.text(safeXmlString(key));\n\t\txml.endTag(null, ElemKey);\n\t\t\n\t\txml.startTag(null, ElemValue);\n\t\tboolean protect = value.isProtected();\n\t\tif (isEntryString) {\n\t\t\tif (key.equals(PwDefsV4.TITLE_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectTitle;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.USERNAME_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUserName;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.PASSWORD_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectPassword;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.URL_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectUrl;\n\t\t\t}\n\t\t\telse if (key.equals(PwDefsV4.NOTES_FIELD)) {\n\t\t\t\tprotect = mPM.memoryProtection.protectNotes;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (protect) {\n\t\t\txml.attribute(null, AttrProtected, ValTrue);\n\t\t\t\n\t\t\tbyte[] data = value.toString().getBytes(\"UTF-8\");\n\t\t\tint valLength = data.length;\n\t\t\t\n\t\t\tif (valLength > 0) {\n\t\t\t\tbyte[] encoded = new byte[valLength];\n\t\t\t\trandomStream.processBytes(data, 0, valLength, encoded, 0);\n\t\t\t\txml.text(String.valueOf(Base64Coder.encode(encoded)));\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\txml.text(safeXmlString(value.toString()));\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemValue);\n\t\txml.endTag(null, ElemString);\n\t\t\n\t}\n\n\tprivate void writeObject(String name, PwDeletedObject value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemUuid, value.uuid);\n\t\twriteObject(ElemDeletionTime, value.getDeletionTime());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(Map<String, ProtectedBinary> binaries) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(binaries != null);\n\t\t\n\t\tfor (Entry<String, ProtectedBinary> pair : binaries.entrySet()) {\n\t\t\twriteObject(pair.getKey(), pair.getValue(), true);\n\t\t}\n\t}\n\n\n\tprivate void writeList(String name, List<PwDeletedObject> value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwDeletedObject pdo : value) {\n\t\t\twriteObject(ElemDeletedObject, pdo);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeList(String name, MemoryProtectionConfig value) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemProtTitle, value.protectTitle);\n\t\twriteObject(ElemProtUserName, value.protectUserName);\n\t\twriteObject(ElemProtPassword, value.protectPassword);\n\t\twriteObject(ElemProtURL, value.protectUrl);\n\t\twriteObject(ElemProtNotes, value.protectNotes);\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, Map<String, String> customData) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && customData != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (Entry<String, String> pair : customData.entrySet()) {\n\t\t\twriteObject(ElemStringDictExItem, ElemKey, pair.getKey(), ElemValue, pair.getValue());\n\t\t\t  \n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\t\n\tprivate void writeList(String name, ITimeLogger it) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && it != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\twriteObject(ElemLastModTime, it.getLastModificationTime());\n\t\twriteObject(ElemCreationTime, it.getCreationTime());\n\t\twriteObject(ElemLastAccessTime, it.getLastAccessTime());\n\t\twriteObject(ElemExpiryTime, it.getExpiryTime());\n\t\twriteObject(ElemExpires, it.expires());\n\t\twriteObject(ElemUsageCount, it.getUsageCount());\n\t\twriteObject(ElemLocationChanged, it.getLocationChanged());\n\t\t\n\t\txml.endTag(null, name);\n\t}\n\n\tprivate void writeList(String name, List<PwEntryV4> value, boolean isHistory) throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tassert(name != null && value != null);\n\t\t\n\t\txml.startTag(null, name);\n\t\t\n\t\tfor (PwEntryV4 entry : value) {\n\t\t\twriteEntry(entry, isHistory);\n\t\t}\n\t\t\n\t\txml.endTag(null, name);\n\t\t\n\t}\n\n\tprivate void writeCustomIconList() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\tList<PwIconCustom> customIcons = mPM.customIcons;\n\t\tif (customIcons.size() == 0) return;\n\t\t\n\t\txml.startTag(null, ElemCustomIcons);\n\t\t\n\t\tfor (PwIconCustom icon : customIcons) {\n\t\t\txml.startTag(null, ElemCustomIconItem);\n\t\t\t\n\t\t\twriteObject(ElemCustomIconItemID, icon.uuid);\n\t\t\twriteObject(ElemCustomIconItemData, String.valueOf(Base64Coder.encode(icon.imageData)));\n\t\t\t\n\t\t\txml.endTag(null, ElemCustomIconItem);\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemCustomIcons);\n\t}\n\t\n\tprivate void writeBinPool() throws IllegalArgumentException, IllegalStateException, IOException {\n\t\txml.startTag(null, ElemBinaries);\n\t\t\n\t\tfor (Entry<Integer, ProtectedBinary> pair : binPool.entrySet()) {\n\t\t\txml.startTag(null, ElemBinary);\n\t\t\txml.attribute(null, AttrId, Integer.toString(pair.getKey()));\n\t\t\t\n\t\t\tsubWriteValue(pair.getValue());\n\t\t\t\n\t\t\txml.endTag(null, ElemBinary);\n\t\t\t\n\t\t}\n\t\t\n\t\txml.endTag(null, ElemBinaries);\n\t\t\n\t}\n\n\tprivate String safeXmlString(String text) {\n\t\tif (EmptyUtils.isNullOrEmpty(text)) {\n\t\t\treturn text;\n\t\t}\n\t\t\n\t\tStringBuilder sb = new StringBuilder();\n\t\t\n\t\tchar ch;\n\t\tfor (int i = 0; i < text.length(); i++) {\n\t\t\tch = text.charAt(i);\n\t\t\t\n\t\t\tif(((ch >= 0x20) && (ch <= 0xD7FF)) ||              \n\t\t\t        (ch == 0x9) || (ch == 0xA) || (ch == 0xD) ||\n\t\t\t        ((ch >= 0xE000) && (ch <= 0xFFFD))) {\n\t\t\t\t\n\t\t\t\tsb.append(ch);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\treturn sb.toString();\n\t}\n\n}\n","lineNo":377}
{"Smelly Sample":"/*\n * Copyright 2010-2012 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbHeaderV4 extends PwDbHeader {\n\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n    public static final int DBSIG_2               = 0xB54BFB67;\n    \n    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;\n    public static final int FILE_VERSION_32 =             0x00030001;\n    \n    public class PwDbHeaderV4Fields {\n        public static final byte EndOfHeader = 0;\n\t\tpublic static final byte Comment = 1;\n        public static final byte CipherID = 2;\n        public static final byte CompressionFlags = 3;\n        public static final byte MasterSeed = 4;\n        public static final byte TransformSeed = 5;\n        public static final byte TransformRounds = 6;\n        public static final byte EncryptionIV = 7;\n        public static final byte ProtectedStreamKey = 8;\n        public static final byte StreamStartBytes = 9;\n        public static final byte InnerRandomStreamID = 10;\n\n    }\n    \n    private PwDatabaseV4 db;\n    public byte[] protectedStreamKey = new byte[32];\n    public byte[] streamStartBytes = new byte[32];\n    public CrsAlgorithm innerRandomStream;\n\n    public PwDbHeaderV4(PwDatabaseV4 d) {\n    \tdb = d;\n    \t\n    \tmasterSeed = new byte[32];\n    }\n\n\t/** Assumes the input stream is at the beginning of the .kdbx file\n\t * @param is\n\t * @throws IOException \n\t * @throws InvalidDBVersionException \n\t */\n\tpublic byte[] loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 implementation\");\n\t\t}\n\t\t\n\t\tDigestInputStream dis = new DigestInputStream(is, md);\n\t\tLEDataInputStream lis = new LEDataInputStream(dis);\n\n\t\tint sig1 = lis.readInt();\n\t\tint sig2 = lis.readInt();\n\t\t\n\t\tif ( ! matchesHeader(sig1, sig2) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tlong version = lis.readUInt();\n\t\tif ( ! validVersion(version) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tboolean done = false;\n\t\twhile ( ! done ) {\n\t\t\tdone = readHeaderField(lis);\n\t\t}\n\t\t\n\t\treturn md.digest();\n\t}\n\t\n\tprivate boolean readHeaderField(LEDataInputStream dis) throws IOException {\n\t\tbyte fieldID = (byte) dis.read();\n\t\t\n\t\tint fieldSize = dis.readUShort();\n\t\t\n\t\tbyte[] fieldData = null;\n\t\tif ( fieldSize > 0 ) {\n\t\t\tfieldData = new byte[fieldSize];\n\t\t\t\n\t\t\tint readSize = dis.read(fieldData);\n\t\t\tif ( readSize != fieldSize ) {\n\t\t\t\tthrow new IOException(\"Header ended early.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch ( fieldID ) {\n\t\t\tcase PwDbHeaderV4Fields.EndOfHeader:\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CipherID:\n\t\t\t\tsetCipher(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CompressionFlags:\n\t\t\t\tsetCompressionFlags(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.MasterSeed:\n\t\t\t\tmasterSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformSeed:\n\t\t\t\ttransformSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformRounds:\n\t\t\t\tsetTransformRounds(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.EncryptionIV:\n\t\t\t\tencryptionIV = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.ProtectedStreamKey:\n\t\t\t\tprotectedStreamKey = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.StreamStartBytes:\n\t\t\t\tstreamStartBytes = fieldData;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomStreamID:\n\t\t\t\tsetRandomStreamID(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow new IOException(\"Invalid header type.\");\n\t\t\t\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void setCipher(byte[] pbId) throws IOException {\n\t\tif ( pbId == null || pbId.length != 16 ) {\n\t\t\tthrow new IOException(\"Invalid cipher ID.\");\n\t\t}\n\t\t\n\t\tdb.dataCipher = Types.bytestoUUID(pbId);\n\t}\n\t\n\tprivate void setCompressionFlags(byte[] pbFlags) throws IOException {\n\t\tif ( pbFlags == null || pbFlags.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid compression flags.\");\n\t\t}\n\t\t\n\t\tint flag = LEDataInputStream.readInt(pbFlags, 0);\n\t\tif ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Unrecognized compression flag.\");\n\t\t}\n\t\t\n\t\tdb.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);\n\t\t\n\t}\n\t\n\tprivate void setTransformRounds(byte[] rounds) throws IOException {\n\t\tif ( rounds == null || rounds.length != 8 ) {\n\t\t\tthrow new IOException(\"Invalid rounds.\");\n\t\t}\n\t\t\n\t\tlong rnd = LEDataInputStream.readLong(rounds, 0);\n\t\t\n\t\tif ( rnd < 0 || rnd > Integer.MAX_VALUE ) {\n\t\t\t//TODO: Actually support really large numbers\n\t\t\tthrow new IOException(\"Rounds higher than \" + Integer.MAX_VALUE + \" are not currently supported.\");\n\t\t}\n\t\t\n\t\tdb.numKeyEncRounds = rnd;\n\t\t\n\t}\n\t\n\tprivate void setRandomStreamID(byte[] streamID) throws IOException {\n\t\tif ( streamID == null || streamID.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tint id = LEDataInputStream.readInt(streamID, 0);\n\t\tif ( id < 0 || id >= CrsAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tinnerRandomStream = CrsAlgorithm.fromId(id);\n\t}\n\t\n\t/** Determines if this is a supported version.\n\t * \n\t *  A long is needed here to represent the unsigned int since we perform\n\t *  arithmetic on it.\n\t * @param version\n\t * @return\n\t */\n\tprivate boolean validVersion(long version) {\n\t\t\n\t\treturn ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK));\n\t\t\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );\n\t}\n    \n}\n","Method after Refactoring":"/*\n * Copyright 2010-2017 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport com.keepassdroid.database.exception.InvalidAlgorithmException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.stream.CopyInputStream;\nimport com.keepassdroid.stream.HmacBlockStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\nimport javax.crypto.Mac;\n\npublic class PwDbHeaderV4 extends PwDbHeader {\n\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n    public static final int DBSIG_2               = 0xB54BFB67;\n    \n    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;\n    public static final int FILE_VERSION_32_3 =           0x00030001;\n\tpublic static final int FILE_VERSION_32_4 =           0x00040001;\n\tpublic static final int FILE_VERSION_32 =             FILE_VERSION_32_4;\n\n    public class PwDbHeaderV4Fields {\n        public static final byte EndOfHeader = 0;\n\t\tpublic static final byte Comment = 1;\n        public static final byte CipherID = 2;\n        public static final byte CompressionFlags = 3;\n        public static final byte MasterSeed = 4;\n        public static final byte TransformSeed = 5;\n        public static final byte TransformRounds = 6;\n        public static final byte EncryptionIV = 7;\n        public static final byte ProtectedStreamKey = 8;\n        public static final byte StreamStartBytes = 9;\n        public static final byte InnerRandomStreamID = 10;\n\n    }\n\n\tpublic class HeaderAndHash {\n\t\tpublic byte[] header;\n\t\tpublic byte[] hash;\n\n\t\tpublic HeaderAndHash (byte[] header, byte[] hash) {\n\t\t\tthis.header = header;\n\t\t\tthis.hash = hash;\n\t\t}\n\t}\n    \n    private PwDatabaseV4 db;\n    public byte[] protectedStreamKey = new byte[32];\n    public byte[] streamStartBytes = new byte[32];\n    public CrsAlgorithm innerRandomStream;\n\tpublic long version;\n\n    public PwDbHeaderV4(PwDatabaseV4 d) {\n    \tdb = d;\n    \t\n    \tmasterSeed = new byte[32];\n    }\n\n\t/** Assumes the input stream is at the beginning of the .kdbx file\n\t * @param is\n\t * @throws IOException \n\t * @throws InvalidDBVersionException \n\t */\n\tpublic HeaderAndHash loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 implementation\");\n\t\t}\n\t\t\n\t\tByteArrayOutputStream headerBOS = new ByteArrayOutputStream();\n\t\tCopyInputStream cis = new CopyInputStream(is, headerBOS);\n\t\tDigestInputStream dis = new DigestInputStream(cis, md);\n\t\tLEDataInputStream lis = new LEDataInputStream(dis);\n\n\t\tint sig1 = lis.readInt();\n\t\tint sig2 = lis.readInt();\n\t\t\n\t\tif ( ! matchesHeader(sig1, sig2) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tversion = lis.readUInt();\n\t\tif ( ! validVersion(version) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tboolean done = false;\n\t\twhile ( ! done ) {\n\t\t\tdone = readHeaderField(lis);\n\t\t}\n\n\t\tbyte[] hash = md.digest();\n\t\treturn new HeaderAndHash(headerBOS.toByteArray(), hash);\n\t}\n\t\n\tprivate boolean readHeaderField(LEDataInputStream dis) throws IOException {\n\t\tbyte fieldID = (byte) dis.read();\n\t\t\n\t\tint fieldSize = dis.readUShort();\n\t\t\n\t\tbyte[] fieldData = null;\n\t\tif ( fieldSize > 0 ) {\n\t\t\tfieldData = new byte[fieldSize];\n\t\t\t\n\t\t\tint readSize = dis.read(fieldData);\n\t\t\tif ( readSize != fieldSize ) {\n\t\t\t\tthrow new IOException(\"Header ended early.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch ( fieldID ) {\n\t\t\tcase PwDbHeaderV4Fields.EndOfHeader:\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CipherID:\n\t\t\t\tsetCipher(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CompressionFlags:\n\t\t\t\tsetCompressionFlags(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.MasterSeed:\n\t\t\t\tmasterSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformSeed:\n\t\t\t\ttransformSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformRounds:\n\t\t\t\tsetTransformRounds(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.EncryptionIV:\n\t\t\t\tencryptionIV = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.ProtectedStreamKey:\n\t\t\t\tprotectedStreamKey = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.StreamStartBytes:\n\t\t\t\tstreamStartBytes = fieldData;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomStreamID:\n\t\t\t\tsetRandomStreamID(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow new IOException(\"Invalid header type.\");\n\t\t\t\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void setCipher(byte[] pbId) throws IOException {\n\t\tif ( pbId == null || pbId.length != 16 ) {\n\t\t\tthrow new IOException(\"Invalid cipher ID.\");\n\t\t}\n\t\t\n\t\tdb.dataCipher = Types.bytestoUUID(pbId);\n\t}\n\t\n\tprivate void setCompressionFlags(byte[] pbFlags) throws IOException {\n\t\tif ( pbFlags == null || pbFlags.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid compression flags.\");\n\t\t}\n\t\t\n\t\tint flag = LEDataInputStream.readInt(pbFlags, 0);\n\t\tif ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Unrecognized compression flag.\");\n\t\t}\n\t\t\n\t\tdb.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);\n\t\t\n\t}\n\t\n\tprivate void setTransformRounds(byte[] rounds) throws IOException {\n\t\tif ( rounds == null || rounds.length != 8 ) {\n\t\t\tthrow new IOException(\"Invalid rounds.\");\n\t\t}\n\t\t\n\t\tlong rnd = LEDataInputStream.readLong(rounds, 0);\n\t\t\n\t\tif ( rnd < 0 || rnd > Integer.MAX_VALUE ) {\n\t\t\t//TODO: Actually support really large numbers\n\t\t\tthrow new IOException(\"Rounds higher than \" + Integer.MAX_VALUE + \" are not currently supported.\");\n\t\t}\n\t\t\n\t\tdb.numKeyEncRounds = rnd;\n\t\t\n\t}\n\t\n\tprivate void setRandomStreamID(byte[] streamID) throws IOException {\n\t\tif ( streamID == null || streamID.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tint id = LEDataInputStream.readInt(streamID, 0);\n\t\tif ( id < 0 || id >= CrsAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tinnerRandomStream = CrsAlgorithm.fromId(id);\n\t}\n\t\n\t/** Determines if this is a supported version.\n\t * \n\t *  A long is needed here to represent the unsigned int since we perform\n\t *  arithmetic on it.\n\t * @param version\n\t * @return\n\t */\n\tprivate boolean validVersion(long version) {\n\t\t\n\t\treturn ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32_3 & FILE_VERSION_CRITICAL_MASK));\n\t\t\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );\n\t}\n\n\tpublic static byte[] computeHeaderHmac(byte[] header, byte[] key) throws IOException{\n\t\tbyte[] headerHmac;\n\t\tbyte[] blockKey = HmacBlockStream.GetHmacKey64(key, Types.ULONG_MAX_VALUE);\n\n\t\tMac hmac;\n\t\ttry {\n\t\t\thmac = Mac.getInstance(\"HmacSHA256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No HmacAlogirthm\");\n\t\t}\n\n\t\treturn hmac.doFinal(header);\n\t}\n    \n}\n","lineNo":99}
{"Smelly Sample":"/*\n * Copyright 2013-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.fileselect;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.compat.EditorCompat;\nimport com.keepassdroid.utils.UriUtil;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.preference.PreferenceManager;\n\npublic class RecentFileHistory {\n\n    private static String DB_KEY = \"recent_databases\";\n    private static String KEYFILE_KEY = \"recent_keyfiles\";\n\n    private List<String> databases = new ArrayList<String>();\n    private List<String> keyfiles = new ArrayList<String>();\n    private Context ctx;\n    private SharedPreferences prefs;\n    private OnSharedPreferenceChangeListener listner;\n    private boolean enabled;\n    private boolean init = false;\n\n    public RecentFileHistory(Context c) {\n        ctx = c.getApplicationContext();\n\n        prefs = PreferenceManager.getDefaultSharedPreferences(c);\n        enabled = prefs.getBoolean(ctx.getString(R.string.recentfile_key), ctx.getResources().getBoolean(R.bool.recentfile_default));\n        listner = new OnSharedPreferenceChangeListener() {\n\n            @Override\n            public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,\n                    String key) {\n                if (key.equals(ctx.getString(R.string.recentfile_key))) {\n                    enabled = sharedPreferences.getBoolean(ctx.getString(R.string.recentfile_key), ctx.getResources().getBoolean(R.bool.recentfile_default));\n                }\n            }\n        };\n        prefs.registerOnSharedPreferenceChangeListener(listner);\n    }\n\n    private synchronized void init() {\n        if (!init) {\n            if (!upgradeFromSQL()) {\n                loadPrefs();\n            }\n\n            init = true;\n        }\n    }\n\n    private boolean upgradeFromSQL() {\n\n        try {\n            // Check for a database to upgrade from\n            if (!sqlDatabaseExists()) {\n                return false;\n            }\n\n            databases.clear();\n            keyfiles.clear();\n\n            FileDbHelper helper = new FileDbHelper(ctx);\n            helper.open();\n            Cursor cursor = helper.fetchAllFiles();\n\n            int dbIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_FILENAME);\n            int keyIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_KEYFILE);\n\n            if(cursor.moveToFirst()) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(dbIndex);\n                    String keyfile = cursor.getString(keyIndex);\n\n                    databases.add(filename);\n                    keyfiles.add(keyfile);\n                }\n            }\n\n            savePrefs();\n\n            cursor.close();\n            helper.close();\n\n        } catch (Exception e) {\n            // If upgrading fails, we'll just give up on it.\n        }\n\n        try {\n            FileDbHelper.deleteDatabase(ctx);\n        } catch (Exception e) {\n            // If we fail to delete it, just move on\n        }\n\n        return true;\n    }\n\n    private boolean sqlDatabaseExists() {\n        File db = ctx.getDatabasePath(FileDbHelper.DATABASE_NAME);\n        return db.exists();\n    }\n\n    public void createFile(Uri uri, Uri keyUri) {\n        if (!enabled || uri == null || keyUri == null) return;\n\n        init();\n\n        // Remove any existing instance of the same filename\n        deleteFile(uri, false);\n\n        databases.add(0, uri.toString());\n        keyfiles.add(0, keyUri.toString());\n\n        trimLists();\n        savePrefs();\n    }\n\n    public boolean hasRecentFiles() {\n        if (!enabled) return false;\n\n        init();\n\n        return databases.size() > 0;\n    }\n\n    public String getDatabaseAt(int i) {\n        init();\n        return databases.get(i);\n    }\n\n    public String getKeyfileAt(int i) {\n        init();\n        return keyfiles.get(i);\n    }\n\n    private void loadPrefs() {\n        loadList(databases, DB_KEY);\n        loadList(keyfiles, KEYFILE_KEY);\n    }\n\n    private void savePrefs() {\n        saveList(DB_KEY, databases);\n        saveList(KEYFILE_KEY, keyfiles);\n    }\n\n    private void loadList(List<String> list, String keyprefix) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n        int size = prefs.getInt(keyprefix, 0);\n\n        list.clear();\n        for (int i = 0; i < size; i++) {\n            list.add(prefs.getString(keyprefix + \"_\" + i, \"\"));\n        }\n    }\n\n    private void saveList(String keyprefix, List<String> list) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n        SharedPreferences.Editor edit = prefs.edit();\n        int size = list.size();\n        edit.putInt(keyprefix, size);\n\n        for (int i = 0; i < size; i++) {\n            edit.putString(keyprefix + \"_\" + i, list.get(i));\n        }\n        EditorCompat.apply(edit);\n    }\n\n    public void deleteFile(Uri uri) {\n        deleteFile(uri, true);\n    }\n\n    public void deleteFile(Uri uri, boolean save) {\n        init();\n\n        String uriName = uri.toString();\n        String fileName = uri.getPath();\n\n        for (int i = 0; i < databases.size(); i++) {\n            String entry = databases.get(i);\n            if (uriName.equals(entry) || fileName.equals(entry)) {\n                databases.remove(i);\n                keyfiles.remove(i);\n                break;\n            }\n        }\n\n        if (save) {\n            savePrefs();\n        }\n    }\n\n    public List<String> getDbList() {\n        init();\n\n        return databases;\n    }\n\n    public Uri getFileByName(Uri database) {\n        if (!enabled) return null;\n\n        init();\n\n        int size = databases.size();\n        for (int i = 0; i < size; i++) {\n            if (UriUtil.equalsDefaultfile(database,databases.get(i))) {\n                return UriUtil.parseDefaultFile(keyfiles.get(i));\n            }\n        }\n\n        return null;\n    }\n\n    public void deleteAll() {\n        init();\n\n        databases.clear();\n        keyfiles.clear();\n\n        savePrefs();\n    }\n\n    public void deleteAllKeys() {\n        init();\n\n        keyfiles.clear();\n\n        int size = databases.size();\n        for (int i = 0; i < size; i++) {\n            keyfiles.add(\"\");\n        }\n\n        savePrefs();\n    }\n\n    private void trimLists() {\n        int size = databases.size();\n        for (int i = FileDbHelper.MAX_FILES; i < size; i++) {\n            databases.remove(i);\n            keyfiles.remove(i);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright 2013-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.fileselect;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.compat.EditorCompat;\nimport com.keepassdroid.utils.UriUtil;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.content.SharedPreferences.OnSharedPreferenceChangeListener;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.preference.PreferenceManager;\n\npublic class RecentFileHistory {\n\n    private static String DB_KEY = \"recent_databases\";\n    private static String KEYFILE_KEY = \"recent_keyfiles\";\n\n    private List<String> databases = new ArrayList<String>();\n    private List<String> keyfiles = new ArrayList<String>();\n    private Context ctx;\n    private SharedPreferences prefs;\n    private OnSharedPreferenceChangeListener listner;\n    private boolean enabled;\n    private boolean init = false;\n\n    public RecentFileHistory(Context c) {\n        ctx = c.getApplicationContext();\n\n        prefs = PreferenceManager.getDefaultSharedPreferences(c);\n        enabled = prefs.getBoolean(ctx.getString(R.string.recentfile_key), ctx.getResources().getBoolean(R.bool.recentfile_default));\n        listner = new OnSharedPreferenceChangeListener() {\n\n            @Override\n            public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,\n                    String key) {\n                if (key.equals(ctx.getString(R.string.recentfile_key))) {\n                    enabled = sharedPreferences.getBoolean(ctx.getString(R.string.recentfile_key), ctx.getResources().getBoolean(R.bool.recentfile_default));\n                }\n            }\n        };\n        prefs.registerOnSharedPreferenceChangeListener(listner);\n    }\n\n    private synchronized void init() {\n        if (!init) {\n            if (!upgradeFromSQL()) {\n                loadPrefs();\n            }\n\n            init = true;\n        }\n    }\n\n    private boolean upgradeFromSQL() {\n\n        try {\n            // Check for a database to upgrade from\n            if (!sqlDatabaseExists()) {\n                return false;\n            }\n\n            databases.clear();\n            keyfiles.clear();\n\n            FileDbHelper helper = new FileDbHelper(ctx);\n            helper.open();\n            Cursor cursor = helper.fetchAllFiles();\n\n            int dbIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_FILENAME);\n            int keyIndex = cursor.getColumnIndex(FileDbHelper.KEY_FILE_KEYFILE);\n\n            if(cursor.moveToFirst()) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(dbIndex);\n                    String keyfile = cursor.getString(keyIndex);\n\n                    databases.add(filename);\n                    keyfiles.add(keyfile);\n                }\n            }\n\n            savePrefs();\n\n            cursor.close();\n            helper.close();\n\n        } catch (Exception e) {\n            // If upgrading fails, we'll just give up on it.\n        }\n\n        try {\n            FileDbHelper.deleteDatabase(ctx);\n        } catch (Exception e) {\n            // If we fail to delete it, just move on\n        }\n\n        return true;\n    }\n\n    private boolean sqlDatabaseExists() {\n        File db = ctx.getDatabasePath(FileDbHelper.DATABASE_NAME);\n        return db.exists();\n    }\n\n    public void createFile(Uri uri, Uri keyUri) {\n        if (!enabled || uri == null) return;\n\n        init();\n\n        // Remove any existing instance of the same filename\n        deleteFile(uri, false);\n\n        databases.add(0, uri.toString());\n\n        String key = (keyUri == null) ? \"\" : keyUri.toString();\n        keyfiles.add(0, key);\n\n        trimLists();\n        savePrefs();\n    }\n\n    public boolean hasRecentFiles() {\n        if (!enabled) return false;\n\n        init();\n\n        return databases.size() > 0;\n    }\n\n    public String getDatabaseAt(int i) {\n        init();\n        return databases.get(i);\n    }\n\n    public String getKeyfileAt(int i) {\n        init();\n        return keyfiles.get(i);\n    }\n\n    private void loadPrefs() {\n        loadList(databases, DB_KEY);\n        loadList(keyfiles, KEYFILE_KEY);\n    }\n\n    private void savePrefs() {\n        saveList(DB_KEY, databases);\n        saveList(KEYFILE_KEY, keyfiles);\n    }\n\n    private void loadList(List<String> list, String keyprefix) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n        int size = prefs.getInt(keyprefix, 0);\n\n        list.clear();\n        for (int i = 0; i < size; i++) {\n            list.add(prefs.getString(keyprefix + \"_\" + i, \"\"));\n        }\n    }\n\n    private void saveList(String keyprefix, List<String> list) {\n        SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n        SharedPreferences.Editor edit = prefs.edit();\n        int size = list.size();\n        edit.putInt(keyprefix, size);\n\n        for (int i = 0; i < size; i++) {\n            edit.putString(keyprefix + \"_\" + i, list.get(i));\n        }\n        EditorCompat.apply(edit);\n    }\n\n    public void deleteFile(Uri uri) {\n        deleteFile(uri, true);\n    }\n\n    public void deleteFile(Uri uri, boolean save) {\n        init();\n\n        String uriName = uri.toString();\n        String fileName = uri.getPath();\n\n        for (int i = 0; i < databases.size(); i++) {\n            String entry = databases.get(i);\n            if (uriName.equals(entry) || fileName.equals(entry)) {\n                databases.remove(i);\n                keyfiles.remove(i);\n                break;\n            }\n        }\n\n        if (save) {\n            savePrefs();\n        }\n    }\n\n    public List<String> getDbList() {\n        init();\n\n        return databases;\n    }\n\n    public Uri getFileByName(Uri database) {\n        if (!enabled) return null;\n\n        init();\n\n        int size = databases.size();\n        for (int i = 0; i < size; i++) {\n            if (UriUtil.equalsDefaultfile(database,databases.get(i))) {\n                return UriUtil.parseDefaultFile(keyfiles.get(i));\n            }\n        }\n\n        return null;\n    }\n\n    public void deleteAll() {\n        init();\n\n        databases.clear();\n        keyfiles.clear();\n\n        savePrefs();\n    }\n\n    public void deleteAllKeys() {\n        init();\n\n        keyfiles.clear();\n\n        int size = databases.size();\n        for (int i = 0; i < size; i++) {\n            keyfiles.add(\"\");\n        }\n\n        savePrefs();\n    }\n\n    private void trimLists() {\n        int size = databases.size();\n        for (int i = FileDbHelper.MAX_FILES; i < size; i++) {\n            databases.remove(i);\n            keyfiles.remove(i);\n        }\n    }\n}\n","lineNo":139}
{"Smelly Sample":"/*\n * Copyright 2009-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.tests.database;\n\nimport java.io.InputStream;\n\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.net.Uri;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3Debug;\nimport com.keepassdroid.database.load.Importer;\n\npublic class TestData {\n\tprivate static final String TEST1_KEYFILE = \"\";\n\tprivate static final String TEST1_KDB = \"test1.kdb\";\n\tprivate static final String TEST1_PASSWORD = \"12345\";\n\n\tprivate static Database mDb1;\n\n\t\n\tpublic static Database GetDb1(Context ctx) throws Exception {\n\t\treturn GetDb1(ctx, false);\n\t}\n\t\n\tpublic static Database GetDb1(Context ctx, boolean forceReload) throws Exception {\n\t\tif ( mDb1 == null || forceReload ) {\n\t\t\tmDb1 = GetDb(ctx, TEST1_KDB, TEST1_PASSWORD, TEST1_KEYFILE, \"/sdcard/test1.kdb\");\n\t\t}\n\t\t\n\t\treturn mDb1;\n\t}\n\t\n\tpublic static Database GetDb(Context ctx, String asset, String password, String keyfile, String filename) throws Exception {\n\t\tAssetManager am = ctx.getAssets();\n\t\tInputStream is = am.open(asset, AssetManager.ACCESS_STREAMING);\n\n\t\tDatabase Db = new Database();\n\t\tDb.LoadData(ctx, is, password, keyfile, Importer.DEBUG);\n\t\tUri.Builder b = new Uri.Builder();\n\n\t\tDb.mUri = b.scheme(\"file\").path(filename).build();\n\t\t\n\t\treturn Db;\n\t\t\n\t}\n\t\n\tpublic static PwDatabaseV3Debug GetTest1(Context ctx) throws Exception {\n\t\tif ( mDb1 == null ) {\n\t\t\tGetDb1(ctx);\n\t\t}\n\t\t\n\t\treturn (PwDatabaseV3Debug) mDb1.pm;\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.tests.database;\n\nimport java.io.InputStream;\n\nimport android.content.Context;\nimport android.content.res.AssetManager;\nimport android.net.Uri;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3Debug;\nimport com.keepassdroid.database.load.Importer;\nimport com.keepassdroid.tests.TestUtil;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.UriUtil;\n\npublic class TestData {\n\tprivate static final String TEST1_KEYFILE = \"\";\n\tprivate static final String TEST1_KDB = \"test1.kdb\";\n\tprivate static final String TEST1_PASSWORD = \"12345\";\n\n\tprivate static Database mDb1;\n\n\t\n\tpublic static Database GetDb1(Context ctx) throws Exception {\n\t\treturn GetDb1(ctx, false);\n\t}\n\t\n\tpublic static Database GetDb1(Context ctx, boolean forceReload) throws Exception {\n\t\tif ( mDb1 == null || forceReload ) {\n\t\t\tmDb1 = GetDb(ctx, TEST1_KDB, TEST1_PASSWORD, TEST1_KEYFILE, \"/sdcard/test1.kdb\");\n\t\t}\n\t\t\n\t\treturn mDb1;\n\t}\n\t\n\tpublic static Database GetDb(Context ctx, String asset, String password, String keyfile, String filename) throws Exception {\n\t\tAssetManager am = ctx.getAssets();\n\t\tInputStream is = am.open(asset, AssetManager.ACCESS_STREAMING);\n\n\t\tDatabase Db = new Database();\n\n\t\tInputStream keyIs = TestUtil.getKeyFileInputStream(ctx, keyfile);\n\n\t\tDb.LoadData(ctx, is, password, keyIs, Importer.DEBUG);\n\t\tUri.Builder b = new Uri.Builder();\n\n\t\tDb.mUri = b.scheme(\"file\").path(filename).build();\n\t\t\n\t\treturn Db;\n\t\t\n\t}\n\t\n\tpublic static PwDatabaseV3Debug GetTest1(Context ctx) throws Exception {\n\t\tif ( mDb1 == null ) {\n\t\t\tGetDb1(ctx);\n\t\t}\n\t\t\n\t\treturn (PwDatabaseV3Debug) mDb1.pm;\n\t}\n}\n","lineNo":61}
{"Smelly Sample":"/*\n * Copyright 2009-2015 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SyncFailedException;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport android.content.Context;\nimport android.net.Uri;\n\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.load.Importer;\nimport com.keepassdroid.database.load.ImporterFactory;\nimport com.keepassdroid.database.save.PwDbOutput;\nimport com.keepassdroid.icons.DrawableFactory;\nimport com.keepassdroid.search.SearchDbHelper;\n\n/**\n * @author bpellin\n */\npublic class Database {\n    public Set<PwGroup> dirty = new HashSet<PwGroup>();\n    public PwDatabase pm;\n    public Uri mUri;\n    public SearchDbHelper searchHelper;\n    public boolean readOnly = false;\n    public boolean passwordEncodingError = false;\n\n    public DrawableFactory drawFactory = new DrawableFactory();\n\n    private boolean loaded = false;\n\n    public boolean Loaded() {\n        return loaded;\n    }\n\n    public void setLoaded() {\n        loaded = true;\n    }\n\n    public void LoadData(Context ctx, InputStream is, String password, String keyfile) throws IOException, InvalidDBException {\n        LoadData(ctx, is, password, keyfile, new UpdateStatus(), !Importer.DEBUG);\n    }\n\n    public void LoadData(Context ctx, Uri uri, String password, String keyfile) throws IOException, FileNotFoundException, InvalidDBException {\n        LoadData(ctx, uri, password, keyfile, new UpdateStatus(), !Importer.DEBUG);\n    }\n\n    public void LoadData(Context ctx, Uri uri, String password, String keyfile, UpdateStatus status) throws IOException, FileNotFoundException, InvalidDBException {\n        LoadData(ctx, uri, password, keyfile, status, !Importer.DEBUG);\n    }\n\n    public void LoadData(Context ctx, Uri uri, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, FileNotFoundException, InvalidDBException {\n        mUri = uri;\n        readOnly = false;\n        if (uri.getScheme().equals(\"file\")) {\n            File file = new File(uri.getPath());\n            readOnly = !file.canWrite();\n        }\n\n        InputStream is = ctx.getContentResolver().openInputStream(uri);\n\n        LoadData(ctx, is, password, keyfile, status, debug);\n    }\n\n    public void LoadData(Context ctx, InputStream is, String password, String keyfile, boolean debug) throws IOException, InvalidDBException {\n        LoadData(ctx, is, password, keyfile, new UpdateStatus(), debug);\n    }\n\n    public void LoadData(Context ctx, InputStream is, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, InvalidDBException {\n\n        BufferedInputStream bis = new BufferedInputStream(is);\n\n        if ( ! bis.markSupported() ) {\n            throw new IOException(\"Input stream does not support mark.\");\n        }\n\n        // We'll end up reading 8 bytes to identify the header. Might as well use two extra.\n        bis.mark(10);\n\n        Importer imp = ImporterFactory.createImporter(bis, debug);\n\n        bis.reset();  // Return to the start\n\n        pm = imp.openDatabase(bis, password, keyfile, status);\n        if ( pm != null ) {\n            PwGroup root = pm.rootGroup;\n\n            pm.populateGlobals(root);\n\n            LoadData(ctx, pm, password, keyfile, status);\n        }\n\n        loaded = true;\n    }\n\n    public void LoadData(Context ctx, PwDatabase pm, String password, String keyfile, UpdateStatus status) {\n        if ( pm != null ) {\n            passwordEncodingError = !pm.validatePasswordEncoding(password);\n        }\n\n        searchHelper = new SearchDbHelper(ctx);\n\n        loaded = true;\n    }\n\n    public PwGroup Search(String str) {\n        if (searchHelper == null) { return null; }\n\n        PwGroup group = searchHelper.search(this, str);\n\n        return group;\n\n    }\n\n    public void SaveData(Context ctx) throws IOException, PwDbOutputException {\n        SaveData(ctx, mUri);\n    }\n\n    public void SaveData(Context ctx, Uri uri) throws IOException, PwDbOutputException {\n        if (uri.getScheme().equals(\"data\")) {\n            String filename = uri.getPath();\n            File tempFile = new File(filename + \".tmp\");\n            FileOutputStream fos = new FileOutputStream(tempFile);\n            //BufferedOutputStream bos = new BufferedOutputStream(fos);\n\n            //PwDbV3Output pmo = new PwDbV3Output(pm, bos, App.getCalendar());\n            PwDbOutput pmo = PwDbOutput.getInstance(pm, fos);\n            pmo.output();\n            //bos.flush();\n            //bos.close();\n            fos.close();\n\n            // Force data to disk before continuing\n            try {\n                fos.getFD().sync();\n            } catch (SyncFailedException e) {\n                // Ignore if fsync fails. We tried.\n            }\n\n            File orig = new File(filename);\n\n            if (!tempFile.renameTo(orig)) {\n                throw new IOException(\"Failed to store database.\");\n            }\n        }\n        else {\n            OutputStream os;\n            try {\n                os = ctx.getContentResolver().openOutputStream(uri);\n            } catch (Exception e) {\n                throw new IOException(\"Failed to store database.\");\n            }\n\n            PwDbOutput pmo = PwDbOutput.getInstance(pm, os);\n            pmo.output();\n            os.close();\n        }\n\n        mUri = uri;\n\n    }\n\n    public void clear() {\n        dirty.clear();\n        drawFactory.clear();\n\n        pm = null;\n        mUri = null;\n        loaded = false;\n        passwordEncodingError = false;\n    }\n\n    public void markAllGroupsAsDirty() {\n        for ( PwGroup group : pm.getGroups() ) {\n            dirty.add(group);\n        }\n\n        // TODO: This should probably be abstracted out\n        // The root group in v3 is not an 'official' group\n        if ( pm instanceof PwDatabaseV3 ) {\n            dirty.add(pm.rootGroup);\n        }\n    }\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2015 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SyncFailedException;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.net.Uri;\n\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.load.Importer;\nimport com.keepassdroid.database.load.ImporterFactory;\nimport com.keepassdroid.database.save.PwDbOutput;\nimport com.keepassdroid.icons.DrawableFactory;\nimport com.keepassdroid.search.SearchDbHelper;\nimport com.keepassdroid.utils.UriUtil;\n\n/**\n * @author bpellin\n */\npublic class Database {\n    public Set<PwGroup> dirty = new HashSet<PwGroup>();\n    public PwDatabase pm;\n    public Uri mUri;\n    public SearchDbHelper searchHelper;\n    public boolean readOnly = false;\n    public boolean passwordEncodingError = false;\n\n    public DrawableFactory drawFactory = new DrawableFactory();\n\n    private boolean loaded = false;\n\n    public boolean Loaded() {\n        return loaded;\n    }\n\n    public void setLoaded() {\n        loaded = true;\n    }\n\n    public void LoadData(Context ctx, InputStream is, String password, InputStream keyInputStream) throws IOException, InvalidDBException {\n        LoadData(ctx, is, password, keyInputStream, new UpdateStatus(), !Importer.DEBUG);\n    }\n\n    public void LoadData(Context ctx, Uri uri, String password, Uri keyfile) throws IOException, FileNotFoundException, InvalidDBException {\n        LoadData(ctx, uri, password, keyfile, new UpdateStatus(), !Importer.DEBUG);\n    }\n\n    public void LoadData(Context ctx, Uri uri, String password, Uri keyfile, UpdateStatus status) throws IOException, FileNotFoundException, InvalidDBException {\n        LoadData(ctx, uri, password, keyfile, status, !Importer.DEBUG);\n    }\n\n    public void LoadData(Context ctx, Uri uri, String password, Uri keyfile, UpdateStatus status, boolean debug) throws IOException, FileNotFoundException, InvalidDBException {\n        mUri = uri;\n        readOnly = false;\n        if (uri.getScheme().equals(\"file\")) {\n            File file = new File(uri.getPath());\n            readOnly = !file.canWrite();\n        }\n\n        InputStream is = UriUtil.getUriInputStream(ctx, uri);\n        InputStream kfIs = UriUtil.getUriInputStream(ctx, keyfile);\n\n        LoadData(ctx, is, password, kfIs, status, debug);\n    }\n\n    public void LoadData(Context ctx, InputStream is, String password, InputStream kfIs, boolean debug) throws IOException, InvalidDBException {\n        LoadData(ctx, is, password, kfIs, new UpdateStatus(), debug);\n    }\n\n    public void LoadData(Context ctx, InputStream is, String password, InputStream kfIs, UpdateStatus status, boolean debug) throws IOException, InvalidDBException {\n\n        BufferedInputStream bis = new BufferedInputStream(is);\n\n        if ( ! bis.markSupported() ) {\n            throw new IOException(\"Input stream does not support mark.\");\n        }\n\n        // We'll end up reading 8 bytes to identify the header. Might as well use two extra.\n        bis.mark(10);\n\n        Importer imp = ImporterFactory.createImporter(bis, debug);\n\n        bis.reset();  // Return to the start\n\n        pm = imp.openDatabase(bis, password, kfIs, status);\n        if ( pm != null ) {\n            PwGroup root = pm.rootGroup;\n\n            pm.populateGlobals(root);\n\n            LoadData(ctx, pm, password, kfIs, status);\n        }\n\n        loaded = true;\n    }\n\n    public void LoadData(Context ctx, PwDatabase pm, String password, InputStream keyInputStream, UpdateStatus status) {\n        if ( pm != null ) {\n            passwordEncodingError = !pm.validatePasswordEncoding(password);\n        }\n\n        searchHelper = new SearchDbHelper(ctx);\n\n        loaded = true;\n    }\n\n    public PwGroup Search(String str) {\n        if (searchHelper == null) { return null; }\n\n        PwGroup group = searchHelper.search(this, str);\n\n        return group;\n\n    }\n\n    public void SaveData(Context ctx) throws IOException, PwDbOutputException {\n        SaveData(ctx, mUri);\n    }\n\n    public void SaveData(Context ctx, Uri uri) throws IOException, PwDbOutputException {\n        if (uri.getScheme().equals(\"file\")) {\n            String filename = uri.getPath();\n            File tempFile = new File(filename + \".tmp\");\n            FileOutputStream fos = new FileOutputStream(tempFile);\n            //BufferedOutputStream bos = new BufferedOutputStream(fos);\n\n            //PwDbV3Output pmo = new PwDbV3Output(pm, bos, App.getCalendar());\n            PwDbOutput pmo = PwDbOutput.getInstance(pm, fos);\n            pmo.output();\n            //bos.flush();\n            //bos.close();\n            fos.close();\n\n            // Force data to disk before continuing\n            try {\n                fos.getFD().sync();\n            } catch (SyncFailedException e) {\n                // Ignore if fsync fails. We tried.\n            }\n\n            File orig = new File(filename);\n\n            if (!tempFile.renameTo(orig)) {\n                throw new IOException(\"Failed to store database.\");\n            }\n        }\n        else {\n            OutputStream os;\n            try {\n                os = ctx.getContentResolver().openOutputStream(uri);\n            } catch (Exception e) {\n                throw new IOException(\"Failed to store database.\");\n            }\n\n            PwDbOutput pmo = PwDbOutput.getInstance(pm, os);\n            pmo.output();\n            os.close();\n        }\n\n        mUri = uri;\n\n    }\n\n    public void clear() {\n        dirty.clear();\n        drawFactory.clear();\n\n        pm = null;\n        mUri = null;\n        loaded = false;\n        passwordEncodingError = false;\n    }\n\n    public void markAllGroupsAsDirty() {\n        for ( PwGroup group : pm.getGroups() ) {\n            dirty.add(group);\n        }\n\n        // TODO: This should probably be abstracted out\n        // The root group in v3 is not an 'official' group\n        if ( pm instanceof PwDatabaseV3 ) {\n            dirty.add(pm.rootGroup);\n        }\n    }\n\n}\n","lineNo":94}
{"Smelly Sample":"/*\n * Copyright 2009-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.edit;\n\nimport java.io.IOException;\n\nimport android.content.Context;\nimport android.content.DialogInterface;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.dialog.PasswordEncodingDialogHelper;\n\npublic class SetPassword extends RunnableOnFinish {\n\t\n\tprivate String mPassword;\n\tprivate String mKeyfile;\n\tprivate Database mDb;\n\tprivate boolean mDontSave;\n\tprivate Context ctx;\n\t\n\tpublic SetPassword(Context ctx, Database db, String password, String keyfile, OnFinish finish) {\n\t\tthis(ctx, db, password, keyfile, finish, false);\n\t\t\n\t}\n\n\tpublic SetPassword(Context ctx, Database db, String password, String keyfile, OnFinish finish, boolean dontSave) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmPassword = password;\n\t\tmKeyfile = keyfile;\n\t\tmDontSave = dontSave;\n\t\tthis.ctx = ctx;\n\t}\n\t\n\tpublic boolean validatePassword(Context ctx, DialogInterface.OnClickListener onclick) {\n\t\tif (!mDb.pm.validatePasswordEncoding(mPassword)) {\n\t\t\tPasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper();\n\t\t\tdialog.show(ctx, onclick, true);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tPwDatabase pm = mDb.pm;\n\t\t\n\t\tbyte[] backupKey = new byte[pm.masterKey.length];\n\t\tSystem.arraycopy(pm.masterKey, 0, backupKey, 0, backupKey.length);\n\n\t\t// Set key\n\t\ttry {\n\t\t\tpm.setMasterKey(mPassword, mKeyfile);\n\t\t} catch (InvalidKeyFileException e) {\n\t\t\terase(backupKey);\n\t\t\tfinish(false, e.getMessage());\n\t\t\treturn;\n\t\t} catch (IOException e) {\n\t\t\terase(backupKey);\n\t\t\tfinish(false, e.getMessage());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Save Database\n\t\tmFinish = new AfterSave(backupKey, mFinish);\n\t\tSaveDB save = new SaveDB(ctx, mDb, mFinish, mDontSave);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterSave extends OnFinish {\n\t\tprivate byte[] mBackup;\n\t\t\n\t\tpublic AfterSave(byte[] backup, OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t\t\n\t\t\tmBackup = backup;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( ! mSuccess ) {\n\t\t\t\t// Erase the current master key\n\t\t\t\terase(mDb.pm.masterKey);\n\t\t\t\tmDb.pm.masterKey = mBackup;\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\n\t}\n\t\n\t/** Overwrite the array as soon as we don't need it to avoid keeping the extra data in memory\n\t * @param array\n\t */\n\tprivate void erase(byte[] array) {\n\t\tif ( array == null ) return;\n\t\t\n\t\tfor ( int i = 0; i < array.length; i++ ) {\n\t\t\tarray[i] = 0;\n\t\t}\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2016 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.edit;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.net.Uri;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.dialog.PasswordEncodingDialogHelper;\nimport com.keepassdroid.utils.UriUtil;\n\npublic class SetPassword extends RunnableOnFinish {\n\t\n\tprivate String mPassword;\n\tprivate Uri mKeyfile;\n\tprivate Database mDb;\n\tprivate boolean mDontSave;\n\tprivate Context ctx;\n\t\n\tpublic SetPassword(Context ctx, Database db, String password, Uri keyfile, OnFinish finish) {\n\t\tthis(ctx, db, password, keyfile, finish, false);\n\t\t\n\t}\n\n\tpublic SetPassword(Context ctx, Database db, String password, Uri keyfile, OnFinish finish, boolean dontSave) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmPassword = password;\n\t\tmKeyfile = keyfile;\n\t\tmDontSave = dontSave;\n\t\tthis.ctx = ctx;\n\t}\n\t\n\tpublic boolean validatePassword(Context ctx, DialogInterface.OnClickListener onclick) {\n\t\tif (!mDb.pm.validatePasswordEncoding(mPassword)) {\n\t\t\tPasswordEncodingDialogHelper dialog = new PasswordEncodingDialogHelper();\n\t\t\tdialog.show(ctx, onclick, true);\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tPwDatabase pm = mDb.pm;\n\t\t\n\t\tbyte[] backupKey = new byte[pm.masterKey.length];\n\t\tSystem.arraycopy(pm.masterKey, 0, backupKey, 0, backupKey.length);\n\n\t\t// Set key\n\t\ttry {\n\t\t\tInputStream is = UriUtil.getUriInputStream(ctx, mKeyfile);\n\t\t\tpm.setMasterKey(mPassword, is);\n\t\t} catch (InvalidKeyFileException e) {\n\t\t\terase(backupKey);\n\t\t\tfinish(false, e.getMessage());\n\t\t\treturn;\n\t\t} catch (IOException e) {\n\t\t\terase(backupKey);\n\t\t\tfinish(false, e.getMessage());\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Save Database\n\t\tmFinish = new AfterSave(backupKey, mFinish);\n\t\tSaveDB save = new SaveDB(ctx, mDb, mFinish, mDontSave);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterSave extends OnFinish {\n\t\tprivate byte[] mBackup;\n\t\t\n\t\tpublic AfterSave(byte[] backup, OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t\t\n\t\t\tmBackup = backup;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( ! mSuccess ) {\n\t\t\t\t// Erase the current master key\n\t\t\t\terase(mDb.pm.masterKey);\n\t\t\t\tmDb.pm.masterKey = mBackup;\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\n\t}\n\t\n\t/** Overwrite the array as soon as we don't need it to avoid keeping the extra data in memory\n\t * @param array\n\t */\n\tprivate void erase(byte[] array) {\n\t\tif ( array == null ) return;\n\t\t\n\t\tfor ( int i = 0; i < array.length; i++ ) {\n\t\t\tarray[i] = 0;\n\t\t}\n\t}\n\n}\n","lineNo":77}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport com.keepassdroid.database.exception.SamsungClipboardException;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.text.ClipboardManager;\nimport android.widget.TextView;\n\npublic class Util {\n\tpublic static String getClipboard(Context context) {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\treturn clipboard.getText().toString();\n\t}\n\t\n\tpublic static void copyToClipboard(Context context, String text) throws SamsungClipboardException {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\t\n\t\ttry {\n\t\t\tclipboard.setText(text);\n\t\t} catch (NullPointerException e) {\n\t\t\tthrow new SamsungClipboardException(e);\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, String url) throws ActivityNotFoundException {\n\t\tif ( url != null && url.length() > 0 ) {\n\t\t\tUri uri = Uri.parse(url);\n\t\t\tcontext.startActivity(new Intent(Intent.ACTION_VIEW, uri));\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, int resId) throws ActivityNotFoundException {\n\t\tgotoUrl(context, context.getString(resId));\n\t}\n\n\tpublic static String getEditText(Activity act, int resId) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tpublic static void setEditText(Activity act, int resId, String str) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\t\n\tpublic static void copyStream(InputStream in, OutputStream out) throws IOException {\n\t\tbyte[] buf = new byte[1024];\n\t\tint read;\n\t\twhile ((read = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, read);\n\t\t}\n\t}\n\n\t\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2015 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.utils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\n\nimport com.keepassdroid.database.exception.SamsungClipboardException;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.text.ClipboardManager;\nimport android.widget.TextView;\n\npublic class Util {\n\tpublic static String getClipboard(Context context) {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\tCharSequence csText = clipboard.getText();\n\t\tif (csText == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\treturn csText.toString();\n\t}\n\t\n\tpublic static void copyToClipboard(Context context, String text) throws SamsungClipboardException {\n\t\tClipboardManager clipboard = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);\n\t\t\n\t\ttry {\n\t\t\tclipboard.setText(text);\n\t\t} catch (NullPointerException e) {\n\t\t\tthrow new SamsungClipboardException(e);\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, String url) throws ActivityNotFoundException {\n\t\tif ( url != null && url.length() > 0 ) {\n\t\t\tUri uri = Uri.parse(url);\n\t\t\tcontext.startActivity(new Intent(Intent.ACTION_VIEW, uri));\n\t\t}\n\t}\n\t\n\tpublic static void gotoUrl(Context context, int resId) throws ActivityNotFoundException {\n\t\tgotoUrl(context, context.getString(resId));\n\t}\n\n\tpublic static String getEditText(Activity act, int resId) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tpublic static void setEditText(Activity act, int resId, String str) {\n\t\tTextView te =  (TextView) act.findViewById(resId);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\t\n\tpublic static void copyStream(InputStream in, OutputStream out) throws IOException {\n\t\tbyte[] buf = new byte[1024];\n\t\tint read;\n\t\twhile ((read = in.read(buf)) != -1) {\n\t\t\tout.write(buf, 0, read);\n\t\t}\n\t}\n\n\t\n\t\n}\n","lineNo":39}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.UUID;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.text.SpannableString;\nimport android.text.method.LinkMovementMethod;\nimport android.text.method.PasswordTransformationMethod;\nimport android.text.util.Linkify;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.compat.ActivityCompat;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.exception.SamsungClipboardException;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.Types;\nimport com.keepassdroid.utils.Util;\n\npublic class EntryActivity extends LockCloseActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_REFRESH_POS = \"refresh_pos\";\n\n\tpublic static final int NOTIFY_USERNAME = 1;\n\tpublic static final int NOTIFY_PASSWORD = 2;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw, int pos) {\n\t\tIntent i;\n\t\t\n\t\tif ( pw instanceof PwEntryV4 ) {\n\t\t\ti = new Intent(act, EntryActivityV4.class);\n\t\t} else {\n\t\t\ti = new Intent(act, EntryActivity.class);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_ENTRY, Types.UUIDtoBytes(pw.getUUID()));\n\t\ti.putExtra(KEY_REFRESH_POS, pos);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\tprotected PwEntry mEntry;\n\tprivate Timer mTimer = new Timer();\n\tprivate boolean mShowPassword;\n\tprivate int mPos;\n\tprivate NotificationManager mNM;\n\tprivate BroadcastReceiver mIntentReceiver;\n\t\n\tprivate DateFormat dateFormat;\n\tprivate DateFormat timeFormat;\n\t\n\tprotected void setEntryView() {\n\t\tsetContentView(R.layout.entry_view);\n\t}\n\t\n\tprotected void setupEditButtons() {\n\t\tButton edit = (Button) findViewById(R.id.entry_edit);\n\t\tedit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity.Launch(EntryActivity.this, mEntry);\n\t\t\t}\n\t\t\t\n\t\t});\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tmShowPassword = ! prefs.getBoolean(getString(R.string.maskpass_key), getResources().getBoolean(R.bool.maskpass_default));\n\t\t\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetEntryView();\n\t\t\n\t\tContext appCtx = getApplicationContext();\n\t\tdateFormat = android.text.format.DateFormat.getDateFormat(appCtx);\n\t\ttimeFormat = android.text.format.DateFormat.getTimeFormat(appCtx);\n\n\t\tDatabase db = App.getDB();\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( ! db.Loaded() ) {\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\n\t\tIntent i = getIntent();\n\t\tUUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));\n\t\tmPos = i.getIntExtra(KEY_REFRESH_POS, -1);\n\t\tassert(uuid != null);\n\t\t\n\t\tmEntry = db.pm.entries.get(uuid);\n\t\tif (mEntry == null) {\n\t\t\tToast.makeText(this, R.string.entry_not_found, Toast.LENGTH_LONG).show();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Refresh Menu contents in case onCreateMenuOptions was called before mEntry was set\n\t\tActivityCompat.invalidateOptionsMenu(this);\n\t\t\n\t\t// Update last access time.\n\t\tmEntry.touch(false, false);\n\t\t\n\t\tfillData(false);\n\n\t\tsetupEditButtons();\n\t\t\n\t\t// Notification Manager\n\t\tmNM = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\t\n\t\tif ( mEntry.getPassword().length() > 0 ) {\n\t\t\t// only show notification if password is available\n\t\t\tNotification password = getNotification(Intents.COPY_PASSWORD, R.string.copy_password);\n\t\t\tmNM.notify(NOTIFY_PASSWORD, password);\n\t\t}\n\t\t\n\t\tif ( mEntry.getUsername().length() > 0 ) {\n\t\t\t// only show notification if username is available\n\t\t\tNotification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);\n\t\t\tmNM.notify(NOTIFY_USERNAME, username);\n\t\t}\n\t\t\t\n\t\tmIntentReceiver = new BroadcastReceiver() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\tString action = intent.getAction();\n\n\t\t\t\tif ( action.equals(Intents.COPY_USERNAME) ) {\n\t\t\t\t\tString username = mEntry.getUsername();\n\t\t\t\t\tif ( username.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(username);\n\t\t\t\t\t}\n\t\t\t\t} else if ( action.equals(Intents.COPY_PASSWORD) ) {\n\t\t\t\t\tString password = new String(mEntry.getPassword());\n\t\t\t\t\tif ( password.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(new String(mEntry.getPassword()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tIntentFilter filter = new IntentFilter();\n\t\tfilter.addAction(Intents.COPY_USERNAME);\n\t\tfilter.addAction(Intents.COPY_PASSWORD);\n\t\tregisterReceiver(mIntentReceiver, filter);\n\t}\n\t\n\t@Override\n\tprotected void onDestroy() {\n\t\t// These members might never get initialized if the app timed out\n\t\tif ( mIntentReceiver != null ) {\n\t\t\tunregisterReceiver(mIntentReceiver);\n\t\t}\n\t\t\n\t\tif ( mNM != null ) {\n\t\t\tmNM.cancelAll();\n\t\t}\n\t\t\n\t\tsuper.onDestroy();\n\t}\n\n\tprivate Notification getNotification(String intentText, int descResId) {\n\t\tString desc = getString(descResId);\n\t\tNotification notify = new Notification(R.drawable.notify, desc, System.currentTimeMillis());\n\t\t\n\t\tIntent intent = new Intent(intentText);\n\t\tPendingIntent pending = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n\t\t\n\t\tnotify.setLatestEventInfo(this, getString(R.string.app_name), desc, pending);\n\t\t\n\t\treturn notify;\n\t}\n\t\n\tprivate String getDateTime(Date dt) {\n\t\treturn dateFormat.format(dt) + \" \" + timeFormat.format(dt);\n\t\t\n\t}\n\t\n\tprotected void fillData(boolean trimList) {\n\t\tImageView iv = (ImageView) findViewById(R.id.entry_icon);\n\t\tApp.getDB().drawFactory.assignDrawableTo(iv, getResources(), mEntry.getIcon());\n\n\t\tpopulateText(R.id.entry_title, mEntry.getTitle());\n\t\tpopulateText(R.id.entry_user_name, mEntry.getUsername());\n\t\t\n\t\tpopulateText(R.id.entry_url, mEntry.getUrl());\n\t\tpopulateText(R.id.entry_password, mEntry.getPassword());\n\t\tsetPasswordStyle();\n\t\t\n\t\tpopulateText(R.id.entry_created, getDateTime(mEntry.getCreationTime()));\n\t\tpopulateText(R.id.entry_modified, getDateTime(mEntry.getLastModificationTime()));\n\t\tpopulateText(R.id.entry_accessed, getDateTime(mEntry.getLastAccessTime()));\n\t\t\n\t\tDate expires = mEntry.getExpiryTime();\n\t\tif ( mEntry.expires() ) {\n\t\t\tpopulateText(R.id.entry_expires, getDateTime(expires));\n\t\t} else {\n\t\t\tpopulateText(R.id.entry_expires, R.string.never);\n\t\t}\n\t\tpopulateText(R.id.entry_comment, mEntry.getNotes());\n\n\t}\n\t\n\tprivate void populateText(int viewId, int resId) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(resId);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\tfillData(true);\n\t\t\tif ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\t\tIntent ret = new Intent();\n\t\t\t\tret.putExtra(KEY_REFRESH_POS, mPos);\n\t\t\t\tsetResult(KeePass.EXIT_REFRESH, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.entry, menu);\n\t\t\n\t\tMenuItem togglePassword = menu.findItem(R.id.menu_toggle_pass);\n\t\tif ( mShowPassword ) {\n\t\t\ttogglePassword.setTitle(R.string.menu_hide_password);\n\t\t} else {\n\t\t\ttogglePassword.setTitle(R.string.show_password);\n\t\t}\n\t\t\n\t\tMenuItem gotoUrl = menu.findItem(R.id.menu_goto_url);\n\t\tMenuItem copyUser = menu.findItem(R.id.menu_copy_user);\n\t\tMenuItem copyPass = menu.findItem(R.id.menu_copy_pass);\n\t\t\n\t\t// In API >= 11 onCreateOptionsMenu may be called before onCreate completes\n\t\t// so mEntry may not be set\n\t\tif (mEntry == null) {\n\t\t\tgotoUrl.setVisible(false);\n\t\t\tcopyUser.setVisible(false);\n\t\t\tcopyPass.setVisible(false);\n\t\t}\n\t\telse {\n\t\t\tString url = mEntry.getUrl();\n\t\t\tif (EmptyUtils.isNullOrEmpty(url)) {\n\t\t\t\t// disable button if url is not available\n\t\t\t\tgotoUrl.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getUsername().length() == 0 ) {\n\t\t\t\t// disable button if username is not available\n\t\t\t\tcopyUser.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getPassword().length() == 0 ) {\n\t\t\t\t// disable button if password is not available\n\t\t\t\tcopyPass.setVisible(false);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t} else {\n\t\t\tpassword.setTransformationMethod(PasswordTransformationMethod.getInstance());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase R.id.menu_donate:\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, R.string.donate_url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\tcase R.id.menu_toggle_pass:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.show_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_goto_url:\n\t\t\tString url;\n\t\t\turl = mEntry.getUrl();\n\t\t\t\n\t\t\t// Default http:// if no protocol specified\n\t\t\tif ( ! url.contains(\"://\") ) {\n\t\t\t\turl = \"http://\" + url;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.no_url_handler, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_user:\n\t\t\ttimeoutCopyToClipboard(mEntry.getUsername());\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_pass:\n\t\t\ttimeoutCopyToClipboard(new String(mEntry.getPassword()));\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_lock:\n\t\t\tApp.setShutdown();\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void timeoutCopyToClipboard(String text) {\n\t\ttry {\n\t\t\tUtil.copyToClipboard(this, text);\n\t\t} catch (SamsungClipboardException e) {\n\t\t\tshowSamsungDialog();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tString sClipClear = prefs.getString(getString(R.string.clipboard_timeout_key), getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong clipClearTime = Long.parseLong(sClipClear);\n\t\t\n\t\tif ( clipClearTime > 0 ) {\n\t\t\tmTimer.schedule(new ClearClipboardTask(this, text), clipClearTime);\n\t\t}\n\t}\n\t\n\n\t// Setup to allow the toast to happen in the foreground\n\tfinal Handler uiThreadCallback = new Handler();\n\n\t// Task which clears the clipboard, and sends a toast to the foreground.\n\tprivate class ClearClipboardTask extends TimerTask {\n\t\t\n\t\tprivate final String mClearText;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tClearClipboardTask(Context ctx, String clearText) {\n\t\t\tmClearText = clearText;\n\t\t\tmCtx = ctx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tString currentClip = Util.getClipboard(mCtx);\n\t\t\t\n\t\t\tif ( currentClip.equals(mClearText) ) {\n\t\t\t\ttry {\n\t\t\t\t\tUtil.copyToClipboard(mCtx, \"\");\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));\n\t\t\t\t} catch (SamsungClipboardException e) {\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.clipboard_error_clear));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void showSamsungDialog() {\n\t\tString text = getString(R.string.clipboard_error).concat(System.getProperty(\"line.separator\")).concat(getString(R.string.clipboard_error_url));\n\t\tSpannableString s = new SpannableString(text);\n\t\tTextView tv = new TextView(this);\n\t\ttv.setText(s);\n\t\ttv.setAutoLinkMask(RESULT_OK);\n\t\ttv.setMovementMethod(LinkMovementMethod.getInstance());\n\t\tLinkify.addLinks(s, Linkify.WEB_URLS);\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.clipboard_error_title)\n\t\t\t.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.setView(tv)\n\t\t\t.show();\n\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.text.DateFormat;\nimport java.util.Date;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.UUID;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.text.SpannableString;\nimport android.text.method.LinkMovementMethod;\nimport android.text.method.PasswordTransformationMethod;\nimport android.text.util.Linkify;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.ImageView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.compat.ActivityCompat;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.exception.SamsungClipboardException;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.utils.EmptyUtils;\nimport com.keepassdroid.utils.Types;\nimport com.keepassdroid.utils.Util;\n\npublic class EntryActivity extends LockCloseActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_REFRESH_POS = \"refresh_pos\";\n\n\tpublic static final int NOTIFY_USERNAME = 1;\n\tpublic static final int NOTIFY_PASSWORD = 2;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw, int pos) {\n\t\tIntent i;\n\t\t\n\t\tif ( pw instanceof PwEntryV4 ) {\n\t\t\ti = new Intent(act, EntryActivityV4.class);\n\t\t} else {\n\t\t\ti = new Intent(act, EntryActivity.class);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_ENTRY, Types.UUIDtoBytes(pw.getUUID()));\n\t\ti.putExtra(KEY_REFRESH_POS, pos);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\tprotected PwEntry mEntry;\n\tprivate Timer mTimer = new Timer();\n\tprivate boolean mShowPassword;\n\tprivate int mPos;\n\tprivate NotificationManager mNM;\n\tprivate BroadcastReceiver mIntentReceiver;\n\t\n\tprivate DateFormat dateFormat;\n\tprivate DateFormat timeFormat;\n\t\n\tprotected void setEntryView() {\n\t\tsetContentView(R.layout.entry_view);\n\t}\n\t\n\tprotected void setupEditButtons() {\n\t\tButton edit = (Button) findViewById(R.id.entry_edit);\n\t\tedit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity.Launch(EntryActivity.this, mEntry);\n\t\t\t}\n\t\t\t\n\t\t});\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tmShowPassword = ! prefs.getBoolean(getString(R.string.maskpass_key), getResources().getBoolean(R.bool.maskpass_default));\n\t\t\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetEntryView();\n\t\t\n\t\tContext appCtx = getApplicationContext();\n\t\tdateFormat = android.text.format.DateFormat.getDateFormat(appCtx);\n\t\ttimeFormat = android.text.format.DateFormat.getTimeFormat(appCtx);\n\n\t\tDatabase db = App.getDB();\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( ! db.Loaded() ) {\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\n\t\tIntent i = getIntent();\n\t\tUUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));\n\t\tmPos = i.getIntExtra(KEY_REFRESH_POS, -1);\n\t\tassert(uuid != null);\n\t\t\n\t\tmEntry = db.pm.entries.get(uuid);\n\t\tif (mEntry == null) {\n\t\t\tToast.makeText(this, R.string.entry_not_found, Toast.LENGTH_LONG).show();\n\t\t\tfinish();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t// Refresh Menu contents in case onCreateMenuOptions was called before mEntry was set\n\t\tActivityCompat.invalidateOptionsMenu(this);\n\t\t\n\t\t// Update last access time.\n\t\tmEntry.touch(false, false);\n\t\t\n\t\tfillData(false);\n\n\t\tsetupEditButtons();\n\t\t\n\t\t// Notification Manager\n\t\tmNM = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);\n\t\t\n\t\tif ( mEntry.getPassword().length() > 0 ) {\n\t\t\t// only show notification if password is available\n\t\t\tNotification password = getNotification(Intents.COPY_PASSWORD, R.string.copy_password);\n\t\t\tmNM.notify(NOTIFY_PASSWORD, password);\n\t\t}\n\t\t\n\t\tif ( mEntry.getUsername().length() > 0 ) {\n\t\t\t// only show notification if username is available\n\t\t\tNotification username = getNotification(Intents.COPY_USERNAME, R.string.copy_username);\n\t\t\tmNM.notify(NOTIFY_USERNAME, username);\n\t\t}\n\t\t\t\n\t\tmIntentReceiver = new BroadcastReceiver() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\t\tString action = intent.getAction();\n\n\t\t\t\tif ( action.equals(Intents.COPY_USERNAME) ) {\n\t\t\t\t\tString username = mEntry.getUsername();\n\t\t\t\t\tif ( username.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(username);\n\t\t\t\t\t}\n\t\t\t\t} else if ( action.equals(Intents.COPY_PASSWORD) ) {\n\t\t\t\t\tString password = new String(mEntry.getPassword());\n\t\t\t\t\tif ( password.length() > 0 ) {\n\t\t\t\t\t\ttimeoutCopyToClipboard(new String(mEntry.getPassword()));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\t\n\t\tIntentFilter filter = new IntentFilter();\n\t\tfilter.addAction(Intents.COPY_USERNAME);\n\t\tfilter.addAction(Intents.COPY_PASSWORD);\n\t\tregisterReceiver(mIntentReceiver, filter);\n\t}\n\t\n\t@Override\n\tprotected void onDestroy() {\n\t\t// These members might never get initialized if the app timed out\n\t\tif ( mIntentReceiver != null ) {\n\t\t\tunregisterReceiver(mIntentReceiver);\n\t\t}\n\t\t\n\t\tif ( mNM != null ) {\n\t\t\tmNM.cancelAll();\n\t\t}\n\t\t\n\t\tsuper.onDestroy();\n\t}\n\n\tprivate Notification getNotification(String intentText, int descResId) {\n\t\tString desc = getString(descResId);\n\t\tNotification notify = new Notification(R.drawable.notify, desc, System.currentTimeMillis());\n\t\t\n\t\tIntent intent = new Intent(intentText);\n\t\tPendingIntent pending = PendingIntent.getBroadcast(this, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n\t\t\n\t\tnotify.setLatestEventInfo(this, getString(R.string.app_name), desc, pending);\n\t\t\n\t\treturn notify;\n\t}\n\t\n\tprivate String getDateTime(Date dt) {\n\t\treturn dateFormat.format(dt) + \" \" + timeFormat.format(dt);\n\t\t\n\t}\n\t\n\tprotected void fillData(boolean trimList) {\n\t\tImageView iv = (ImageView) findViewById(R.id.entry_icon);\n\t\tDatabase db = App.getDB();\n\t\tdb.drawFactory.assignDrawableTo(iv, getResources(), mEntry.getIcon());\n\t\t\n\t\tPwDatabase pm = db.pm;\n\n\t\tpopulateText(R.id.entry_title, mEntry.getTitle(true, pm));\n\t\tpopulateText(R.id.entry_user_name, mEntry.getUsername(true, pm));\n\t\t\n\t\tpopulateText(R.id.entry_url, mEntry.getUrl(true, pm));\n\t\tpopulateText(R.id.entry_password, mEntry.getPassword(true, pm));\n\t\tsetPasswordStyle();\n\t\t\n\t\tpopulateText(R.id.entry_created, getDateTime(mEntry.getCreationTime()));\n\t\tpopulateText(R.id.entry_modified, getDateTime(mEntry.getLastModificationTime()));\n\t\tpopulateText(R.id.entry_accessed, getDateTime(mEntry.getLastAccessTime()));\n\t\t\n\t\tDate expires = mEntry.getExpiryTime();\n\t\tif ( mEntry.expires() ) {\n\t\t\tpopulateText(R.id.entry_expires, getDateTime(expires));\n\t\t} else {\n\t\t\tpopulateText(R.id.entry_expires, R.string.never);\n\t\t}\n\t\tpopulateText(R.id.entry_comment, mEntry.getNotes(true, pm));\n\n\t}\n\t\n\tprivate void populateText(int viewId, int resId) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(resId);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\tfillData(true);\n\t\t\tif ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\t\tIntent ret = new Intent();\n\t\t\t\tret.putExtra(KEY_REFRESH_POS, mPos);\n\t\t\t\tsetResult(KeePass.EXIT_REFRESH, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.entry, menu);\n\t\t\n\t\tMenuItem togglePassword = menu.findItem(R.id.menu_toggle_pass);\n\t\tif ( mShowPassword ) {\n\t\t\ttogglePassword.setTitle(R.string.menu_hide_password);\n\t\t} else {\n\t\t\ttogglePassword.setTitle(R.string.show_password);\n\t\t}\n\t\t\n\t\tMenuItem gotoUrl = menu.findItem(R.id.menu_goto_url);\n\t\tMenuItem copyUser = menu.findItem(R.id.menu_copy_user);\n\t\tMenuItem copyPass = menu.findItem(R.id.menu_copy_pass);\n\t\t\n\t\t// In API >= 11 onCreateOptionsMenu may be called before onCreate completes\n\t\t// so mEntry may not be set\n\t\tif (mEntry == null) {\n\t\t\tgotoUrl.setVisible(false);\n\t\t\tcopyUser.setVisible(false);\n\t\t\tcopyPass.setVisible(false);\n\t\t}\n\t\telse {\n\t\t\tString url = mEntry.getUrl();\n\t\t\tif (EmptyUtils.isNullOrEmpty(url)) {\n\t\t\t\t// disable button if url is not available\n\t\t\t\tgotoUrl.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getUsername().length() == 0 ) {\n\t\t\t\t// disable button if username is not available\n\t\t\t\tcopyUser.setVisible(false);\n\t\t\t}\n\t\t\tif ( mEntry.getPassword().length() == 0 ) {\n\t\t\t\t// disable button if password is not available\n\t\t\t\tcopyPass.setVisible(false);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t} else {\n\t\t\tpassword.setTransformationMethod(PasswordTransformationMethod.getInstance());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase R.id.menu_donate:\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, R.string.donate_url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\tcase R.id.menu_toggle_pass:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.show_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_goto_url:\n\t\t\tString url;\n\t\t\turl = mEntry.getUrl();\n\t\t\t\n\t\t\t// Default http:// if no protocol specified\n\t\t\tif ( ! url.contains(\"://\") ) {\n\t\t\t\turl = \"http://\" + url;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.no_url_handler, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_user:\n\t\t\ttimeoutCopyToClipboard(mEntry.getUsername(true, App.getDB().pm));\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_copy_pass:\n\t\t\ttimeoutCopyToClipboard(new String(mEntry.getPassword(true, App.getDB().pm)));\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_lock:\n\t\t\tApp.setShutdown();\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void timeoutCopyToClipboard(String text) {\n\t\ttry {\n\t\t\tUtil.copyToClipboard(this, text);\n\t\t} catch (SamsungClipboardException e) {\n\t\t\tshowSamsungDialog();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tString sClipClear = prefs.getString(getString(R.string.clipboard_timeout_key), getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong clipClearTime = Long.parseLong(sClipClear);\n\t\t\n\t\tif ( clipClearTime > 0 ) {\n\t\t\tmTimer.schedule(new ClearClipboardTask(this, text), clipClearTime);\n\t\t}\n\t}\n\t\n\n\t// Setup to allow the toast to happen in the foreground\n\tfinal Handler uiThreadCallback = new Handler();\n\n\t// Task which clears the clipboard, and sends a toast to the foreground.\n\tprivate class ClearClipboardTask extends TimerTask {\n\t\t\n\t\tprivate final String mClearText;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tClearClipboardTask(Context ctx, String clearText) {\n\t\t\tmClearText = clearText;\n\t\t\tmCtx = ctx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tString currentClip = Util.getClipboard(mCtx);\n\t\t\t\n\t\t\tif ( currentClip.equals(mClearText) ) {\n\t\t\t\ttry {\n\t\t\t\t\tUtil.copyToClipboard(mCtx, \"\");\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));\n\t\t\t\t} catch (SamsungClipboardException e) {\n\t\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.clipboard_error_clear));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void showSamsungDialog() {\n\t\tString text = getString(R.string.clipboard_error).concat(System.getProperty(\"line.separator\")).concat(getString(R.string.clipboard_error_url));\n\t\tSpannableString s = new SpannableString(text);\n\t\tTextView tv = new TextView(this);\n\t\ttv.setText(s);\n\t\ttv.setAutoLinkMask(RESULT_OK);\n\t\ttv.setMovementMethod(LinkMovementMethod.getInstance());\n\t\tLinkify.addLinks(s, Linkify.WEB_URLS);\n\t\t\n\t\tAlertDialog.Builder builder = new AlertDialog.Builder(this);\n\t\tbuilder.setTitle(R.string.clipboard_error_title)\n\t\t\t.setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(DialogInterface dialog, int which) {\n\t\t\t\t\tdialog.dismiss();\n\t\t\t\t}\n\t\t\t})\n\t\t\t.setView(tv)\n\t\t\t.show();\n\t\t\n\t}\n}\n","lineNo":233}
{"Smelly Sample":"/*\n * Copyright 2009-2012 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n\nDerived from\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\npackage com.keepassdroid.database.load;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDate;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV3;\nimport com.keepassdroid.database.PwEncryptionAlgorithm;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.exception.InvalidAlgorithmException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.stream.NullOutputStream;\nimport com.keepassdroid.utils.Types;\n\n/**\n * Load a v3 database file.\n *\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n */\npublic class ImporterV3 extends Importer {\n\n\tpublic ImporterV3() {\n\t\tsuper();\n\t}\n\n\tprotected PwDatabaseV3 createDB() {\n\t\treturn new PwDatabaseV3();\n\t}\n\n\t/**\n\t * Load a v3 database file, return contents in a new PwDatabaseV3.\n\t * \n\t * @param infile  Existing file to load.\n\t * @param password Pass phrase for infile.\n\t * @param pRepair (unused)\n\t * @return new PwDatabaseV3 container.\n\t * \n\t * @throws IOException on any file error.\n\t * @throws InvalidKeyFileException \n\t * @throws InvalidPasswordException \n\t * @throws InvalidPasswordException on a decryption error, or possible internal bug.\n\t * @throws InvalidDBSignatureException \n\t * @throws InvalidDBVersionException \n\t * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.\n\t * @throws BadPaddingException on a decryption error, or possible internal bug.\n\t * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.\n\t * @throws NoSuchPaddingException on a decryption error, or possible internal bug.\n\t * @throws InvalidAlgorithmParameterException if error decrypting main file body. \n\t * @throws ShortBufferException if error decrypting main file body.\n\t */\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile )\n\tthrows IOException, InvalidDBException\n\t{\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile, UpdateStatus status )\n\tthrows IOException, InvalidDBException\n\t{\n\t\tPwDatabaseV3        newManager;\n\n\n\t\t// Load entire file, most of it's encrypted.\n\t\tbyte[] filebuf = new byte[(int)inStream.available()];\n\t\tinStream.read( filebuf, 0, (int)inStream.available());\n\t\tinStream.close();\n\n\t\t// Parse header (unencrypted)\n\t\tif( filebuf.length < PwDbHeaderV3.BUF_SIZE )\n\t\t\tthrow new IOException( \"File too short for header\" );\n\t\tPwDbHeaderV3 hdr = new PwDbHeaderV3();\n\t\thdr.loadFromFile(filebuf, 0 );\n\n\t\tif( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeaderV3.DBSIG_2) ) {\n\t\t\tthrow new InvalidDBSignatureException();\n\t\t}\n\n\t\tif( !hdr.matchesVersion() ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\n\t\tstatus.updateMessage(R.string.creating_db_key);\n\t\tnewManager = createDB();\n\t\tnewManager.setMasterKey( password, keyfile );\n\n\t\t// Select algorithm\n\t\tif( (hdr.flags & PwDbHeaderV3.FLAG_RIJNDAEL) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Rjindal;\n\t\t} else if( (hdr.flags & PwDbHeaderV3.FLAG_TWOFISH) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Twofish;\n\t\t} else {\n\t\t\tthrow new InvalidAlgorithmException();\n\t\t}\n\n\t\t// Copy for testing\n\t\tnewManager.copyHeader(hdr);\n\t\t\n\t\tnewManager.numKeyEncRounds = hdr.numKeyEncRounds;\n\n\t\tnewManager.name = \"KeePass Password Manager\";\n\n\t\t// Generate transformedMasterKey from masterKey\n\t\tnewManager.makeFinalKey(hdr.masterSeed, hdr.transformSeed, newManager.numKeyEncRounds);\n\n\t\tstatus.updateMessage(R.string.decrypting_db);\n\t\t// Initialize Rijndael algorithm\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tif ( newManager.algorithm == PwEncryptionAlgorithm.Rjindal ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\t\t} else if ( newManager.algorithm == PwEncryptionAlgorithm.Twofish ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"TWOFISH/CBC/PKCS7PADDING\");\n\t\t\t} else {\n\t\t\t\tthrow new IOException( \"Encryption algorithm is not supported\" );\n\t\t\t}\n\n\t\t} catch (NoSuchAlgorithmException e1) {\n\t\t\tthrow new IOException(\"No such algorithm\");\n\t\t} catch (NoSuchPaddingException e1) {\n\t\t\tthrow new IOException(\"No such pdading\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( newManager.finalKey, \"AES\" ), new IvParameterSpec( hdr.encryptionIV ) );\n\t\t} catch (InvalidKeyException e1) {\n\t\t\tthrow new IOException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e1) {\n\t\t\tthrow new IOException(\"Invalid algorithm parameter.\");\n\t\t}\n\n\t\t// Decrypt! The first bytes aren't encrypted (that's the header)\n\t\tint encryptedPartSize;\n\t\ttry {\n\t\t\tencryptedPartSize = cipher.doFinal(filebuf, PwDbHeaderV3.BUF_SIZE, filebuf.length - PwDbHeaderV3.BUF_SIZE, filebuf, PwDbHeaderV3.BUF_SIZE );\n\t\t} catch (ShortBufferException e1) {\n\t\t\tthrow new IOException(\"Buffer too short\");\n\t\t} catch (IllegalBlockSizeException e1) {\n\t\t\tthrow new IOException(\"Invalid block size\");\n\t\t} catch (BadPaddingException e1) {\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Copy decrypted data for testing\n\t\tnewManager.copyEncrypted(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 algorithm\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\tdos.write(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\t\tdos.close();\n\t\tbyte[] hash = md.digest();\n\t\t\n\t\tif( ! Arrays.equals(hash, hdr.contentsHash) ) {\n\n\t\t\tLog.w(\"KeePassDroid\",\"Database file did not decrypt correctly. (checksum code is broken)\");\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Import all groups\n\n\t\tint pos = PwDbHeaderV3.BUF_SIZE;\n\t\tPwGroupV3 newGrp = new PwGroupV3();\n\t\tfor( int i = 0; i < hdr.numGroups; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tpos += 2;\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos );\n\t\t\tpos += 4;\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewGrp.populateBlankFields(newManager);\n\t\t\t\tnewManager.groups.add(newGrp);\n\t\t\t\tnewGrp = new PwGroupV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadGroupField(newManager, newGrp, fieldType, filebuf, pos);\n\t\t\t}\n\t\t\tpos += fieldSize;\n\t\t}\n\n\t\t// Import all entries\n\t\tPwEntryV3 newEnt = new PwEntryV3();\n\t\tfor( int i = 0; i < hdr.numEntries; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos + 2 );\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewEnt.populateBlankFields(newManager);\n\t\t\t\tnewManager.entries.add(newEnt);\n\t\t\t\tnewEnt = new PwEntryV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadEntryField(newManager, newEnt, filebuf, pos);\n\t\t\t}\n\t\t\tpos += 2 + 4 + fieldSize;\n\t\t}\n\n\t\tnewManager.constructTree(null);\n\t\t\n\t\treturn newManager;\n\t}\n\n\t/**\n\t * KeePass's custom pad style.\n\t * \n\t * @param data buffer to pad.\n\t * @return addtional bytes to append to data[] to make\n\t *    a properly padded array.\n\t */\n\tpublic static byte[] makePad( byte[] data ) {\n\t\t//custom pad method\n\n\t\t// append 0x80 plus zeros to a multiple of 4 bytes\n\t\tint thisblk = 32 - data.length % 32;  // bytes needed to finish blk\n\t\tint nextblk = 0;                      // 32 if we need another block\n\t\t// need 9 bytes; add new block if no room\n\t\tif( thisblk < 9 ) {\n\t\t\tnextblk = 32;\n\t\t}\n\n\t\t// all bytes are zeroed for free\n\t\tbyte[] pad = new byte[ thisblk + nextblk ];\n\t\tpad[0] = (byte)0x80;\n\n\t\t// write length*8 to end of final block\n\t\tint ix = thisblk + nextblk - 8;\n\t\tLEDataOutputStream.writeInt( data.length>>29, pad, ix );\n\t\tbsw32( pad, ix );\n\t\tix += 4;\n\t\tLEDataOutputStream.writeInt( data.length<<3, pad, ix );\n\t\tbsw32( pad, ix );\n\n\t\treturn pad;\n\t}\n\n\tpublic static void bsw32( byte[] ary, int offset ) {\n\t\tbyte t = ary[offset];\n\t\tary[offset] = ary[offset+3];\n\t\tary[offset+3] = t;\n\t\tt = ary[offset+1];\n\t\tary[offset+1] = ary[offset+2];\n\t\tary[offset+2] = t;\n\t}\n\n\n\t/**\n\t * Parse and save one record from binary file.\n\t * @param buf\n\t * @param offset\n\t * @return If >0, \n\t * @throws UnsupportedEncodingException \n\t */\n\tvoid readGroupField(PwDatabaseV3 db, PwGroupV3 grp, int fieldType, byte[] buf, int offset) throws UnsupportedEncodingException {\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tgrp.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tgrp.name = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tgrp.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tgrp.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tgrp.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tgrp.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tgrp.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tgrp.level = LEDataInputStream.readUShort(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tgrp.flags = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\n\tvoid readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset)\n\tthrows UnsupportedEncodingException\n\t{\n\t\tint fieldType = LEDataInputStream.readUShort(buf, offset);\n\t\toffset += 2;\n\t\tint fieldSize = LEDataInputStream.readInt(buf, offset);\n\t\toffset += 4;\n\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tent.setUUID(Types.bytestoUUID(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tent.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tint iconId = LEDataInputStream.readInt(buf, offset);\n\t\t\t\n\t\t\t// Clean up after bug that set icon ids to -1\n\t\t\tif (iconId == -1) {\n\t\t\t\ticonId = 0;\n\t\t\t}\n\t\t\t\n\t\t\tent.icon = db.iconFactory.getIcon(iconId);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tent.title = Types.readCString(buf, offset); \n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tent.url = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tent.username = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tent.setPassword(buf, offset, Types.strlen(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tent.additional = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tent.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000A :\n\t\t\tent.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000B :\n\t\t\tent.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000C :\n\t\t\tent.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000D :\n\t\t\tent.binaryDesc = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000E :\n\t\t\tent.setBinaryData(buf, offset, fieldSize);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2012 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n\nDerived from\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\npackage com.keepassdroid.database.load;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDate;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV3;\nimport com.keepassdroid.database.PwEncryptionAlgorithm;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.exception.InvalidAlgorithmException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.stream.NullOutputStream;\nimport com.keepassdroid.utils.Types;\n\n/**\n * Load a v3 database file.\n *\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n */\npublic class ImporterV3 extends Importer {\n\n\tpublic ImporterV3() {\n\t\tsuper();\n\t}\n\n\tprotected PwDatabaseV3 createDB() {\n\t\treturn new PwDatabaseV3();\n\t}\n\n\t/**\n\t * Load a v3 database file, return contents in a new PwDatabaseV3.\n\t * \n\t * @param infile  Existing file to load.\n\t * @param password Pass phrase for infile.\n\t * @param pRepair (unused)\n\t * @return new PwDatabaseV3 container.\n\t * \n\t * @throws IOException on any file error.\n\t * @throws InvalidKeyFileException \n\t * @throws InvalidPasswordException \n\t * @throws InvalidPasswordException on a decryption error, or possible internal bug.\n\t * @throws InvalidDBSignatureException \n\t * @throws InvalidDBVersionException \n\t * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.\n\t * @throws BadPaddingException on a decryption error, or possible internal bug.\n\t * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.\n\t * @throws NoSuchPaddingException on a decryption error, or possible internal bug.\n\t * @throws InvalidAlgorithmParameterException if error decrypting main file body. \n\t * @throws ShortBufferException if error decrypting main file body.\n\t */\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile )\n\tthrows IOException, InvalidDBException\n\t{\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile, UpdateStatus status )\n\tthrows IOException, InvalidDBException\n\t{\n\t\tPwDatabaseV3        newManager;\n\n\n\t\t// Load entire file, most of it's encrypted.\n\t\tint fileSize = inStream.available();\n\t\tbyte[] filebuf = new byte[fileSize + 16]; // Pad with a blocksize (Twofish uses 128 bits), since Android 4.3 tries to write more to the buffer\n\t\tinStream.read(filebuf, 0, fileSize);\n\t\tinStream.close();\n\n\t\t// Parse header (unencrypted)\n\t\tif( fileSize < PwDbHeaderV3.BUF_SIZE )\n\t\t\tthrow new IOException( \"File too short for header\" );\n\t\tPwDbHeaderV3 hdr = new PwDbHeaderV3();\n\t\thdr.loadFromFile(filebuf, 0 );\n\n\t\tif( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeaderV3.DBSIG_2) ) {\n\t\t\tthrow new InvalidDBSignatureException();\n\t\t}\n\n\t\tif( !hdr.matchesVersion() ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\n\t\tstatus.updateMessage(R.string.creating_db_key);\n\t\tnewManager = createDB();\n\t\tnewManager.setMasterKey( password, keyfile );\n\n\t\t// Select algorithm\n\t\tif( (hdr.flags & PwDbHeaderV3.FLAG_RIJNDAEL) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Rjindal;\n\t\t} else if( (hdr.flags & PwDbHeaderV3.FLAG_TWOFISH) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Twofish;\n\t\t} else {\n\t\t\tthrow new InvalidAlgorithmException();\n\t\t}\n\n\t\t// Copy for testing\n\t\tnewManager.copyHeader(hdr);\n\t\t\n\t\tnewManager.numKeyEncRounds = hdr.numKeyEncRounds;\n\n\t\tnewManager.name = \"KeePass Password Manager\";\n\n\t\t// Generate transformedMasterKey from masterKey\n\t\tnewManager.makeFinalKey(hdr.masterSeed, hdr.transformSeed, newManager.numKeyEncRounds);\n\n\t\tstatus.updateMessage(R.string.decrypting_db);\n\t\t// Initialize Rijndael algorithm\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tif ( newManager.algorithm == PwEncryptionAlgorithm.Rjindal ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\t\t} else if ( newManager.algorithm == PwEncryptionAlgorithm.Twofish ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"TWOFISH/CBC/PKCS7PADDING\");\n\t\t\t} else {\n\t\t\t\tthrow new IOException( \"Encryption algorithm is not supported\" );\n\t\t\t}\n\n\t\t} catch (NoSuchAlgorithmException e1) {\n\t\t\tthrow new IOException(\"No such algorithm\");\n\t\t} catch (NoSuchPaddingException e1) {\n\t\t\tthrow new IOException(\"No such pdading\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( newManager.finalKey, \"AES\" ), new IvParameterSpec( hdr.encryptionIV ) );\n\t\t} catch (InvalidKeyException e1) {\n\t\t\tthrow new IOException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e1) {\n\t\t\tthrow new IOException(\"Invalid algorithm parameter.\");\n\t\t}\n\n\t\t// Decrypt! The first bytes aren't encrypted (that's the header)\n\t\tint encryptedPartSize;\n\t\ttry {\n\t\t\tencryptedPartSize = cipher.doFinal(filebuf, PwDbHeaderV3.BUF_SIZE, fileSize - PwDbHeaderV3.BUF_SIZE, filebuf, PwDbHeaderV3.BUF_SIZE );\n\t\t} catch (ShortBufferException e1) {\n\t\t\tthrow new IOException(\"Buffer too short\");\n\t\t} catch (IllegalBlockSizeException e1) {\n\t\t\tthrow new IOException(\"Invalid block size\");\n\t\t} catch (BadPaddingException e1) {\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Copy decrypted data for testing\n\t\tnewManager.copyEncrypted(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 algorithm\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\tdos.write(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\t\tdos.close();\n\t\tbyte[] hash = md.digest();\n\t\t\n\t\tif( ! Arrays.equals(hash, hdr.contentsHash) ) {\n\n\t\t\tLog.w(\"KeePassDroid\",\"Database file did not decrypt correctly. (checksum code is broken)\");\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Import all groups\n\n\t\tint pos = PwDbHeaderV3.BUF_SIZE;\n\t\tPwGroupV3 newGrp = new PwGroupV3();\n\t\tfor( int i = 0; i < hdr.numGroups; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tpos += 2;\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos );\n\t\t\tpos += 4;\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewGrp.populateBlankFields(newManager);\n\t\t\t\tnewManager.groups.add(newGrp);\n\t\t\t\tnewGrp = new PwGroupV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadGroupField(newManager, newGrp, fieldType, filebuf, pos);\n\t\t\t}\n\t\t\tpos += fieldSize;\n\t\t}\n\n\t\t// Import all entries\n\t\tPwEntryV3 newEnt = new PwEntryV3();\n\t\tfor( int i = 0; i < hdr.numEntries; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos + 2 );\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewEnt.populateBlankFields(newManager);\n\t\t\t\tnewManager.entries.add(newEnt);\n\t\t\t\tnewEnt = new PwEntryV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadEntryField(newManager, newEnt, filebuf, pos);\n\t\t\t}\n\t\t\tpos += 2 + 4 + fieldSize;\n\t\t}\n\n\t\tnewManager.constructTree(null);\n\t\t\n\t\treturn newManager;\n\t}\n\n\t/**\n\t * KeePass's custom pad style.\n\t * \n\t * @param data buffer to pad.\n\t * @return addtional bytes to append to data[] to make\n\t *    a properly padded array.\n\t */\n\tpublic static byte[] makePad( byte[] data ) {\n\t\t//custom pad method\n\n\t\t// append 0x80 plus zeros to a multiple of 4 bytes\n\t\tint thisblk = 32 - data.length % 32;  // bytes needed to finish blk\n\t\tint nextblk = 0;                      // 32 if we need another block\n\t\t// need 9 bytes; add new block if no room\n\t\tif( thisblk < 9 ) {\n\t\t\tnextblk = 32;\n\t\t}\n\n\t\t// all bytes are zeroed for free\n\t\tbyte[] pad = new byte[ thisblk + nextblk ];\n\t\tpad[0] = (byte)0x80;\n\n\t\t// write length*8 to end of final block\n\t\tint ix = thisblk + nextblk - 8;\n\t\tLEDataOutputStream.writeInt( data.length>>29, pad, ix );\n\t\tbsw32( pad, ix );\n\t\tix += 4;\n\t\tLEDataOutputStream.writeInt( data.length<<3, pad, ix );\n\t\tbsw32( pad, ix );\n\n\t\treturn pad;\n\t}\n\n\tpublic static void bsw32( byte[] ary, int offset ) {\n\t\tbyte t = ary[offset];\n\t\tary[offset] = ary[offset+3];\n\t\tary[offset+3] = t;\n\t\tt = ary[offset+1];\n\t\tary[offset+1] = ary[offset+2];\n\t\tary[offset+2] = t;\n\t}\n\n\n\t/**\n\t * Parse and save one record from binary file.\n\t * @param buf\n\t * @param offset\n\t * @return If >0, \n\t * @throws UnsupportedEncodingException \n\t */\n\tvoid readGroupField(PwDatabaseV3 db, PwGroupV3 grp, int fieldType, byte[] buf, int offset) throws UnsupportedEncodingException {\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tgrp.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tgrp.name = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tgrp.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tgrp.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tgrp.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tgrp.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tgrp.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tgrp.level = LEDataInputStream.readUShort(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tgrp.flags = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\n\tvoid readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset)\n\tthrows UnsupportedEncodingException\n\t{\n\t\tint fieldType = LEDataInputStream.readUShort(buf, offset);\n\t\toffset += 2;\n\t\tint fieldSize = LEDataInputStream.readInt(buf, offset);\n\t\toffset += 4;\n\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tent.setUUID(Types.bytestoUUID(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tent.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tint iconId = LEDataInputStream.readInt(buf, offset);\n\t\t\t\n\t\t\t// Clean up after bug that set icon ids to -1\n\t\t\tif (iconId == -1) {\n\t\t\t\ticonId = 0;\n\t\t\t}\n\t\t\t\n\t\t\tent.icon = db.iconFactory.getIcon(iconId);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tent.title = Types.readCString(buf, offset); \n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tent.url = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tent.username = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tent.setPassword(buf, offset, Types.strlen(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tent.additional = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tent.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000A :\n\t\t\tent.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000B :\n\t\t\tent.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000C :\n\t\t\tent.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000D :\n\t\t\tent.binaryDesc = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000E :\n\t\t\tent.setBinaryData(buf, offset, fieldSize);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","lineNo":139}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.net.URLDecoder;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.text.InputType;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CompoundButton.OnCheckedChangeListener;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.compat.BackupManagerCompat;\nimport com.keepassdroid.compat.EditorCompat;\nimport com.keepassdroid.database.edit.LoadDB;\nimport com.keepassdroid.database.edit.OnFinish;\nimport com.keepassdroid.fileselect.BrowserDialog;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.settings.AppSettingsActivity;\nimport com.keepassdroid.utils.Interaction;\nimport com.keepassdroid.utils.Util;\n\npublic class PasswordActivity extends LockingActivity {\n\n\tpublic static final String KEY_DEFAULT_FILENAME = \"defaultFileName\";\n\tprivate static final String KEY_FILENAME = \"fileName\";\n\tprivate static final String KEY_KEYFILE = \"keyFile\";\n\tprivate static final String KEY_PASSWORD = \"password\";\n\tprivate static final String KEY_LAUNCH_IMMEDIATELY = \"launchImmediately\";\n\tprivate static final String VIEW_INTENT = \"android.intent.action.VIEW\";\n\t\n\tprivate static final int FILE_BROWSE = 256;\n\tpublic static final int GET_CONTENT = 257;\n\n\tprivate String mFileName;\n\tprivate String mKeyFile;\n\tprivate boolean mRememberKeyfile;\n\tSharedPreferences prefs;\n\t\n\tpublic static void Launch(Activity act, String fileName) throws FileNotFoundException {\n\t\tLaunch(act,fileName,\"\");\n\t}\n\t\n\tpublic static void Launch(Activity act, String fileName, String keyFile) throws FileNotFoundException {\n\t\tFile dbFile = new File(fileName);\n\t\tif ( ! dbFile.exists() ) {\n\t\t\tthrow new FileNotFoundException();\n\t\t}\n\t\t\n\t\tIntent i = new Intent(act, PasswordActivity.class);\n\t\ti.putExtra(KEY_FILENAME, fileName);\n\t\ti.putExtra(KEY_KEYFILE, keyFile);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t\t\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tswitch (requestCode) {\n\t\t\n\t\tcase KeePass.EXIT_NORMAL:\n\t\t\tsetEditText(R.id.password, \"\");\n\t\t\tApp.getDB().clear();\n\t\t\tbreak;\n\t\t\n\t\tcase KeePass.EXIT_LOCK:\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tsetEditText(R.id.password, \"\");\n\t\t\tfinish();\n\t\t\tApp.getDB().clear(); \n\t\t\tbreak;\n\t\tcase FILE_BROWSE:\n\t\t\tif (resultCode == RESULT_OK) {\n\t\t\t\tString filename = data.getDataString();\n\t\t\t\tif (filename != null) {\n\t\t\t\t\tif (filename.startsWith(\"file://\")) {\n\t\t\t\t\t\tfilename = filename.substring(7);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfilename = URLDecoder.decode(filename);\n\t\t\t\t\t\n\t\t\t\t\tEditText fn = (EditText) findViewById(R.id.pass_keyfile);\n\t\t\t\t\tfn.setText(filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GET_CONTENT:\n\t\t\tif (resultCode == RESULT_OK) {\n\t\t\t\tString filename = data.getData().getPath();\n\t\t\t\t\t\n\t\t\t\tEditText fn = (EditText) findViewById(R.id.pass_keyfile);\n\t\t\t\tfn.setText(filename);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\n\t\tIntent i = getIntent();\n\t\tString action = i.getAction();\n\t\tString password = \"\";\n\t\tboolean launch_immediately = false;\n\t\t\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tmRememberKeyfile = prefs.getBoolean(getString(R.string.keyfile_key), getResources().getBoolean(R.bool.keyfile_default));\n\t\t\n\t\tif ( action != null && action.equals(VIEW_INTENT) ) {\n\t\t\tmFileName = i.getDataString();\n\t\t\t\n\t\t\tif ( ! mFileName.substring(0, 7).equals(\"file://\") ) {\n\t\t\t\tToast.makeText(this, R.string.error_can_not_handle_uri, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmFileName = URLDecoder.decode(mFileName.substring(7, mFileName.length()));\n\t\t\t\t\t\t\n\t\t\tif ( mFileName.length() == 0 ) {\n\t\t\t\t// No file name\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tFile dbFile = new File(mFileName);\n\t\t\tif ( ! dbFile.exists() ) {\n\t\t\t\t// File does not exist\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmKeyFile = getKeyFile(mFileName);\n\t\t\t\n\t\t} else {\n\t\t\tmFileName = i.getStringExtra(KEY_FILENAME);\n\t\t\tmKeyFile = i.getStringExtra(KEY_KEYFILE);\n\t\t\tpassword = i.getStringExtra(KEY_PASSWORD);\n\t\t\tlaunch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false);\n\t\t\t\n\t\t\tif ( mKeyFile == null || mKeyFile.length() == 0) {\n\t\t\t\tmKeyFile = getKeyFile(mFileName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsetContentView(R.layout.password);\n\t\tpopulateView();\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new OkClickHandler());\n\t\t\n\t\tCheckBox checkBox = (CheckBox) findViewById(R.id.show_password);\n\t\t// Show or hide password\n\t\tcheckBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView,\n\t\t\t\t\tboolean isChecked) {\n\t\t\t\tTextView password = (TextView) findViewById(R.id.password);\n\n\t\t\t\tif ( isChecked ) {\n\t\t\t\t\tpassword.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD);\n\t\t\t\t} else {\n\t\t\t\t\tpassword.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tif (password != null) {\n\t\t\tTextView tv_password = (TextView) findViewById(R.id.password);\n\t\t\ttv_password.setText(password);\n\t\t}\n\t\t\n\t\tCheckBox defaultCheck = (CheckBox) findViewById(R.id.default_database);\n\t\tdefaultCheck.setOnCheckedChangeListener(new DefaultCheckChange());\n\t\t\n\t\tImageButton browse = (ImageButton) findViewById(R.id.browse_button);\n\t\tbrowse.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent i = new Intent(Intent.ACTION_GET_CONTENT);\n\t\t\t\ti.setType(\"file/*\");\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tstartActivityForResult(i, GET_CONTENT);\n\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\tlookForOpenIntentsFilePicker();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void lookForOpenIntentsFilePicker() {\n\t\t\t\tif (Interaction.isIntentAvailable(PasswordActivity.this, Intents.OPEN_INTENTS_FILE_BROWSE)) {\n\t\t\t\t\tIntent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);\n\t\t\t\t\t\n\t\t\t\t\tif (mFileName.length() > 0) {\n\t\t\t\t\t\tFile keyfile = new File(mFileName);\n\t\t\t\t\t\tFile parent = keyfile.getParentFile();\n\t\t\t\t\t\tif (parent != null) {\n\t\t\t\t\t\t\ti.setData(Uri.parse(\"file://\" + parent.getAbsolutePath()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstartActivityForResult(i, FILE_BROWSE);\n\t\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void showBrowserDialog() {\n\t\t\t\tBrowserDialog diag = new BrowserDialog(PasswordActivity.this);\n\t\t\t\tdiag.show();\n\t\t\t}\n\t\t});\n\t\t\n\t\tretrieveSettings();\n\t\t\n\t\tif (launch_immediately)\n\t\t\tloadDatabase(password, mKeyFile);\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// If the application was shutdown make sure to clear the password field, if it\n\t\t// was saved in the instance state\n\t\tif (App.isShutdown()) {\n\t\t\tTextView password = (TextView) findViewById(R.id.password);\n\t\t\tpassword.setText(\"\");\n\t\t}\n\t\t\n\t\t// Clear the shutdown flag\n\t\tApp.clearShutdown();\n\t}\n\n\tprivate void retrieveSettings() {\n\t\tString defaultFilename = prefs.getString(KEY_DEFAULT_FILENAME, \"\");\n\t\tif (mFileName.length() > 0 && mFileName.equals(defaultFilename)) {\n\t\t\tCheckBox checkbox = (CheckBox) findViewById(R.id.default_database);\n\t\t\tcheckbox.setChecked(true);\n\t\t}\n\t}\n\t\n\tprivate String getKeyFile(String filename) {\n\t\tif ( mRememberKeyfile ) {\n\t\t\t\n\t\t\tString keyfile = App.getFileHistory().getFileByName(filename);\n\t\t\t\n\t\t\treturn keyfile;\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tprivate void populateView() {\n\t\tsetEditText(R.id.filename, mFileName);\n\t\t\n\t\tsetEditText(R.id.pass_keyfile, mKeyFile);\n\t}\n\t\n\t/*\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t*/\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class DefaultCheckChange implements CompoundButton.OnCheckedChangeListener {\n\t\t\n\t\t@Override\n\t\tpublic void onCheckedChanged(CompoundButton buttonView,\n\t\t\t\tboolean isChecked) {\n\t\t\t\n\t\t\tString newDefaultFileName;\n\t\t\t\n\t\t\tif (isChecked) {\n\t\t\t\tnewDefaultFileName = mFileName;\n\t\t\t} else {\n\t\t\t\tnewDefaultFileName = \"\";\n\t\t\t}\n\t\t\t\n\t\t\tSharedPreferences.Editor editor = prefs.edit();\n\t\t\teditor.putString(KEY_DEFAULT_FILENAME, newDefaultFileName);\n\t\t\tEditorCompat.apply(editor);\n\t\t\t\n\t\t\tBackupManagerCompat backupManager = new BackupManagerCompat(PasswordActivity.this);\n\t\t\tbackupManager.dataChanged();\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate class OkClickHandler implements View.OnClickListener {\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.password);\n\t\t\tString key = getEditText(R.id.pass_keyfile);\n\t\t\tloadDatabase(pass, key);\n\t\t}\t\t\t\n\t}\n\t\n\tprivate void loadDatabase(String pass, String keyfile)\n\t{\n\t\tif ( pass.length() == 0 && keyfile.length() == 0 ) {\n\t\t\terrorMessage(R.string.error_nopass);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString fileName = getEditText(R.id.filename);\n\t\t\n\t\t\n\t\t// Clear before we load\n\t\tDatabase db = App.getDB();\n\t\tdb.clear();\n\t\t\n\t\t// Clear the shutdown flag\n\t\tApp.clearShutdown();\n\t\t\n\t\tHandler handler = new Handler();\n\t\tLoadDB task = new LoadDB(db, PasswordActivity.this, fileName, pass, keyfile, new AfterLoad(handler));\n\t\tProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database);\n\t\tpt.run();\t\t\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\treturn Util.getEditText(this, resId);\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tTextView te =  (TextView) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflate = getMenuInflater();\n\t\tinflate.inflate(R.menu.password, menu);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase R.id.menu_about:\n\t\t\tAboutDialog dialog = new AboutDialog(this);\n\t\t\tdialog.show();\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_app_settings:\n\t\t\tAppSettingsActivity.Launch(this);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate final class AfterLoad extends OnFinish {\n\t\t\n\t\tpublic AfterLoad(Handler handler) {\n\t\t\tsuper(handler);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tGroupActivity.Launch(PasswordActivity.this);\n\t\t\t} else {\n\t\t\t\tdisplayMessage(PasswordActivity.this);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.net.URLDecoder;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.preference.PreferenceManager;\nimport android.text.InputType;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.CompoundButton;\nimport android.widget.CompoundButton.OnCheckedChangeListener;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.compat.BackupManagerCompat;\nimport com.keepassdroid.compat.EditorCompat;\nimport com.keepassdroid.database.edit.LoadDB;\nimport com.keepassdroid.database.edit.OnFinish;\nimport com.keepassdroid.fileselect.BrowserDialog;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.settings.AppSettingsActivity;\nimport com.keepassdroid.utils.Interaction;\nimport com.keepassdroid.utils.Util;\n\npublic class PasswordActivity extends LockingActivity {\n\n\tpublic static final String KEY_DEFAULT_FILENAME = \"defaultFileName\";\n\tprivate static final String KEY_FILENAME = \"fileName\";\n\tprivate static final String KEY_KEYFILE = \"keyFile\";\n\tprivate static final String KEY_PASSWORD = \"password\";\n\tprivate static final String KEY_LAUNCH_IMMEDIATELY = \"launchImmediately\";\n\tprivate static final String VIEW_INTENT = \"android.intent.action.VIEW\";\n\t\n\tprivate static final int FILE_BROWSE = 256;\n\tpublic static final int GET_CONTENT = 257;\n\n\tprivate String mFileName;\n\tprivate String mKeyFile;\n\tprivate boolean mRememberKeyfile;\n\tSharedPreferences prefs;\n\t\n\tpublic static void Launch(Activity act, String fileName) throws FileNotFoundException {\n\t\tLaunch(act,fileName,\"\");\n\t}\n\t\n\tpublic static void Launch(Activity act, String fileName, String keyFile) throws FileNotFoundException {\n\t\tFile dbFile = new File(fileName);\n\t\tif ( ! dbFile.exists() ) {\n\t\t\tthrow new FileNotFoundException();\n\t\t}\n\t\t\n\t\tIntent i = new Intent(act, PasswordActivity.class);\n\t\ti.putExtra(KEY_FILENAME, fileName);\n\t\ti.putExtra(KEY_KEYFILE, keyFile);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t\t\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tswitch (requestCode) {\n\t\t\n\t\tcase KeePass.EXIT_NORMAL:\n\t\t\tsetEditText(R.id.password, \"\");\n\t\t\tApp.getDB().clear();\n\t\t\tbreak;\n\t\t\n\t\tcase KeePass.EXIT_LOCK:\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tsetEditText(R.id.password, \"\");\n\t\t\tfinish();\n\t\t\tApp.getDB().clear(); \n\t\t\tbreak;\n\t\tcase FILE_BROWSE:\n\t\t\tif (resultCode == RESULT_OK) {\n\t\t\t\tString filename = data.getDataString();\n\t\t\t\tif (filename != null) {\n\t\t\t\t\tif (filename.startsWith(\"file://\")) {\n\t\t\t\t\t\tfilename = filename.substring(7);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfilename = URLDecoder.decode(filename);\n\t\t\t\t\t\n\t\t\t\t\tEditText fn = (EditText) findViewById(R.id.pass_keyfile);\n\t\t\t\t\tfn.setText(filename);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase GET_CONTENT:\n\t\t\tif (resultCode == RESULT_OK) {\n\t\t\t\tif (data != null) {\n\t\t\t\t\tUri uri = data.getData();\n\t\t\t\t\tif (uri != null) {\n\t\t\t\t\t\tString path = uri.getPath();\n\t\t\t\t\t\tif (path != null) {\n\t\t\t\t\t\t\tEditText fn = (EditText) findViewById(R.id.pass_keyfile);\n\t\t\t\t\t\t\tfn.setText(path);\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\n\t\tIntent i = getIntent();\n\t\tString action = i.getAction();\n\t\tString password = \"\";\n\t\tboolean launch_immediately = false;\n\t\t\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tmRememberKeyfile = prefs.getBoolean(getString(R.string.keyfile_key), getResources().getBoolean(R.bool.keyfile_default));\n\t\t\n\t\tif ( action != null && action.equals(VIEW_INTENT) ) {\n\t\t\tmFileName = i.getDataString();\n\t\t\t\n\t\t\tif ( ! mFileName.substring(0, 7).equals(\"file://\") ) {\n\t\t\t\tToast.makeText(this, R.string.error_can_not_handle_uri, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmFileName = URLDecoder.decode(mFileName.substring(7, mFileName.length()));\n\t\t\t\t\t\t\n\t\t\tif ( mFileName.length() == 0 ) {\n\t\t\t\t// No file name\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tFile dbFile = new File(mFileName);\n\t\t\tif ( ! dbFile.exists() ) {\n\t\t\t\t// File does not exist\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmKeyFile = getKeyFile(mFileName);\n\t\t\t\n\t\t} else {\n\t\t\tmFileName = i.getStringExtra(KEY_FILENAME);\n\t\t\tmKeyFile = i.getStringExtra(KEY_KEYFILE);\n\t\t\tpassword = i.getStringExtra(KEY_PASSWORD);\n\t\t\tlaunch_immediately = i.getBooleanExtra(KEY_LAUNCH_IMMEDIATELY, false);\n\t\t\t\n\t\t\tif ( mKeyFile == null || mKeyFile.length() == 0) {\n\t\t\t\tmKeyFile = getKeyFile(mFileName);\n\t\t\t}\n\t\t}\n\t\t\n\t\tsetContentView(R.layout.password);\n\t\tpopulateView();\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new OkClickHandler());\n\t\t\n\t\tCheckBox checkBox = (CheckBox) findViewById(R.id.show_password);\n\t\t// Show or hide password\n\t\tcheckBox.setOnCheckedChangeListener(new OnCheckedChangeListener() {\n\n\t\t\tpublic void onCheckedChanged(CompoundButton buttonView,\n\t\t\t\t\tboolean isChecked) {\n\t\t\t\tTextView password = (TextView) findViewById(R.id.password);\n\n\t\t\t\tif ( isChecked ) {\n\t\t\t\t\tpassword.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_VISIBLE_PASSWORD);\n\t\t\t\t} else {\n\t\t\t\t\tpassword.setInputType(InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tif (password != null) {\n\t\t\tTextView tv_password = (TextView) findViewById(R.id.password);\n\t\t\ttv_password.setText(password);\n\t\t}\n\t\t\n\t\tCheckBox defaultCheck = (CheckBox) findViewById(R.id.default_database);\n\t\tdefaultCheck.setOnCheckedChangeListener(new DefaultCheckChange());\n\t\t\n\t\tImageButton browse = (ImageButton) findViewById(R.id.browse_button);\n\t\tbrowse.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent i = new Intent(Intent.ACTION_GET_CONTENT);\n\t\t\t\ti.setType(\"file/*\");\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tstartActivityForResult(i, GET_CONTENT);\n\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\tlookForOpenIntentsFilePicker();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void lookForOpenIntentsFilePicker() {\n\t\t\t\tif (Interaction.isIntentAvailable(PasswordActivity.this, Intents.OPEN_INTENTS_FILE_BROWSE)) {\n\t\t\t\t\tIntent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);\n\t\t\t\t\t\n\t\t\t\t\tif (mFileName.length() > 0) {\n\t\t\t\t\t\tFile keyfile = new File(mFileName);\n\t\t\t\t\t\tFile parent = keyfile.getParentFile();\n\t\t\t\t\t\tif (parent != null) {\n\t\t\t\t\t\t\ti.setData(Uri.parse(\"file://\" + parent.getAbsolutePath()));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstartActivityForResult(i, FILE_BROWSE);\n\t\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void showBrowserDialog() {\n\t\t\t\tBrowserDialog diag = new BrowserDialog(PasswordActivity.this);\n\t\t\t\tdiag.show();\n\t\t\t}\n\t\t});\n\t\t\n\t\tretrieveSettings();\n\t\t\n\t\tif (launch_immediately)\n\t\t\tloadDatabase(password, mKeyFile);\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// If the application was shutdown make sure to clear the password field, if it\n\t\t// was saved in the instance state\n\t\tif (App.isShutdown()) {\n\t\t\tTextView password = (TextView) findViewById(R.id.password);\n\t\t\tpassword.setText(\"\");\n\t\t}\n\t\t\n\t\t// Clear the shutdown flag\n\t\tApp.clearShutdown();\n\t}\n\n\tprivate void retrieveSettings() {\n\t\tString defaultFilename = prefs.getString(KEY_DEFAULT_FILENAME, \"\");\n\t\tif (mFileName.length() > 0 && mFileName.equals(defaultFilename)) {\n\t\t\tCheckBox checkbox = (CheckBox) findViewById(R.id.default_database);\n\t\t\tcheckbox.setChecked(true);\n\t\t}\n\t}\n\t\n\tprivate String getKeyFile(String filename) {\n\t\tif ( mRememberKeyfile ) {\n\t\t\t\n\t\t\tString keyfile = App.getFileHistory().getFileByName(filename);\n\t\t\t\n\t\t\treturn keyfile;\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tprivate void populateView() {\n\t\tsetEditText(R.id.filename, mFileName);\n\t\t\n\t\tsetEditText(R.id.pass_keyfile, mKeyFile);\n\t}\n\t\n\t/*\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t*/\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class DefaultCheckChange implements CompoundButton.OnCheckedChangeListener {\n\t\t\n\t\t@Override\n\t\tpublic void onCheckedChanged(CompoundButton buttonView,\n\t\t\t\tboolean isChecked) {\n\t\t\t\n\t\t\tString newDefaultFileName;\n\t\t\t\n\t\t\tif (isChecked) {\n\t\t\t\tnewDefaultFileName = mFileName;\n\t\t\t} else {\n\t\t\t\tnewDefaultFileName = \"\";\n\t\t\t}\n\t\t\t\n\t\t\tSharedPreferences.Editor editor = prefs.edit();\n\t\t\teditor.putString(KEY_DEFAULT_FILENAME, newDefaultFileName);\n\t\t\tEditorCompat.apply(editor);\n\t\t\t\n\t\t\tBackupManagerCompat backupManager = new BackupManagerCompat(PasswordActivity.this);\n\t\t\tbackupManager.dataChanged();\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate class OkClickHandler implements View.OnClickListener {\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.password);\n\t\t\tString key = getEditText(R.id.pass_keyfile);\n\t\t\tloadDatabase(pass, key);\n\t\t}\t\t\t\n\t}\n\t\n\tprivate void loadDatabase(String pass, String keyfile)\n\t{\n\t\tif ( pass.length() == 0 && keyfile.length() == 0 ) {\n\t\t\terrorMessage(R.string.error_nopass);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tString fileName = getEditText(R.id.filename);\n\t\t\n\t\t\n\t\t// Clear before we load\n\t\tDatabase db = App.getDB();\n\t\tdb.clear();\n\t\t\n\t\t// Clear the shutdown flag\n\t\tApp.clearShutdown();\n\t\t\n\t\tHandler handler = new Handler();\n\t\tLoadDB task = new LoadDB(db, PasswordActivity.this, fileName, pass, keyfile, new AfterLoad(handler));\n\t\tProgressTask pt = new ProgressTask(PasswordActivity.this, task, R.string.loading_database);\n\t\tpt.run();\t\t\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\treturn Util.getEditText(this, resId);\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tTextView te =  (TextView) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflate = getMenuInflater();\n\t\tinflate.inflate(R.menu.password, menu);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase R.id.menu_about:\n\t\t\tAboutDialog dialog = new AboutDialog(this);\n\t\t\tdialog.show();\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_app_settings:\n\t\t\tAppSettingsActivity.Launch(this);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate final class AfterLoad extends OnFinish {\n\t\t\n\t\tpublic AfterLoad(Handler handler) {\n\t\t\tsuper(handler);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tGroupActivity.Launch(PasswordActivity.this);\n\t\t\t} else {\n\t\t\t\tdisplayMessage(PasswordActivity.this);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n","lineNo":131}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.fileselect;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URLDecoder;\n\nimport android.app.ListActivity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.preference.PreferenceManager;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.AboutDialog;\nimport com.keepassdroid.GroupActivity;\nimport com.keepassdroid.PasswordActivity;\nimport com.keepassdroid.ProgressTask;\nimport com.keepassdroid.SetPasswordDialog;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.database.edit.CreateDB;\nimport com.keepassdroid.database.edit.FileOnFinish;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.settings.AppSettingsActivity;\nimport com.keepassdroid.utils.Interaction;\nimport com.keepassdroid.utils.Util;\nimport com.keepassdroid.view.FileNameView;\n\npublic class FileSelectActivity extends ListActivity {\n\n\tprivate static final int CMENU_CLEAR = Menu.FIRST;\n\t\n\tpublic static final int FILE_BROWSE = 1;\n\tpublic static final int GET_CONTENT = 2;\n\t\n\tprivate RecentFileHistory fileHistory;\n\n\tprivate boolean recentMode = false;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tfileHistory = App.getFileHistory();\n\n\t\tif (fileHistory.hasRecentFiles()) {\n\t\t\trecentMode = true;\n\t\t\tsetContentView(R.layout.file_selection);\n\t\t} else {\n\t\t\tsetContentView(R.layout.file_selection_no_recent);\n\t\t}\n\n\t\t// Open button\n\t\tButton openButton = (Button) findViewById(R.id.open);\n\t\topenButton.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tString fileName = Util.getEditText(FileSelectActivity.this,\n\t\t\t\t\t\tR.id.file_filename);\n\n\t\t\t\ttry {\n\t\t\t\t\tPasswordActivity.Launch(FileSelectActivity.this, fileName);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\tR.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\t\t// Create button\n\t\tButton createButton = (Button) findViewById(R.id.create);\n\t\tcreateButton.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tString filename = Util.getEditText(FileSelectActivity.this,\n\t\t\t\t\t\tR.id.file_filename);\n\n\t\t\t\t// Make sure file name exists\n\t\t\t\tif (filename.length() == 0) {\n\t\t\t\t\tToast\n\t\t\t\t\t\t\t.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\t\tR.string.error_filename_required,\n\t\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Try to create the file\n\t\t\t\tFile file = new File(filename);\n\t\t\t\ttry {\n\t\t\t\t\tif (file.exists()) {\n\t\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\tR.string.error_database_exists,\n\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tFile parent = file.getParentFile();\n\t\t\t\t\t\n\t\t\t\t\tif ( parent == null || (parent.exists() && ! parent.isDirectory()) ) {\n\t\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\tR.string.error_invalid_path,\n\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( ! parent.exists() ) {\n\t\t\t\t\t\t// Create parent dircetory\n\t\t\t\t\t\tif ( ! parent.mkdirs() ) {\n\t\t\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\t\tR.string.error_could_not_create_parent,\n\t\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfile.createNewFile();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tToast.makeText(\n\t\t\t\t\t\t\tFileSelectActivity.this,\n\t\t\t\t\t\t\tgetText(R.string.error_file_not_create) + \" \"\n\t\t\t\t\t\t\t\t\t+ e.getLocalizedMessage(),\n\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Prep an object to collect a password once the database has\n\t\t\t\t// been created\n\t\t\t\tCollectPassword password = new CollectPassword(\n\t\t\t\t\t\tnew LaunchGroupActivity(filename));\n\n\t\t\t\t// Create the new database\n\t\t\t\tCreateDB create = new CreateDB(filename, password, true);\n\t\t\t\tProgressTask createTask = new ProgressTask(\n\t\t\t\t\t\tFileSelectActivity.this, create,\n\t\t\t\t\t\tR.string.progress_create);\n\t\t\t\tcreateTask.run();\n\n\t\t\t}\n\n\t\t});\n\t\t\n\t\tImageButton browseButton = (ImageButton) findViewById(R.id.browse_button);\n\t\tbrowseButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent i = new Intent(Intent.ACTION_GET_CONTENT);\n\t\t\t\ti.setType(\"file/*\");\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tstartActivityForResult(i, GET_CONTENT);\n\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\tlookForOpenIntentsFilePicker();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void lookForOpenIntentsFilePicker() {\n\t\t\t\t\n\t\t\t\tif (Interaction.isIntentAvailable(FileSelectActivity.this, Intents.OPEN_INTENTS_FILE_BROWSE)) {\n\t\t\t\t\tIntent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);\n\t\t\t\t\ti.setData(Uri.parse(\"file://\" + Util.getEditText(FileSelectActivity.this, R.id.file_filename)));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstartActivityForResult(i, FILE_BROWSE);\n\t\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void showBrowserDialog() {\n\t\t\t\tBrowserDialog diag = new BrowserDialog(FileSelectActivity.this);\n\t\t\t\tdiag.show();\n\t\t\t}\n\t\t});\n\n\t\tfillData();\n\t\t\n\t\tregisterForContextMenu(getListView());\n\t\t\n\t\t// Load default database\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tString fileName = prefs.getString(PasswordActivity.KEY_DEFAULT_FILENAME, \"\");\n\t\t\n\t\tif (fileName.length() > 0) {\n\t\t\tFile db = new File(fileName);\n\t\t\t\n\t\t\tif (db.exists()) {\n\t\t\t\ttry {\n\t\t\t\t\tPasswordActivity.Launch(FileSelectActivity.this, fileName);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore exception\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class LaunchGroupActivity extends FileOnFinish {\n\t\tprivate String mFilename;\n\n\t\tpublic LaunchGroupActivity(String filename) {\n\t\t\tsuper(null);\n\n\t\t\tmFilename = filename;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (mSuccess) {\n\t\t\t\t// Add to recent files\n\t\t\t\tfileHistory.createFile(mFilename, getFilename());\n\n\t\t\t\tGroupActivity.Launch(FileSelectActivity.this);\n\n\t\t\t} else {\n\t\t\t\tFile file = new File(mFilename);\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class CollectPassword extends FileOnFinish {\n\n\t\tpublic CollectPassword(FileOnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tSetPasswordDialog password = new SetPasswordDialog(FileSelectActivity.this, mOnFinish);\n\t\t\tpassword.show();\n\t\t}\n\n\t}\n\n\tprivate void fillData() {\n\t\t// Set the initial value of the filename\n\t\tEditText filename = (EditText) findViewById(R.id.file_filename);\n\t\tfilename.setText(Environment.getExternalStorageDirectory().getAbsolutePath() + getString(R.string.default_file_path));\n\t\t\n\t\tArrayAdapter<String> adapter = new ArrayAdapter<String>(this, R.layout.file_row, R.id.file_filename, fileHistory.getDbList());\n\t\tsetListAdapter(adapter);\n\t}\n\n\t@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\n\t\tString fileName = fileHistory.getDatabaseAt(position);\n\t\tString keyFile = fileHistory.getKeyfileAt(position);\n\n\t\ttry {\n\t\t\tPasswordActivity.Launch(this, fileName, keyFile);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG)\n\t\t\t\t\t.show();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\n\t\tfillData();\n\t\t\n\t\tString filename = null;\n\t\tif (requestCode == FILE_BROWSE && resultCode == RESULT_OK) {\n\t\t\tfilename = data.getDataString();\n\t\t\tif (filename != null) {\n\t\t\t\tif (filename.startsWith(\"file://\")) {\n\t\t\t\t\tfilename = filename.substring(7);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfilename = URLDecoder.decode(filename);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (requestCode == GET_CONTENT && resultCode == RESULT_OK) {\n\t\t\tfilename = data.getData().getPath();\n\t\t}\n\t\t\n\t\tif (filename != null) {\n\t\t\tEditText fn = (EditText) findViewById(R.id.file_filename);\n\t\t\tfn.setText(filename);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Check to see if we need to change modes\n\t\tif ( fileHistory.hasRecentFiles() != recentMode ) {\n\t\t\t// Restart the activity\n\t\t\tIntent intent = getIntent();\n\t\t\tstartActivity(intent);\n\t\t\tfinish();\n\t\t}\n\t\t\n\t\tFileNameView fnv = (FileNameView) findViewById(R.id.file_select);\n\t\tfnv.updateExternalStorageWarning();\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.fileselect, menu);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.menu_donate:\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, R.string.donate_url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_about:\n\t\t\tAboutDialog dialog = new AboutDialog(this);\n\t\t\tdialog.show();\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_app_settings:\n\t\t\tAppSettingsActivity.Launch(this);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v,\n\t\t\tContextMenuInfo menuInfo) {\n\t\tsuper.onCreateContextMenu(menu, v, menuInfo);\n\t\t\n\t\tmenu.add(0, CMENU_CLEAR, 0, R.string.remove_from_filelist);\n\t}\n\n\t@Override\n\tpublic boolean onContextItemSelected(MenuItem item) {\n\t\tsuper.onContextItemSelected(item);\n\t\t\n\t\tif ( item.getItemId() == CMENU_CLEAR ) {\n\t\t\tAdapterContextMenuInfo acmi = (AdapterContextMenuInfo) item.getMenuInfo();\n\t\t\t\n\t\t\tTextView tv = (TextView) acmi.targetView;\n\t\t\tString filename = tv.getText().toString();\n\t\t\tfileHistory.deleteFile(filename);\n\t\t\t\n\t\t\trefreshList();\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void refreshList() {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayAdapter<String> adapter = (ArrayAdapter<String>) getListAdapter();\n\t\tadapter.notifyDataSetChanged();\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.fileselect;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URLDecoder;\n\nimport android.app.ListActivity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.preference.PreferenceManager;\nimport android.view.ContextMenu;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.ImageButton;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.AboutDialog;\nimport com.keepassdroid.GroupActivity;\nimport com.keepassdroid.PasswordActivity;\nimport com.keepassdroid.ProgressTask;\nimport com.keepassdroid.SetPasswordDialog;\nimport com.keepassdroid.app.App;\nimport com.keepassdroid.database.edit.CreateDB;\nimport com.keepassdroid.database.edit.FileOnFinish;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.settings.AppSettingsActivity;\nimport com.keepassdroid.utils.Interaction;\nimport com.keepassdroid.utils.Util;\nimport com.keepassdroid.view.FileNameView;\n\npublic class FileSelectActivity extends ListActivity {\n\n\tprivate static final int CMENU_CLEAR = Menu.FIRST;\n\t\n\tpublic static final int FILE_BROWSE = 1;\n\tpublic static final int GET_CONTENT = 2;\n\t\n\tprivate RecentFileHistory fileHistory;\n\n\tprivate boolean recentMode = false;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\t\n\t\tfileHistory = App.getFileHistory();\n\n\t\tif (fileHistory.hasRecentFiles()) {\n\t\t\trecentMode = true;\n\t\t\tsetContentView(R.layout.file_selection);\n\t\t} else {\n\t\t\tsetContentView(R.layout.file_selection_no_recent);\n\t\t}\n\n\t\t// Open button\n\t\tButton openButton = (Button) findViewById(R.id.open);\n\t\topenButton.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tString fileName = Util.getEditText(FileSelectActivity.this,\n\t\t\t\t\t\tR.id.file_filename);\n\n\t\t\t\ttry {\n\t\t\t\t\tPasswordActivity.Launch(FileSelectActivity.this, fileName);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\tR.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\t}\n\n\t\t\t}\n\t\t});\n\n\t\t// Create button\n\t\tButton createButton = (Button) findViewById(R.id.create);\n\t\tcreateButton.setOnClickListener(new View.OnClickListener() {\n\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tString filename = Util.getEditText(FileSelectActivity.this,\n\t\t\t\t\t\tR.id.file_filename);\n\n\t\t\t\t// Make sure file name exists\n\t\t\t\tif (filename.length() == 0) {\n\t\t\t\t\tToast\n\t\t\t\t\t\t\t.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\t\tR.string.error_filename_required,\n\t\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Try to create the file\n\t\t\t\tFile file = new File(filename);\n\t\t\t\ttry {\n\t\t\t\t\tif (file.exists()) {\n\t\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\tR.string.error_database_exists,\n\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tFile parent = file.getParentFile();\n\t\t\t\t\t\n\t\t\t\t\tif ( parent == null || (parent.exists() && ! parent.isDirectory()) ) {\n\t\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\tR.string.error_invalid_path,\n\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif ( ! parent.exists() ) {\n\t\t\t\t\t\t// Create parent dircetory\n\t\t\t\t\t\tif ( ! parent.mkdirs() ) {\n\t\t\t\t\t\t\tToast.makeText(FileSelectActivity.this,\n\t\t\t\t\t\t\t\t\tR.string.error_could_not_create_parent,\n\t\t\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfile.createNewFile();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tToast.makeText(\n\t\t\t\t\t\t\tFileSelectActivity.this,\n\t\t\t\t\t\t\tgetText(R.string.error_file_not_create) + \" \"\n\t\t\t\t\t\t\t\t\t+ e.getLocalizedMessage(),\n\t\t\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Prep an object to collect a password once the database has\n\t\t\t\t// been created\n\t\t\t\tCollectPassword password = new CollectPassword(\n\t\t\t\t\t\tnew LaunchGroupActivity(filename));\n\n\t\t\t\t// Create the new database\n\t\t\t\tCreateDB create = new CreateDB(filename, password, true);\n\t\t\t\tProgressTask createTask = new ProgressTask(\n\t\t\t\t\t\tFileSelectActivity.this, create,\n\t\t\t\t\t\tR.string.progress_create);\n\t\t\t\tcreateTask.run();\n\n\t\t\t}\n\n\t\t});\n\t\t\n\t\tImageButton browseButton = (ImageButton) findViewById(R.id.browse_button);\n\t\tbrowseButton.setOnClickListener(new View.OnClickListener() {\n\t\t\t\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent i = new Intent(Intent.ACTION_GET_CONTENT);\n\t\t\t\ti.setType(\"file/*\");\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tstartActivityForResult(i, GET_CONTENT);\n\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\tlookForOpenIntentsFilePicker();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void lookForOpenIntentsFilePicker() {\n\t\t\t\t\n\t\t\t\tif (Interaction.isIntentAvailable(FileSelectActivity.this, Intents.OPEN_INTENTS_FILE_BROWSE)) {\n\t\t\t\t\tIntent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);\n\t\t\t\t\ti.setData(Uri.parse(\"file://\" + Util.getEditText(FileSelectActivity.this, R.id.file_filename)));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tstartActivityForResult(i, FILE_BROWSE);\n\t\t\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t} else {\n\t\t\t\t\tshowBrowserDialog();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tprivate void showBrowserDialog() {\n\t\t\t\tBrowserDialog diag = new BrowserDialog(FileSelectActivity.this);\n\t\t\t\tdiag.show();\n\t\t\t}\n\t\t});\n\n\t\tfillData();\n\t\t\n\t\tregisterForContextMenu(getListView());\n\t\t\n\t\t// Load default database\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(this);\n\t\tString fileName = prefs.getString(PasswordActivity.KEY_DEFAULT_FILENAME, \"\");\n\t\t\n\t\tif (fileName.length() > 0) {\n\t\t\tFile db = new File(fileName);\n\t\t\t\n\t\t\tif (db.exists()) {\n\t\t\t\ttry {\n\t\t\t\t\tPasswordActivity.Launch(FileSelectActivity.this, fileName);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t// Ignore exception\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class LaunchGroupActivity extends FileOnFinish {\n\t\tprivate String mFilename;\n\n\t\tpublic LaunchGroupActivity(String filename) {\n\t\t\tsuper(null);\n\n\t\t\tmFilename = filename;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif (mSuccess) {\n\t\t\t\t// Add to recent files\n\t\t\t\tfileHistory.createFile(mFilename, getFilename());\n\n\t\t\t\tGroupActivity.Launch(FileSelectActivity.this);\n\n\t\t\t} else {\n\t\t\t\tFile file = new File(mFilename);\n\t\t\t\tfile.delete();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate class CollectPassword extends FileOnFinish {\n\n\t\tpublic CollectPassword(FileOnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tSetPasswordDialog password = new SetPasswordDialog(FileSelectActivity.this, mOnFinish);\n\t\t\tpassword.show();\n\t\t}\n\n\t}\n\n\tprivate void fillData() {\n\t\t// Set the initial value of the filename\n\t\tEditText filename = (EditText) findViewById(R.id.file_filename);\n\t\tfilename.setText(Environment.getExternalStorageDirectory().getAbsolutePath() + getString(R.string.default_file_path));\n\t\t\n\t\tArrayAdapter<String> adapter = new ArrayAdapter<String>(this, R.layout.file_row, R.id.file_filename, fileHistory.getDbList());\n\t\tsetListAdapter(adapter);\n\t}\n\n\t@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\n\t\tString fileName = fileHistory.getDatabaseAt(position);\n\t\tString keyFile = fileHistory.getKeyfileAt(position);\n\n\t\ttry {\n\t\t\tPasswordActivity.Launch(this, fileName, keyFile);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG)\n\t\t\t\t\t.show();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\n\t\tfillData();\n\t\t\n\t\tString filename = null;\n\t\tif (requestCode == FILE_BROWSE && resultCode == RESULT_OK) {\n\t\t\tfilename = data.getDataString();\n\t\t\tif (filename != null) {\n\t\t\t\tif (filename.startsWith(\"file://\")) {\n\t\t\t\t\tfilename = filename.substring(7);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfilename = URLDecoder.decode(filename);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse if (requestCode == GET_CONTENT && resultCode == RESULT_OK) {\n\t\t\tif (data != null) {\n\t\t\t\tUri uri = data.getData();\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tfilename = uri.getPath();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (filename != null) {\n\t\t\tEditText fn = (EditText) findViewById(R.id.file_filename);\n\t\t\tfn.setText(filename);\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Check to see if we need to change modes\n\t\tif ( fileHistory.hasRecentFiles() != recentMode ) {\n\t\t\t// Restart the activity\n\t\t\tIntent intent = getIntent();\n\t\t\tstartActivity(intent);\n\t\t\tfinish();\n\t\t}\n\t\t\n\t\tFileNameView fnv = (FileNameView) findViewById(R.id.file_select);\n\t\tfnv.updateExternalStorageWarning();\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tMenuInflater inflater = getMenuInflater();\n\t\tinflater.inflate(R.menu.fileselect, menu);\n\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase R.id.menu_donate:\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, R.string.donate_url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show();\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_about:\n\t\t\tAboutDialog dialog = new AboutDialog(this);\n\t\t\tdialog.show();\n\t\t\treturn true;\n\t\t\t\n\t\tcase R.id.menu_app_settings:\n\t\t\tAppSettingsActivity.Launch(this);\n\t\t\treturn true;\n\t\t}\n\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v,\n\t\t\tContextMenuInfo menuInfo) {\n\t\tsuper.onCreateContextMenu(menu, v, menuInfo);\n\t\t\n\t\tmenu.add(0, CMENU_CLEAR, 0, R.string.remove_from_filelist);\n\t}\n\n\t@Override\n\tpublic boolean onContextItemSelected(MenuItem item) {\n\t\tsuper.onContextItemSelected(item);\n\t\t\n\t\tif ( item.getItemId() == CMENU_CLEAR ) {\n\t\t\tAdapterContextMenuInfo acmi = (AdapterContextMenuInfo) item.getMenuInfo();\n\t\t\t\n\t\t\tTextView tv = (TextView) acmi.targetView;\n\t\t\tString filename = tv.getText().toString();\n\t\t\tfileHistory.deleteFile(filename);\n\t\t\t\n\t\t\trefreshList();\n\t\t\t\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void refreshList() {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayAdapter<String> adapter = (ArrayAdapter<String>) getListAdapter();\n\t\tadapter.notifyDataSetChanged();\n\t}\n\n}\n","lineNo":318}
{"Smelly Sample":"/*\n * Copyright 2009-2011 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.edit;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\n\npublic class AddEntry extends RunnableOnFinish {\n\tprotected Database mDb;\n\tprivate PwEntry mEntry;\n\t\n\tpublic static AddEntry getInstance(Database db, PwEntry entry, OnFinish finish) {\n\t\treturn new AddEntry(db, entry, finish);\n\t}\n\t\n\tprotected AddEntry(Database db, PwEntry entry, OnFinish finish) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmEntry = entry;\n\t\t\n\t\tmFinish = new AfterAdd(mFinish);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tmDb.pm.addEntryTo(mEntry, mEntry.getParent());\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterAdd extends OnFinish {\n\n\t\tpublic AfterAdd(OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\t\n\t\t\t\tPwGroup parent = mEntry.getParent();\n\n\t\t\t\t// Mark parent group dirty\n\t\t\t\tmDb.dirty.add(parent);\n\t\t\n\t\t\t\t// Add entry to global\n\t\t\t\tmDb.entries.put(mEntry.getUUID(), mEntry);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tmDb.pm.removeEntryFrom(mEntry, mEntry.getParent());\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\t}\n\t\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.edit;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\n\npublic class AddEntry extends RunnableOnFinish {\n\tprotected Database mDb;\n\tprivate PwEntry mEntry;\n\t\n\tpublic static AddEntry getInstance(Database db, PwEntry entry, OnFinish finish) {\n\t\treturn new AddEntry(db, entry, finish);\n\t}\n\t\n\tprotected AddEntry(Database db, PwEntry entry, OnFinish finish) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmEntry = entry;\n\t\t\n\t\tmFinish = new AfterAdd(mFinish);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tmDb.pm.addEntryTo(mEntry, mEntry.getParent());\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterAdd extends OnFinish {\n\n\t\tpublic AfterAdd(OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tPwDatabase pm = mDb.pm;\n\t\t\tif ( mSuccess ) {\n\t\t\t\t\n\t\t\t\tPwGroup parent = mEntry.getParent();\n\n\t\t\t\t// Mark parent group dirty\n\t\t\t\tmDb.dirty.add(parent);\n\t\t\n\t\t\t\t// Add entry to global\n\t\t\t\tpm.entries.put(mEntry.getUUID(), mEntry);\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\tpm.removeEntryFrom(mEntry, mEntry.getParent());\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\t}\n\t\n\n}\n","lineNo":61}
{"Smelly Sample":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.edit;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwGroup;\n\npublic class AddGroup extends RunnableOnFinish {\n\tprotected Database mDb;\n\tprivate String mName;\n\tprivate int mIconID;\n\tprivate PwGroup mGroup;\n\tprivate PwGroup mParent;\n\tprotected boolean mDontSave;\n\t\n\t\n\tpublic static AddGroup getInstance(Database db, String name, int iconid, PwGroup parent, OnFinish finish, boolean dontSave) {\n\t\treturn new AddGroup(db, name, iconid, parent, finish, dontSave);\n\t}\n\t\n\t\n\tprivate AddGroup(Database db, String name, int iconid, PwGroup parent, OnFinish finish, boolean dontSave) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmName = name;\n\t\tmIconID = iconid;\n\t\tmParent = parent;\n\t\tmDontSave = dontSave;\n\t\t\n\t\tmFinish = new AfterAdd(mFinish);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tPwDatabase pm = mDb.pm;\n\t\t\n\t\t// Generate new group\n\t\tmGroup = pm.createGroup();\n\t\tmGroup.initNewGroup(mName, pm.newGroupId());\n\t\tmGroup.icon = mDb.pm.iconFactory.getIcon(mIconID);\n\t\tpm.addGroupTo(mGroup, mParent);\n\t\t\n\t\t//mParent.sortGroupsByName();\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish, mDontSave);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterAdd extends OnFinish {\n\n\t\tpublic AfterAdd(OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\t\n\t\t\tif ( mSuccess ) {\n\t\t\t\t// Mark parent group dirty\n\t\t\t\tmDb.dirty.add(mParent);\n\t\t\t\t\n\t\t\t\t// Add group to global list\n\t\t\t\tmDb.groups.put(mGroup.getId(), mGroup);\n\t\t\t} else {\n\t\t\t\tmDb.pm.removeGroupFrom(mGroup, mParent);\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\n\t}\n\t\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2013 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.edit;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabase;\nimport com.keepassdroid.database.PwGroup;\n\npublic class AddGroup extends RunnableOnFinish {\n\tprotected Database mDb;\n\tprivate String mName;\n\tprivate int mIconID;\n\tprivate PwGroup mGroup;\n\tprivate PwGroup mParent;\n\tprotected boolean mDontSave;\n\t\n\t\n\tpublic static AddGroup getInstance(Database db, String name, int iconid, PwGroup parent, OnFinish finish, boolean dontSave) {\n\t\treturn new AddGroup(db, name, iconid, parent, finish, dontSave);\n\t}\n\t\n\t\n\tprivate AddGroup(Database db, String name, int iconid, PwGroup parent, OnFinish finish, boolean dontSave) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmName = name;\n\t\tmIconID = iconid;\n\t\tmParent = parent;\n\t\tmDontSave = dontSave;\n\t\t\n\t\tmFinish = new AfterAdd(mFinish);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tPwDatabase pm = mDb.pm;\n\t\t\n\t\t// Generate new group\n\t\tmGroup = pm.createGroup();\n\t\tmGroup.initNewGroup(mName, pm.newGroupId());\n\t\tmGroup.icon = mDb.pm.iconFactory.getIcon(mIconID);\n\t\tpm.addGroupTo(mGroup, mParent);\n\t\t\n\t\t//mParent.sortGroupsByName();\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish, mDontSave);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterAdd extends OnFinish {\n\n\t\tpublic AfterAdd(OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tPwDatabase pm = mDb.pm;\n\t\t\tif ( mSuccess ) {\n\t\t\t\t// Mark parent group dirty\n\t\t\t\tmDb.dirty.add(mParent);\n\t\t\t\t\n\t\t\t\t// Add group to global list\n\t\t\t\tpm.groups.put(mGroup.getId(), mGroup);\n\t\t\t} else {\n\t\t\t\tpm.removeGroupFrom(mGroup, mParent);\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\n\t}\n\t\n\n}\n","lineNo":77}
{"Smelly Sample":"/*\n * Copyright 2009-2012 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n\nDerived from\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\npackage com.keepassdroid.database.load;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDate;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV3;\nimport com.keepassdroid.database.PwEncryptionAlgorithm;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.exception.InvalidAlgorithmException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.stream.NullOutputStream;\nimport com.keepassdroid.utils.Types;\n\n/**\n * Load a v3 database file.\n *\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n */\npublic class ImporterV3 extends Importer {\n\n\tpublic ImporterV3() {\n\t\tsuper();\n\t}\n\n\tprotected PwDatabaseV3 createDB() {\n\t\treturn new PwDatabaseV3();\n\t}\n\n\t/**\n\t * Load a v3 database file, return contents in a new PwDatabaseV3.\n\t * \n\t * @param infile  Existing file to load.\n\t * @param password Pass phrase for infile.\n\t * @param pRepair (unused)\n\t * @return new PwDatabaseV3 container.\n\t * \n\t * @throws IOException on any file error.\n\t * @throws InvalidKeyFileException \n\t * @throws InvalidPasswordException \n\t * @throws InvalidPasswordException on a decryption error, or possible internal bug.\n\t * @throws InvalidDBSignatureException \n\t * @throws InvalidDBVersionException \n\t * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.\n\t * @throws BadPaddingException on a decryption error, or possible internal bug.\n\t * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.\n\t * @throws NoSuchPaddingException on a decryption error, or possible internal bug.\n\t * @throws InvalidAlgorithmParameterException if error decrypting main file body. \n\t * @throws ShortBufferException if error decrypting main file body.\n\t */\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile )\n\tthrows IOException, InvalidDBException\n\t{\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile, UpdateStatus status )\n\tthrows IOException, InvalidDBException\n\t{\n\t\tPwDatabaseV3        newManager;\n\n\n\t\t// Load entire file, most of it's encrypted.\n\t\tbyte[] filebuf = new byte[(int)inStream.available()];\n\t\tinStream.read( filebuf, 0, (int)inStream.available());\n\t\tinStream.close();\n\n\t\t// Parse header (unencrypted)\n\t\tif( filebuf.length < PwDbHeaderV3.BUF_SIZE )\n\t\t\tthrow new IOException( \"File too short for header\" );\n\t\tPwDbHeaderV3 hdr = new PwDbHeaderV3();\n\t\thdr.loadFromFile(filebuf, 0 );\n\n\t\tif( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeaderV3.DBSIG_2) ) {\n\t\t\tthrow new InvalidDBSignatureException();\n\t\t}\n\n\t\tif( !hdr.matchesVersion() ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\n\t\tstatus.updateMessage(R.string.creating_db_key);\n\t\tnewManager = createDB();\n\t\tnewManager.setMasterKey( password, keyfile );\n\n\t\t// Select algorithm\n\t\tif( (hdr.flags & PwDbHeaderV3.FLAG_RIJNDAEL) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Rjindal;\n\t\t} else if( (hdr.flags & PwDbHeaderV3.FLAG_TWOFISH) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Twofish;\n\t\t} else {\n\t\t\tthrow new InvalidAlgorithmException();\n\t\t}\n\n\t\t// Copy for testing\n\t\tnewManager.copyHeader(hdr);\n\t\t\n\t\tnewManager.numKeyEncRounds = hdr.numKeyEncRounds;\n\n\t\tnewManager.name = \"KeePass Password Manager\";\n\n\t\t// Generate transformedMasterKey from masterKey\n\t\tnewManager.makeFinalKey(hdr.masterSeed, hdr.transformSeed, newManager.numKeyEncRounds);\n\n\t\tstatus.updateMessage(R.string.decrypting_db);\n\t\t// Initialize Rijndael algorithm\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tif ( newManager.algorithm == PwEncryptionAlgorithm.Rjindal ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\t\t} else if ( newManager.algorithm == PwEncryptionAlgorithm.Twofish ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"TWOFISH/CBC/PKCS7PADDING\");\n\t\t\t} else {\n\t\t\t\tthrow new IOException( \"Encryption algorithm is not supported\" );\n\t\t\t}\n\n\t\t} catch (NoSuchAlgorithmException e1) {\n\t\t\tthrow new IOException(\"No such algorithm\");\n\t\t} catch (NoSuchPaddingException e1) {\n\t\t\tthrow new IOException(\"No such pdading\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( newManager.finalKey, \"AES\" ), new IvParameterSpec( hdr.encryptionIV ) );\n\t\t} catch (InvalidKeyException e1) {\n\t\t\tthrow new IOException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e1) {\n\t\t\tthrow new IOException(\"Invalid algorithm parameter.\");\n\t\t}\n\n\t\t// Decrypt! The first bytes aren't encrypted (that's the header)\n\t\tint encryptedPartSize;\n\t\ttry {\n\t\t\tencryptedPartSize = cipher.doFinal(filebuf, PwDbHeaderV3.BUF_SIZE, filebuf.length - PwDbHeaderV3.BUF_SIZE, filebuf, PwDbHeaderV3.BUF_SIZE );\n\t\t} catch (ShortBufferException e1) {\n\t\t\tthrow new IOException(\"Buffer too short\");\n\t\t} catch (IllegalBlockSizeException e1) {\n\t\t\tthrow new IOException(\"Invalid block size\");\n\t\t} catch (BadPaddingException e1) {\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Copy decrypted data for testing\n\t\tnewManager.copyEncrypted(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 algorithm\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\tdos.write(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\t\tdos.close();\n\t\tbyte[] hash = md.digest();\n\t\t\n\t\tif( ! Arrays.equals(hash, hdr.contentsHash) ) {\n\n\t\t\tLog.w(\"KeePassDroid\",\"Database file did not decrypt correctly. (checksum code is broken)\");\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Import all groups\n\n\t\tint pos = PwDbHeaderV3.BUF_SIZE;\n\t\tPwGroupV3 newGrp = new PwGroupV3();\n\t\tfor( int i = 0; i < hdr.numGroups; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tpos += 2;\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos );\n\t\t\tpos += 4;\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewGrp.populateBlankFields(newManager);\n\t\t\t\tnewManager.groups.add(newGrp);\n\t\t\t\tnewGrp = new PwGroupV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadGroupField(newManager, newGrp, fieldType, filebuf, pos);\n\t\t\t}\n\t\t\tpos += fieldSize;\n\t\t}\n\n\t\t// Import all entries\n\t\tPwEntryV3 newEnt = new PwEntryV3();\n\t\tfor( int i = 0; i < hdr.numEntries; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos + 2 );\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewEnt.populateBlankFields(newManager);\n\t\t\t\tnewManager.entries.add(newEnt);\n\t\t\t\tnewEnt = new PwEntryV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadEntryField(newManager, newEnt, filebuf, pos);\n\t\t\t}\n\t\t\tpos += 2 + 4 + fieldSize;\n\t\t}\n\n\t\tnewManager.constructTree(null);\n\t\t\n\t\treturn newManager;\n\t}\n\n\t/**\n\t * KeePass's custom pad style.\n\t * \n\t * @param data buffer to pad.\n\t * @return addtional bytes to append to data[] to make\n\t *    a properly padded array.\n\t */\n\tpublic static byte[] makePad( byte[] data ) {\n\t\t//custom pad method\n\n\t\t// append 0x80 plus zeros to a multiple of 4 bytes\n\t\tint thisblk = 32 - data.length % 32;  // bytes needed to finish blk\n\t\tint nextblk = 0;                      // 32 if we need another block\n\t\t// need 9 bytes; add new block if no room\n\t\tif( thisblk < 9 ) {\n\t\t\tnextblk = 32;\n\t\t}\n\n\t\t// all bytes are zeroed for free\n\t\tbyte[] pad = new byte[ thisblk + nextblk ];\n\t\tpad[0] = (byte)0x80;\n\n\t\t// write length*8 to end of final block\n\t\tint ix = thisblk + nextblk - 8;\n\t\tLEDataOutputStream.writeInt( data.length>>29, pad, ix );\n\t\tbsw32( pad, ix );\n\t\tix += 4;\n\t\tLEDataOutputStream.writeInt( data.length<<3, pad, ix );\n\t\tbsw32( pad, ix );\n\n\t\treturn pad;\n\t}\n\n\tpublic static void bsw32( byte[] ary, int offset ) {\n\t\tbyte t = ary[offset];\n\t\tary[offset] = ary[offset+3];\n\t\tary[offset+3] = t;\n\t\tt = ary[offset+1];\n\t\tary[offset+1] = ary[offset+2];\n\t\tary[offset+2] = t;\n\t}\n\n\n\t/**\n\t * Parse and save one record from binary file.\n\t * @param buf\n\t * @param offset\n\t * @return If >0, \n\t * @throws UnsupportedEncodingException \n\t */\n\tvoid readGroupField(PwDatabaseV3 db, PwGroupV3 grp, int fieldType, byte[] buf, int offset) throws UnsupportedEncodingException {\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tgrp.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tgrp.name = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tgrp.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tgrp.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tgrp.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tgrp.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tgrp.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tgrp.level = LEDataInputStream.readUShort(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tgrp.flags = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\n\tvoid readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset)\n\tthrows UnsupportedEncodingException\n\t{\n\t\tint fieldType = LEDataInputStream.readUShort(buf, offset);\n\t\toffset += 2;\n\t\tint fieldSize = LEDataInputStream.readInt(buf, offset);\n\t\toffset += 4;\n\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tent.setUUID(Types.bytestoUUID(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tent.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tent.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tent.title = Types.readCString(buf, offset); \n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tent.url = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tent.username = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tent.setPassword(buf, offset, Types.strlen(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tent.additional = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tent.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000A :\n\t\t\tent.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000B :\n\t\t\tent.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000C :\n\t\t\tent.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000D :\n\t\t\tent.binaryDesc = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000E :\n\t\t\tent.setBinaryData(buf, offset, fieldSize);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2012 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n *\n\nDerived from\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\npackage com.keepassdroid.database.load;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDate;\nimport com.keepassdroid.database.PwDbHeader;\nimport com.keepassdroid.database.PwDbHeaderV3;\nimport com.keepassdroid.database.PwEncryptionAlgorithm;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.exception.InvalidAlgorithmException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.LEDataOutputStream;\nimport com.keepassdroid.stream.NullOutputStream;\nimport com.keepassdroid.utils.Types;\n\n/**\n * Load a v3 database file.\n *\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n */\npublic class ImporterV3 extends Importer {\n\n\tpublic ImporterV3() {\n\t\tsuper();\n\t}\n\n\tprotected PwDatabaseV3 createDB() {\n\t\treturn new PwDatabaseV3();\n\t}\n\n\t/**\n\t * Load a v3 database file, return contents in a new PwDatabaseV3.\n\t * \n\t * @param infile  Existing file to load.\n\t * @param password Pass phrase for infile.\n\t * @param pRepair (unused)\n\t * @return new PwDatabaseV3 container.\n\t * \n\t * @throws IOException on any file error.\n\t * @throws InvalidKeyFileException \n\t * @throws InvalidPasswordException \n\t * @throws InvalidPasswordException on a decryption error, or possible internal bug.\n\t * @throws InvalidDBSignatureException \n\t * @throws InvalidDBVersionException \n\t * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.\n\t * @throws BadPaddingException on a decryption error, or possible internal bug.\n\t * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.\n\t * @throws NoSuchPaddingException on a decryption error, or possible internal bug.\n\t * @throws InvalidAlgorithmParameterException if error decrypting main file body. \n\t * @throws ShortBufferException if error decrypting main file body.\n\t */\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile )\n\tthrows IOException, InvalidDBException\n\t{\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\n\tpublic PwDatabaseV3 openDatabase( InputStream inStream, String password, String keyfile, UpdateStatus status )\n\tthrows IOException, InvalidDBException\n\t{\n\t\tPwDatabaseV3        newManager;\n\n\n\t\t// Load entire file, most of it's encrypted.\n\t\tbyte[] filebuf = new byte[(int)inStream.available()];\n\t\tinStream.read( filebuf, 0, (int)inStream.available());\n\t\tinStream.close();\n\n\t\t// Parse header (unencrypted)\n\t\tif( filebuf.length < PwDbHeaderV3.BUF_SIZE )\n\t\t\tthrow new IOException( \"File too short for header\" );\n\t\tPwDbHeaderV3 hdr = new PwDbHeaderV3();\n\t\thdr.loadFromFile(filebuf, 0 );\n\n\t\tif( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeaderV3.DBSIG_2) ) {\n\t\t\tthrow new InvalidDBSignatureException();\n\t\t}\n\n\t\tif( !hdr.matchesVersion() ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\n\t\tstatus.updateMessage(R.string.creating_db_key);\n\t\tnewManager = createDB();\n\t\tnewManager.setMasterKey( password, keyfile );\n\n\t\t// Select algorithm\n\t\tif( (hdr.flags & PwDbHeaderV3.FLAG_RIJNDAEL) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Rjindal;\n\t\t} else if( (hdr.flags & PwDbHeaderV3.FLAG_TWOFISH) != 0 ) {\n\t\t\tnewManager.algorithm = PwEncryptionAlgorithm.Twofish;\n\t\t} else {\n\t\t\tthrow new InvalidAlgorithmException();\n\t\t}\n\n\t\t// Copy for testing\n\t\tnewManager.copyHeader(hdr);\n\t\t\n\t\tnewManager.numKeyEncRounds = hdr.numKeyEncRounds;\n\n\t\tnewManager.name = \"KeePass Password Manager\";\n\n\t\t// Generate transformedMasterKey from masterKey\n\t\tnewManager.makeFinalKey(hdr.masterSeed, hdr.transformSeed, newManager.numKeyEncRounds);\n\n\t\tstatus.updateMessage(R.string.decrypting_db);\n\t\t// Initialize Rijndael algorithm\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tif ( newManager.algorithm == PwEncryptionAlgorithm.Rjindal ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\t\t} else if ( newManager.algorithm == PwEncryptionAlgorithm.Twofish ) {\n\t\t\t\tcipher = CipherFactory.getInstance(\"TWOFISH/CBC/PKCS7PADDING\");\n\t\t\t} else {\n\t\t\t\tthrow new IOException( \"Encryption algorithm is not supported\" );\n\t\t\t}\n\n\t\t} catch (NoSuchAlgorithmException e1) {\n\t\t\tthrow new IOException(\"No such algorithm\");\n\t\t} catch (NoSuchPaddingException e1) {\n\t\t\tthrow new IOException(\"No such pdading\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( newManager.finalKey, \"AES\" ), new IvParameterSpec( hdr.encryptionIV ) );\n\t\t} catch (InvalidKeyException e1) {\n\t\t\tthrow new IOException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e1) {\n\t\t\tthrow new IOException(\"Invalid algorithm parameter.\");\n\t\t}\n\n\t\t// Decrypt! The first bytes aren't encrypted (that's the header)\n\t\tint encryptedPartSize;\n\t\ttry {\n\t\t\tencryptedPartSize = cipher.doFinal(filebuf, PwDbHeaderV3.BUF_SIZE, filebuf.length - PwDbHeaderV3.BUF_SIZE, filebuf, PwDbHeaderV3.BUF_SIZE );\n\t\t} catch (ShortBufferException e1) {\n\t\t\tthrow new IOException(\"Buffer too short\");\n\t\t} catch (IllegalBlockSizeException e1) {\n\t\t\tthrow new IOException(\"Invalid block size\");\n\t\t} catch (BadPaddingException e1) {\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Copy decrypted data for testing\n\t\tnewManager.copyEncrypted(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 algorithm\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\tdos.write(filebuf, PwDbHeaderV3.BUF_SIZE, encryptedPartSize);\n\t\tdos.close();\n\t\tbyte[] hash = md.digest();\n\t\t\n\t\tif( ! Arrays.equals(hash, hdr.contentsHash) ) {\n\n\t\t\tLog.w(\"KeePassDroid\",\"Database file did not decrypt correctly. (checksum code is broken)\");\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\t// Import all groups\n\n\t\tint pos = PwDbHeaderV3.BUF_SIZE;\n\t\tPwGroupV3 newGrp = new PwGroupV3();\n\t\tfor( int i = 0; i < hdr.numGroups; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tpos += 2;\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos );\n\t\t\tpos += 4;\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewGrp.populateBlankFields(newManager);\n\t\t\t\tnewManager.groups.add(newGrp);\n\t\t\t\tnewGrp = new PwGroupV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadGroupField(newManager, newGrp, fieldType, filebuf, pos);\n\t\t\t}\n\t\t\tpos += fieldSize;\n\t\t}\n\n\t\t// Import all entries\n\t\tPwEntryV3 newEnt = new PwEntryV3();\n\t\tfor( int i = 0; i < hdr.numEntries; ) {\n\t\t\tint fieldType = LEDataInputStream.readUShort( filebuf, pos );\n\t\t\tint fieldSize = LEDataInputStream.readInt( filebuf, pos + 2 );\n\n\t\t\tif( fieldType == 0xFFFF ) {\n\t\t\t\t// End-Group record.  Save group and count it.\n\t\t\t\tnewEnt.populateBlankFields(newManager);\n\t\t\t\tnewManager.entries.add(newEnt);\n\t\t\t\tnewEnt = new PwEntryV3();\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treadEntryField(newManager, newEnt, filebuf, pos);\n\t\t\t}\n\t\t\tpos += 2 + 4 + fieldSize;\n\t\t}\n\n\t\tnewManager.constructTree(null);\n\t\t\n\t\treturn newManager;\n\t}\n\n\t/**\n\t * KeePass's custom pad style.\n\t * \n\t * @param data buffer to pad.\n\t * @return addtional bytes to append to data[] to make\n\t *    a properly padded array.\n\t */\n\tpublic static byte[] makePad( byte[] data ) {\n\t\t//custom pad method\n\n\t\t// append 0x80 plus zeros to a multiple of 4 bytes\n\t\tint thisblk = 32 - data.length % 32;  // bytes needed to finish blk\n\t\tint nextblk = 0;                      // 32 if we need another block\n\t\t// need 9 bytes; add new block if no room\n\t\tif( thisblk < 9 ) {\n\t\t\tnextblk = 32;\n\t\t}\n\n\t\t// all bytes are zeroed for free\n\t\tbyte[] pad = new byte[ thisblk + nextblk ];\n\t\tpad[0] = (byte)0x80;\n\n\t\t// write length*8 to end of final block\n\t\tint ix = thisblk + nextblk - 8;\n\t\tLEDataOutputStream.writeInt( data.length>>29, pad, ix );\n\t\tbsw32( pad, ix );\n\t\tix += 4;\n\t\tLEDataOutputStream.writeInt( data.length<<3, pad, ix );\n\t\tbsw32( pad, ix );\n\n\t\treturn pad;\n\t}\n\n\tpublic static void bsw32( byte[] ary, int offset ) {\n\t\tbyte t = ary[offset];\n\t\tary[offset] = ary[offset+3];\n\t\tary[offset+3] = t;\n\t\tt = ary[offset+1];\n\t\tary[offset+1] = ary[offset+2];\n\t\tary[offset+2] = t;\n\t}\n\n\n\t/**\n\t * Parse and save one record from binary file.\n\t * @param buf\n\t * @param offset\n\t * @return If >0, \n\t * @throws UnsupportedEncodingException \n\t */\n\tvoid readGroupField(PwDatabaseV3 db, PwGroupV3 grp, int fieldType, byte[] buf, int offset) throws UnsupportedEncodingException {\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tgrp.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tgrp.name = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tgrp.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tgrp.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tgrp.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tgrp.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tgrp.icon = db.iconFactory.getIcon(LEDataInputStream.readInt(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tgrp.level = LEDataInputStream.readUShort(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tgrp.flags = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\n\n\tvoid readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset)\n\tthrows UnsupportedEncodingException\n\t{\n\t\tint fieldType = LEDataInputStream.readUShort(buf, offset);\n\t\toffset += 2;\n\t\tint fieldSize = LEDataInputStream.readInt(buf, offset);\n\t\toffset += 4;\n\n\t\tswitch( fieldType ) {\n\t\tcase 0x0000 :\n\t\t\t// Ignore field\n\t\t\tbreak;\n\t\tcase 0x0001 :\n\t\t\tent.setUUID(Types.bytestoUUID(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0002 :\n\t\t\tent.groupId = LEDataInputStream.readInt(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0003 :\n\t\t\tint iconId = LEDataInputStream.readInt(buf, offset);\n\t\t\t\n\t\t\t// Clean up after bug that set icon ids to -1\n\t\t\tif (iconId == -1) {\n\t\t\t\ticonId = 0;\n\t\t\t}\n\t\t\t\n\t\t\tent.icon = db.iconFactory.getIcon(iconId);\n\t\t\tbreak;\n\t\tcase 0x0004 :\n\t\t\tent.title = Types.readCString(buf, offset); \n\t\t\tbreak;\n\t\tcase 0x0005 :\n\t\t\tent.url = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0006 :\n\t\t\tent.username = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0007 :\n\t\t\tent.setPassword(buf, offset, Types.strlen(buf, offset));\n\t\t\tbreak;\n\t\tcase 0x0008 :\n\t\t\tent.additional = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x0009 :\n\t\t\tent.tCreation = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000A :\n\t\t\tent.tLastMod = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000B :\n\t\t\tent.tLastAccess = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000C :\n\t\t\tent.tExpire = new PwDate(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000D :\n\t\t\tent.binaryDesc = Types.readCString(buf, offset);\n\t\t\tbreak;\n\t\tcase 0x000E :\n\t\t\tent.setBinaryData(buf, offset, fieldSize);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n","lineNo":393}
{}
{"Smelly Sample":"/*\n * Copyright 2010-2011 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbHeaderV4 extends PwDbHeader {\n\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n    public static final int DBSIG_2               = 0xB54BFB67;\n    \n    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;\n    private static final int FILE_VERSION_32 =            0x02010100;\n    \n    private class PwDbHeaderV4Fields {\n        public static final byte EndOfHeader = 0;\n        @SuppressWarnings(\"unused\")\n\t\tpublic static final byte Comment = 1;\n        public static final byte CipherID = 2;\n        public static final byte CompressionFlags = 3;\n        public static final byte MasterSeed = 4;\n        public static final byte TransformSeed = 5;\n        public static final byte TransformRounds = 6;\n        public static final byte EncryptionIV = 7;\n        public static final byte ProtectedStreamKey = 8;\n        public static final byte StreamStartBytes = 9;\n        public static final byte InnerRandomStreamID = 10;\n\n    }\n    \n    private PwDatabaseV4 db;\n    public byte[] protectedStreamKey;\n    public byte[] streamStartBytes;\n    public CrsAlgorithm innerRandomStream;\n\n    public PwDbHeaderV4(PwDatabaseV4 d) {\n    \tdb = d;\n    }\n\n\t/** Assumes the input stream is at the beginning of the .kdbx file\n\t * @param is\n\t * @throws IOException \n\t * @throws InvalidDBVersionException \n\t */\n\tpublic void loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {\n\t\tLEDataInputStream dis = new LEDataInputStream(is);\n\n\t\tint sig1 = dis.readInt();\n\t\tint sig2 = dis.readInt();\n\t\t\n\t\tif ( ! matchesHeader(sig1, sig2) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tlong version = dis.readUInt();\n\t\tif ( ! validVersion(version) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tboolean done = false;\n\t\twhile ( ! done ) {\n\t\t\tdone = readHeaderField(dis);\n\t\t}\n\t}\n\t\n\tprivate boolean readHeaderField(LEDataInputStream dis) throws IOException {\n\t\tbyte fieldID = (byte) dis.read();\n\t\t\n\t\tint fieldSize = dis.readShort();\n\t\t\n\t\tbyte[] fieldData = null;\n\t\tif ( fieldSize > 0 ) {\n\t\t\tfieldData = new byte[fieldSize];\n\t\t\t\n\t\t\tint readSize = dis.read(fieldData);\n\t\t\tif ( readSize != fieldSize ) {\n\t\t\t\tthrow new IOException(\"Header ended early.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch ( fieldID ) {\n\t\t\tcase PwDbHeaderV4Fields.EndOfHeader:\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CipherID:\n\t\t\t\tsetCipher(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CompressionFlags:\n\t\t\t\tsetCompressionFlags(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.MasterSeed:\n\t\t\t\tmasterSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformSeed:\n\t\t\t\ttransformSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformRounds:\n\t\t\t\tsetTransformRounds(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.EncryptionIV:\n\t\t\t\tencryptionIV = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.ProtectedStreamKey:\n\t\t\t\tprotectedStreamKey = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.StreamStartBytes:\n\t\t\t\tstreamStartBytes = fieldData;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomStreamID:\n\t\t\t\tsetRandomStreamID(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow new IOException(\"Invalid header type.\");\n\t\t\t\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void setCipher(byte[] pbId) throws IOException {\n\t\tif ( pbId == null || pbId.length != 16 ) {\n\t\t\tthrow new IOException(\"Invalid cipher ID.\");\n\t\t}\n\t\t\n\t\tdb.dataCipher = Types.bytestoUUID(pbId);\n\t}\n\t\n\tprivate void setCompressionFlags(byte[] pbFlags) throws IOException {\n\t\tif ( pbFlags == null || pbFlags.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid compression flags.\");\n\t\t}\n\t\t\n\t\tint flag = LEDataInputStream.readInt(pbFlags, 0);\n\t\tif ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Unrecognized compression flag.\");\n\t\t}\n\t\t\n\t\tdb.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);\n\t\t\n\t}\n\t\n\tprivate void setTransformRounds(byte[] rounds) throws IOException {\n\t\tif ( rounds == null || rounds.length != 8 ) {\n\t\t\tthrow new IOException(\"Invalid rounds.\");\n\t\t}\n\t\t\n\t\tlong rnd = LEDataInputStream.readLong(rounds, 0);\n\t\t\n\t\tif ( rnd < 0 || rnd > Integer.MAX_VALUE ) {\n\t\t\t//TODO: Actually support really large numbers\n\t\t\tthrow new IOException(\"Rounds higher than \" + Integer.MAX_VALUE + \" are not currently supported.\");\n\t\t}\n\t\t\n\t\tdb.numKeyEncRounds = rnd;\n\t\t\n\t}\n\t\n\tprivate void setRandomStreamID(byte[] streamID) throws IOException {\n\t\tif ( streamID == null || streamID.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tint id = LEDataInputStream.readInt(streamID, 0);\n\t\tif ( id < 0 || id >= CrsAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tinnerRandomStream = CrsAlgorithm.fromId(id);\n\t}\n\t\n\t/** Determines if this is a supported version.\n\t * \n\t *  A long is needed here to represent the unsigned int since we perform\n\t *  arithmetic on it.\n\t * @param version\n\t * @return\n\t */\n\tprivate boolean validVersion(long version) {\n\t\t\n\t\treturn ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK));\n\t\t\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );\n\t}\n    \n}\n","Method after Refactoring":"/*\n * Copyright 2010-2012 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.DigestInputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\npublic class PwDbHeaderV4 extends PwDbHeader {\n\tpublic static final int DBSIG_PRE2            = 0xB54BFB66;\n    public static final int DBSIG_2               = 0xB54BFB67;\n    \n    private static final int FILE_VERSION_CRITICAL_MASK = 0xFFFF0000;\n    private static final int FILE_VERSION_32 =            0x02010100;\n    \n    private class PwDbHeaderV4Fields {\n        public static final byte EndOfHeader = 0;\n        @SuppressWarnings(\"unused\")\n\t\tpublic static final byte Comment = 1;\n        public static final byte CipherID = 2;\n        public static final byte CompressionFlags = 3;\n        public static final byte MasterSeed = 4;\n        public static final byte TransformSeed = 5;\n        public static final byte TransformRounds = 6;\n        public static final byte EncryptionIV = 7;\n        public static final byte ProtectedStreamKey = 8;\n        public static final byte StreamStartBytes = 9;\n        public static final byte InnerRandomStreamID = 10;\n\n    }\n    \n    private PwDatabaseV4 db;\n    public byte[] protectedStreamKey;\n    public byte[] streamStartBytes;\n    public CrsAlgorithm innerRandomStream;\n\n    public PwDbHeaderV4(PwDatabaseV4 d) {\n    \tdb = d;\n    }\n\n\t/** Assumes the input stream is at the beginning of the .kdbx file\n\t * @param is\n\t * @throws IOException \n\t * @throws InvalidDBVersionException \n\t */\n\tpublic byte[] loadFromFile(InputStream is) throws IOException, InvalidDBVersionException {\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"No SHA-256 implementation\");\n\t\t}\n\t\t\n\t\tDigestInputStream dis = new DigestInputStream(is, md);\n\t\tLEDataInputStream lis = new LEDataInputStream(dis);\n\n\t\tint sig1 = lis.readInt();\n\t\tint sig2 = lis.readInt();\n\t\t\n\t\tif ( ! matchesHeader(sig1, sig2) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tlong version = lis.readUInt();\n\t\tif ( ! validVersion(version) ) {\n\t\t\tthrow new InvalidDBVersionException();\n\t\t}\n\t\t\n\t\tboolean done = false;\n\t\twhile ( ! done ) {\n\t\t\tdone = readHeaderField(lis);\n\t\t}\n\t\t\n\t\treturn md.digest();\n\t}\n\t\n\tprivate boolean readHeaderField(LEDataInputStream dis) throws IOException {\n\t\tbyte fieldID = (byte) dis.read();\n\t\t\n\t\tint fieldSize = dis.readShort();\n\t\t\n\t\tbyte[] fieldData = null;\n\t\tif ( fieldSize > 0 ) {\n\t\t\tfieldData = new byte[fieldSize];\n\t\t\t\n\t\t\tint readSize = dis.read(fieldData);\n\t\t\tif ( readSize != fieldSize ) {\n\t\t\t\tthrow new IOException(\"Header ended early.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\tswitch ( fieldID ) {\n\t\t\tcase PwDbHeaderV4Fields.EndOfHeader:\n\t\t\t\treturn true;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CipherID:\n\t\t\t\tsetCipher(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.CompressionFlags:\n\t\t\t\tsetCompressionFlags(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.MasterSeed:\n\t\t\t\tmasterSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformSeed:\n\t\t\t\ttransformSeed = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.TransformRounds:\n\t\t\t\tsetTransformRounds(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.EncryptionIV:\n\t\t\t\tencryptionIV = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.ProtectedStreamKey:\n\t\t\t\tprotectedStreamKey = fieldData;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.StreamStartBytes:\n\t\t\t\tstreamStartBytes = fieldData;\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcase PwDbHeaderV4Fields.InnerRandomStreamID:\n\t\t\t\tsetRandomStreamID(fieldData);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow new IOException(\"Invalid header type.\");\n\t\t\t\n\t\t}\n\t\t\n\t\treturn false;\n\t}\n\t\n\tprivate void setCipher(byte[] pbId) throws IOException {\n\t\tif ( pbId == null || pbId.length != 16 ) {\n\t\t\tthrow new IOException(\"Invalid cipher ID.\");\n\t\t}\n\t\t\n\t\tdb.dataCipher = Types.bytestoUUID(pbId);\n\t}\n\t\n\tprivate void setCompressionFlags(byte[] pbFlags) throws IOException {\n\t\tif ( pbFlags == null || pbFlags.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid compression flags.\");\n\t\t}\n\t\t\n\t\tint flag = LEDataInputStream.readInt(pbFlags, 0);\n\t\tif ( flag < 0 || flag >= PwCompressionAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Unrecognized compression flag.\");\n\t\t}\n\t\t\n\t\tdb.compressionAlgorithm = PwCompressionAlgorithm.fromId(flag);\n\t\t\n\t}\n\t\n\tprivate void setTransformRounds(byte[] rounds) throws IOException {\n\t\tif ( rounds == null || rounds.length != 8 ) {\n\t\t\tthrow new IOException(\"Invalid rounds.\");\n\t\t}\n\t\t\n\t\tlong rnd = LEDataInputStream.readLong(rounds, 0);\n\t\t\n\t\tif ( rnd < 0 || rnd > Integer.MAX_VALUE ) {\n\t\t\t//TODO: Actually support really large numbers\n\t\t\tthrow new IOException(\"Rounds higher than \" + Integer.MAX_VALUE + \" are not currently supported.\");\n\t\t}\n\t\t\n\t\tdb.numKeyEncRounds = rnd;\n\t\t\n\t}\n\t\n\tprivate void setRandomStreamID(byte[] streamID) throws IOException {\n\t\tif ( streamID == null || streamID.length != 4 ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tint id = LEDataInputStream.readInt(streamID, 0);\n\t\tif ( id < 0 || id >= CrsAlgorithm.count ) {\n\t\t\tthrow new IOException(\"Invalid stream id.\");\n\t\t}\n\t\t\n\t\tinnerRandomStream = CrsAlgorithm.fromId(id);\n\t}\n\t\n\t/** Determines if this is a supported version.\n\t * \n\t *  A long is needed here to represent the unsigned int since we perform\n\t *  arithmetic on it.\n\t * @param version\n\t * @return\n\t */\n\tprivate boolean validVersion(long version) {\n\t\t\n\t\treturn ! ((version & FILE_VERSION_CRITICAL_MASK) > (FILE_VERSION_32 & FILE_VERSION_CRITICAL_MASK));\n\t\t\n\t}\n\n\tpublic static boolean matchesHeader(int sig1, int sig2) {\n\t\treturn (sig1 == PWM_DBSIG_1) && ( (sig2 == DBSIG_2) || (sig2 == DBSIG_2) );\n\t}\n    \n}\n","lineNo":77}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.view.PwEntryView;\nimport com.keepassdroid.view.PwGroupView;\n\npublic class PwGroupListAdapter extends BaseAdapter {\n\n\tprivate GroupBaseActivity mAct;\n\tprivate PwGroup mGroup;\n\tprivate List<PwGroup> groupsForViewing;\n\tprivate List<PwEntry> entriesForViewing;\n\tprivate Comparator<PwEntry> entryComp = new PwEntry.EntryNameComparator();\n\tprivate Comparator<PwGroup> groupComp = new PwGroup.GroupNameComparator();\n\tprivate SharedPreferences prefs;\n\t\n\tpublic PwGroupListAdapter(GroupBaseActivity act, PwGroup group) {\n\t\tmAct = act;\n\t\tmGroup = group;\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(act);\n\t\t\n\t\tfilterAndSort();\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void notifyDataSetChanged() {\n\t\tsuper.notifyDataSetChanged();\n\t\t\n\t\tfilterAndSort();\n\t}\n\n\t@Override\n\tpublic void notifyDataSetInvalidated() {\n\t\tsuper.notifyDataSetInvalidated();\n\t\t\n\t\tfilterAndSort();\n\t}\n\n\tprivate void filterAndSort() {\n\t\tentriesForViewing = new ArrayList<PwEntry>();\n\t\t\n\t\tfor (int i = 0; i < mGroup.childEntries.size(); i++) {\n\t\t\tPwEntry entry = mGroup.childEntries.get(i);\n\t\t\tif ( ! entry.isMetaStream() ) {\n\t\t\t\tentriesForViewing.add(entry);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean sortLists = prefs.getBoolean(mAct.getString(R.string.sort_key),\tmAct.getResources().getBoolean(R.bool.sort_default)); \n\t\tif ( sortLists ) {\n\t\t\tgroupsForViewing = new ArrayList<PwGroup>(mGroup.childGroups);\n\t\t\t\n\t\t\tCollections.sort(entriesForViewing, entryComp);\n\t\t\tCollections.sort(groupsForViewing, groupComp);\n\t\t} else {\n\t\t\tgroupsForViewing = mGroup.childGroups;\n\t\t}\n\t}\n\t\n\tpublic int getCount() {\n\t\t\n\t\treturn groupsForViewing.size() + entriesForViewing.size();\n\t}\n\n\tpublic Object getItem(int position) {\n\t\treturn position;\n\t}\n\n\tpublic long getItemId(int position) {\n\t\treturn position;\n\t}\n\n\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\tint size = groupsForViewing.size();\n\t\t\n\t\tif ( position < size ) { \n\t\t\treturn createGroupView(position, convertView);\n\t\t} else {\n\t\t\treturn createEntryView(position - size, convertView);\n\t\t}\n\t}\n\n\tprivate View createGroupView(int position, View convertView) {\n\t\tPwGroupView gv;\n\n\t\tPwGroup group = groupsForViewing.get(position);\n\t\tgv = PwGroupView.getInstance(mAct, group);\n\n\t\treturn gv;\n\t}\n\n\tprivate PwEntryView createEntryView(int position, View convertView) {\n\t\tPwEntryView ev;\n\n\t\tev = PwEntryView.getInstance(mAct, entriesForViewing.get(position), position);\n\n\t\treturn ev;\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.BaseAdapter;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.view.PwEntryView;\nimport com.keepassdroid.view.PwGroupView;\n\npublic class PwGroupListAdapter extends BaseAdapter {\n\n\tprivate GroupBaseActivity mAct;\n\tprivate PwGroup mGroup;\n\tprivate List<PwGroup> groupsForViewing;\n\tprivate List<PwEntry> entriesForViewing;\n\tprivate Comparator<PwEntry> entryComp = new PwEntry.EntryNameComparator();\n\tprivate Comparator<PwGroup> groupComp = new PwGroup.GroupNameComparator();\n\tprivate SharedPreferences prefs;\n\t\n\tpublic PwGroupListAdapter(GroupBaseActivity act, PwGroup group) {\n\t\tmAct = act;\n\t\tmGroup = group;\n\t\tprefs = PreferenceManager.getDefaultSharedPreferences(act);\n\t\t\n\t\tfilterAndSort();\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void notifyDataSetChanged() {\n\t\tsuper.notifyDataSetChanged();\n\t\t\n\t\tfilterAndSort();\n\t}\n\n\t@Override\n\tpublic void notifyDataSetInvalidated() {\n\t\tsuper.notifyDataSetInvalidated();\n\t\t\n\t\tfilterAndSort();\n\t}\n\n\tprivate void filterAndSort() {\n\t\tentriesForViewing = new ArrayList<PwEntry>();\n\t\t\n\t\tfor (int i = 0; i < mGroup.childEntries.size(); i++) {\n\t\t\tPwEntry entry = mGroup.childEntries.get(i);\n\t\t\tif ( ! entry.isMetaStream() ) {\n\t\t\t\tentriesForViewing.add(entry);\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean sortLists = prefs.getBoolean(mAct.getString(R.string.sort_key),\tmAct.getResources().getBoolean(R.bool.sort_default)); \n\t\tif ( sortLists ) {\n\t\t\tgroupsForViewing = new ArrayList<PwGroup>(mGroup.childGroups);\n\t\t\t\n\t\t\tCollections.sort(entriesForViewing, entryComp);\n\t\t\tCollections.sort(groupsForViewing, groupComp);\n\t\t} else {\n\t\t\tgroupsForViewing = mGroup.childGroups;\n\t\t}\n\t}\n\t\n\tpublic int getCount() {\n\t\t\n\t\treturn groupsForViewing.size() + entriesForViewing.size();\n\t}\n\n\tpublic Object getItem(int position) {\n\t\treturn position;\n\t}\n\n\tpublic long getItemId(int position) {\n\t\treturn position;\n\t}\n\n\tpublic View getView(int position, View convertView, ViewGroup parent) {\n\t\tint size = groupsForViewing.size();\n\t\t\n\t\tif ( position < size ) { \n\t\t\treturn createGroupView(position, convertView);\n\t\t} else {\n\t\t\treturn createEntryView(position - size, convertView);\n\t\t}\n\t}\n\n\tprivate View createGroupView(int position, View convertView) {\n\t\tPwGroup group = groupsForViewing.get(position);\n\t\tPwGroupView gv;\n\t\t\n\t\tif (convertView == null || !(convertView instanceof PwGroupView)) {\n\t\n\t\t\tgv = PwGroupView.getInstance(mAct, group);\n\t\t} \n\t\telse {\n\t\t\tgv = (PwGroupView) convertView;\n\t\t\tgv.convertView(group);\n\t\t\t\n\t\t}\n\t\t\n\t\treturn gv;\n\t}\n\n\tprivate PwEntryView createEntryView(int position, View convertView) {\n\t\tPwEntry entry = entriesForViewing.get(position);\n\t\tPwEntryView ev;\n\n\t\tif (convertView == null || !(convertView instanceof PwEntryView)) {\n\t\t\tev = PwEntryView.getInstance(mAct, entry, position);\n\t\t}\n\t\telse {\n\t\t\tev = (PwEntryView) convertView;\n\t\t\tev.convertView(entry, position);\n\t\t}\n\n\t\treturn ev;\n\t}\n\n}\n","lineNo":134}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.utils.Types;\n\npublic class PwEntryOutputV3 {\n\t// Constants\n\tpublic static final byte[] UUID_FIELD_TYPE =     Types.writeShort(1);\n\tpublic static final byte[] GROUPID_FIELD_TYPE =  Types.writeShort(2);\n\tpublic static final byte[] IMAGEID_FIELD_TYPE =  Types.writeShort(3);\n\tpublic static final byte[] TITLE_FIELD_TYPE =    Types.writeShort(4);\n\tpublic static final byte[] URL_FIELD_TYPE =      Types.writeShort(5);\n\tpublic static final byte[] USERNAME_FIELD_TYPE =  Types.writeShort(6);\n\tpublic static final byte[] PASSWORD_FIELD_TYPE = Types.writeShort(7);\n\tpublic static final byte[] ADDITIONAL_FIELD_TYPE =   Types.writeShort(8);\n\tpublic static final byte[] CREATE_FIELD_TYPE =   Types.writeShort(9);\n\tpublic static final byte[] MOD_FIELD_TYPE =   Types.writeShort(10);\n\tpublic static final byte[] ACCESS_FIELD_TYPE =   Types.writeShort(11);\n\tpublic static final byte[] EXPIRE_FIELD_TYPE =   Types.writeShort(12);\n\tpublic static final byte[] BINARY_DESC_FIELD_TYPE =   Types.writeShort(13);\n\tpublic static final byte[] BINARY_DATA_FIELD_TYPE =   Types.writeShort(14);\n\tpublic static final byte[] END_FIELD_TYPE =     Types.writeShort(0xFFFF);\n\tpublic static final byte[] LONG_FOUR = Types.writeInt(4);\n\tpublic static final byte[] UUID_FIELD_SIZE =    Types.writeInt(16);\n\tpublic static final byte[] DATE_FIELD_SIZE =    Types.writeInt(5);\n\tpublic static final byte[] IMAGEID_FIELD_SIZE = LONG_FOUR;\n\tpublic static final byte[] LEVEL_FIELD_SIZE =   LONG_FOUR;\n\tpublic static final byte[] FLAGS_FIELD_SIZE =   LONG_FOUR;\n\tpublic static final byte[] ZERO_FIELD_SIZE =    Types.writeInt(0);\n\tpublic static final byte[] ZERO_FIVE       =   {0x00, 0x00, 0x00, 0x00, 0x00};\n\tpublic static final byte[] TEST = {0x33, 0x33, 0x33, 0x33};\n\n\tprivate OutputStream mOS;\n\tprivate PwEntryV3 mPE;\n\tprivate long outputBytes = 0;\n\t\n\t/** Output the PwGroupV3 to the stream\n\t * @param pe\n\t * @param os\n\t */\n\tpublic PwEntryOutputV3(PwEntryV3 pe, OutputStream os) {\n\t\tmPE = pe;\n\t\tmOS = os;\n\t}\n\n\t//NOTE: Need be to careful about using ints.  The actual type written to file is a unsigned int\n\tpublic void output() throws IOException {\n\t\t\n\t\toutputBytes += 134;  // Length of fixed size fields\n\t\t\n\t\t// UUID\n\t\tmOS.write(UUID_FIELD_TYPE);\n\t\tmOS.write(UUID_FIELD_SIZE);\n\t\tmOS.write(Types.UUIDtoBytes(mPE.getUUID()));\n\t\t\n\t\t// Group ID\n\t\tmOS.write(GROUPID_FIELD_TYPE);\n\t\tmOS.write(LONG_FOUR);\n\t\tmOS.write(Types.writeInt(mPE.groupId));\n\t\t\n\t\t// Image ID\n\t\tif (mPE.icon != null) {\n\t\t\tmOS.write(IMAGEID_FIELD_TYPE);\n\t\t\tmOS.write(LONG_FOUR);\n\t\t\tmOS.write(Types.writeInt(mPE.icon.iconId));\n\t\t}\n\n\t\t// Title\n\t\t//byte[] title = mPE.title.getBytes(\"UTF-8\");\n\t\tmOS.write(TITLE_FIELD_TYPE);\n\t\tint titleLen = Types.writeCString(mPE.title, mOS);\n\t\toutputBytes += titleLen;\n\n\t\t// URL\n\t\tmOS.write(URL_FIELD_TYPE);\n\t\tint urlLen = Types.writeCString(mPE.url, mOS);\n\t\toutputBytes += urlLen;\n\t\t\n\t\t// Username\n\t\tmOS.write(USERNAME_FIELD_TYPE);\n\t\tint userLen = Types.writeCString(mPE.username, mOS);\n\t\toutputBytes += userLen;\n\t\t\n\t\t// Password\n\t\tbyte[] password = mPE.getPasswordBytes();\n\t\tmOS.write(PASSWORD_FIELD_TYPE);\n\t\tmOS.write(Types.writeInt(password.length+1));\n\t\tmOS.write(password);\n\t\tmOS.write(0);\n\t\toutputBytes += password.length + 1;\n\n\t\t// Additional\n\t\tmOS.write(ADDITIONAL_FIELD_TYPE);\n\t\tint addlLen = Types.writeCString(mPE.additional, mOS);\n\t\toutputBytes += addlLen;\n\n\t\t// Create date\n\t\tif (mPE.tCreation != null) {\n\t\t\twriteDate(CREATE_FIELD_TYPE, mPE.tCreation.getCDate());\n\t\t}\n\t\t\n\t\t// Modification date\n\t\tif (mPE.tLastMod != null) {\n\t\t\twriteDate(MOD_FIELD_TYPE, mPE.tLastMod.getCDate());\n\t\t}\n\n\t\t// Access date\n\t\tif (mPE.tLastAccess != null) {\n\t\t\twriteDate(ACCESS_FIELD_TYPE, mPE.tLastAccess.getCDate());\n\t\t}\n\n\t\t// Expiration date\n\t\tif (mPE.tExpire != null) {\n\t\t\twriteDate(EXPIRE_FIELD_TYPE, mPE.tExpire.getCDate());\n\t\t}\n\t\n\t\t// Binary desc\n\t\tif (mPE.binaryDesc != null) {\n\t\t\tmOS.write(BINARY_DESC_FIELD_TYPE);\n\t\t\tint descLen = Types.writeCString(mPE.binaryDesc, mOS);\n\t\t\toutputBytes += descLen;\n\t\t}\n\t\n\t\t// Binary data\n\t\tint dataLen = writeByteArray(mPE.getBinaryData());\n\t\toutputBytes += dataLen;\n\n\t\t// End\n\t\tmOS.write(END_FIELD_TYPE);\n\t\tmOS.write(ZERO_FIELD_SIZE);\n\t}\n\t\n\tprivate int writeByteArray(byte[] data) throws IOException {\n\t\tint dataLen;\n\t\tif ( data != null ) {\n\t\t\tdataLen = data.length;\n\t\t} else {\n\t\t\tdataLen = 0;\n\t\t}\n\t\tmOS.write(BINARY_DATA_FIELD_TYPE);\n\t\tmOS.write(Types.writeInt(dataLen));\n\t\tif ( data != null ) {\n\t\t\tmOS.write(data);\n\t\t}\n\t\t\n\t\treturn dataLen;\n\n\t}\n\t\n\tprivate void writeDate(byte[] type, byte[] date) throws IOException {\n\t\tmOS.write(type);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tif ( date != null ) {\n\t\t\tmOS.write(date);\n\t\t} else {\n\t\t\tmOS.write(ZERO_FIVE);\n\t\t}\n\t}\n\t\n\t/** Returns the number of bytes written by the stream\n\t * @return Number of bytes written\n\t */\n\tpublic long getLength() {\n\t\treturn outputBytes;\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.save;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.utils.Types;\n\npublic class PwEntryOutputV3 {\n\t// Constants\n\tpublic static final byte[] UUID_FIELD_TYPE =     Types.writeShort(1);\n\tpublic static final byte[] GROUPID_FIELD_TYPE =  Types.writeShort(2);\n\tpublic static final byte[] IMAGEID_FIELD_TYPE =  Types.writeShort(3);\n\tpublic static final byte[] TITLE_FIELD_TYPE =    Types.writeShort(4);\n\tpublic static final byte[] URL_FIELD_TYPE =      Types.writeShort(5);\n\tpublic static final byte[] USERNAME_FIELD_TYPE =  Types.writeShort(6);\n\tpublic static final byte[] PASSWORD_FIELD_TYPE = Types.writeShort(7);\n\tpublic static final byte[] ADDITIONAL_FIELD_TYPE =   Types.writeShort(8);\n\tpublic static final byte[] CREATE_FIELD_TYPE =   Types.writeShort(9);\n\tpublic static final byte[] MOD_FIELD_TYPE =   Types.writeShort(10);\n\tpublic static final byte[] ACCESS_FIELD_TYPE =   Types.writeShort(11);\n\tpublic static final byte[] EXPIRE_FIELD_TYPE =   Types.writeShort(12);\n\tpublic static final byte[] BINARY_DESC_FIELD_TYPE =   Types.writeShort(13);\n\tpublic static final byte[] BINARY_DATA_FIELD_TYPE =   Types.writeShort(14);\n\tpublic static final byte[] END_FIELD_TYPE =     Types.writeShort(0xFFFF);\n\tpublic static final byte[] LONG_FOUR = Types.writeInt(4);\n\tpublic static final byte[] UUID_FIELD_SIZE =    Types.writeInt(16);\n\tpublic static final byte[] DATE_FIELD_SIZE =    Types.writeInt(5);\n\tpublic static final byte[] IMAGEID_FIELD_SIZE = LONG_FOUR;\n\tpublic static final byte[] LEVEL_FIELD_SIZE =   LONG_FOUR;\n\tpublic static final byte[] FLAGS_FIELD_SIZE =   LONG_FOUR;\n\tpublic static final byte[] ZERO_FIELD_SIZE =    Types.writeInt(0);\n\tpublic static final byte[] ZERO_FIVE       =   {0x00, 0x00, 0x00, 0x00, 0x00};\n\tpublic static final byte[] TEST = {0x33, 0x33, 0x33, 0x33};\n\n\tprivate OutputStream mOS;\n\tprivate PwEntryV3 mPE;\n\tprivate long outputBytes = 0;\n\t\n\t/** Output the PwGroupV3 to the stream\n\t * @param pe\n\t * @param os\n\t */\n\tpublic PwEntryOutputV3(PwEntryV3 pe, OutputStream os) {\n\t\tmPE = pe;\n\t\tmOS = os;\n\t}\n\n\t//NOTE: Need be to careful about using ints.  The actual type written to file is a unsigned int\n\tpublic void output() throws IOException {\n\t\t\n\t\toutputBytes += 134;  // Length of fixed size fields\n\t\t\n\t\t// UUID\n\t\tmOS.write(UUID_FIELD_TYPE);\n\t\tmOS.write(UUID_FIELD_SIZE);\n\t\tmOS.write(Types.UUIDtoBytes(mPE.getUUID()));\n\t\t\n\t\t// Group ID\n\t\tmOS.write(GROUPID_FIELD_TYPE);\n\t\tmOS.write(LONG_FOUR);\n\t\tmOS.write(Types.writeInt(mPE.groupId));\n\t\t\n\t\t// Image ID\n\t\tif (mPE.icon != null) {\n\t\t\tmOS.write(IMAGEID_FIELD_TYPE);\n\t\t\tmOS.write(LONG_FOUR);\n\t\t\tmOS.write(Types.writeInt(mPE.icon.iconId));\n\t\t}\n\n\t\t// Title\n\t\t//byte[] title = mPE.title.getBytes(\"UTF-8\");\n\t\tif (mPE.title != null) {\n\t\t\tmOS.write(TITLE_FIELD_TYPE);\n\t\t\tint titleLen = Types.writeCString(mPE.title, mOS);\n\t\t\toutputBytes += titleLen;\n\t\t}\n\n\t\t// URL\n\t\tif (mPE.url != null) {\n\t\t\tmOS.write(URL_FIELD_TYPE);\n\t\t\tint urlLen = Types.writeCString(mPE.url, mOS);\n\t\t\toutputBytes += urlLen;\n\t\t}\n\t\t\n\t\t// Username\n\t\tif (mPE.username != null) {\n\t\t\tmOS.write(USERNAME_FIELD_TYPE);\n\t\t\tint userLen = Types.writeCString(mPE.username, mOS);\n\t\t\toutputBytes += userLen;\n\t\t}\n\t\t\n\t\t// Password\n\t\tbyte[] password = mPE.getPasswordBytes();\n\t\tmOS.write(PASSWORD_FIELD_TYPE);\n\t\tmOS.write(Types.writeInt(password.length+1));\n\t\tmOS.write(password);\n\t\tmOS.write(0);\n\t\toutputBytes += password.length + 1;\n\n\t\t// Additional\n\t\tif (mPE.additional != null) {\n\t\t\tmOS.write(ADDITIONAL_FIELD_TYPE);\n\t\t\tint addlLen = Types.writeCString(mPE.additional, mOS);\n\t\t\toutputBytes += addlLen;\n\t\t}\n\n\t\t// Create date\n\t\tif (mPE.tCreation != null) {\n\t\t\twriteDate(CREATE_FIELD_TYPE, mPE.tCreation.getCDate());\n\t\t}\n\t\t\n\t\t// Modification date\n\t\tif (mPE.tLastMod != null) {\n\t\t\twriteDate(MOD_FIELD_TYPE, mPE.tLastMod.getCDate());\n\t\t}\n\n\t\t// Access date\n\t\tif (mPE.tLastAccess != null) {\n\t\t\twriteDate(ACCESS_FIELD_TYPE, mPE.tLastAccess.getCDate());\n\t\t}\n\n\t\t// Expiration date\n\t\tif (mPE.tExpire != null) {\n\t\t\twriteDate(EXPIRE_FIELD_TYPE, mPE.tExpire.getCDate());\n\t\t}\n\t\n\t\t// Binary desc\n\t\tif (mPE.binaryDesc != null) {\n\t\t\tmOS.write(BINARY_DESC_FIELD_TYPE);\n\t\t\tint descLen = Types.writeCString(mPE.binaryDesc, mOS);\n\t\t\toutputBytes += descLen;\n\t\t}\n\t\n\t\t// Binary data\n\t\tbyte[] binaryData = mPE.getBinaryData();\n\t\tif (binaryData != null) {\n\t\t\tint dataLen = writeByteArray(binaryData);\n\t\t\toutputBytes += dataLen;\n\t\t}\n\n\t\t// End\n\t\tmOS.write(END_FIELD_TYPE);\n\t\tmOS.write(ZERO_FIELD_SIZE);\n\t}\n\t\n\tprivate int writeByteArray(byte[] data) throws IOException {\n\t\tint dataLen;\n\t\tif ( data != null ) {\n\t\t\tdataLen = data.length;\n\t\t} else {\n\t\t\tdataLen = 0;\n\t\t}\n\t\tmOS.write(BINARY_DATA_FIELD_TYPE);\n\t\tmOS.write(Types.writeInt(dataLen));\n\t\tif ( data != null ) {\n\t\t\tmOS.write(data);\n\t\t}\n\t\t\n\t\treturn dataLen;\n\n\t}\n\t\n\tprivate void writeDate(byte[] type, byte[] date) throws IOException {\n\t\tmOS.write(type);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tif ( date != null ) {\n\t\t\tmOS.write(date);\n\t\t} else {\n\t\t\tmOS.write(ZERO_FIVE);\n\t\t}\n\t}\n\t\n\t/** Returns the number of bytes written by the stream\n\t * @return Number of bytes written\n\t */\n\tpublic long getLength() {\n\t\treturn outputBytes;\n\t}\n}\n","lineNo":155}
{"Smelly Sample":"/*\n * Copyright 2009-2011 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.search;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.PwGroupV4;\n\npublic class SearchDbHelper {\n\tprivate final Context mCtx;\n\t\n\tpublic SearchDbHelper(Context ctx) {\n\t\tmCtx = ctx;\n\t}\n\t\n\tprivate boolean omitBackup() {\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mCtx);\n\t\treturn prefs.getBoolean(mCtx.getString(R.string.omitbackup_key), mCtx.getResources().getBoolean(R.bool.omitbackup_default));\n\t\t\n\t}\n\t\n\tpublic PwGroup search(Database db, String qStr) {\n\n\t\tPwGroup group;\n\t\tif ( db.pm instanceof PwDatabaseV3 ) {\n\t\t\tgroup = new PwGroupV3();\n\t\t} else if ( db.pm instanceof PwDatabaseV4 ) {\n\t\t\tgroup = new PwGroupV4();\n\t\t} else {\n\t\t\tLog.d(\"SearchDbHelper\", \"Tried to search with unknown db\");\n\t\t\treturn null;\n\t\t}\n\t\tgroup.name = \"Search results\";\n\t\tgroup.childEntries = new ArrayList<PwEntry>();\n\t\t\n\t\t// Search all entries\n\t\tqStr = qStr.toLowerCase();\n\t\tboolean isOmitBackup = omitBackup();\n\t\tfor (PwEntry entry : db.pm.getEntries()) {\n\t\t\t\n\t\t\tif (!isOmitBackup || !db.pm.isBackup(entry.getParent())) {\n\t\t\t\t// Search all strings in the entry\n\t\t\t\tIterator<String> iter = entry.stringIterator();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tString str = iter.next().toLowerCase();\n\t\t\t\t\tif (str.contains(qStr)) {\n\t\t\t\t\t\tgroup.childEntries.add(entry);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn group;\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009-2011 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.search;\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.PwGroupV4;\n\npublic class SearchDbHelper {\n\tprivate final Context mCtx;\n\t\n\tpublic SearchDbHelper(Context ctx) {\n\t\tmCtx = ctx;\n\t}\n\t\n\tprivate boolean omitBackup() {\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(mCtx);\n\t\treturn prefs.getBoolean(mCtx.getString(R.string.omitbackup_key), mCtx.getResources().getBoolean(R.bool.omitbackup_default));\n\t\t\n\t}\n\t\n\tpublic PwGroup search(Database db, String qStr) {\n\n\t\tPwGroup group;\n\t\tif ( db.pm instanceof PwDatabaseV3 ) {\n\t\t\tgroup = new PwGroupV3();\n\t\t} else if ( db.pm instanceof PwDatabaseV4 ) {\n\t\t\tgroup = new PwGroupV4();\n\t\t} else {\n\t\t\tLog.d(\"SearchDbHelper\", \"Tried to search with unknown db\");\n\t\t\treturn null;\n\t\t}\n\t\tgroup.name = \"Search results\";\n\t\tgroup.childEntries = new ArrayList<PwEntry>();\n\t\t\n\t\t// Search all entries\n\t\tqStr = qStr.toLowerCase();\n\t\tboolean isOmitBackup = omitBackup();\n\t\tfor (PwEntry entry : db.pm.getEntries()) {\n\t\t\t\n\t\t\tif (!isOmitBackup || !db.pm.isBackup(entry.getParent())) {\n\t\t\t\t// Search all strings in the entry\n\t\t\t\tIterator<String> iter = entry.stringIterator();\n\t\t\t\twhile (iter.hasNext()) {\n\t\t\t\t\tString str = iter.next();\n\t\t\t\t\tif (str != null) {\n\t\t\t\t\t\tString lower = str.toLowerCase();\n\t\t\t\t\t\tif (lower.contains(qStr)) {\n\t\t\t\t\t\t\tgroup.childEntries.add(entry);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn group;\n\t}\n}\n","lineNo":77}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.bouncycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwCustomIcon;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.exception.ArcFourException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\npublic class ImporterV4 extends Importer {\n\t\n\tprivate StreamCipher randomStream;\n\tprivate PwDatabaseV4 db;\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile) throws IOException, InvalidDBException {\n\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile, UpdateStatus status) throws IOException,\n\t\t\tInvalidDBException {\n\n\t\tdb = new PwDatabaseV4();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\t\t\n\t\theader.loadFromFile(inStream);\n\t\t\t\n\t\tdb.setMasterKey(password, keyfile);\n\t\tdb.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);\n\t\t\n\t\t// Attach decryptor\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = CipherFactory.getInstance(db.dataCipher, db.finalKey, header.encryptionIV);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t}\n\t\t\n\t\tInputStream decrypted = new BetterCipherInputStream(inStream, cipher, 50 * 1024);\n\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\tbyte[] storedStartBytes = dataDecrypted.readBytes(32);\n\t\tif ( storedStartBytes == null || storedStartBytes.length != 32 ) {\n\t\t\tthrow new IOException(\"Invalid data.\");\n\t\t}\n\t\t\n\t\tif ( ! Arrays.equals(storedStartBytes, header.streamStartBytes) ) {\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\tHashedBlockInputStream hashed = new HashedBlockInputStream(dataDecrypted); \n\t\t\n\t\tInputStream decompressed;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tdecompressed = new GZIPInputStream(hashed); \n\t\t} else {\n\t\t\tdecompressed = hashed;\n\t\t}\n\t\t\n\t\tif ( header.protectedStreamKey == null ) {\n\t\t\tassert(false);\n\t\t\tthrow new IOException(\"Invalid stream key.\");\n\t\t}\n\t\t\n\t\trandomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);\n\t\t\n\t\tif ( randomStream == null ) {\n\t\t\tthrow new ArcFourException();\n\t\t}\n\t\t\n\t\tReadXmlStreamed(decompressed);\n\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\t\n\tprivate enum KdbContext {\n        Null,\n        KeePassFile,\n        Meta,\n        Root,\n        MemoryProtection,\n        CustomIcons,\n        CustomIcon,\n        CustomData,\n        CustomDataItem,\n        RootDeletedObjects,\n        DeletedObject,\n        Group,\n        GroupTimes,\n        Entry,\n        EntryTimes,\n        EntryString,\n        EntryBinary,\n        EntryAutoType,\n        EntryAutoTypeItem,\n        EntryHistory\n\t}\n\t\n    private static final String ElemDocNode = \"KeePassFile\";\n    private static final String ElemMeta = \"Meta\";\n    private static final String ElemRoot = \"Root\";\n    private static final String ElemGroup = \"Group\";\n    private static final String ElemEntry = \"Entry\";\n\n    private static final String ElemGenerator = \"Generator\";\n    private static final String ElemDbName = \"DatabaseName\";\n    private static final String ElemDbNameChanged = \"DatabaseNameChanged\";\n    private static final String ElemDbDesc = \"DatabaseDescription\";\n    private static final String ElemDbDescChanged = \"DatabaseDescriptionChanged\";\n    private static final String ElemDbDefaultUser = \"DefaultUserName\";\n    private static final String ElemDbDefaultUserChanged = \"DefaultUserNameChanged\";\n    private static final String ElemDbMntncHistoryDays = \"MaintenanceHistoryDays\";\n    private static final String ElemDbKeyChanged = \"MasterKeyChanged\";\n    private static final String ElemDbKeyChangeRec = \"MasterKeyChangeRec\";\n    private static final String ElemDbKeyChangeForce = \"MasterKeyChangeForce\";\n    private static final String ElemRecycleBinEnabled = \"RecycleBinEnabled\";\n    private static final String ElemRecycleBinUuid = \"RecycleBinUUID\";\n    private static final String ElemRecycleBinChanged = \"RecycleBinChanged\";\n    private static final String ElemEntryTemplatesGroup = \"EntryTemplatesGroup\";\n    private static final String ElemEntryTemplatesGroupChanged = \"EntryTemplatesGroupChanged\";\n    private static final String ElemLastSelectedGroup = \"LastSelectedGroup\";\n    private static final String ElemLastTopVisibleGroup = \"LastTopVisibleGroup\";\n\n    private static final String ElemMemoryProt = \"MemoryProtection\";\n    private static final String ElemProtTitle = \"ProtectTitle\";\n    private static final String ElemProtUserName = \"ProtectUserName\";\n    private static final String ElemProtPassword = \"ProtectPassword\";\n    private static final String ElemProtURL = \"ProtectURL\";\n    private static final String ElemProtNotes = \"ProtectNotes\";\n    private static final String ElemProtAutoHide = \"AutoEnableVisualHiding\";\n\n    private static final String ElemCustomIcons = \"CustomIcons\";\n    private static final String ElemCustomIconItem = \"Icon\";\n    private static final String ElemCustomIconItemID = \"UUID\";\n    private static final String ElemCustomIconItemData = \"Data\";\n\n    private static final String ElemAutoType = \"AutoType\";\n    private static final String ElemHistory = \"History\";\n\n    private static final String ElemName = \"Name\";\n    private static final String ElemNotes = \"Notes\";\n    private static final String ElemUuid = \"UUID\";\n    private static final String ElemIcon = \"IconID\";\n    private static final String ElemCustomIconID = \"CustomIconUUID\";\n    private static final String ElemFgColor = \"ForegroundColor\";\n    private static final String ElemBgColor = \"BackgroundColor\";\n    private static final String ElemOverrideUrl = \"OverrideURL\";\n    private static final String ElemTimes = \"Times\";\n    private static final String ElemTags = \"Tags\";\n\n    private static final String ElemCreationTime = \"CreationTime\";\n    private static final String ElemLastModTime = \"LastModificationTime\";\n    private static final String ElemLastAccessTime = \"LastAccessTime\";\n    private static final String ElemExpiryTime = \"ExpiryTime\";\n    private static final String ElemExpires = \"Expires\";\n    private static final String ElemUsageCount = \"UsageCount\";\n    private static final String ElemLocationChanged = \"LocationChanged\";\n\n    private static final String ElemGroupDefaultAutoTypeSeq = \"DefaultAutoTypeSequence\";\n    private static final String ElemEnableAutoType = \"EnableAutoType\";\n    private static final String ElemEnableSearching = \"EnableSearching\";\n\n    private static final String ElemString = \"String\";\n    private static final String ElemBinary = \"Binary\";\n    private static final String ElemKey = \"Key\";\n    private static final String ElemValue = \"Value\";\n\n    private static final String ElemAutoTypeEnabled = \"Enabled\";\n    private static final String ElemAutoTypeObfuscation = \"DataTransferObfuscation\";\n    private static final String ElemAutoTypeDefaultSeq = \"DefaultSequence\";\n    private static final String ElemAutoTypeItem = \"Association\";\n    private static final String ElemWindow = \"Window\";\n    private static final String ElemKeystrokeSequence = \"KeystrokeSequence\";\n\n    private static final String AttrProtected = \"Protected\";\n\n    private static final String ElemIsExpanded = \"IsExpanded\";\n    private static final String ElemLastTopVisibleEntry = \"LastTopVisibleEntry\";\n\n    private static final String ElemDeletedObjects = \"DeletedObjects\";\n    private static final String ElemDeletedObject = \"DeletedObject\";\n    private static final String ElemDeletionTime = \"DeletionTime\";\n\n    @SuppressWarnings(\"unused\")\n\tprivate static final String ValFalse = \"False\";\n    private static final String ValTrue = \"True\";\n\n    private static final String ElemCustomData = \"CustomData\";\n    private static final String ElemStringDictExItem = \"Item\";\n    \n    private static final long DEFAULT_HISTORY_DAYS = 365;\n\n\t\n\tprivate boolean readNextNode = true;\n\tprivate Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();\n\tprivate PwGroupV4 ctxGroup = null;\n\tprivate PwEntryV4 ctxEntry = null;\n\tprivate String ctxStringName = null;\n\tprivate String ctxStringValue = null;\n\tprivate String ctxBinaryName = null;\n\tprivate byte[] ctxBinaryValue = null;\n\tprivate String ctxATName = null;\n\tprivate String ctxATSeq = null;\n\tprivate boolean entryInHistory = false;\n\tprivate PwEntryV4 ctxHistoryBase = null;\n\tprivate PwDeletedObject ctxDeletedObject = null;\n\tprivate UUID customIconID = PwDatabaseV4.UUID_ZERO;\n\tprivate byte[] customIconData;\n\tprivate String customDataKey = null;\n\tprivate String customDataValue = null;\n\t\n\tprivate void ReadXmlStreamed(InputStream readerStream) throws IOException {\n\t\t\n\t\t\ttry {\n\t\t\t\tReadDocumentStreamed(CreatePullParser(readerStream));\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t}\n\t\n\tprivate static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {\n\t\tXmlPullParserFactory xppf = XmlPullParserFactory.newInstance();\n\t\txppf.setNamespaceAware(false);\n\t\t\n\t\tXmlPullParser xpp = xppf.newPullParser();\n\t\txpp.setInput(readerStream, null);\n\t\t\n\t\treturn xpp;\n\t}\n\n\tprivate void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tctxGroups.clear();\n\t\t\n\t\tKdbContext ctx = KdbContext.Null;\n\t\t\n\t\treadNextNode = true;\n\t\t\n\t\twhile (true) {\n\t\t\tif ( readNextNode ) {\n\t\t\t\tif( xpp.next() == XmlPullParser.END_DOCUMENT ) break;\n\t\t\t} else {\n\t\t\t\treadNextNode = true;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ( xpp.getEventType() ) {\n\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\tctx = ReadXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase XmlPullParser.END_TAG:\n\t\t\t\tctx = EndXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Error checks\n\t\tif ( ctx != KdbContext.Null ) throw new IOException(\"Malformed\");\n\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Malformed\");\n\t}\n\n\n\tprivate KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tString name = xpp.getName();\n\t\tswitch (ctx) {\n\t\tcase Null:\n\t\t\tif ( name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.KeePassFile, xpp);\n\t\t\t} else ReadUnknown(xpp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase KeePassFile:\n\t\t\tif ( name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Meta, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Root, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Meta:\n\t\t\tif ( name.equalsIgnoreCase(ElemGenerator) ) {\n\t\t\t\tReadString(xpp); // Ignore\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbName) ) {\n\t\t\t\tdb.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {\n\t\t\t\tdb.nameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {\n\t\t\t\tdb.description = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {\n\t\t\t\tdb.descriptionChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {\n\t\t\t\tdb.defaultUserName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {\n\t\t\t\tdb.defaultUserNameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {\n\t\t\t\tdb.keyChangeRecDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {\n\t\t\t\tdb.keyChangeForceDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.MemoryProtection, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcons, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {\n\t\t\t\tdb.recycleBinEnabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {\n\t\t\t\tdb.recycleBinUUID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {\n\t\t\t\tdb.recycleBinChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {\n\t\t\t\tdb.entryTemplatesGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {\n\t\t\t\tdb.lastSelectedGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {\n\t\t\t\tdb.lastTopVisibleGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomData, xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MemoryProtection:\n\t\t\tif ( name.equalsIgnoreCase(ElemProtTitle) ) {\n\t\t\t\tdb.memoryProtection.protectTitle = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {\n\t\t\t\tdb.memoryProtection.protectUserName = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {\n\t\t\t\tdb.memoryProtection.protectPassword = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtURL) ) {\n\t\t\t\tdb.memoryProtection.protectUrl = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {\n\t\t\t\tdb.memoryProtection.protectNotes = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {\n\t\t\t\tdb.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcons:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcon, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcon:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {\n\t\t\t\tcustomIconID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {\n\t\t\t\tString strData = ReadString(xpp);\n\t\t\t\tif ( strData != null && strData.length() > 0 ) {\n\t\t\t\t\tcustomIconData = Base64Coder.decode(strData);\n\t\t\t\t} else {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CustomData:\n\t\t\tif ( name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomDataItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tcustomDataKey = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tcustomDataValue = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Root:\n\t\t\tif ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tassert(ctxGroups.size() == 0);\n\t\t\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Group list should be empty.\");\n\t\t\t\t\n\t\t\t\tdb.rootGroup = new PwGroupV4();\n\t\t\t\tctxGroups.push((PwGroupV4)db.rootGroup);\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Group:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxGroup.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemName) ) {\n\t\t\t\tctxGroup.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemNotes) ) {\n\t\t\t\tctxGroup.notes = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxGroup.iconId = (int)ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxGroup.customIconUuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {\n\t\t\t\tctxGroup.isExpanded = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {\n\t\t\t\tctxGroup.defaultAutoTypeSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {\n\t\t\t\tctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {\n\t\t\t\tctxGroup.enableSearching = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {\n\t\t\t\tctxGroup.lastTopVisibleEntry = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tctxGroup = new PwGroupV4();\n\t\t\t\tctxGroups.peek().AddGroup(ctxGroup, true);\n\t\t\t\tctxGroups.push(ctxGroup);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxGroup.AddEntry(ctxEntry, true);\n\t\t\t\t\n\t\t\t\tentryInHistory = false;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Entry:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxEntry.setUUID(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxEntry.imageId = (int)ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxEntry.customIconUuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemFgColor) ) {\n\t\t\t\tctxEntry.foregroundColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBgColor) ) {\n\t\t\t\tctxEntry.backgroupColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {\n\t\t\t\tctxEntry.overrideURL = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTags) ) {\n\t\t\t\tctxEntry.tags = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemString) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryString, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryBinary, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoType, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\t\tassert(!entryInHistory);\n\t\t\t\t\n\t\t\t\tif ( ! entryInHistory ) {\n\t\t\t\t\tctxHistoryBase = ctxEntry;\n\t\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryHistory, xpp);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase GroupTimes:\n\t\tcase EntryTimes:\n\t\t\tITimeLogger tl;\n\t\t\tif ( ctx == KdbContext.GroupTimes ) {\n\t\t\t\ttl = ctxGroup;\n\t\t\t} else {\n\t\t\t\ttl = ctxEntry;\n\t\t\t}\n\t\t\t\n\t\t\tif ( name.equalsIgnoreCase(ElemLastModTime) ) {\n\t\t\t\ttl.setLastModificationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {\n\t\t\t\ttl.setCreationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {\n\t\t\t\ttl.setLastAccessTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {\n\t\t\t\ttl.setExpiryTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpires) ) {\n\t\t\t\ttl.setExpires(ReadBool(xpp, false));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {\n\t\t\t\ttl.setUsageCount(ReadULong(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {\n\t\t\t\ttl.setLocationChanged(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryString:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxStringName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxStringValue = ReadProtectedString(xpp); \n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryBinary:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxBinaryName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxBinaryValue = ReadProtectedBinary(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoType:\n\t\t\tif ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {\n\t\t\t\tctxEntry.autoType.enabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {\n\t\t\t\tctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {\n\t\t\t\tctxEntry.autoType.defaultSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoTypeItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemWindow) ) {\n\t\t\t\tctxATName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {\n\t\t\t\tctxATSeq = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryHistory:\n\t\t\tif ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxHistoryBase.history.add(ctxEntry);\n\t\t\t\t\n\t\t\t\tentryInHistory = true;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase RootDeletedObjects:\n\t\t\tif ( name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\t\tctxDeletedObject = new PwDeletedObject();\n\t\t\t\tdb.deletedObjects.add(ctxDeletedObject);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.DeletedObject, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase DeletedObject:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxDeletedObject.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {\n\t\t\t\tctxDeletedObject.setDeletionTime(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tReadUnknown(xpp);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ctx;\n\t}\n\n\tprivate KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {\n\t\tassert(xpp.getEventType() == XmlPullParser.END_TAG);\n\t\t\n\t\tString name = xpp.getName();\n\t\tif ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\treturn KdbContext.Null;\n\t\t} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\tif ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tdb.customIcons.add(new PwCustomIcon(customIconID, customIconData));\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomIconID = PwDatabaseV4.UUID_ZERO;\n\t\t\tcustomIconData = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomIcons;\n\t\t} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\tif ( customDataKey != null && customDataValue != null) {\n\t\t\t\tdb.customData.put(customDataKey, customDataValue);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomDataKey = null;\n\t\t\tcustomDataValue = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomData;\n\t\t} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\tif ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxGroup.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tctxGroups.pop();\n\t\t\t\n\t\t\tif ( ctxGroups.size() == 0 ) {\n\t\t\t\tctxGroup = null;\n\t\t\t\treturn KdbContext.Root;\n\t\t\t} else {\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\treturn KdbContext.Group;\n\t\t\t}\n\t\t} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\tif ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxEntry.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tif ( entryInHistory ) {\n\t\t\t\tctxEntry = ctxHistoryBase;\n\t\t\t\treturn KdbContext.EntryHistory;\n\t\t\t}\n\t\t\t\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {\n\t\t\tctxEntry.strings.put(ctxStringName, ctxStringValue);\n\t\t\tctxStringName = null;\n\t\t\tctxStringValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\tctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);\n\t\t\tctxBinaryName = null;\n\t\t\tctxBinaryValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\tctxEntry.autoType.put(ctxATName, ctxATSeq);\n\t\t\tctxATName = null;\n\t\t\tctxATSeq = null;\n\t\t\t\n\t\t\treturn KdbContext.EntryAutoType;\n\t\t} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\tentryInHistory = false;\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\treturn KdbContext.Root;\n\t\t} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\tctxDeletedObject = null;\n\t\t\treturn KdbContext.RootDeletedObjects;\n\t\t} else {\n\t\t\tassert(false);\n\t\t\t\n\t\t\tthrow new RuntimeException(\"Invalid end element\");\n\t\t}\n\t}\n\t\n\tprivate static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-mm-dd'T'HH:mm:ss'Z'\");\n\tprivate Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString sDate = ReadString(xpp);\n\t\t\n\t\tDate utcDate;\n\t\ttry {\n\t\t\tutcDate = dateFormat.parse(sDate);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\treturn utcDate;\n\t\t\n\t}\n\n\tprivate void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(false);\n\t\t\n\t\tif ( xpp.isEmptyElementTag() ) return;\n\t\t\n\t\tString unknownName = xpp.getName();\n\t\tProcessNode(xpp);\n\t\t\n\t\twhile (xpp.next() != XmlPullParser.END_DOCUMENT ) {\n\t\t\tif ( xpp.getEventType() == XmlPullParser.END_TAG ) break;\n\t\t\tif ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;\n\t\t\t\n\t\t\tReadUnknown(xpp);\n\t\t}\n\t\t\n\t\tassert(xpp.getName() == unknownName);\n\t\t\n\t}\n\t\n\tprivate boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tif ( str.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( str.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn bDefault;\n\t\t}\n\t}\n\t\n\tprivate UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString encoded = ReadString(xpp);\n\t\t\n\t\tif (encoded == null || encoded.length() == 0 ) {\n\t\t\treturn PwDatabaseV4.UUID_ZERO;\n\t\t}\n\t\t\n\t\t// TODO: Switch to framework Base64 once API level 8 is the minimum\n\t\tbyte[] buf = Base64Coder.decode(encoded);\n\t\t\n\t\treturn Types.bytestoUUID(buf);\n\t}\n\t\n\tprivate static final long MAX_UINT = 4294967296L; // 2^32\n\tprivate long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u;\n\t\t\n\t\tu = ReadULong(xpp, uDefault);\n\t\tif ( u < 0 || u > MAX_UINT ) {\n\t\t\tthrow new NumberFormatException(\"Outside of the uint size\");\n\t\t}\n\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tlong u;\n\t\ttry {\n\t\t\tu = Long.parseLong(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u = ReadLong(xpp, uDefault);\n\t\t\n\t\tif ( u < 0 ) {\n\t\t\tu = uDefault;\n\t\t}\n\t\t\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate String ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t} \n\t\t}\n\t\t\n\t\treturn ReadString(xpp);\n\t}\n\t\n\tprivate byte[] ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) return buf;\n\t\t\n\t\tString base64 = ReadString(xpp);\n\t\tif ( base64.length() == 0 ) return new byte[0];\n\t\t\n\t\treturn Base64Coder.decode(base64);\n\t}\n\t\n\tprivate String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t\t\n\t}\n\t\n\tprivate String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t}\n\n\tprivate byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(xpp.getEventType() == XmlPullParser.START_TAG);\n\t\t\n\t\tbyte[] buf = null;\n\t\t\n\t\tif ( xpp.getAttributeCount() > 0 ) {\n\t\t\tString protect = xpp.getAttributeValue(null, AttrProtected);\n\t\t\tif ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {\n\t\t\t\tString encrypted = ReadStringRaw(xpp);\n\t\t\t\t\n\t\t\t\tif ( encrypted.length() > 0 ) {\n\t\t\t\t\tbuf = Base64Coder.decode(encrypted);\n\t\t\t\t\tbyte[] plainText = new byte[buf.length];\n\t\t\t\t\t\n\t\t\t\t\trandomStream.processBytes(buf, 0, buf.length, plainText, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn plainText;\n\t\t\t\t} else {\n\t\t\t\t\tbuf = new byte[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tprivate KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,\n\t\t\tXmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tif ( xpp.isEmptyElementTag() ) {\n\t\t\txpp.next();  // Consume the end tag\n\t\t\treturn ctxCurrent;\n\t\t}\n\t\treturn ctxNew;\n\t}\n\n\n\tprivate Boolean StringToBoolean(String str) {\n\t\tif ( str == null || str.length() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString trimmed = str.trim();\n\t\tif ( trimmed.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( trimmed.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.Stack;\nimport java.util.UUID;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\n\nimport org.bouncycastle.crypto.StreamCipher;\nimport org.xmlpull.v1.XmlPullParser;\nimport org.xmlpull.v1.XmlPullParserException;\nimport org.xmlpull.v1.XmlPullParserFactory;\n\nimport biz.source_code.base64Coder.Base64Coder;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.crypto.PwStreamCipherFactory;\nimport com.keepassdroid.database.ITimeLogger;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwIconCustom;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.PwDeletedObject;\nimport com.keepassdroid.database.PwEntryV4;\nimport com.keepassdroid.database.PwGroupV4;\nimport com.keepassdroid.database.exception.ArcFourException;\nimport com.keepassdroid.database.exception.InvalidDBException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.utils.Types;\n\npublic class ImporterV4 extends Importer {\n\t\n\tprivate StreamCipher randomStream;\n\tprivate PwDatabaseV4 db;\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile) throws IOException, InvalidDBException {\n\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile, UpdateStatus status) throws IOException,\n\t\t\tInvalidDBException {\n\n\t\tdb = new PwDatabaseV4();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\t\t\n\t\theader.loadFromFile(inStream);\n\t\t\t\n\t\tdb.setMasterKey(password, keyfile);\n\t\tdb.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);\n\t\t\n\t\t// Attach decryptor\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = CipherFactory.getInstance(db.dataCipher, db.finalKey, header.encryptionIV);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t}\n\t\t\n\t\tInputStream decrypted = new BetterCipherInputStream(inStream, cipher, 50 * 1024);\n\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\tbyte[] storedStartBytes = dataDecrypted.readBytes(32);\n\t\tif ( storedStartBytes == null || storedStartBytes.length != 32 ) {\n\t\t\tthrow new IOException(\"Invalid data.\");\n\t\t}\n\t\t\n\t\tif ( ! Arrays.equals(storedStartBytes, header.streamStartBytes) ) {\n\t\t\tthrow new InvalidPasswordException();\n\t\t}\n\n\t\tHashedBlockInputStream hashed = new HashedBlockInputStream(dataDecrypted); \n\t\t\n\t\tInputStream decompressed;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tdecompressed = new GZIPInputStream(hashed); \n\t\t} else {\n\t\t\tdecompressed = hashed;\n\t\t}\n\t\t\n\t\tif ( header.protectedStreamKey == null ) {\n\t\t\tassert(false);\n\t\t\tthrow new IOException(\"Invalid stream key.\");\n\t\t}\n\t\t\n\t\trandomStream = PwStreamCipherFactory.getInstance(header.innerRandomStream, header.protectedStreamKey);\n\t\t\n\t\tif ( randomStream == null ) {\n\t\t\tthrow new ArcFourException();\n\t\t}\n\t\t\n\t\tReadXmlStreamed(decompressed);\n\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\t\n\tprivate enum KdbContext {\n        Null,\n        KeePassFile,\n        Meta,\n        Root,\n        MemoryProtection,\n        CustomIcons,\n        CustomIcon,\n        CustomData,\n        CustomDataItem,\n        RootDeletedObjects,\n        DeletedObject,\n        Group,\n        GroupTimes,\n        Entry,\n        EntryTimes,\n        EntryString,\n        EntryBinary,\n        EntryAutoType,\n        EntryAutoTypeItem,\n        EntryHistory\n\t}\n\t\n    private static final String ElemDocNode = \"KeePassFile\";\n    private static final String ElemMeta = \"Meta\";\n    private static final String ElemRoot = \"Root\";\n    private static final String ElemGroup = \"Group\";\n    private static final String ElemEntry = \"Entry\";\n\n    private static final String ElemGenerator = \"Generator\";\n    private static final String ElemDbName = \"DatabaseName\";\n    private static final String ElemDbNameChanged = \"DatabaseNameChanged\";\n    private static final String ElemDbDesc = \"DatabaseDescription\";\n    private static final String ElemDbDescChanged = \"DatabaseDescriptionChanged\";\n    private static final String ElemDbDefaultUser = \"DefaultUserName\";\n    private static final String ElemDbDefaultUserChanged = \"DefaultUserNameChanged\";\n    private static final String ElemDbMntncHistoryDays = \"MaintenanceHistoryDays\";\n    private static final String ElemDbKeyChanged = \"MasterKeyChanged\";\n    private static final String ElemDbKeyChangeRec = \"MasterKeyChangeRec\";\n    private static final String ElemDbKeyChangeForce = \"MasterKeyChangeForce\";\n    private static final String ElemRecycleBinEnabled = \"RecycleBinEnabled\";\n    private static final String ElemRecycleBinUuid = \"RecycleBinUUID\";\n    private static final String ElemRecycleBinChanged = \"RecycleBinChanged\";\n    private static final String ElemEntryTemplatesGroup = \"EntryTemplatesGroup\";\n    private static final String ElemEntryTemplatesGroupChanged = \"EntryTemplatesGroupChanged\";\n    private static final String ElemLastSelectedGroup = \"LastSelectedGroup\";\n    private static final String ElemLastTopVisibleGroup = \"LastTopVisibleGroup\";\n\n    private static final String ElemMemoryProt = \"MemoryProtection\";\n    private static final String ElemProtTitle = \"ProtectTitle\";\n    private static final String ElemProtUserName = \"ProtectUserName\";\n    private static final String ElemProtPassword = \"ProtectPassword\";\n    private static final String ElemProtURL = \"ProtectURL\";\n    private static final String ElemProtNotes = \"ProtectNotes\";\n    private static final String ElemProtAutoHide = \"AutoEnableVisualHiding\";\n\n    private static final String ElemCustomIcons = \"CustomIcons\";\n    private static final String ElemCustomIconItem = \"Icon\";\n    private static final String ElemCustomIconItemID = \"UUID\";\n    private static final String ElemCustomIconItemData = \"Data\";\n\n    private static final String ElemAutoType = \"AutoType\";\n    private static final String ElemHistory = \"History\";\n\n    private static final String ElemName = \"Name\";\n    private static final String ElemNotes = \"Notes\";\n    private static final String ElemUuid = \"UUID\";\n    private static final String ElemIcon = \"IconID\";\n    private static final String ElemCustomIconID = \"CustomIconUUID\";\n    private static final String ElemFgColor = \"ForegroundColor\";\n    private static final String ElemBgColor = \"BackgroundColor\";\n    private static final String ElemOverrideUrl = \"OverrideURL\";\n    private static final String ElemTimes = \"Times\";\n    private static final String ElemTags = \"Tags\";\n\n    private static final String ElemCreationTime = \"CreationTime\";\n    private static final String ElemLastModTime = \"LastModificationTime\";\n    private static final String ElemLastAccessTime = \"LastAccessTime\";\n    private static final String ElemExpiryTime = \"ExpiryTime\";\n    private static final String ElemExpires = \"Expires\";\n    private static final String ElemUsageCount = \"UsageCount\";\n    private static final String ElemLocationChanged = \"LocationChanged\";\n\n    private static final String ElemGroupDefaultAutoTypeSeq = \"DefaultAutoTypeSequence\";\n    private static final String ElemEnableAutoType = \"EnableAutoType\";\n    private static final String ElemEnableSearching = \"EnableSearching\";\n\n    private static final String ElemString = \"String\";\n    private static final String ElemBinary = \"Binary\";\n    private static final String ElemKey = \"Key\";\n    private static final String ElemValue = \"Value\";\n\n    private static final String ElemAutoTypeEnabled = \"Enabled\";\n    private static final String ElemAutoTypeObfuscation = \"DataTransferObfuscation\";\n    private static final String ElemAutoTypeDefaultSeq = \"DefaultSequence\";\n    private static final String ElemAutoTypeItem = \"Association\";\n    private static final String ElemWindow = \"Window\";\n    private static final String ElemKeystrokeSequence = \"KeystrokeSequence\";\n\n    private static final String AttrProtected = \"Protected\";\n\n    private static final String ElemIsExpanded = \"IsExpanded\";\n    private static final String ElemLastTopVisibleEntry = \"LastTopVisibleEntry\";\n\n    private static final String ElemDeletedObjects = \"DeletedObjects\";\n    private static final String ElemDeletedObject = \"DeletedObject\";\n    private static final String ElemDeletionTime = \"DeletionTime\";\n\n    @SuppressWarnings(\"unused\")\n\tprivate static final String ValFalse = \"False\";\n    private static final String ValTrue = \"True\";\n\n    private static final String ElemCustomData = \"CustomData\";\n    private static final String ElemStringDictExItem = \"Item\";\n    \n    private static final long DEFAULT_HISTORY_DAYS = 365;\n\n\t\n\tprivate boolean readNextNode = true;\n\tprivate Stack<PwGroupV4> ctxGroups = new Stack<PwGroupV4>();\n\tprivate PwGroupV4 ctxGroup = null;\n\tprivate PwEntryV4 ctxEntry = null;\n\tprivate String ctxStringName = null;\n\tprivate String ctxStringValue = null;\n\tprivate String ctxBinaryName = null;\n\tprivate byte[] ctxBinaryValue = null;\n\tprivate String ctxATName = null;\n\tprivate String ctxATSeq = null;\n\tprivate boolean entryInHistory = false;\n\tprivate PwEntryV4 ctxHistoryBase = null;\n\tprivate PwDeletedObject ctxDeletedObject = null;\n\tprivate UUID customIconID = PwDatabaseV4.UUID_ZERO;\n\tprivate byte[] customIconData;\n\tprivate String customDataKey = null;\n\tprivate String customDataValue = null;\n\t\n\tprivate void ReadXmlStreamed(InputStream readerStream) throws IOException {\n\t\t\n\t\t\ttry {\n\t\t\t\tReadDocumentStreamed(CreatePullParser(readerStream));\n\t\t\t} catch (XmlPullParserException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t}\n\t\n\tprivate static XmlPullParser CreatePullParser(InputStream readerStream) throws XmlPullParserException {\n\t\tXmlPullParserFactory xppf = XmlPullParserFactory.newInstance();\n\t\txppf.setNamespaceAware(false);\n\t\t\n\t\tXmlPullParser xpp = xppf.newPullParser();\n\t\txpp.setInput(readerStream, null);\n\t\t\n\t\treturn xpp;\n\t}\n\n\tprivate void ReadDocumentStreamed(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tctxGroups.clear();\n\t\t\n\t\tKdbContext ctx = KdbContext.Null;\n\t\t\n\t\treadNextNode = true;\n\t\t\n\t\twhile (true) {\n\t\t\tif ( readNextNode ) {\n\t\t\t\tif( xpp.next() == XmlPullParser.END_DOCUMENT ) break;\n\t\t\t} else {\n\t\t\t\treadNextNode = true;\n\t\t\t}\n\t\t\t\n\t\t\tswitch ( xpp.getEventType() ) {\n\t\t\tcase XmlPullParser.START_TAG:\n\t\t\t\tctx = ReadXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase XmlPullParser.END_TAG:\n\t\t\t\tctx = EndXmlElement(ctx, xpp);\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tassert(false);\n\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t// Error checks\n\t\tif ( ctx != KdbContext.Null ) throw new IOException(\"Malformed\");\n\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Malformed\");\n\t}\n\n\n\tprivate KdbContext ReadXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tString name = xpp.getName();\n\t\tswitch (ctx) {\n\t\tcase Null:\n\t\t\tif ( name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.KeePassFile, xpp);\n\t\t\t} else ReadUnknown(xpp);\n\t\t\tbreak;\n\t\t\t\n\t\tcase KeePassFile:\n\t\t\tif ( name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Meta, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Root, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Meta:\n\t\t\tif ( name.equalsIgnoreCase(ElemGenerator) ) {\n\t\t\t\tReadString(xpp); // Ignore\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbName) ) {\n\t\t\t\tdb.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbNameChanged) ) {\n\t\t\t\tdb.nameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDesc) ) {\n\t\t\t\tdb.description = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDescChanged) ) {\n\t\t\t\tdb.descriptionChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUser) ) {\n\t\t\t\tdb.defaultUserName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbDefaultUserChanged) ) {\n\t\t\t\tdb.defaultUserNameChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbMntncHistoryDays) ) {\n\t\t\t\tdb.maintenanceHistoryDays = ReadUInt(xpp, DEFAULT_HISTORY_DAYS);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChanged) ) {\n\t\t\t\tdb.keyLastChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeRec) ) {\n\t\t\t\tdb.keyChangeRecDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDbKeyChangeForce) ) {\n\t\t\t\tdb.keyChangeForceDays = ReadLong(xpp, -1);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.MemoryProtection, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcons, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinEnabled) ) {\n\t\t\t\tdb.recycleBinEnabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinUuid) ) {\n\t\t\t\tdb.recycleBinUUID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemRecycleBinChanged) ) {\n\t\t\t\tdb.recycleBinChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroup) ) {\n\t\t\t\tdb.entryTemplatesGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntryTemplatesGroupChanged) ) {\n\t\t\t\tdb.entryTemplatesGroupChanged = ReadTime(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastSelectedGroup) ) {\n\t\t\t\tdb.lastSelectedGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleGroup) ) {\n\t\t\t\tdb.lastTopVisibleGroup = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomData, xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase MemoryProtection:\n\t\t\tif ( name.equalsIgnoreCase(ElemProtTitle) ) {\n\t\t\t\tdb.memoryProtection.protectTitle = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtUserName) ) {\n\t\t\t\tdb.memoryProtection.protectUserName = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtPassword) ) {\n\t\t\t\tdb.memoryProtection.protectPassword = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtURL) ) {\n\t\t\t\tdb.memoryProtection.protectUrl = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtNotes) ) {\n\t\t\t\tdb.memoryProtection.protectNotes = ReadBool(xpp, false);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemProtAutoHide) ) {\n\t\t\t\tdb.memoryProtection.autoEnableVisualHiding = ReadBool(xpp, false);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcons:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomIcon, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomIcon:\n\t\t\tif ( name.equalsIgnoreCase(ElemCustomIconItemID) ) {\n\t\t\t\tcustomIconID = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconItemData) ) {\n\t\t\t\tString strData = ReadString(xpp);\n\t\t\t\tif ( strData != null && strData.length() > 0 ) {\n\t\t\t\t\tcustomIconData = Base64Coder.decode(strData);\n\t\t\t\t} else {\n\t\t\t\t\tassert(false);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CustomData:\n\t\t\tif ( name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.CustomDataItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase CustomDataItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tcustomDataKey = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tcustomDataValue = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Root:\n\t\t\tif ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tassert(ctxGroups.size() == 0);\n\t\t\t\tif ( ctxGroups.size() != 0 ) throw new IOException(\"Group list should be empty.\");\n\t\t\t\t\n\t\t\t\tdb.rootGroup = new PwGroupV4();\n\t\t\t\tctxGroups.push((PwGroupV4)db.rootGroup);\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.RootDeletedObjects, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Group:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxGroup.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemName) ) {\n\t\t\t\tctxGroup.name = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemNotes) ) {\n\t\t\t\tctxGroup.notes = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxGroup.iconId = (int)ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxGroup.customIconUuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.GroupTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIsExpanded) ) {\n\t\t\t\tctxGroup.isExpanded = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroupDefaultAutoTypeSeq) ) {\n\t\t\t\tctxGroup.defaultAutoTypeSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableAutoType) ) {\n\t\t\t\tctxGroup.enableAutoType = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEnableSearching) ) {\n\t\t\t\tctxGroup.enableSearching = StringToBoolean(ReadString(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastTopVisibleEntry) ) {\n\t\t\t\tctxGroup.lastTopVisibleEntry = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\t\tctxGroup = new PwGroupV4();\n\t\t\t\tctxGroups.peek().AddGroup(ctxGroup, true);\n\t\t\t\tctxGroups.push(ctxGroup);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Group, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxGroup.AddEntry(ctxEntry, true);\n\t\t\t\t\n\t\t\t\tentryInHistory = false;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase Entry:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxEntry.setUUID(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemIcon) ) {\n\t\t\t\tctxEntry.icon = db.iconFactory.getIcon((int)ReadUInt(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCustomIconID) ) {\n\t\t\t\tctxEntry.customIcon = db.iconFactory.getIcon(ReadUuid(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemFgColor) ) {\n\t\t\t\tctxEntry.foregroundColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBgColor) ) {\n\t\t\t\tctxEntry.backgroupColor = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemOverrideUrl) ) {\n\t\t\t\tctxEntry.overrideURL = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTags) ) {\n\t\t\t\tctxEntry.tags = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryTimes, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemString) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryString, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryBinary, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoType, xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\t\tassert(!entryInHistory);\n\t\t\t\t\n\t\t\t\tif ( ! entryInHistory ) {\n\t\t\t\t\tctxHistoryBase = ctxEntry;\n\t\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryHistory, xpp);\n\t\t\t\t} else {\n\t\t\t\t\tReadUnknown(xpp);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase GroupTimes:\n\t\tcase EntryTimes:\n\t\t\tITimeLogger tl;\n\t\t\tif ( ctx == KdbContext.GroupTimes ) {\n\t\t\t\ttl = ctxGroup;\n\t\t\t} else {\n\t\t\t\ttl = ctxEntry;\n\t\t\t}\n\t\t\t\n\t\t\tif ( name.equalsIgnoreCase(ElemLastModTime) ) {\n\t\t\t\ttl.setLastModificationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemCreationTime) ) {\n\t\t\t\ttl.setCreationTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLastAccessTime) ) {\n\t\t\t\ttl.setLastAccessTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpiryTime) ) {\n\t\t\t\ttl.setExpiryTime(ReadTime(xpp));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemExpires) ) {\n\t\t\t\ttl.setExpires(ReadBool(xpp, false));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemUsageCount) ) {\n\t\t\t\ttl.setUsageCount(ReadULong(xpp, 0));\n\t\t\t} else if ( name.equalsIgnoreCase(ElemLocationChanged) ) {\n\t\t\t\ttl.setLocationChanged(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryString:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxStringName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxStringValue = ReadProtectedString(xpp); \n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryBinary:\n\t\t\tif ( name.equalsIgnoreCase(ElemKey) ) {\n\t\t\t\tctxBinaryName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemValue) ) {\n\t\t\t\tctxBinaryValue = ReadProtectedBinary(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoType:\n\t\t\tif ( name.equalsIgnoreCase(ElemAutoTypeEnabled) ) {\n\t\t\t\tctxEntry.autoType.enabled = ReadBool(xpp, true);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeObfuscation) ) {\n\t\t\t\tctxEntry.autoType.obfuscationOptions = ReadUInt(xpp, 0);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeDefaultSeq) ) {\n\t\t\t\tctxEntry.autoType.defaultSequence = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\t\treturn SwitchContext(ctx, KdbContext.EntryAutoTypeItem, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryAutoTypeItem:\n\t\t\tif ( name.equalsIgnoreCase(ElemWindow) ) {\n\t\t\t\tctxATName = ReadString(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemKeystrokeSequence) ) {\n\t\t\t\tctxATSeq = ReadString(xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase EntryHistory:\n\t\t\tif ( name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\t\tctxEntry = new PwEntryV4();\n\t\t\t\tctxHistoryBase.history.add(ctxEntry);\n\t\t\t\t\n\t\t\t\tentryInHistory = true;\n\t\t\t\treturn SwitchContext(ctx, KdbContext.Entry, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase RootDeletedObjects:\n\t\t\tif ( name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\t\tctxDeletedObject = new PwDeletedObject();\n\t\t\t\tdb.deletedObjects.add(ctxDeletedObject);\n\t\t\t\t\n\t\t\t\treturn SwitchContext(ctx, KdbContext.DeletedObject, xpp);\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tcase DeletedObject:\n\t\t\tif ( name.equalsIgnoreCase(ElemUuid) ) {\n\t\t\t\tctxDeletedObject.uuid = ReadUuid(xpp);\n\t\t\t} else if ( name.equalsIgnoreCase(ElemDeletionTime) ) {\n\t\t\t\tctxDeletedObject.setDeletionTime(ReadTime(xpp));\n\t\t\t} else {\n\t\t\t\tReadUnknown(xpp);\n\t\t\t}\n\t\t\tbreak;\n\t\t\t\n\t\tdefault:\n\t\t\tReadUnknown(xpp);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\treturn ctx;\n\t}\n\n\tprivate KdbContext EndXmlElement(KdbContext ctx, XmlPullParser xpp) throws XmlPullParserException {\n\t\tassert(xpp.getEventType() == XmlPullParser.END_TAG);\n\t\t\n\t\tString name = xpp.getName();\n\t\tif ( ctx == KdbContext.KeePassFile && name.equalsIgnoreCase(ElemDocNode) ) {\n\t\t\treturn KdbContext.Null;\n\t\t} else if ( ctx == KdbContext.Meta && name.equalsIgnoreCase(ElemMeta) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.Root && name.equalsIgnoreCase(ElemRoot) ) {\n\t\t\treturn KdbContext.KeePassFile;\n\t\t} else if ( ctx == KdbContext.MemoryProtection && name.equalsIgnoreCase(ElemMemoryProt) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcons && name.equalsIgnoreCase(ElemCustomIcons) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomIcon && name.equalsIgnoreCase(ElemCustomIconItem) ) {\n\t\t\tif ( ! customIconID.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tPwIconCustom icon = new PwIconCustom(customIconID, customIconData);\n\t\t\t\tdb.customIcons.add(icon);\n\t\t\t\tdb.iconFactory.put(icon);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomIconID = PwDatabaseV4.UUID_ZERO;\n\t\t\tcustomIconData = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomIcons;\n\t\t} else if ( ctx == KdbContext.CustomData && name.equalsIgnoreCase(ElemCustomData) ) {\n\t\t\treturn KdbContext.Meta;\n\t\t} else if ( ctx == KdbContext.CustomDataItem && name.equalsIgnoreCase(ElemStringDictExItem) ) {\n\t\t\tif ( customDataKey != null && customDataValue != null) {\n\t\t\t\tdb.customData.put(customDataKey, customDataValue);\n\t\t\t} else assert(false);\n\t\t\t\n\t\t\tcustomDataKey = null;\n\t\t\tcustomDataValue = null;\n\t\t\t\n\t\t\treturn KdbContext.CustomData;\n\t\t} else if ( ctx == KdbContext.Group && name.equalsIgnoreCase(ElemGroup) ) {\n\t\t\tif ( ctxGroup.uuid == null || ctxGroup.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxGroup.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tctxGroups.pop();\n\t\t\t\n\t\t\tif ( ctxGroups.size() == 0 ) {\n\t\t\t\tctxGroup = null;\n\t\t\t\treturn KdbContext.Root;\n\t\t\t} else {\n\t\t\t\tctxGroup = ctxGroups.peek();\n\t\t\t\treturn KdbContext.Group;\n\t\t\t}\n\t\t} else if ( ctx == KdbContext.GroupTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.Entry && name.equalsIgnoreCase(ElemEntry) ) {\n\t\t\tif ( ctxEntry.uuid == null || ctxEntry.uuid.equals(PwDatabaseV4.UUID_ZERO) ) {\n\t\t\t\tctxEntry.uuid = UUID.randomUUID();\n\t\t\t}\n\t\t\t\n\t\t\tif ( entryInHistory ) {\n\t\t\t\tctxEntry = ctxHistoryBase;\n\t\t\t\treturn KdbContext.EntryHistory;\n\t\t\t}\n\t\t\t\n\t\t\treturn KdbContext.Group;\n\t\t} else if ( ctx == KdbContext.EntryTimes && name.equalsIgnoreCase(ElemTimes) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryString && name.equalsIgnoreCase(ElemString) ) {\n\t\t\tctxEntry.strings.put(ctxStringName, ctxStringValue);\n\t\t\tctxStringName = null;\n\t\t\tctxStringValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryBinary && name.equalsIgnoreCase(ElemBinary) ) {\n\t\t\tctxEntry.binaries.put(ctxBinaryName, ctxBinaryValue);\n\t\t\tctxBinaryName = null;\n\t\t\tctxBinaryValue = null;\n\t\t\t\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoType && name.equalsIgnoreCase(ElemAutoType) ) {\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.EntryAutoTypeItem && name.equalsIgnoreCase(ElemAutoTypeItem) ) {\n\t\t\tctxEntry.autoType.put(ctxATName, ctxATSeq);\n\t\t\tctxATName = null;\n\t\t\tctxATSeq = null;\n\t\t\t\n\t\t\treturn KdbContext.EntryAutoType;\n\t\t} else if ( ctx == KdbContext.EntryHistory && name.equalsIgnoreCase(ElemHistory) ) {\n\t\t\tentryInHistory = false;\n\t\t\treturn KdbContext.Entry;\n\t\t} else if ( ctx == KdbContext.RootDeletedObjects && name.equalsIgnoreCase(ElemDeletedObjects) ) {\n\t\t\treturn KdbContext.Root;\n\t\t} else if ( ctx == KdbContext.DeletedObject && name.equalsIgnoreCase(ElemDeletedObject) ) {\n\t\t\tctxDeletedObject = null;\n\t\t\treturn KdbContext.RootDeletedObjects;\n\t\t} else {\n\t\t\tassert(false);\n\t\t\t\n\t\t\tthrow new RuntimeException(\"Invalid end element\");\n\t\t}\n\t}\n\t\n\tprivate static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-mm-dd'T'HH:mm:ss'Z'\");\n\tprivate Date ReadTime(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString sDate = ReadString(xpp);\n\t\t\n\t\tDate utcDate;\n\t\ttry {\n\t\t\tutcDate = dateFormat.parse(sDate);\n\t\t} catch (ParseException e) {\n\t\t\te.printStackTrace();\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\treturn utcDate;\n\t\t\n\t}\n\n\tprivate void ReadUnknown(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(false);\n\t\t\n\t\tif ( xpp.isEmptyElementTag() ) return;\n\t\t\n\t\tString unknownName = xpp.getName();\n\t\tProcessNode(xpp);\n\t\t\n\t\twhile (xpp.next() != XmlPullParser.END_DOCUMENT ) {\n\t\t\tif ( xpp.getEventType() == XmlPullParser.END_TAG ) break;\n\t\t\tif ( xpp.getEventType() == XmlPullParser.START_TAG ) continue;\n\t\t\t\n\t\t\tReadUnknown(xpp);\n\t\t}\n\t\t\n\t\tassert(xpp.getName() == unknownName);\n\t\t\n\t}\n\t\n\tprivate boolean ReadBool(XmlPullParser xpp, boolean bDefault) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tif ( str.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( str.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\treturn bDefault;\n\t\t}\n\t}\n\t\n\tprivate UUID ReadUuid(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tString encoded = ReadString(xpp);\n\t\t\n\t\tif (encoded == null || encoded.length() == 0 ) {\n\t\t\treturn PwDatabaseV4.UUID_ZERO;\n\t\t}\n\t\t\n\t\t// TODO: Switch to framework Base64 once API level 8 is the minimum\n\t\tbyte[] buf = Base64Coder.decode(encoded);\n\t\t\n\t\treturn Types.bytestoUUID(buf);\n\t}\n\t\n\tprivate static final long MAX_UINT = 4294967296L; // 2^32\n\tprivate long ReadUInt(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u;\n\t\t\n\t\tu = ReadULong(xpp, uDefault);\n\t\tif ( u < 0 || u > MAX_UINT ) {\n\t\t\tthrow new NumberFormatException(\"Outside of the uint size\");\n\t\t}\n\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate long ReadLong(XmlPullParser xpp, long def) throws IOException, XmlPullParserException {\n\t\tString str = ReadString(xpp);\n\t\t\n\t\tlong u;\n\t\ttry {\n\t\t\tu = Long.parseLong(str);\n\t\t} catch( NumberFormatException e) {\n\t\t\tu = def;\n\t\t}\n\t\t\n\t\treturn u;\n\t}\n\t\n\tprivate long ReadULong(XmlPullParser xpp, long uDefault) throws IOException, XmlPullParserException {\n\t\tlong u = ReadLong(xpp, uDefault);\n\t\t\n\t\tif ( u < 0 ) {\n\t\t\tu = uDefault;\n\t\t}\n\t\t\n\t\treturn u;\n\t\t\n\t}\n\t\n\tprivate String ReadProtectedString(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t} \n\t\t}\n\t\t\n\t\treturn ReadString(xpp);\n\t}\n\t\n\tprivate byte[] ReadProtectedBinary(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) return buf;\n\t\t\n\t\tString base64 = ReadString(xpp);\n\t\tif ( base64.length() == 0 ) return new byte[0];\n\t\t\n\t\treturn Base64Coder.decode(base64);\n\t}\n\t\n\tprivate String ReadString(XmlPullParser xpp) throws IOException, XmlPullParserException {\n\t\tbyte[] buf = ProcessNode(xpp);\n\t\t\n\t\tif ( buf != null ) {\n\t\t\ttry {\n\t\t\t\treturn new String(buf, \"UTF-8\");\n\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t\t\n\t}\n\t\n\tprivate String ReadStringRaw(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\t\n\t\t//readNextNode = false;\n\t\treturn xpp.nextText();\n\t}\n\n\tprivate byte[] ProcessNode(XmlPullParser xpp) throws XmlPullParserException, IOException {\n\t\tassert(xpp.getEventType() == XmlPullParser.START_TAG);\n\t\t\n\t\tbyte[] buf = null;\n\t\t\n\t\tif ( xpp.getAttributeCount() > 0 ) {\n\t\t\tString protect = xpp.getAttributeValue(null, AttrProtected);\n\t\t\tif ( protect != null && protect.equalsIgnoreCase(ValTrue) ) {\n\t\t\t\tString encrypted = ReadStringRaw(xpp);\n\t\t\t\t\n\t\t\t\tif ( encrypted.length() > 0 ) {\n\t\t\t\t\tbuf = Base64Coder.decode(encrypted);\n\t\t\t\t\tbyte[] plainText = new byte[buf.length];\n\t\t\t\t\t\n\t\t\t\t\trandomStream.processBytes(buf, 0, buf.length, plainText, 0);\n\t\t\t\t\t\n\t\t\t\t\treturn plainText;\n\t\t\t\t} else {\n\t\t\t\t\tbuf = new byte[0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn buf;\n\t}\n\n\tprivate KdbContext SwitchContext(KdbContext ctxCurrent, KdbContext ctxNew,\n\t\t\tXmlPullParser xpp) throws XmlPullParserException, IOException {\n\n\t\tif ( xpp.isEmptyElementTag() ) {\n\t\t\txpp.next();  // Consume the end tag\n\t\t\treturn ctxCurrent;\n\t\t}\n\t\treturn ctxNew;\n\t}\n\n\n\tprivate Boolean StringToBoolean(String str) {\n\t\tif ( str == null || str.length() == 0 ) {\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tString trimmed = str.trim();\n\t\tif ( trimmed.equalsIgnoreCase(\"true\") ) {\n\t\t\treturn true;\n\t\t} else if ( trimmed.equalsIgnoreCase(\"false\") ) {\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n}\n","lineNo":682}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.search;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.util.Log;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\n\npublic class SearchDbHelper {\n\tprivate static final String DATABASE_NAME = \"search\";\n\tprivate static final String SEARCH_TABLE = \"entries\";\n\tprivate static final int DATABASE_VERSION = 1;\n\t\n\tprivate static final String KEY_UUID = \"uuid\";\n\tprivate static final String KEY_TITLE = \"title\";\n\tprivate static final String KEY_URL = \"url\";\n\tprivate static final String KEY_COMMENT = \"comment\";\n\n\tprivate static final String DATABASE_CREATE = \n\t\t\"create virtual table \" + SEARCH_TABLE + \" using FTS3( \" \n\t\t+ KEY_UUID + \", \"\n\t\t+ KEY_TITLE + \", \" \n\t\t+ KEY_URL + \", \"\n\t\t+ KEY_COMMENT + \");\";\n\t\n\tprivate static final String PRAGMA_NO_SYNCHRONOUS = \"pragma synchronous = off;\";\n\t\n\tprivate final Context mCtx;\n\tprivate DatabaseHelper mDbHelper;\n\tprivate SQLiteDatabase mDb;\n\t\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\t\n\t\tDatabaseHelper(Context ctx) {\n\t\t\tsuper(ctx, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreate(SQLiteDatabase db) {\n\t\t\tdb.execSQL(DATABASE_CREATE);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\t\t\t// Only one database version so far\n\t\t}\n\t\t\n\t}\n\t\n\tpublic SearchDbHelper(Context ctx) {\n\t\tmCtx = ctx;\n\t}\n\t\n\tpublic SearchDbHelper open() throws SQLException {\n\t\tmDbHelper = new DatabaseHelper(mCtx);\n\t\tmDb = mDbHelper.getWritableDatabase();\n\t\tmDb.execSQL(PRAGMA_NO_SYNCHRONOUS);\n\t\treturn this;\n\t}\n\t\n\tpublic void close() {\n\t\tmDb.close();\n\t}\n\n\tpublic void clear() {\n\t\tmDb.delete(SEARCH_TABLE, null, null);\n\t}\n\n\tprivate ContentValues buildNewEntryContent(PwEntry entry) {\n\n\t\tContentValues cv = new ContentValues();\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tcv.put(KEY_UUID, uuidStr);\n\t\tcv.put(KEY_TITLE, entry.getTitle());\n\t\tcv.put(KEY_URL, entry.getUrl());\n\t\tcv.put(KEY_COMMENT, entry.getNotes());\n\t\t\n\t\treturn cv;\n\t}\n\t\n\tpublic void insertEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tmDb.insert(SEARCH_TABLE, null, cv);\n\t}\n\t\n\tpublic void insertEntry(List<? extends PwEntry> entries) {\n\t\tmDb.beginTransaction();\n\n\t\ttry {\n\t\t\tfor (int i=0; i < entries.size(); i++) {\n\t\t\t\tinsertEntry(entries.get(i));\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\t\n\tpublic void updateEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tString uuidStr = cv.getAsString(KEY_UUID);\n\t\t\n\t\tmDb.update(SEARCH_TABLE, cv, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic void deleteEntry(PwEntry entry) {\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tmDb.delete(SEARCH_TABLE, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic PwGroupV3 search(Database db, String qStr) {\n\t\tCursor cursor;\n\t\tcursor = mDb.query(true, SEARCH_TABLE, new String[] {KEY_UUID}, SEARCH_TABLE + \" match ?\", new String[] {qStr}, null, null, null, null);\n\n\t\tPwGroupV3 group = new PwGroupV3();\n\t\tgroup.name = \"Search results\";\n\t\tgroup.childEntries = new ArrayList<PwEntry>();\n\t\tgroup.setGroups(new ArrayList<PwGroup>());\n\t\t\n\t\tcursor.moveToFirst();\n\t\twhile ( ! cursor.isAfterLast() ) {\n\t\t\tString sUUID = cursor.getString(0);\n\t\t\tUUID uuid = UUID.fromString(sUUID);\n\t\t\tLog.d(\"TAG\", uuid.toString()); \n\t\t\tPwEntry entry = (PwEntry) db.entries.get(uuid);\n\t\t\tgroup.childEntries.add(entry);\n\t\t\t\n\t\t\tcursor.moveToNext();\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn group;\n\t}\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.search;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.util.Log;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.PwGroupV4;\n\npublic class SearchDbHelper {\n\tprivate static final String DATABASE_NAME = \"search\";\n\tprivate static final String SEARCH_TABLE = \"entries\";\n\tprivate static final int DATABASE_VERSION = 1;\n\t\n\tprivate static final String KEY_UUID = \"uuid\";\n\tprivate static final String KEY_TITLE = \"title\";\n\tprivate static final String KEY_URL = \"url\";\n\tprivate static final String KEY_COMMENT = \"comment\";\n\n\tprivate static final String DATABASE_CREATE = \n\t\t\"create virtual table \" + SEARCH_TABLE + \" using FTS3( \" \n\t\t+ KEY_UUID + \", \"\n\t\t+ KEY_TITLE + \", \" \n\t\t+ KEY_URL + \", \"\n\t\t+ KEY_COMMENT + \");\";\n\t\n\tprivate static final String PRAGMA_NO_SYNCHRONOUS = \"pragma synchronous = off;\";\n\t\n\tprivate final Context mCtx;\n\tprivate DatabaseHelper mDbHelper;\n\tprivate SQLiteDatabase mDb;\n\t\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\t\n\t\tDatabaseHelper(Context ctx) {\n\t\t\tsuper(ctx, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreate(SQLiteDatabase db) {\n\t\t\tdb.execSQL(DATABASE_CREATE);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\t\t\t// Only one database version so far\n\t\t}\n\t\t\n\t}\n\t\n\tpublic SearchDbHelper(Context ctx) {\n\t\tmCtx = ctx;\n\t}\n\t\n\tpublic SearchDbHelper open() throws SQLException {\n\t\tmDbHelper = new DatabaseHelper(mCtx);\n\t\tmDb = mDbHelper.getWritableDatabase();\n\t\tmDb.execSQL(PRAGMA_NO_SYNCHRONOUS);\n\t\treturn this;\n\t}\n\t\n\tpublic void close() {\n\t\tmDb.close();\n\t}\n\n\tpublic void clear() {\n\t\tmDb.delete(SEARCH_TABLE, null, null);\n\t}\n\n\tprivate ContentValues buildNewEntryContent(PwEntry entry) {\n\n\t\tContentValues cv = new ContentValues();\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tcv.put(KEY_UUID, uuidStr);\n\t\tcv.put(KEY_TITLE, entry.getTitle());\n\t\tcv.put(KEY_URL, entry.getUrl());\n\t\tcv.put(KEY_COMMENT, entry.getNotes());\n\t\t\n\t\treturn cv;\n\t}\n\t\n\tpublic void insertEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tmDb.insert(SEARCH_TABLE, null, cv);\n\t}\n\t\n\tpublic void insertEntry(List<? extends PwEntry> entries) {\n\t\tmDb.beginTransaction();\n\n\t\ttry {\n\t\t\tfor (int i=0; i < entries.size(); i++) {\n\t\t\t\tinsertEntry(entries.get(i));\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\t\n\tpublic void updateEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tString uuidStr = cv.getAsString(KEY_UUID);\n\t\t\n\t\tmDb.update(SEARCH_TABLE, cv, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic void deleteEntry(PwEntry entry) {\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tmDb.delete(SEARCH_TABLE, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic PwGroup search(Database db, String qStr) {\n\t\tCursor cursor;\n\t\tString queryWithWildCard = addWildCard(qStr);\n\t\tcursor = mDb.query(true, SEARCH_TABLE, new String[] {KEY_UUID}, SEARCH_TABLE + \" match ?\", new String[] {queryWithWildCard}, null, null, null, null);\n\n\t\tPwGroup group;\n\t\tif ( db.pm instanceof PwDatabaseV3 ) {\n\t\t\tgroup = new PwGroupV3();\n\t\t} else if ( db.pm instanceof PwDatabaseV4 ) {\n\t\t\tgroup = new PwGroupV4();\n\t\t} else {\n\t\t\tLog.d(\"SearchDbHelper\", \"Tried to search with unknown db\");\n\t\t\treturn null;\n\t\t}\n\t\tgroup.name = \"Search results\";\n\t\tgroup.childEntries = new ArrayList<PwEntry>();\n\t\t\n\t\tcursor.moveToFirst();\n\t\twhile ( ! cursor.isAfterLast() ) {\n\t\t\tString sUUID = cursor.getString(0);\n\t\t\tUUID uuid = UUID.fromString(sUUID);\n\t\t\tLog.d(\"TAG\", uuid.toString()); \n\t\t\tPwEntry entry = (PwEntry) db.entries.get(uuid);\n\t\t\tgroup.childEntries.add(entry);\n\t\t\t\n\t\t\tcursor.moveToNext();\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn group;\n\t}\n\n\tprivate String addWildCard(String qStr) {\n\t\tString result = new String(qStr);\n\t\tif (qStr.endsWith(\"\\\"\") || qStr.endsWith(\"*\")) {\n\t\t\t// Do Nothing\n\t\t}\n\t\telse if (qStr.endsWith(\"%\")){\n\t\t\tresult = result.substring(0, result.length()-1);\n\t\t}\n\t\tresult = result + \"*\";\n\t\treturn result;\n\t}\n\t\n}\n","lineNo":150}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.search;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.util.Log;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\n\npublic class SearchDbHelper {\n\tprivate static final String DATABASE_NAME = \"search\";\n\tprivate static final String SEARCH_TABLE = \"entries\";\n\tprivate static final int DATABASE_VERSION = 1;\n\t\n\tprivate static final String KEY_UUID = \"uuid\";\n\tprivate static final String KEY_TITLE = \"title\";\n\tprivate static final String KEY_URL = \"url\";\n\tprivate static final String KEY_COMMENT = \"comment\";\n\n\tprivate static final String DATABASE_CREATE = \n\t\t\"create virtual table \" + SEARCH_TABLE + \" using FTS3( \" \n\t\t+ KEY_UUID + \", \"\n\t\t+ KEY_TITLE + \", \" \n\t\t+ KEY_URL + \", \"\n\t\t+ KEY_COMMENT + \");\";\n\t\n\tprivate static final String PRAGMA_NO_SYNCHRONOUS = \"pragma synchronous = off;\";\n\t\n\tprivate final Context mCtx;\n\tprivate DatabaseHelper mDbHelper;\n\tprivate SQLiteDatabase mDb;\n\t\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\t\n\t\tDatabaseHelper(Context ctx) {\n\t\t\tsuper(ctx, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreate(SQLiteDatabase db) {\n\t\t\tdb.execSQL(DATABASE_CREATE);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\t\t\t// Only one database version so far\n\t\t}\n\t\t\n\t}\n\t\n\tpublic SearchDbHelper(Context ctx) {\n\t\tmCtx = ctx;\n\t}\n\t\n\tpublic SearchDbHelper open() throws SQLException {\n\t\tmDbHelper = new DatabaseHelper(mCtx);\n\t\tmDb = mDbHelper.getWritableDatabase();\n\t\tmDb.execSQL(PRAGMA_NO_SYNCHRONOUS);\n\t\treturn this;\n\t}\n\t\n\tpublic void close() {\n\t\tmDb.close();\n\t}\n\n\tpublic void clear() {\n\t\tmDb.delete(SEARCH_TABLE, null, null);\n\t}\n\n\tprivate ContentValues buildNewEntryContent(PwEntry entry) {\n\n\t\tContentValues cv = new ContentValues();\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tcv.put(KEY_UUID, uuidStr);\n\t\tcv.put(KEY_TITLE, entry.getTitle());\n\t\tcv.put(KEY_URL, entry.getUrl());\n\t\tcv.put(KEY_COMMENT, entry.getNotes());\n\t\t\n\t\treturn cv;\n\t}\n\t\n\tpublic void insertEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tmDb.insert(SEARCH_TABLE, null, cv);\n\t}\n\t\n\tpublic void insertEntry(List<? extends PwEntry> entries) {\n\t\tmDb.beginTransaction();\n\n\t\ttry {\n\t\t\tfor (int i=0; i < entries.size(); i++) {\n\t\t\t\tinsertEntry(entries.get(i));\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\t\n\tpublic void updateEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tString uuidStr = cv.getAsString(KEY_UUID);\n\t\t\n\t\tmDb.update(SEARCH_TABLE, cv, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic void deleteEntry(PwEntry entry) {\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tmDb.delete(SEARCH_TABLE, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic PwGroupV3 search(Database db, String qStr) {\n\t\tCursor cursor;\n\t\tcursor = mDb.query(true, SEARCH_TABLE, new String[] {KEY_UUID}, SEARCH_TABLE + \" match ?\", new String[] {qStr}, null, null, null, null);\n\n\t\tPwGroupV3 group = new PwGroupV3();\n\t\tgroup.name = \"Search results\";\n\t\tgroup.childEntries = new ArrayList<PwEntry>();\n\t\tgroup.setGroups(new ArrayList<PwGroup>());\n\t\t\n\t\tcursor.moveToFirst();\n\t\twhile ( ! cursor.isAfterLast() ) {\n\t\t\tString sUUID = cursor.getString(0);\n\t\t\tUUID uuid = UUID.fromString(sUUID);\n\t\t\tLog.d(\"TAG\", uuid.toString()); \n\t\t\tPwEntry entry = (PwEntry) db.entries.get(uuid);\n\t\t\tgroup.childEntries.add(entry);\n\t\t\t\n\t\t\tcursor.moveToNext();\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn group;\n\t}\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.search;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.util.Log;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.PwGroupV4;\n\npublic class SearchDbHelper {\n\tprivate static final String DATABASE_NAME = \"search\";\n\tprivate static final String SEARCH_TABLE = \"entries\";\n\tprivate static final int DATABASE_VERSION = 1;\n\t\n\tprivate static final String KEY_UUID = \"uuid\";\n\tprivate static final String KEY_TITLE = \"title\";\n\tprivate static final String KEY_URL = \"url\";\n\tprivate static final String KEY_COMMENT = \"comment\";\n\n\tprivate static final String DATABASE_CREATE = \n\t\t\"create virtual table \" + SEARCH_TABLE + \" using FTS3( \" \n\t\t+ KEY_UUID + \", \"\n\t\t+ KEY_TITLE + \", \" \n\t\t+ KEY_URL + \", \"\n\t\t+ KEY_COMMENT + \");\";\n\t\n\tprivate static final String PRAGMA_NO_SYNCHRONOUS = \"pragma synchronous = off;\";\n\t\n\tprivate final Context mCtx;\n\tprivate DatabaseHelper mDbHelper;\n\tprivate SQLiteDatabase mDb;\n\t\n\tprivate static class DatabaseHelper extends SQLiteOpenHelper {\n\t\t\n\t\tDatabaseHelper(Context ctx) {\n\t\t\tsuper(ctx, DATABASE_NAME, null, DATABASE_VERSION);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onCreate(SQLiteDatabase db) {\n\t\t\tdb.execSQL(DATABASE_CREATE);\n\t\t}\n\n\t\t@Override\n\t\tpublic void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n\t\t\t// Only one database version so far\n\t\t}\n\t\t\n\t}\n\t\n\tpublic SearchDbHelper(Context ctx) {\n\t\tmCtx = ctx;\n\t}\n\t\n\tpublic SearchDbHelper open() throws SQLException {\n\t\tmDbHelper = new DatabaseHelper(mCtx);\n\t\tmDb = mDbHelper.getWritableDatabase();\n\t\tmDb.execSQL(PRAGMA_NO_SYNCHRONOUS);\n\t\treturn this;\n\t}\n\t\n\tpublic void close() {\n\t\tmDb.close();\n\t}\n\n\tpublic void clear() {\n\t\tmDb.delete(SEARCH_TABLE, null, null);\n\t}\n\n\tprivate ContentValues buildNewEntryContent(PwEntry entry) {\n\n\t\tContentValues cv = new ContentValues();\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tcv.put(KEY_UUID, uuidStr);\n\t\tcv.put(KEY_TITLE, entry.getTitle());\n\t\tcv.put(KEY_URL, entry.getUrl());\n\t\tcv.put(KEY_COMMENT, entry.getNotes());\n\t\t\n\t\treturn cv;\n\t}\n\t\n\tpublic void insertEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tmDb.insert(SEARCH_TABLE, null, cv);\n\t}\n\t\n\tpublic void insertEntry(List<? extends PwEntry> entries) {\n\t\tmDb.beginTransaction();\n\n\t\ttry {\n\t\t\tfor (int i=0; i < entries.size(); i++) {\n\t\t\t\tinsertEntry(entries.get(i));\n\t\t\t}\n\t\t\tmDb.setTransactionSuccessful();\n\t\t} finally {\n\t\t\tmDb.endTransaction();\n\t\t}\n\t}\n\t\n\tpublic void updateEntry(PwEntry entry) {\n\t\tContentValues cv = buildNewEntryContent(entry);\n\t\tString uuidStr = cv.getAsString(KEY_UUID);\n\t\t\n\t\tmDb.update(SEARCH_TABLE, cv, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic void deleteEntry(PwEntry entry) {\n\t\tUUID uuid = entry.getUUID();\n\t\tString uuidStr = uuid.toString();\n\t\t\n\t\tmDb.delete(SEARCH_TABLE, KEY_UUID + \" = ?\", new String[] {uuidStr});\n\t}\n\t\n\tpublic PwGroup search(Database db, String qStr) {\n\t\tCursor cursor;\n\t\tString queryWithWildCard = addWildCard(qStr);\n\t\tcursor = mDb.query(true, SEARCH_TABLE, new String[] {KEY_UUID}, SEARCH_TABLE + \" match ?\", new String[] {queryWithWildCard}, null, null, null, null);\n\n\t\tPwGroup group;\n\t\tif ( db.pm instanceof PwDatabaseV3 ) {\n\t\t\tgroup = new PwGroupV3();\n\t\t} else if ( db.pm instanceof PwDatabaseV4 ) {\n\t\t\tgroup = new PwGroupV4();\n\t\t} else {\n\t\t\tLog.d(\"SearchDbHelper\", \"Tried to search with unknown db\");\n\t\t\treturn null;\n\t\t}\n\t\tgroup.name = \"Search results\";\n\t\tgroup.childEntries = new ArrayList<PwEntry>();\n\t\t\n\t\tcursor.moveToFirst();\n\t\twhile ( ! cursor.isAfterLast() ) {\n\t\t\tString sUUID = cursor.getString(0);\n\t\t\tUUID uuid = UUID.fromString(sUUID);\n\t\t\tLog.d(\"TAG\", uuid.toString()); \n\t\t\tPwEntry entry = (PwEntry) db.entries.get(uuid);\n\t\t\tgroup.childEntries.add(entry);\n\t\t\t\n\t\t\tcursor.moveToNext();\n\t\t}\n\t\t\n\t\tcursor.close();\n\t\t\n\t\treturn group;\n\t}\n\n\tprivate String addWildCard(String qStr) {\n\t\tString result = new String(qStr);\n\t\tif (qStr.endsWith(\"\\\"\") || qStr.endsWith(\"*\")) {\n\t\t\t// Do Nothing\n\t\t}\n\t\telse if (qStr.endsWith(\"%\")){\n\t\t\tresult = result.substring(0, result.length()-1);\n\t\t}\n\t\tresult = result + \"*\";\n\t\treturn result;\n\t}\n\t\n}\n","lineNo":150}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.List;\n\nimport com.keepassdroid.crypto.finalkey.FinalKey;\nimport com.keepassdroid.crypto.finalkey.FinalKeyFactory;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.stream.NullOutputStream;\n\npublic abstract class PwDatabase {\n\n\tpublic byte masterKey[] = new byte[32];\n\tpublic byte[] finalKey;\n\tpublic String name = \"KeePass database\";\n\tpublic PwGroup rootGroup;\n\t\n\tpublic void makeFinalKey(byte[] masterSeed, byte[] masterSeed2, int numRounds) throws IOException {\n\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\n\t\tbyte[] transformedMasterKey = transformMasterKey(masterSeed2, masterKey, numRounds); \n\t\tdos.write(masterSeed);\n\t\tdos.write(transformedMasterKey);\n\n\t\tfinalKey = md.digest();\n\t}\n\t\n\t/**\n\t * Encrypt the master key a few times to make brute-force key-search harder\n\t * @throws IOException \n\t */\n\tprivate static byte[] transformMasterKey( byte[] pKeySeed, byte[] pKey, int rounds ) throws IOException\n\t{\n\t\tFinalKey key = FinalKeyFactory.createFinalKey();\n\t\t\n\t\treturn key.transformMasterKey(pKeySeed, pKey, rounds);\n\t}\n\n\n\tpublic abstract byte[] getMasterKey(String key, String keyFileName) throws InvalidKeyFileException, IOException;\n\t\n\tpublic void setMasterKey(String key, String keyFileName)\n\t\t\tthrows InvalidKeyFileException, IOException {\n\t\t\t\tassert( key != null && keyFileName != null );\n\t\t\t\n\t\t\t\tmasterKey = getMasterKey(key, keyFileName);\n\t\t\t}\n\n\tprotected byte[] getCompositeKey(String key, String keyFileName)\n\t\t\tthrows InvalidKeyFileException, IOException {\n\t\t\t\tassert(key != null && keyFileName != null);\n\t\t\t\t\n\t\t\t\tbyte[] fileKey = getFileKey(keyFileName);\n\t\t\t\t\n\t\t\t\tbyte[] passwordKey = getPasswordKey(key);\n\t\t\t\t\n\t\t\t\tMessageDigest md;\n\t\t\t\ttry {\n\t\t\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\t\tthrow new IOException(\"SHA-256 not supported\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmd.update(passwordKey);\n\t\t\t\t\n\t\t\t\treturn md.digest(fileKey);\n\t}\n\n\tprotected byte[] getFileKey(String fileName)\n\t\t\tthrows InvalidKeyFileException, IOException {\n\t\t\t\tassert(fileName != null);\n\t\t\t\t\n\t\t\t\tFile keyfile = new File(fileName);\n\t\t\t\t\n\t\t\t\tif ( ! keyfile.exists() ) {\n\t\t\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbyte[] key = loadXmlKeyFile(fileName);\n\t\t\t\tif ( key != null ) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tFileInputStream fis;\n\t\t\t\ttry {\n\t\t\t\t\tfis = new FileInputStream(keyfile);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlong fileSize = keyfile.length();\n\t\t\t\tif ( fileSize == 0 ) {\n\t\t\t\t\tthrow new InvalidKeyFileException(\"Key file is empty.\");\n\t\t\t\t} else if ( fileSize == 32 ) {\n\t\t\t\t\tbyte[] outputKey = new byte[32];\n\t\t\t\t\tif ( fis.read(outputKey, 0, 32) != 32 ) {\n\t\t\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn outputKey;\n\t\t\t\t} else if ( fileSize == 64 ) {\n\t\t\t\t\tbyte[] hex = new byte[64];\n\t\t\t\t\t\n\t\t\t\t\tif ( fis.read(hex, 0, 64) != 64 ) {\n\t\t\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\treturn hexStringToByteArray(new String(hex));\n\t\t\t\t}\n\t\t\t\n\t\t\t\tMessageDigest md;\n\t\t\t\ttry {\n\t\t\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\t\tthrow new IOException(\"SHA-256 not supported\");\n\t\t\t\t}\n\t\t\t\t//SHA256Digest md = new SHA256Digest();\n\t\t\t\tbyte[] buffer = new byte[2048];\n\t\t\t\tint offset = 0;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint bytesRead = fis.read(buffer, 0, 2048);\n\t\t\t\t\t\tif ( bytesRead == -1 ) break;  // End of file\n\t\t\t\t\t\t\n\t\t\t\t\t\tmd.update(buffer, 0, bytesRead);\n\t\t\t\t\t\toffset += bytesRead;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tSystem.out.println(e.toString());\n\t\t\t\t}\n\t\t\t\n\t\t\t\treturn md.digest();\n\t\t\t}\n\n\tprotected abstract byte[] loadXmlKeyFile(String fileName);\n\n\tpublic static byte[] hexStringToByteArray(String s) {\n\t    int len = s.length();\n\t    byte[] data = new byte[len / 2];\n\t    for (int i = 0; i < len; i += 2) {\n\t        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n\t                             + Character.digit(s.charAt(i+1), 16));\n\t    }\n\t    return data;\n\t}\n\n\tprotected byte[] getPasswordKey(String key, String encoding) throws IOException {\n\t\tassert(key!=null);\n\t\t\n\t\tif ( key.length() == 0 )\n\t\t    throw new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"SHA-256 not supported\");\n\t\t}\n\n\t\tbyte[] bKey;\n\t\ttry {\n\t\t\tbKey = key.getBytes(encoding);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tassert false;\n\t\t\tbKey = key.getBytes();\n\t\t}\n\t\tmd.update(bKey, 0, bKey.length );\n\n\t\treturn md.digest();\n\t}\n\t\n\tpublic abstract byte[] getPasswordKey(String key) throws IOException;\n\n\tpublic abstract List<PwGroup> getGrpRoots();\n\t\n\tpublic abstract List<PwGroup> getGroups();\n\n\tpublic abstract List<PwEntry> getEntries();\n\t\n\tpublic abstract long getNumRounds();\n\t\n\tpublic abstract void setNumRounds(long rounds) throws NumberFormatException;\n\t\n\tpublic abstract boolean appSettingsEnabled();\n\t\n\tpublic abstract PwEncryptionAlgorithm getEncAlgorithm();\n\t\n\tpublic void addGroupTo(PwGroup newGroup, PwGroup parent) {\n\t\t// Add group to parent group\n\t\tif ( parent == null ) {\n\t\t\tparent = rootGroup;\n\t\t}\n\t\t\n\t\tparent.childGroups.add(newGroup);\n\t\tnewGroup.setParent(parent);\n\t}\n\t\n\tpublic void removeGroupFrom(PwGroup remove, PwGroup parent) {\n\t\t// Remove group from parent group\n\t\tparent.childGroups.remove(remove);\n\t}\n\t\n\tpublic void addEntryTo(PwEntry newEntry, PwGroup parent) {\n\t\t// Add entry to parent\n\t\tparent.childEntries.add(newEntry);\n\t}\n\t\n\tpublic void removeEntryFrom(PwEntry remove, PwGroup parent) {\n\t\t// Remove entry for parent\n\t\tparent.childEntries.remove(remove);\n\t}\n\n\tpublic abstract PwGroupId newGroupId();\n\t\n\t/**\n\t * Determine if an id number is already in use\n\t * \n\t * @param id\n\t *            ID number to check for\n\t * @return True if the ID is used, false otherwise\n\t */\n\tprotected boolean isGroupIdUsed(PwGroupId id) {\n\t\tList<PwGroup> groups = getGroups();\n\t\t\n\t\tfor (int i = 0; i < groups.size(); i++) {\n\t\t\tPwGroup group =groups.get(i);\n\t\t\tif (group.getId().equals(id)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\t\n\tpublic abstract PwGroup createGroup();\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.List;\n\nimport com.keepassdroid.crypto.finalkey.FinalKey;\nimport com.keepassdroid.crypto.finalkey.FinalKeyFactory;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.stream.NullOutputStream;\n\npublic abstract class PwDatabase {\n\n\tpublic byte masterKey[] = new byte[32];\n\tpublic byte[] finalKey;\n\tpublic String name = \"KeePass database\";\n\tpublic PwGroup rootGroup;\n\t\n\tpublic void makeFinalKey(byte[] masterSeed, byte[] masterSeed2, int numRounds) throws IOException {\n\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\n\t\tbyte[] transformedMasterKey = transformMasterKey(masterSeed2, masterKey, numRounds); \n\t\tdos.write(masterSeed);\n\t\tdos.write(transformedMasterKey);\n\n\t\tfinalKey = md.digest();\n\t}\n\t\n\t/**\n\t * Encrypt the master key a few times to make brute-force key-search harder\n\t * @throws IOException \n\t */\n\tprivate static byte[] transformMasterKey( byte[] pKeySeed, byte[] pKey, int rounds ) throws IOException\n\t{\n\t\tFinalKey key = FinalKeyFactory.createFinalKey();\n\t\t\n\t\treturn key.transformMasterKey(pKeySeed, pKey, rounds);\n\t}\n\n\n\tpublic abstract byte[] getMasterKey(String key, String keyFileName) throws InvalidKeyFileException, IOException;\n\t\n\tpublic void setMasterKey(String key, String keyFileName)\n\t\t\tthrows InvalidKeyFileException, IOException {\n\t\t\t\tassert( key != null && keyFileName != null );\n\t\t\t\n\t\t\t\tmasterKey = getMasterKey(key, keyFileName);\n\t\t\t}\n\n\tprotected byte[] getCompositeKey(String key, String keyFileName)\n\t\t\tthrows InvalidKeyFileException, IOException {\n\t\t\t\tassert(key != null && keyFileName != null);\n\t\t\t\t\n\t\t\t\tbyte[] fileKey = getFileKey(keyFileName);\n\t\t\t\t\n\t\t\t\tbyte[] passwordKey = getPasswordKey(key);\n\t\t\t\t\n\t\t\t\tMessageDigest md;\n\t\t\t\ttry {\n\t\t\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\t\tthrow new IOException(\"SHA-256 not supported\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmd.update(passwordKey);\n\t\t\t\t\n\t\t\t\treturn md.digest(fileKey);\n\t}\n\n\tprotected byte[] getFileKey(String fileName)\n\t\t\tthrows InvalidKeyFileException, IOException {\n\t\t\t\tassert(fileName != null);\n\t\t\t\t\n\t\t\t\tFile keyfile = new File(fileName);\n\t\t\t\t\n\t\t\t\tif ( ! keyfile.exists() ) {\n\t\t\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbyte[] key = loadXmlKeyFile(fileName);\n\t\t\t\tif ( key != null ) {\n\t\t\t\t\treturn key;\n\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\tFileInputStream fis;\n\t\t\t\ttry {\n\t\t\t\t\tfis = new FileInputStream(keyfile);\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tBufferedInputStream bis = new BufferedInputStream(fis, 64);\n\t\t\t\t\n\t\t\t\tlong fileSize = keyfile.length();\n\t\t\t\tif ( fileSize == 0 ) {\n\t\t\t\t\tthrow new InvalidKeyFileException(\"Key file is empty.\");\n\t\t\t\t} else if ( fileSize == 32 ) {\n\t\t\t\t\tbyte[] outputKey = new byte[32];\n\t\t\t\t\tif ( bis.read(outputKey, 0, 32) != 32 ) {\n\t\t\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn outputKey;\n\t\t\t\t} else if ( fileSize == 64 ) {\n\t\t\t\t\tbyte[] hex = new byte[64];\n\t\t\t\t\t\n\t\t\t\t\tbis.mark(64);\n\t\t\t\t\tif ( bis.read(hex, 0, 64) != 64 ) {\n\t\t\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t\t\t}\n\t\t\t\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn hexStringToByteArray(new String(hex));\n\t\t\t\t\t} catch (IndexOutOfBoundsException e) {\n\t\t\t\t\t\t// Key is not base 64, treat it as binary data\n\t\t\t\t\t\tbis.reset();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\n\t\t\t\tMessageDigest md;\n\t\t\t\ttry {\n\t\t\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\t\tthrow new IOException(\"SHA-256 not supported\");\n\t\t\t\t}\n\t\t\t\t//SHA256Digest md = new SHA256Digest();\n\t\t\t\tbyte[] buffer = new byte[2048];\n\t\t\t\tint offset = 0;\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint bytesRead = bis.read(buffer, 0, 2048);\n\t\t\t\t\t\tif ( bytesRead == -1 ) break;  // End of file\n\t\t\t\t\t\t\n\t\t\t\t\t\tmd.update(buffer, 0, bytesRead);\n\t\t\t\t\t\toffset += bytesRead;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tSystem.out.println(e.toString());\n\t\t\t\t}\n\t\t\t\n\t\t\t\treturn md.digest();\n\t\t\t}\n\n\tprotected abstract byte[] loadXmlKeyFile(String fileName);\n\n\tpublic static byte[] hexStringToByteArray(String s) {\n\t    int len = s.length();\n\t    byte[] data = new byte[len / 2];\n\t    for (int i = 0; i < len; i += 2) {\n\t        data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n\t                             + Character.digit(s.charAt(i+1), 16));\n\t    }\n\t    return data;\n\t}\n\n\tprotected byte[] getPasswordKey(String key, String encoding) throws IOException {\n\t\tassert(key!=null);\n\t\t\n\t\tif ( key.length() == 0 )\n\t\t    throw new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t\n\t\tMessageDigest md;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"SHA-256 not supported\");\n\t\t}\n\n\t\tbyte[] bKey;\n\t\ttry {\n\t\t\tbKey = key.getBytes(encoding);\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tassert false;\n\t\t\tbKey = key.getBytes();\n\t\t}\n\t\tmd.update(bKey, 0, bKey.length );\n\n\t\treturn md.digest();\n\t}\n\t\n\tpublic abstract byte[] getPasswordKey(String key) throws IOException;\n\n\tpublic abstract List<PwGroup> getGrpRoots();\n\t\n\tpublic abstract List<PwGroup> getGroups();\n\n\tpublic abstract List<PwEntry> getEntries();\n\t\n\tpublic abstract long getNumRounds();\n\t\n\tpublic abstract void setNumRounds(long rounds) throws NumberFormatException;\n\t\n\tpublic abstract boolean appSettingsEnabled();\n\t\n\tpublic abstract PwEncryptionAlgorithm getEncAlgorithm();\n\t\n\tpublic void addGroupTo(PwGroup newGroup, PwGroup parent) {\n\t\t// Add group to parent group\n\t\tif ( parent == null ) {\n\t\t\tparent = rootGroup;\n\t\t}\n\t\t\n\t\tparent.childGroups.add(newGroup);\n\t\tnewGroup.setParent(parent);\n\t}\n\t\n\tpublic void removeGroupFrom(PwGroup remove, PwGroup parent) {\n\t\t// Remove group from parent group\n\t\tparent.childGroups.remove(remove);\n\t}\n\t\n\tpublic void addEntryTo(PwEntry newEntry, PwGroup parent) {\n\t\t// Add entry to parent\n\t\tparent.childEntries.add(newEntry);\n\t}\n\t\n\tpublic void removeEntryFrom(PwEntry remove, PwGroup parent) {\n\t\t// Remove entry for parent\n\t\tparent.childEntries.remove(remove);\n\t}\n\n\tpublic abstract PwGroupId newGroupId();\n\t\n\t/**\n\t * Determine if an id number is already in use\n\t * \n\t * @param id\n\t *            ID number to check for\n\t * @return True if the ID is used, false otherwise\n\t */\n\tprotected boolean isGroupIdUsed(PwGroupId id) {\n\t\tList<PwGroup> groups = getGroups();\n\t\t\n\t\tfor (int i = 0; i < groups.size(); i++) {\n\t\t\tPwGroup group =groups.get(i);\n\t\t\tif (group.getId().equals(id)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\t\n\tpublic abstract PwGroup createGroup();\n\n}\n","lineNo":127}
{"Smelly Sample":"package com.keepassdroid.timers;\n\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.util.Log;\n\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.services.TimeoutService;\n\npublic class Timeout {\n\tprivate static final int REQUEST_ID = 0;\n\tprivate static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;  // 5 minutes\n\tprivate static String TAG = \"KeePass Timeout\";\n\n\tprivate static PendingIntent buildIntent(Context ctx) {\n\t\tIntent intent = new Intent(Intents.TIMEOUT);\n\t\tPendingIntent sender = PendingIntent.getBroadcast(ctx, REQUEST_ID, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n\n\t\treturn sender;\n\t}\n\t\n\tpublic static void start(Context ctx) {\n\n\t\tctx.startService(new Intent(ctx, TimeoutService.class));\n\n\t\tlong triggerTime = System.currentTimeMillis() + DEFAULT_TIMEOUT;\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout start\");\n\t\tam.set(AlarmManager.RTC, triggerTime, buildIntent(ctx));\n\t}\n\t\n\tpublic static void cancel(Context ctx) {\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout cancel\");\n\t\tam.cancel(buildIntent(ctx));\n\t\t\n\t\tctx.stopService(new Intent(ctx, TimeoutService.class));\n\n\t}\n\n}\n","Method after Refactoring":"package com.keepassdroid.timers;\n\nimport android.app.AlarmManager;\nimport android.app.PendingIntent;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.util.Log;\n\nimport com.android.keepass.R;\nimport com.keepassdroid.intents.Intents;\nimport com.keepassdroid.services.TimeoutService;\n\npublic class Timeout {\n\tprivate static final int REQUEST_ID = 0;\n\tprivate static final long DEFAULT_TIMEOUT = 5 * 60 * 1000;  // 5 minutes\n\tprivate static String TAG = \"KeePass Timeout\";\n\n\tprivate static PendingIntent buildIntent(Context ctx) {\n\t\tIntent intent = new Intent(Intents.TIMEOUT);\n\t\tPendingIntent sender = PendingIntent.getBroadcast(ctx, REQUEST_ID, intent, PendingIntent.FLAG_CANCEL_CURRENT);\n\n\t\treturn sender;\n\t}\n\t\n\tpublic static void start(Context ctx) {\n\n\n\t\tSharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx);\n\t\tString sTimeout = prefs.getString(ctx.getString(R.string.app_timeout_key), ctx.getString(R.string.clipboard_timeout_default));\n\t\t\n\t\tlong timeout;\n\t\ttry {\n\t\t\ttimeout = Long.parseLong(sTimeout);\n\t\t} catch (NumberFormatException e) {\n\t\t\ttimeout = DEFAULT_TIMEOUT;\n\t\t}\n\t\t\n\t\tif ( timeout == -1 ) {\n\t\t\t// No timeout don't start timeout service\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tctx.startService(new Intent(ctx, TimeoutService.class));\n\n\t\tlong triggerTime = System.currentTimeMillis() + timeout;\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout start\");\n\t\tam.set(AlarmManager.RTC, triggerTime, buildIntent(ctx));\n\t}\n\t\n\tpublic static void cancel(Context ctx) {\n\t\tAlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE);\n\t\t\n\t\tLog.d(TAG, \"Timeout cancel\");\n\t\tam.cancel(buildIntent(ctx));\n\t\t\n\t\tctx.stopService(new Intent(ctx, TimeoutService.class));\n\n\t}\n\n}\n","lineNo":33}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.crypto;\n\nimport java.lang.ref.PhantomReference;\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.HashMap;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\n\nimport android.util.Log;\n\npublic class NativeAESCipherSpi extends CipherSpi {\n\t\n\tprivate static boolean mIsStaticInit = false;\n\tprivate static HashMap<PhantomReference<NativeAESCipherSpi>, Long> mCleanup = new HashMap<PhantomReference<NativeAESCipherSpi>, Long>();\n\tprivate static ReferenceQueue<NativeAESCipherSpi> mQueue = new ReferenceQueue<NativeAESCipherSpi>();\n\t\n\tprivate final int AES_BLOCK_SIZE = 16;\n\tprivate byte[] mIV;\n\t\n\tprivate boolean mIsInited = false;\n\tprivate boolean mEncrypting = false;\n\tprivate long mCtxPtr;\n\t\n\tprivate int mBuffered;\n\tprivate boolean mPadding = false;\n\t\n\tprivate static void staticInit() {\n\t\tmIsStaticInit = true;\n\t\t\n\t\t// Start the cipher context cleanup thread to run forever\n\t\t(new Thread(new Cleanup())).start();\n\t}\n\t\n\tprivate static void addToCleanupQueue(NativeAESCipherSpi ref, long ptr) {\n\t\tLog.d(\"KeepassDroid\", \"queued cipher context: \" + ptr);\n\t\tmCleanup.put(new PhantomReference<NativeAESCipherSpi>(ref, mQueue), ptr);\n\t}\n\t\n\t/** Work with the garbage collector to clean up openssl memory when the cipher\n\t *  context is garbage collected.\n\t * @author bpellin\n\t *\n\t */\n\tprivate static class Cleanup implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tReference<? extends NativeAESCipherSpi> ref = mQueue.remove();\n\t\t\t\t\t\n\t\t\t\t\tlong ctx = mCleanup.remove(ref);\n\t\t\t\t\tnativeCleanup(ctx);\n\t\t\t\t\tLog.d(\"KeePassDroid\", \"Cleaned up cipher context: \" + ctx);\n\t\t\t\t\t\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// Do nothing, but resume looping if mQueue.remove is interrupted\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprivate static native void nativeCleanup(long ctxPtr);\n\n\tpublic NativeAESCipherSpi() {\n\t\tif ( ! mIsStaticInit ) {\n\t\t\tstaticInit();\n\t\t}\n\t}\n\n\t\n\t@Override\n\tprotected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n\t\t\tthrows IllegalBlockSizeException, BadPaddingException {\n\t\tint maxSize = engineGetOutputSize(inputLen);\n\t\tbyte[] output = new byte[maxSize];\n\t\t\n\t\tint finalSize = doFinal(input, inputOffset, inputLen, output, 0);\n\t\t\n\t\tif ( maxSize == finalSize ) {\n\t\t\treturn output;\n\t\t} else {\n\t\t\t// TODO: Special doFinal to avoid this copy\n\t\t\tbyte[] exact = new byte[finalSize];\n\t\t\tSystem.arraycopy(output, 0, exact, 0, finalSize);\n\t\t\treturn exact;\n\t\t}\n\t}\n\n\t@Override\n\tprotected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n\t\t\tbyte[] output, int outputOffset) throws ShortBufferException,\n\t\t\tIllegalBlockSizeException, BadPaddingException {\n\t\t\n\t\tint result = doFinal(input, inputOffset, inputLen, output, outputOffset);\n\t\t\n\t\tif ( result == -1 ) {\n\t\t\tthrow new ShortBufferException();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tprivate int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {\n\t\tmBuffered = 0;\n\t\t\n\t\tint outputSize = engineGetOutputSize(inputLen);\n\t\t\n\t\tint updateAmt =\tnativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize);\n\t\t\n\t\tint finalAmt = nativeDoFinal(mCtxPtr, output, outputOffset + updateAmt, outputSize - updateAmt); \n\t\t\n\t\treturn updateAmt + finalAmt;\n\t}\n\t\n\tprivate native int nativeDoFinal(long ctxPtr, byte[] output, int outputOffest, int outputSize);\n\n\t@Override\n\tprotected int engineGetBlockSize() {\n\t\treturn AES_BLOCK_SIZE;\n\t}\n\n\t@Override\n\tprotected byte[] engineGetIV() {\n\t\treturn mIV;\n\t}\n\n\t@Override\n\tprotected int engineGetOutputSize(int inputLen) {\n\t\tint totalLen = mBuffered + inputLen;\n\t\t\n\t\tif ( ! mPadding || ! mEncrypting ) {\n\t\t\treturn totalLen;\n\t\t}\n\t\t\n\t\tint padLen = AES_BLOCK_SIZE - (totalLen % AES_BLOCK_SIZE);\n\n\t\t// TODO: Round up to nearest full block (there's probably a better way to do this)\n\t\treturn totalLen + padLen;\n\t}\n\n\t@Override\n\tprotected AlgorithmParameters engineGetParameters() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void engineInit(int opmode, Key key, SecureRandom random)\n\t\t\tthrows InvalidKeyException {\n\n\t\tbyte[] ivArray = new byte[16];\n\t\trandom.nextBytes(ivArray);\n\t\t\n\t\tinit(opmode, key, new IvParameterSpec(ivArray));\n\t}\n\n\t@Override\n\tprotected void engineInit(int opmode, Key key,\n\t\t\tAlgorithmParameterSpec params, SecureRandom random)\n\t\t\tthrows InvalidKeyException, InvalidAlgorithmParameterException {\n\t\t\n\t\tIvParameterSpec ivparam;\n\t\t\n\t\tif ( params instanceof IvParameterSpec ) {\n\t\t\tivparam = (IvParameterSpec) params;\n\t\t} else {\n\t\t\tthrow new InvalidAlgorithmParameterException(\"params must be an IvParameterSpec.\");\n\t\t}\n\t\t\n\t\tinit(opmode, key, ivparam);\n\t}\n\t\n\n\t@Override\n\tprotected void engineInit(int opmode, Key key, AlgorithmParameters params,\n\t\t\tSecureRandom random) throws InvalidKeyException,\n\t\t\tInvalidAlgorithmParameterException {\n\t\t\n\t\ttry {\n\t\t\tengineInit(opmode, key, params.getParameterSpec(AlgorithmParameterSpec.class), random);\n\t\t} catch (InvalidParameterSpecException e) {\n\t\t\tthrow new InvalidAlgorithmParameterException(e);\n\t\t}\n\n\t}\n\n\tprivate void init(int opmode, Key key, IvParameterSpec params) {\n\t\tif ( mIsInited ) {\n\t\t\t// Do not allow multiple inits\n\t\t\tassert(true);\n\t\t\tthrow new RuntimeException(\"Don't allow multiple inits\");\n\t\t} else {\n\t\t\tNativeLib.init();\n\t\t\tmIsInited = true;\n\t\t}\n\t\t\n\t\tmIV = params.getIV();\n\t\tmEncrypting = opmode == Cipher.ENCRYPT_MODE;\n\t\tmBuffered = 0;\n\t\tmCtxPtr = nativeInit(mEncrypting, key.getEncoded(), mIV, mPadding);\n\t\taddToCleanupQueue(this, mCtxPtr);\n\t}\n\t\n\tprivate native long nativeInit(boolean encrypt, byte[] key, byte[] iv, boolean mPadding);\n\t\n\t@Override\n\tprotected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n\t\tif ( ! mode.equals(\"CBC\") ) {\n\t\t\tthrow new NoSuchAlgorithmException(\"This only supports CBC mode\");\n\t\t}\n\t}\n\n\t@Override\n\tprotected void engineSetPadding(String padding)\n\t\t\tthrows NoSuchPaddingException {\n\t\t\n\t\tif ( ! mIsInited ) {\n\t\t\tNativeLib.init();\n\t\t}\n\t\t\n\t\tif ( padding.length() == 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! padding.equals(\"PKCS5Padding\") ) {\n\t\t\tthrow new NoSuchPaddingException(\"Only supports PKCS5Padding.\");\n\t\t}\n\t\t\t\n\t\tmPadding = true;\n\n\t}\n\t\n\t@Override\n\tprotected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n\t\tint maxSize = engineGetOutputSize(inputLen);\n\t\tbyte output[] = new byte[maxSize];\n\t\t\n\t\tint updateSize = update(input, inputOffset, inputLen, output, 0);\n\t\t\n\t\tif ( updateSize == maxSize ) {\n\t\t\treturn output;\n\t\t} else {\n\t\t\t// TODO: We could optimize update for this case to avoid this extra copy\n\t\t\tbyte[] exact = new byte[updateSize];\n\t\t\tSystem.arraycopy(output, 0, exact, 0, updateSize);\n\t\t\treturn exact;\n\t\t}\n\t\t\n\t}\n\n\t@Override\n\tprotected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n\t\t\tbyte[] output, int outputOffset) throws ShortBufferException {\n\t\t\n\t\tint result = update(input, inputOffset, inputLen, output, outputOffset);\n\t\t\n\t\tif ( result == -1 ) {\n\t\t\tthrow new ShortBufferException(\"Insufficient buffer.\");\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tint update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {\n\t\tmBuffered = (mBuffered + inputLen) % AES_BLOCK_SIZE; \n\t\treturn nativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, engineGetOutputSize(inputLen));\n\t}\n\t\n\tprivate native int nativeUpdate(long ctxPtr, byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset, int outputSize);\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.crypto;\n\nimport java.lang.ref.PhantomReference;\nimport java.lang.ref.Reference;\nimport java.lang.ref.ReferenceQueue;\nimport java.security.AlgorithmParameters;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.Key;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\nimport java.util.HashMap;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherSpi;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\nimport javax.crypto.spec.IvParameterSpec;\n\nimport android.util.Log;\n\npublic class NativeAESCipherSpi extends CipherSpi {\n\t\n\tprivate static boolean mIsStaticInit = false;\n\tprivate static HashMap<PhantomReference<NativeAESCipherSpi>, Long> mCleanup = new HashMap<PhantomReference<NativeAESCipherSpi>, Long>();\n\tprivate static ReferenceQueue<NativeAESCipherSpi> mQueue = new ReferenceQueue<NativeAESCipherSpi>();\n\t\n\tprivate final int AES_BLOCK_SIZE = 16;\n\tprivate byte[] mIV;\n\t\n\tprivate boolean mIsInited = false;\n\tprivate boolean mEncrypting = false;\n\tprivate long mCtxPtr;\n\t\n\tprivate int mBuffered;\n\tprivate boolean mPadding = false;\n\t\n\tprivate static void staticInit() {\n\t\tmIsStaticInit = true;\n\t\t\n\t\t// Start the cipher context cleanup thread to run forever\n\t\t(new Thread(new Cleanup())).start();\n\t}\n\t\n\tprivate static void addToCleanupQueue(NativeAESCipherSpi ref, long ptr) {\n\t\tLog.d(\"KeepassDroid\", \"queued cipher context: \" + ptr);\n\t\tmCleanup.put(new PhantomReference<NativeAESCipherSpi>(ref, mQueue), ptr);\n\t}\n\t\n\t/** Work with the garbage collector to clean up openssl memory when the cipher\n\t *  context is garbage collected.\n\t * @author bpellin\n\t *\n\t */\n\tprivate static class Cleanup implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\twhile (true) {\n\t\t\t\ttry {\n\t\t\t\t\tReference<? extends NativeAESCipherSpi> ref = mQueue.remove();\n\t\t\t\t\t\n\t\t\t\t\tlong ctx = mCleanup.remove(ref);\n\t\t\t\t\tnativeCleanup(ctx);\n\t\t\t\t\tLog.d(\"KeePassDroid\", \"Cleaned up cipher context: \" + ctx);\n\t\t\t\t\t\n\t\t\t\t} catch (InterruptedException e) {\n\t\t\t\t\t// Do nothing, but resume looping if mQueue.remove is interrupted\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\tprivate static native void nativeCleanup(long ctxPtr);\n\n\tpublic NativeAESCipherSpi() {\n\t\tif ( ! mIsStaticInit ) {\n\t\t\tstaticInit();\n\t\t}\n\t}\n\n\t\n\t@Override\n\tprotected byte[] engineDoFinal(byte[] input, int inputOffset, int inputLen)\n\t\t\tthrows IllegalBlockSizeException, BadPaddingException {\n\t\tint maxSize = engineGetOutputSize(inputLen);\n\t\tbyte[] output = new byte[maxSize];\n\t\t\n\t\tint finalSize = doFinal(input, inputOffset, inputLen, output, 0);\n\t\t\n\t\tif ( maxSize == finalSize ) {\n\t\t\treturn output;\n\t\t} else {\n\t\t\t// TODO: Special doFinal to avoid this copy\n\t\t\tbyte[] exact = new byte[finalSize];\n\t\t\tSystem.arraycopy(output, 0, exact, 0, finalSize);\n\t\t\treturn exact;\n\t\t}\n\t}\n\n\t@Override\n\tprotected int engineDoFinal(byte[] input, int inputOffset, int inputLen,\n\t\t\tbyte[] output, int outputOffset) throws ShortBufferException,\n\t\t\tIllegalBlockSizeException, BadPaddingException {\n\t\t\n\t\tint result = doFinal(input, inputOffset, inputLen, output, outputOffset);\n\t\t\n\t\tif ( result == -1 ) {\n\t\t\tthrow new ShortBufferException();\n\t\t}\n\t\t\n\t\treturn result;\n\t}\n\t\n\tprivate int doFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {\n\t\t\n\t\tint outputSize = engineGetOutputSize(inputLen);\n\t\t\n\t\tint updateAmt =\tnativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize);\n\t\t\n\t\tint finalAmt = nativeDoFinal(mCtxPtr, output, outputOffset + updateAmt, outputSize - updateAmt); \n\t\t\n\t\tint out = updateAmt + finalAmt;\n\t\t\n\t\tmBuffered = 0;\n\t\t\n\t\treturn out;\n\t}\n\t\n\tprivate native int nativeDoFinal(long ctxPtr, byte[] output, int outputOffest, int outputSize);\n\n\t@Override\n\tprotected int engineGetBlockSize() {\n\t\treturn AES_BLOCK_SIZE;\n\t}\n\n\t@Override\n\tprotected byte[] engineGetIV() {\n\t\treturn mIV;\n\t}\n\n\t@Override\n\tprotected int engineGetOutputSize(int inputLen) {\n\t\tint totalLen = mBuffered + inputLen;\n\n\t\t/*\n\t\tif ( ! mPadding || ! mEncrypting ) {\n\t\t\treturn totalLen;\n\t\t}\n\t\t*/\n\t\t\n\t\tint padLen = AES_BLOCK_SIZE - (totalLen % AES_BLOCK_SIZE);\n\n\t\t// TODO: Round up to nearest full block (there's probably a better way to do this)\n\t\treturn totalLen + padLen;\n\t}\n\n\t@Override\n\tprotected AlgorithmParameters engineGetParameters() {\n\t\t// TODO Auto-generated method stub\n\t\treturn null;\n\t}\n\n\t@Override\n\tprotected void engineInit(int opmode, Key key, SecureRandom random)\n\t\t\tthrows InvalidKeyException {\n\n\t\tbyte[] ivArray = new byte[16];\n\t\trandom.nextBytes(ivArray);\n\t\t\n\t\tinit(opmode, key, new IvParameterSpec(ivArray));\n\t}\n\n\t@Override\n\tprotected void engineInit(int opmode, Key key,\n\t\t\tAlgorithmParameterSpec params, SecureRandom random)\n\t\t\tthrows InvalidKeyException, InvalidAlgorithmParameterException {\n\t\t\n\t\tIvParameterSpec ivparam;\n\t\t\n\t\tif ( params instanceof IvParameterSpec ) {\n\t\t\tivparam = (IvParameterSpec) params;\n\t\t} else {\n\t\t\tthrow new InvalidAlgorithmParameterException(\"params must be an IvParameterSpec.\");\n\t\t}\n\t\t\n\t\tinit(opmode, key, ivparam);\n\t}\n\t\n\n\t@Override\n\tprotected void engineInit(int opmode, Key key, AlgorithmParameters params,\n\t\t\tSecureRandom random) throws InvalidKeyException,\n\t\t\tInvalidAlgorithmParameterException {\n\t\t\n\t\ttry {\n\t\t\tengineInit(opmode, key, params.getParameterSpec(AlgorithmParameterSpec.class), random);\n\t\t} catch (InvalidParameterSpecException e) {\n\t\t\tthrow new InvalidAlgorithmParameterException(e);\n\t\t}\n\n\t}\n\n\tprivate void init(int opmode, Key key, IvParameterSpec params) {\n\t\tif ( mIsInited ) {\n\t\t\t// Do not allow multiple inits\n\t\t\tassert(true);\n\t\t\tthrow new RuntimeException(\"Don't allow multiple inits\");\n\t\t} else {\n\t\t\tNativeLib.init();\n\t\t\tmIsInited = true;\n\t\t}\n\t\t\n\t\tmIV = params.getIV();\n\t\tmEncrypting = opmode == Cipher.ENCRYPT_MODE;\n\t\tmBuffered = 0;\n\t\tmCtxPtr = nativeInit(mEncrypting, key.getEncoded(), mIV, mPadding);\n\t\taddToCleanupQueue(this, mCtxPtr);\n\t}\n\t\n\tprivate native long nativeInit(boolean encrypt, byte[] key, byte[] iv, boolean mPadding);\n\t\n\t@Override\n\tprotected void engineSetMode(String mode) throws NoSuchAlgorithmException {\n\t\tif ( ! mode.equals(\"CBC\") ) {\n\t\t\tthrow new NoSuchAlgorithmException(\"This only supports CBC mode\");\n\t\t}\n\t}\n\n\t@Override\n\tprotected void engineSetPadding(String padding)\n\t\t\tthrows NoSuchPaddingException {\n\t\t\n\t\tif ( ! mIsInited ) {\n\t\t\tNativeLib.init();\n\t\t}\n\t\t\n\t\tif ( padding.length() == 0 ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ! padding.equals(\"PKCS5Padding\") ) {\n\t\t\tthrow new NoSuchPaddingException(\"Only supports PKCS5Padding.\");\n\t\t}\n\t\t\t\n\t\tmPadding = true;\n\n\t}\n\t\n\t@Override\n\tprotected byte[] engineUpdate(byte[] input, int inputOffset, int inputLen) {\n\t\tint maxSize = engineGetOutputSize(inputLen);\n\t\tbyte output[] = new byte[maxSize];\n\t\t\n\t\tint updateSize = update(input, inputOffset, inputLen, output, 0);\n\t\t\n\t\tif ( updateSize == maxSize ) {\n\t\t\treturn output;\n\t\t} else {\n\t\t\t// TODO: We could optimize update for this case to avoid this extra copy\n\t\t\tbyte[] exact = new byte[updateSize];\n\t\t\tSystem.arraycopy(output, 0, exact, 0, updateSize);\n\t\t\treturn exact;\n\t\t}\n\t\t\n\t}\n\n\t@Override\n\tprotected int engineUpdate(byte[] input, int inputOffset, int inputLen,\n\t\t\tbyte[] output, int outputOffset) throws ShortBufferException {\n\t\t\n\t\tint result = update(input, inputOffset, inputLen, output, outputOffset);\n\t\t\n\t\tif ( result == -1 ) {\n\t\t\tthrow new ShortBufferException(\"Insufficient buffer.\");\n\t\t}\n\t\t\n\t\treturn result;\n\t\t\n\t}\n\t\n\tint update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) {\n\t\tint outputSize = engineGetOutputSize(inputLen);\n\t\t\n\t\tint out = nativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, outputSize);\n\t\t\n\t\tmBuffered = (mBuffered + ((inputLen - out))) % AES_BLOCK_SIZE;\n\t\t\n\t\treturn out;\n\t\t\n\t\t\n\t}\n\t\n\tprivate native int nativeUpdate(long ctxPtr, byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset, int outputSize);\n\t\n}\n","lineNo":307}
{"Smelly Sample":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntryV3   metaInfo;\n\n    // all entries\n    public Vector<PwEntryV3> entries = new Vector<PwEntryV3>();\n    // all groups\n    public Vector<PwGroupV3> groups = new Vector<PwGroupV3>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public Vector<PwGroupV3> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroupV3> getGrpChildren( PwGroupV3 parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroupV3 grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntryV3> getEntries( PwGroupV3 parent ) {\n\tVector<PwEntryV3> kids = new Vector<PwEntryV3>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntryV3 ent = (PwEntryV3)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntryV3 ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroupV3> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntryV3>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntryV3>();\n   \t\tgroup.childGroups = new Vector<PwGroupV3>();\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tif ( groups.get(i).groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n}\n","Method after Refactoring":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    private Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n\n    @Override\n    public Vector<PwGroup> getGroups() {\n    \treturn groups;\n    }\n    \n\t@Override\n\tpublic Vector<PwEntry> getEntries() {\n\t\treturn entries;\n\t}\n\t\n   \n    public void setGroups(Vector<PwGroup> grp) {\n    \tgroups = grp;\n    }\n    \n    @Override\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = (PwGroupV3) groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n\tpublic Vector<PwGroup> getGrpChildren(PwGroupV3 parent) {\n\t\tint idx = groups.indexOf(parent);\n\t\tint target = parent.level + 1;\n\t\tVector<PwGroup> kids = new Vector<PwGroup>();\n\t\twhile (++idx < groups.size()) {\n\t\t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(idx);\n\t\t\tif (grp.level < target)\n\t\t\t\tbreak;\n\t\t\telse if (grp.level == target)\n\t\t\t\tkids.addElement(grp);\n\t\t}\n\t\treturn kids;\n\t}\n\n\tpublic Vector<PwEntry> getEntries(PwGroupV3 parent) {\n\t\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t\t/*\n\t\t * for( Iterator i = entries.iterator(); i.hasNext(); ) { PwEntryV3 ent\n\t\t * = (PwEntryV3)i.next(); if( ent.groupId == parent.groupId ) kids.add(\n\t\t * ent ); }\n\t\t */\n\t\tfor (int i = 0; i < entries.size(); i++) {\n\t\t\tPwEntryV3 ent = (PwEntryV3) entries.elementAt(i);\n\t\t\tif (ent.groupId == parent.groupId)\n\t\t\t\tkids.addElement(ent);\n\t\t}\n\t\treturn kids;\n\t}\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.setGroups(rootChildGroups);\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t    \tPwGroupV3 grp = (PwGroupV3) rootChildGroups.elementAt(i);\n\t\t\tgrp.parent = rootGroup;\n\t\t\tconstructTree(grp);\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.setGroups(getGrpChildren(currentGroup));\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t\tPwEntryV3 entry = (PwEntryV3) currentGroup.childEntries.elementAt(i);\n\t    entry.parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t\tPwGroupV3 grp = (PwGroupV3) currentGroup.childGroups.elementAt(i); \n\t    grp.parent = currentGroup;\n\t    constructTree((PwGroupV3) currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntry>();\n   \t\tgroup.setGroups(new Vector<PwGroup>());\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 group = (PwGroupV3) groups.get(i);\n    \t\tif ( group.groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n\t@Override\n\tpublic long getNumRounds() {\n\t\treturn numKeyEncRounds;\n\t}\n\n\t@Override\n\tpublic void setNumRonuds(long rounds) throws NumberFormatException {\n\t\tif ( rounds > Integer.MAX_VALUE || rounds < Integer.MIN_VALUE ) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\t\n\t\tnumKeyEncRounds = (int) rounds;\n\t}\n\n\n}\n","lineNo":172}
{"Smelly Sample":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntryV3   metaInfo;\n\n    // all entries\n    public Vector<PwEntryV3> entries = new Vector<PwEntryV3>();\n    // all groups\n    public Vector<PwGroupV3> groups = new Vector<PwGroupV3>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public Vector<PwGroupV3> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroupV3> getGrpChildren( PwGroupV3 parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroupV3 grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntryV3> getEntries( PwGroupV3 parent ) {\n\tVector<PwEntryV3> kids = new Vector<PwEntryV3>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntryV3 ent = (PwEntryV3)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntryV3 ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroupV3> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntryV3>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntryV3>();\n   \t\tgroup.childGroups = new Vector<PwGroupV3>();\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tif ( groups.get(i).groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n}\n","Method after Refactoring":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    private Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n\n    @Override\n    public Vector<PwGroup> getGroups() {\n    \treturn groups;\n    }\n    \n\t@Override\n\tpublic Vector<PwEntry> getEntries() {\n\t\treturn entries;\n\t}\n\t\n   \n    public void setGroups(Vector<PwGroup> grp) {\n    \tgroups = grp;\n    }\n    \n    @Override\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = (PwGroupV3) groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n\tpublic Vector<PwGroup> getGrpChildren(PwGroupV3 parent) {\n\t\tint idx = groups.indexOf(parent);\n\t\tint target = parent.level + 1;\n\t\tVector<PwGroup> kids = new Vector<PwGroup>();\n\t\twhile (++idx < groups.size()) {\n\t\t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(idx);\n\t\t\tif (grp.level < target)\n\t\t\t\tbreak;\n\t\t\telse if (grp.level == target)\n\t\t\t\tkids.addElement(grp);\n\t\t}\n\t\treturn kids;\n\t}\n\n\tpublic Vector<PwEntry> getEntries(PwGroupV3 parent) {\n\t\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t\t/*\n\t\t * for( Iterator i = entries.iterator(); i.hasNext(); ) { PwEntryV3 ent\n\t\t * = (PwEntryV3)i.next(); if( ent.groupId == parent.groupId ) kids.add(\n\t\t * ent ); }\n\t\t */\n\t\tfor (int i = 0; i < entries.size(); i++) {\n\t\t\tPwEntryV3 ent = (PwEntryV3) entries.elementAt(i);\n\t\t\tif (ent.groupId == parent.groupId)\n\t\t\t\tkids.addElement(ent);\n\t\t}\n\t\treturn kids;\n\t}\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.setGroups(rootChildGroups);\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t    \tPwGroupV3 grp = (PwGroupV3) rootChildGroups.elementAt(i);\n\t\t\tgrp.parent = rootGroup;\n\t\t\tconstructTree(grp);\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.setGroups(getGrpChildren(currentGroup));\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t\tPwEntryV3 entry = (PwEntryV3) currentGroup.childEntries.elementAt(i);\n\t    entry.parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t\tPwGroupV3 grp = (PwGroupV3) currentGroup.childGroups.elementAt(i); \n\t    grp.parent = currentGroup;\n\t    constructTree((PwGroupV3) currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntry>();\n   \t\tgroup.setGroups(new Vector<PwGroup>());\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 group = (PwGroupV3) groups.get(i);\n    \t\tif ( group.groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n\t@Override\n\tpublic long getNumRounds() {\n\t\treturn numKeyEncRounds;\n\t}\n\n\t@Override\n\tpublic void setNumRonuds(long rounds) throws NumberFormatException {\n\t\tif ( rounds > Integer.MAX_VALUE || rounds < Integer.MIN_VALUE ) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\t\n\t\tnumKeyEncRounds = (int) rounds;\n\t}\n\n\n}\n","lineNo":191}
{"Smelly Sample":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntryV3   metaInfo;\n\n    // all entries\n    public Vector<PwEntryV3> entries = new Vector<PwEntryV3>();\n    // all groups\n    public Vector<PwGroupV3> groups = new Vector<PwGroupV3>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public Vector<PwGroupV3> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroupV3> getGrpChildren( PwGroupV3 parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroupV3 grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntryV3> getEntries( PwGroupV3 parent ) {\n\tVector<PwEntryV3> kids = new Vector<PwEntryV3>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntryV3 ent = (PwEntryV3)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntryV3 ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroupV3> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntryV3>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntryV3>();\n   \t\tgroup.childGroups = new Vector<PwGroupV3>();\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tif ( groups.get(i).groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n}\n","Method after Refactoring":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    private Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n\n    @Override\n    public Vector<PwGroup> getGroups() {\n    \treturn groups;\n    }\n    \n\t@Override\n\tpublic Vector<PwEntry> getEntries() {\n\t\treturn entries;\n\t}\n\t\n   \n    public void setGroups(Vector<PwGroup> grp) {\n    \tgroups = grp;\n    }\n    \n    @Override\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = (PwGroupV3) groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n\tpublic Vector<PwGroup> getGrpChildren(PwGroupV3 parent) {\n\t\tint idx = groups.indexOf(parent);\n\t\tint target = parent.level + 1;\n\t\tVector<PwGroup> kids = new Vector<PwGroup>();\n\t\twhile (++idx < groups.size()) {\n\t\t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(idx);\n\t\t\tif (grp.level < target)\n\t\t\t\tbreak;\n\t\t\telse if (grp.level == target)\n\t\t\t\tkids.addElement(grp);\n\t\t}\n\t\treturn kids;\n\t}\n\n\tpublic Vector<PwEntry> getEntries(PwGroupV3 parent) {\n\t\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t\t/*\n\t\t * for( Iterator i = entries.iterator(); i.hasNext(); ) { PwEntryV3 ent\n\t\t * = (PwEntryV3)i.next(); if( ent.groupId == parent.groupId ) kids.add(\n\t\t * ent ); }\n\t\t */\n\t\tfor (int i = 0; i < entries.size(); i++) {\n\t\t\tPwEntryV3 ent = (PwEntryV3) entries.elementAt(i);\n\t\t\tif (ent.groupId == parent.groupId)\n\t\t\t\tkids.addElement(ent);\n\t\t}\n\t\treturn kids;\n\t}\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.setGroups(rootChildGroups);\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t    \tPwGroupV3 grp = (PwGroupV3) rootChildGroups.elementAt(i);\n\t\t\tgrp.parent = rootGroup;\n\t\t\tconstructTree(grp);\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.setGroups(getGrpChildren(currentGroup));\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t\tPwEntryV3 entry = (PwEntryV3) currentGroup.childEntries.elementAt(i);\n\t    entry.parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t\tPwGroupV3 grp = (PwGroupV3) currentGroup.childGroups.elementAt(i); \n\t    grp.parent = currentGroup;\n\t    constructTree((PwGroupV3) currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntry>();\n   \t\tgroup.setGroups(new Vector<PwGroup>());\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 group = (PwGroupV3) groups.get(i);\n    \t\tif ( group.groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n\t@Override\n\tpublic long getNumRounds() {\n\t\treturn numKeyEncRounds;\n\t}\n\n\t@Override\n\tpublic void setNumRonuds(long rounds) throws NumberFormatException {\n\t\tif ( rounds > Integer.MAX_VALUE || rounds < Integer.MIN_VALUE ) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\t\n\t\tnumKeyEncRounds = (int) rounds;\n\t}\n\n\n}\n","lineNo":186}
{"Smelly Sample":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntryV3   metaInfo;\n\n    // all entries\n    public Vector<PwEntryV3> entries = new Vector<PwEntryV3>();\n    // all groups\n    public Vector<PwGroupV3> groups = new Vector<PwGroupV3>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public Vector<PwGroupV3> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroupV3> getGrpChildren( PwGroupV3 parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroupV3 grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntryV3> getEntries( PwGroupV3 parent ) {\n\tVector<PwEntryV3> kids = new Vector<PwEntryV3>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntryV3 ent = (PwEntryV3)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntryV3 ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroupV3> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntryV3>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntryV3>();\n   \t\tgroup.childGroups = new Vector<PwGroupV3>();\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tif ( groups.get(i).groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n}\n","Method after Refactoring":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    private Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n\n    @Override\n    public Vector<PwGroup> getGroups() {\n    \treturn groups;\n    }\n    \n\t@Override\n\tpublic Vector<PwEntry> getEntries() {\n\t\treturn entries;\n\t}\n\t\n   \n    public void setGroups(Vector<PwGroup> grp) {\n    \tgroups = grp;\n    }\n    \n    @Override\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = (PwGroupV3) groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n\tpublic Vector<PwGroup> getGrpChildren(PwGroupV3 parent) {\n\t\tint idx = groups.indexOf(parent);\n\t\tint target = parent.level + 1;\n\t\tVector<PwGroup> kids = new Vector<PwGroup>();\n\t\twhile (++idx < groups.size()) {\n\t\t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(idx);\n\t\t\tif (grp.level < target)\n\t\t\t\tbreak;\n\t\t\telse if (grp.level == target)\n\t\t\t\tkids.addElement(grp);\n\t\t}\n\t\treturn kids;\n\t}\n\n\tpublic Vector<PwEntry> getEntries(PwGroupV3 parent) {\n\t\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t\t/*\n\t\t * for( Iterator i = entries.iterator(); i.hasNext(); ) { PwEntryV3 ent\n\t\t * = (PwEntryV3)i.next(); if( ent.groupId == parent.groupId ) kids.add(\n\t\t * ent ); }\n\t\t */\n\t\tfor (int i = 0; i < entries.size(); i++) {\n\t\t\tPwEntryV3 ent = (PwEntryV3) entries.elementAt(i);\n\t\t\tif (ent.groupId == parent.groupId)\n\t\t\t\tkids.addElement(ent);\n\t\t}\n\t\treturn kids;\n\t}\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.setGroups(rootChildGroups);\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t    \tPwGroupV3 grp = (PwGroupV3) rootChildGroups.elementAt(i);\n\t\t\tgrp.parent = rootGroup;\n\t\t\tconstructTree(grp);\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.setGroups(getGrpChildren(currentGroup));\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t\tPwEntryV3 entry = (PwEntryV3) currentGroup.childEntries.elementAt(i);\n\t    entry.parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t\tPwGroupV3 grp = (PwGroupV3) currentGroup.childGroups.elementAt(i); \n\t    grp.parent = currentGroup;\n\t    constructTree((PwGroupV3) currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntry>();\n   \t\tgroup.setGroups(new Vector<PwGroup>());\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 group = (PwGroupV3) groups.get(i);\n    \t\tif ( group.groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n\t@Override\n\tpublic long getNumRounds() {\n\t\treturn numKeyEncRounds;\n\t}\n\n\t@Override\n\tpublic void setNumRonuds(long rounds) throws NumberFormatException {\n\t\tif ( rounds > Integer.MAX_VALUE || rounds < Integer.MIN_VALUE ) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\t\n\t\tnumKeyEncRounds = (int) rounds;\n\t}\n\n\n}\n","lineNo":172}
{"Smelly Sample":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntryV3   metaInfo;\n\n    // all entries\n    public Vector<PwEntryV3> entries = new Vector<PwEntryV3>();\n    // all groups\n    public Vector<PwGroupV3> groups = new Vector<PwGroupV3>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public Vector<PwGroupV3> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroupV3> getGrpChildren( PwGroupV3 parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroupV3> kids = new Vector<PwGroupV3>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroupV3 grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntryV3> getEntries( PwGroupV3 parent ) {\n\tVector<PwEntryV3> kids = new Vector<PwEntryV3>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntryV3 ent = (PwEntryV3)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntryV3 ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroupV3> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntryV3>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntryV3>();\n   \t\tgroup.childGroups = new Vector<PwGroupV3>();\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tif ( groups.get(i).groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n}\n","Method after Refactoring":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage com.keepassdroid.database;\n\n// Java\nimport java.io.IOException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.Random;\nimport java.util.Vector;\n\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\n\n\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwDatabaseV3 extends PwDatabase {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    private Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Algorithm used to encrypt the database\n    public int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeaderV3 dbHeader;\n    // root group\n    public PwGroupV3 rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n\n    @Override\n    public Vector<PwGroup> getGroups() {\n    \treturn groups;\n    }\n    \n\t@Override\n\tpublic Vector<PwEntry> getEntries() {\n\t\treturn entries;\n\t}\n\t\n   \n    public void setGroups(Vector<PwGroup> grp) {\n    \tgroups = grp;\n    }\n    \n    @Override\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroupV3 grp = (PwGroupV3) groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n\tpublic Vector<PwGroup> getGrpChildren(PwGroupV3 parent) {\n\t\tint idx = groups.indexOf(parent);\n\t\tint target = parent.level + 1;\n\t\tVector<PwGroup> kids = new Vector<PwGroup>();\n\t\twhile (++idx < groups.size()) {\n\t\t\tPwGroupV3 grp = (PwGroupV3) groups.elementAt(idx);\n\t\t\tif (grp.level < target)\n\t\t\t\tbreak;\n\t\t\telse if (grp.level == target)\n\t\t\t\tkids.addElement(grp);\n\t\t}\n\t\treturn kids;\n\t}\n\n\tpublic Vector<PwEntry> getEntries(PwGroupV3 parent) {\n\t\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t\t/*\n\t\t * for( Iterator i = entries.iterator(); i.hasNext(); ) { PwEntryV3 ent\n\t\t * = (PwEntryV3)i.next(); if( ent.groupId == parent.groupId ) kids.add(\n\t\t * ent ); }\n\t\t */\n\t\tfor (int i = 0; i < entries.size(); i++) {\n\t\t\tPwEntryV3 ent = (PwEntryV3) entries.elementAt(i);\n\t\t\tif (ent.groupId == parent.groupId)\n\t\t\t\tkids.addElement(ent);\n\t\t}\n\t\treturn kids;\n\t}\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroupV3 group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntryV3 entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroupV3 currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroupV3();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.setGroups(rootChildGroups);\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    rootGroup.level = -1;\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t    \tPwGroupV3 grp = (PwGroupV3) rootChildGroups.elementAt(i);\n\t\t\tgrp.parent = rootGroup;\n\t\t\tconstructTree(grp);\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.setGroups(getGrpChildren(currentGroup));\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t\tPwEntryV3 entry = (PwEntryV3) currentGroup.childEntries.elementAt(i);\n\t    entry.parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t\tPwGroupV3 grp = (PwGroupV3) currentGroup.childGroups.elementAt(i); \n\t    grp.parent = currentGroup;\n\t    constructTree((PwGroupV3) currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n    \n    public PwGroupV3 newGroup(String name, PwGroupV3 parent) {\n    \t// Initialize group    \t\n    \tPwGroupV3 group = new PwGroupV3();\n\n    \tgroup.parent = parent;\n    \tgroup.groupId = newGroupId();\n    \tgroup.imageId = 0;\n    \tgroup.name = name;\n    \t\n    \tDate now = Calendar.getInstance().getTime();\n    \tgroup.tCreation = new PwDate(now);\n    \tgroup.tLastAccess = new PwDate(now);\n    \tgroup.tLastMod = new PwDate(now);\n    \tgroup.tExpire = new PwDate(PwGroupV3.NEVER_EXPIRE);\n    \t\n   \t\tgroup.level = parent.level + 1;\n\n   \t\tgroup.childEntries = new Vector<PwEntry>();\n   \t\tgroup.setGroups(new Vector<PwGroup>());\n   \t\t\n   \t\t// Add group PwDatabaseV3 and Parent\n   \t\tparent.childGroups.add(group);\n   \t\tgroups.add(group);\n   \t\t\n    \treturn group;\n    }\n    \n    public void removeGroup(PwGroupV3 group) {\n    \tgroup.parent.childGroups.remove(group);\n    \tgroups.remove(group);\n    }\n    \n    /** Generates an unused random group id\n     * @return new group id\n     */\n    private int newGroupId() {\n    \tboolean foundUnusedId = false;\n    \tint newId = 0;\n    \t\n    \tRandom random = new Random();\n    \t\n    \twhile ( ! foundUnusedId ) {\n    \t\tnewId = random.nextInt();\n    \t\t\n    \t\tif ( ! isGroupIdUsed(newId) ) {\n    \t\t\tfoundUnusedId = true;\n    \t\t}\n    \t}\n    \t\n    \treturn newId;\n    }\n    \n    /** Determine if an id number is already in use\n     * @param id ID number to check for\n     * @return True if the ID is used, false otherwise\n     */\n    private boolean isGroupIdUsed(int id) {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroupV3 group = (PwGroupV3) groups.get(i);\n    \t\tif ( group.groupId == id ) {\n    \t\t\treturn true;\n    \t\t}\n    \t}\n    \t\n    \treturn false;\n    }\n    \n\tpublic byte[] getMasterKey(String key, String keyFileName)\n\tthrows InvalidKeyFileException, IOException {\n\t\tassert( key != null && keyFileName != null );\n\t\t\n\t\tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n\t\t\treturn getCompositeKey(key, keyFileName);\n\t\t} else if ( key.length() > 0 ) {\n\t\t\treturn getPasswordKey(key);\n\t\t} else if ( keyFileName.length() > 0 ) {\n\t\t\treturn getFileKey(keyFileName);\n\t\t} else {\n\t\t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t}\n\t\t\n\t}\n\n\tpublic byte[] getPasswordKey(String key) throws IOException {\n\t\treturn getPasswordKey(key, \"ISO-8859-1\");\n\t}\n\n\t@Override\n\tpublic long getNumRounds() {\n\t\treturn numKeyEncRounds;\n\t}\n\n\t@Override\n\tpublic void setNumRonuds(long rounds) throws NumberFormatException {\n\t\tif ( rounds > Integer.MAX_VALUE || rounds < Integer.MIN_VALUE ) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\t\n\t\tnumKeyEncRounds = (int) rounds;\n\t}\n\n\n}\n","lineNo":256}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherInputStream;\nimport javax.crypto.NoSuchPaddingException;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.LEDataInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\n\npublic class ImporterV4 extends Importer {\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile) throws IOException, InvalidKeyFileException,\n\t\t\tInvalidPasswordException, InvalidDBSignatureException, InvalidDBVersionException {\n\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile, UpdateStatus status) throws IOException,\n\t\t\tInvalidKeyFileException, InvalidPasswordException,\n\t\t\tInvalidDBSignatureException, InvalidDBVersionException {\n\n\t\t\n\t\tPwDatabaseV4 db = new PwDatabaseV4();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\t\t\n\t\theader.loadFromFile(inStream);\n\t\t\t\n\t\tdb.setMasterKey(password, keyfile);\n\t\tdb.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);\n\t\t\n\t\t// Attach decryptor\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = CipherFactory.getInstance(db.dataCipher, db.finalKey, header.encryptionIV);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t}\n\t\t\n\t\tInputStream decrypted = new CipherInputStream(inStream, cipher);\n\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\tbyte[] storedStartBytes = dataDecrypted.readBytes(32);\n\t\tif ( storedStartBytes == null || storedStartBytes.length != 32 ) {\n\t\t\tthrow new IOException(\"Invalid data.\");\n\t\t}\n\t\t\n\t\tif ( ! Arrays.equals(storedStartBytes, header.streamStartBytes) ) {\n\t\t\t// TODO: Probably need a special error here.  This would probably indicate\n\t\t\t//       an incorrect password/key\n\t\t\tthrow new IOException(\"Bad database key\");\n\t\t}\n\t\t\n\t\tHashedBlockInputStream hashed = new HashedBlockInputStream(decrypted); \n\t\t\n\t\tInputStream decompressed;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tdecompressed = new GZIPInputStream(hashed); \n\t\t} else {\n\t\t\tdecompressed = hashed;\n\t\t}\n\t\t\n\t\t// TODO: output into database instead of file\n\t\tFileOutputStream fos = new FileOutputStream(\"/sdcard/output.xml\");\n\t\t\n\t\tbyte[] buf = new byte[1024];\n\t\tint bytesRead;\n\t\twhile ( (bytesRead = decompressed.read(buf)) != -1 ) {\n\t\t\tfos.write(buf, 0, bytesRead);\n\t\t}\n\t\t\n\t\tfos.close();\n\t\t\n\t\treturn db;\n\t}\n\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database.load;\n\nimport java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.Arrays;\nimport java.util.zip.GZIPInputStream;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.w3c.dom.Document;\nimport org.xml.sax.SAXException;\n\nimport com.keepassdroid.UpdateStatus;\nimport com.keepassdroid.crypto.CipherFactory;\nimport com.keepassdroid.database.PwCompressionAlgorithm;\nimport com.keepassdroid.database.PwDatabaseV4;\nimport com.keepassdroid.database.PwDbHeaderV4;\nimport com.keepassdroid.database.exception.InconsistentDBException;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidDBVersionException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.stream.BetterCipherInputStream;\nimport com.keepassdroid.stream.HashedBlockInputStream;\nimport com.keepassdroid.stream.LEDataInputStream;\n\npublic class ImporterV4 extends Importer {\n\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile) throws IOException, InvalidKeyFileException,\n\t\t\tInvalidPasswordException, InvalidDBSignatureException, InvalidDBVersionException {\n\n\t\treturn openDatabase(inStream, password, keyfile, new UpdateStatus());\n\t}\n\t\n\t@Override\n\tpublic PwDatabaseV4 openDatabase(InputStream inStream, String password,\n\t\t\tString keyfile, UpdateStatus status) throws IOException,\n\t\t\tInvalidKeyFileException, InvalidPasswordException,\n\t\t\tInvalidDBSignatureException, InvalidDBVersionException {\n\n\t\t// TODO: Measure whether this buffer is better or worse for performance\n\t\tBufferedInputStream bis = new BufferedInputStream(inStream);\n\n\t\tPwDatabaseV4 db = new PwDatabaseV4();\n\t\t\n\t\tPwDbHeaderV4 header = new PwDbHeaderV4(db);\n\t\t\n\t\theader.loadFromFile(bis);\n\t\t\t\n\t\tdb.setMasterKey(password, keyfile);\n\t\tdb.makeFinalKey(header.masterSeed, header.transformSeed, (int)db.numKeyEncRounds);\n\t\t\n\t\t// Attach decryptor\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = CipherFactory.getInstance(db.dataCipher, db.finalKey, header.encryptionIV);\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (NoSuchPaddingException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new IOException(\"Invalid algorithm.\");\n\t\t}\n\t\t\n\t\tInputStream decrypted = new BetterCipherInputStream(bis, cipher, 50 * 1024);\n\t\tLEDataInputStream dataDecrypted = new LEDataInputStream(decrypted);\n\t\tbyte[] storedStartBytes = dataDecrypted.readBytes(32);\n\t\tif ( storedStartBytes == null || storedStartBytes.length != 32 ) {\n\t\t\tthrow new IOException(\"Invalid data.\");\n\t\t}\n\t\t\n\t\tif ( ! Arrays.equals(storedStartBytes, header.streamStartBytes) ) {\n\t\t\t// TODO: Probably need a special error here.  This would probably indicate\n\t\t\t//       an incorrect password/key\n\t\t\tthrow new IOException(\"Bad database key\");\n\t\t}\n\n\t\t\t\tHashedBlockInputStream hashed = new HashedBlockInputStream(dataDecrypted); \n\t\t\n\t\tInputStream decompressed;\n\t\tif ( db.compressionAlgorithm == PwCompressionAlgorithm.Gzip ) {\n\t\t\tdecompressed = new GZIPInputStream(hashed); \n\t\t} else {\n\t\t\tdecompressed = hashed;\n\t\t}\n\t\t\n\t\t// TODO: Measure whether this buffer is better or worse for performance\n\t\tBufferedInputStream bis2 = new BufferedInputStream(decompressed);\n\t\t\n\t\t// Parse the xml document\n\t\tDocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n\t\tDocumentBuilder docB;\n\t\ttry {\n\t\t\tdocB = dbf.newDocumentBuilder();\n\t\t} catch (ParserConfigurationException e) {\n\t\t\tthrow new IOException(\"Couldn't create document builder.\");\n\t\t}\n\t\t\n\t\tDocument doc;\n\t\ttry {\n\t\t\tdoc = docB.parse(bis2);\n\t\t} catch (SAXException e) {\n\t\t\tthrow new IOException(\"Failed to parse db xml: \" + e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\ttry {\n\t\t\tdb.parseDB(doc);\n\t\t} catch (InconsistentDBException e) {\n\t\t\tthrow new IOException(e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\t/*\n\t\tFileOutputStream fos = new FileOutputStream(\"/sdcard/outputx.xml\");\n\t\tbyte[] buf = new byte[1024];\n\t\tint bytesRead;\n\t\twhile ( (bytesRead = decompressed.read(buf)) != -1 ) {\n\t\t\tfos.write(buf, 0, bytesRead);\n\t\t}\n\t\tfos.close();\n\t\t*/\n\t\t\n\t\treturn db;\n\t\t\n\t\t\n\t}\n\n\n}\n","lineNo":71}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.tests.database;\n\nimport java.util.Vector;\n\n\nimport android.content.Context;\nimport android.test.AndroidTestCase;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.edit.DeleteGroup;\nimport com.keepassdroid.search.SearchDbHelper;\n\npublic class DeleteEntry extends AndroidTestCase {\n\tprivate static final String GROUP1_NAME = \"Group1\";\n\tprivate static final String ENTRY1_NAME = \"Test1\";\n\tprivate static final String ENTRY2_NAME = \"Test2\";\n\tprivate static final String KEYFILE = \"\";\n\tprivate static final String PASSWORD = \"12345\";\n\tprivate static final String ASSET = \"delete.kdb\";\n\tprivate static final String FILENAME = \"/sdcard/delete.kdb\";\n\t\n\tpublic void testDelete() {\n\t\t\n\t\tDatabase db;\n\t\t\n\t\tContext ctx = getContext();\n\t\t\n\t\ttry {\n\t\t\tdb = TestData.GetDb(ctx, ASSET, PASSWORD, KEYFILE, FILENAME);\n\t\t} catch (Exception e) {\n\t\t\tassertTrue(\"Failed to open database: \" + e.getMessage(), false);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tPwGroupV3 group1 = getGroup(db.pm, GROUP1_NAME);\n\t\tassertNotNull(\"Could not find group1\", group1);\n\t\t\n\t\t// Delete the group\n\t\tDeleteGroup task = new DeleteGroup(db, group1, null, true);\n\t\ttask.run();\n\t\t\n\t\t// Verify the entries were deleted\n\t\tPwEntryV3 entry1 = getEntry(db.pm, ENTRY1_NAME);\n\t\tassertNull(\"Entry 1 was not removed\", entry1);\n\n\t\tPwEntryV3 entry2 = getEntry(db.pm, ENTRY2_NAME);\n\t\tassertNull(\"Entry 2 was not removed\", entry2);\n\t\t\n\t\t// Verify the entries were removed from the search index\n\t\tSearchDbHelper dbHelp = new SearchDbHelper(ctx);\n\t\tdbHelp.open();\n\t\tPwGroupV3 results1 = dbHelp.search(db, ENTRY1_NAME);\n\t\tPwGroupV3 results2 = dbHelp.search(db, ENTRY2_NAME);\n\t\tdbHelp.close();\n\t\t\n\t\tassertEquals(\"Entry1 was not removed from the search results\", 0, results1.childEntries.size());\n\t\tassertEquals(\"Entry2 was not removed from the search results\", 0, results2.childEntries.size());\n\t\t\n\t\t// Verify the group was deleted\n\t\tgroup1 = getGroup(db.pm, GROUP1_NAME);\n\t\tassertNull(\"Group 1 was not removed.\", group1);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tprivate PwEntryV3 getEntry(PwDatabaseV3 pm, String name) {\n\t\tVector<PwEntryV3> entries = pm.entries;\n\t\tfor ( int i = 0; i < entries.size(); i++ ) {\n\t\t\tPwEntryV3 entry = entries.get(i);\n\t\t\tif ( entry.title.equals(name) ) {\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate PwGroupV3 getGroup(PwDatabaseV3 pm, String name) {\n\t\tVector<PwGroupV3> groups = pm.groups;\n\t\tfor ( int i = 0; i < groups.size(); i++ ) {\n\t\t\tPwGroupV3 group = groups.get(i);\n\t\t\tif ( group.name.equals(name) ) {\n\t\t\t\treturn group;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.tests.database;\n\nimport java.util.Vector;\n\nimport android.content.Context;\nimport android.test.AndroidTestCase;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwEntry;\nimport com.keepassdroid.database.PwGroup;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.edit.DeleteGroup;\nimport com.keepassdroid.search.SearchDbHelper;\n\npublic class DeleteEntry extends AndroidTestCase {\n\tprivate static final String GROUP1_NAME = \"Group1\";\n\tprivate static final String ENTRY1_NAME = \"Test1\";\n\tprivate static final String ENTRY2_NAME = \"Test2\";\n\tprivate static final String KEYFILE = \"\";\n\tprivate static final String PASSWORD = \"12345\";\n\tprivate static final String ASSET = \"delete.kdb\";\n\tprivate static final String FILENAME = \"/sdcard/delete.kdb\";\n\t\n\tpublic void testDelete() {\n\t\t\n\t\tDatabase db;\n\t\t\n\t\tContext ctx = getContext();\n\t\t\n\t\ttry {\n\t\t\tdb = TestData.GetDb(ctx, ASSET, PASSWORD, KEYFILE, FILENAME);\n\t\t} catch (Exception e) {\n\t\t\tassertTrue(\"Failed to open database: \" + e.getMessage(), false);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tPwDatabaseV3 pm = (PwDatabaseV3) db.pm;\n\t\tPwGroup group1 = getGroup(pm, GROUP1_NAME);\n\t\tassertNotNull(\"Could not find group1\", group1);\n\t\t\n\t\t// Delete the group\n\t\tDeleteGroup task = new DeleteGroup(db, group1, null, true);\n\t\ttask.run();\n\t\t\n\t\t// Verify the entries were deleted\n\t\tPwEntry entry1 = getEntry(pm, ENTRY1_NAME);\n\t\tassertNull(\"Entry 1 was not removed\", entry1);\n\n\t\tPwEntry entry2 = getEntry(pm, ENTRY2_NAME);\n\t\tassertNull(\"Entry 2 was not removed\", entry2);\n\t\t\n\t\t// Verify the entries were removed from the search index\n\t\tSearchDbHelper dbHelp = new SearchDbHelper(ctx);\n\t\tdbHelp.open();\n\t\tPwGroupV3 results1 = dbHelp.search(db, ENTRY1_NAME);\n\t\tPwGroupV3 results2 = dbHelp.search(db, ENTRY2_NAME);\n\t\tdbHelp.close();\n\t\t\n\t\tassertEquals(\"Entry1 was not removed from the search results\", 0, results1.childEntries.size());\n\t\tassertEquals(\"Entry2 was not removed from the search results\", 0, results2.childEntries.size());\n\t\t\n\t\t// Verify the group was deleted\n\t\tgroup1 = getGroup(pm, GROUP1_NAME);\n\t\tassertNull(\"Group 1 was not removed.\", group1);\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tprivate PwEntry getEntry(PwDatabaseV3 pm, String name) {\n\t\tVector<PwEntry> entries = pm.entries;\n\t\tfor ( int i = 0; i < entries.size(); i++ ) {\n\t\t\tPwEntry entry = entries.get(i);\n\t\t\tif ( entry.title.equals(name) ) {\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t\t\n\t}\n\t\n\tprivate PwGroup getGroup(PwDatabaseV3 pm, String name) {\n\t\tVector<PwGroup> groups = pm.getGroups();\n\t\tfor ( int i = 0; i < groups.size(); i++ ) {\n\t\t\tPwGroup group = groups.get(i);\n\t\t\tif ( group.getName().equals(name) ) {\n\t\t\t\treturn group;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\n}\n","lineNo":57}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.WeakReference;\nimport java.util.HashMap;\nimport java.util.UUID;\nimport java.util.Vector;\n\n\nimport android.content.Context;\nimport android.os.Debug;\n\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.load.ImporterV3;\nimport com.keepassdroid.database.save.InvalidKeyFileException;\nimport com.keepassdroid.database.save.InvalidPasswordException;\nimport com.keepassdroid.database.save.PwDbV3Output;\nimport com.keepassdroid.database.save.PwDbOutputException;\nimport com.keepassdroid.search.SearchDbHelper;\nimport com.keepassdroid.utils.Types;\n\n/**\n * @author bpellin\n */\npublic class Database {\n\tpublic HashMap<Integer, WeakReference<PwGroupV3>> gGroups = new HashMap<Integer, WeakReference<PwGroupV3>>();\n\tpublic HashMap<UUID, WeakReference<PwEntryV3>> gEntries = new HashMap<UUID, WeakReference<PwEntryV3>>();\n\tpublic HashMap<PwGroupV3, WeakReference<PwGroupV3>> gDirty = new HashMap<PwGroupV3, WeakReference<PwGroupV3>>();\n\tpublic PwGroupV3 gRoot;\n\tpublic PwDatabaseV3 mPM;\n\tpublic String mFilename;\n\tpublic SearchDbHelper searchHelper;\n\tpublic boolean indexBuilt = false;\n\t\n\tprivate boolean loaded = false;\n\t\n\tpublic boolean Loaded() {\n\t\treturn loaded;\n\t}\n\t\n\tpublic void setLoaded() {\n\t\tloaded = true;\n\t}\n\t\n\tpublic void LoadData(Context ctx, InputStream is, String password, String keyfile) throws IOException, InvalidKeyFileException, InvalidPasswordException {\n\t\tLoadData(ctx, is, password, keyfile, new UpdateStatus(), !ImporterV3.DEBUG);\n\t}\n\n\tpublic void LoadData(Context ctx, String filename, String password, String keyfile) throws IOException, InvalidKeyFileException, FileNotFoundException, InvalidPasswordException {\n\t\tLoadData(ctx, filename, password, keyfile, new UpdateStatus(), !ImporterV3.DEBUG);\n\t}\n\t\n\tpublic void LoadData(Context ctx, String filename, String password, String keyfile, UpdateStatus status) throws IOException, InvalidKeyFileException, FileNotFoundException, InvalidPasswordException {\n\t\tLoadData(ctx, filename, password, keyfile, status, !ImporterV3.DEBUG);\n\t}\n\t\n\tpublic void LoadData(Context ctx, String filename, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, InvalidKeyFileException, FileNotFoundException, InvalidPasswordException {\n\t\tFileInputStream fis;\n\t\tfis = new FileInputStream(filename);\n\t\t\n\t\tLoadData(ctx, fis, password, keyfile, status, debug);\n\t\n\t\tmFilename = filename;\n\t}\n\n\tpublic void LoadData(Context ctx, InputStream is, String password, String keyfile, boolean debug) throws IOException, InvalidKeyFileException, InvalidPasswordException {\n\t\tLoadData(ctx, is, password, keyfile, new UpdateStatus(), debug);\n\t}\n\n\tpublic void LoadData(Context ctx, InputStream is, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, InvalidKeyFileException, InvalidPasswordException {\n\t\tImporterV3 Importer = new ImporterV3(debug);\n\t\t\n\t\tmPM = Importer.openDatabase(is, password, keyfile, status);\n\t\tif ( mPM != null ) {\n\t\t\tmPM.constructTree(null);\n\t\t\tpopulateGlobals(null);\n\t\t}\n\t\t\n\t\tloaded = true;\n\t}\n\t\n\t\n\t/** Build the search index from the current database\n\t * @param ctx (this should be an App context not an activity constant to avoid leaks)\n\t */\n\tpublic void buildSearchIndex(Context ctx) {\n\n\t\tDebug.startMethodTracing(\"search\");\n\t\tsearchHelper = new SearchDbHelper(ctx);\n\t\t\n\t\tinitSearch();\n\t\t\n\t\tsearchHelper.open();\n\t\tsearchHelper.insertEntry(mPM.entries);\n\t\t/*for ( int i = 0; i < mPM.entries.size(); i++) {\n\t\t\tPwEntryV3 entry = mPM.entries.get(i);\n\t\t\tif ( ! entry.isMetaStream() ) {\n\t\t\t\tsearchHelper.insertEntry(entry);\n\t\t\t}\n\t\t} */\n\t\tsearchHelper.close();\n\t\t\n\t\tindexBuilt = true;\n\t\tDebug.stopMethodTracing();\n\t}\n\t\n\tpublic PwGroupV3 Search(String str) {\n\t\tsearchHelper.open();\n\t\tPwGroupV3 group = searchHelper.search(this, str);\n\t\tsearchHelper.close();\n\t\t\n\t\treturn group;\n\t\t\n\t}\n\t\n\tpublic void SaveData() throws IOException, PwDbOutputException {\n\t\tSaveData(mFilename);\n\t}\n\t\n\tpublic void SaveData(String filename) throws IOException, PwDbOutputException {\n\t\tFile tempFile = new File(filename + \".tmp\");\n\t\tFileOutputStream fos = new FileOutputStream(tempFile);\n\t\t//BufferedOutputStream bos = new BufferedOutputStream(fos);\n\t\t\n\t\t//PwDbV3Output pmo = new PwDbV3Output(mPM, bos, App.getCalendar());\n\t\tPwDbV3Output pmo = new PwDbV3Output(mPM, fos);\n\t\tpmo.output();\n\t\t//bos.flush();\n\t\t//bos.close();\n\t\tfos.close();\n\t\t\n\t\tFile orig = new File(filename);\n\t\torig.delete();\n\t\t\n\t\tif ( ! tempFile.renameTo(orig) ) {\n\t\t\tthrow new IOException(\"Failed to store database.\");\n\t\t}\n\t\t\n\t\tmFilename = filename;\n\t\t\n\t}\n\t\n\tprivate void populateGlobals(PwGroupV3 currentGroup) {\n\t\tif (currentGroup == null) {\n\t\t\tVector<PwGroupV3> rootChildGroups = mPM.getGrpRoots();\n\t\t\tfor (int i = 0; i < rootChildGroups.size(); i++ ){\n\t\t\t\tPwGroupV3 cur = rootChildGroups.elementAt(i);\n\t\t\t\tgRoot = cur.parent;\n\t\t\t\tgGroups.put(cur.groupId, new WeakReference<PwGroupV3>(cur));\n\t\t\t\tpopulateGlobals(cur);\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tVector<PwGroupV3> childGroups = currentGroup.childGroups;\n\t\tVector<PwEntryV3> childEntries = currentGroup.childEntries;\n\t\t\n\t\tfor (int i = 0; i < childEntries.size(); i++ ) {\n\t\t\tPwEntryV3 cur = childEntries.elementAt(i);\n\t\t\tgEntries.put(Types.bytestoUUID(cur.uuid), new WeakReference<PwEntryV3>(cur));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < childGroups.size(); i++ ) {\n\t\t\tPwGroupV3 cur = childGroups.elementAt(i);\n\t\t\tgGroups.put(cur.groupId, new WeakReference<PwGroupV3>(cur));\n\t\t\tpopulateGlobals(cur);\n\t\t}\n\t}\n\t\n\tpublic void clear() {\n\t\tinitSearch();\n\t\t\n\t\tindexBuilt = false;\n\t\tgGroups.clear();\n\t\tgEntries.clear();\n\t\tgRoot = null;\n\t\tmPM = null;\n\t\tmFilename = null;\n\t\tloaded = false;\n\t}\n\t\n\tpublic void initSearch() {\n\t\tif ( searchHelper != null ) {\n\t\t\tsearchHelper.open();\n\t\t\tsearchHelper.clear();\n\t\t\tsearchHelper.close();\n\t\t}\n\t}\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.lang.ref.WeakReference;\nimport java.util.HashMap;\nimport java.util.UUID;\nimport java.util.Vector;\n\nimport android.content.Context;\nimport android.os.Debug;\n\nimport com.keepassdroid.database.PwDatabaseV3;\nimport com.keepassdroid.database.PwEntryV3;\nimport com.keepassdroid.database.PwGroupV3;\nimport com.keepassdroid.database.exception.InvalidDBSignatureException;\nimport com.keepassdroid.database.exception.InvalidKeyFileException;\nimport com.keepassdroid.database.exception.InvalidPasswordException;\nimport com.keepassdroid.database.exception.Kdb4Exception;\nimport com.keepassdroid.database.exception.PwDbOutputException;\nimport com.keepassdroid.database.load.Importer;\nimport com.keepassdroid.database.load.ImporterFactory;\nimport com.keepassdroid.database.load.ImporterV3;\nimport com.keepassdroid.database.save.PwDbV3Output;\nimport com.keepassdroid.search.SearchDbHelper;\nimport com.keepassdroid.utils.Types;\n\n/**\n * @author bpellin\n */\npublic class Database {\n\tpublic HashMap<Integer, WeakReference<PwGroupV3>> gGroups = new HashMap<Integer, WeakReference<PwGroupV3>>();\n\tpublic HashMap<UUID, WeakReference<PwEntryV3>> gEntries = new HashMap<UUID, WeakReference<PwEntryV3>>();\n\tpublic HashMap<PwGroupV3, WeakReference<PwGroupV3>> gDirty = new HashMap<PwGroupV3, WeakReference<PwGroupV3>>();\n\tpublic PwGroupV3 gRoot;\n\tpublic PwDatabaseV3 mPM;\n\tpublic String mFilename;\n\tpublic SearchDbHelper searchHelper;\n\tpublic boolean indexBuilt = false;\n\t\n\tprivate boolean loaded = false;\n\t\n\tpublic boolean Loaded() {\n\t\treturn loaded;\n\t}\n\t\n\tpublic void setLoaded() {\n\t\tloaded = true;\n\t}\n\t\n\tpublic void LoadData(Context ctx, InputStream is, String password, String keyfile) throws IOException, InvalidKeyFileException, InvalidPasswordException, InvalidDBSignatureException, Kdb4Exception {\n\t\tLoadData(ctx, is, password, keyfile, new UpdateStatus(), !Importer.DEBUG);\n\t}\n\n\tpublic void LoadData(Context ctx, String filename, String password, String keyfile) throws IOException, InvalidKeyFileException, FileNotFoundException, InvalidPasswordException, InvalidDBSignatureException, Kdb4Exception {\n\t\tLoadData(ctx, filename, password, keyfile, new UpdateStatus(), !Importer.DEBUG);\n\t}\n\t\n\tpublic void LoadData(Context ctx, String filename, String password, String keyfile, UpdateStatus status) throws IOException, InvalidKeyFileException, FileNotFoundException, InvalidPasswordException, InvalidDBSignatureException, Kdb4Exception {\n\t\tLoadData(ctx, filename, password, keyfile, status, !Importer.DEBUG);\n\t}\n\t\n\tpublic void LoadData(Context ctx, String filename, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, InvalidKeyFileException, FileNotFoundException, InvalidPasswordException, InvalidDBSignatureException, Kdb4Exception {\n\t\tFileInputStream fis;\n\t\tfis = new FileInputStream(filename);\n\t\t\n\t\tLoadData(ctx, fis, password, keyfile, status, debug);\n\t\n\t\tmFilename = filename;\n\t}\n\n\tpublic void LoadData(Context ctx, InputStream is, String password, String keyfile, boolean debug) throws IOException, InvalidKeyFileException, InvalidPasswordException, InvalidDBSignatureException, Kdb4Exception {\n\t\tLoadData(ctx, is, password, keyfile, new UpdateStatus(), debug);\n\t}\n\n\tpublic void LoadData(Context ctx, InputStream is, String password, String keyfile, UpdateStatus status, boolean debug) throws IOException, InvalidKeyFileException, InvalidPasswordException, InvalidDBSignatureException, Kdb4Exception {\n\n\t\tBufferedInputStream bis = new BufferedInputStream(is);\n\t\t\n\t\tif ( ! bis.markSupported() ) {\n\t\t\tthrow new IOException(\"Input stream does not support mark.\");\n\t\t}\n\t\t\n\t\t// We'll end up reading 8 bytes to identify the header. Might as well use two extra.\n\t\tbis.mark(10);\n\t\t\n\t\tImporter imp = ImporterFactory.createImporter(bis, debug);\n\n\t\t\n\t\tImporterV3 Importer;\n\t\tImporter = (ImporterV3) imp;  // Remove me when V4 support is in\n\t\t\n\t\tbis.reset();  // Return to the start\n\t\t\n\t\tmPM = Importer.openDatabase(bis, password, keyfile, status);\n\t\tif ( mPM != null ) {\n\t\t\tmPM.constructTree(null);\n\t\t\tpopulateGlobals(null);\n\t\t}\n\t\t\n\t\tloaded = true;\n\t}\n\t\n\t\n\t/** Build the search index from the current database\n\t * @param ctx (this should be an App context not an activity constant to avoid leaks)\n\t */\n\tpublic void buildSearchIndex(Context ctx) {\n\n\t\tDebug.startMethodTracing(\"search\");\n\t\tsearchHelper = new SearchDbHelper(ctx);\n\t\t\n\t\tinitSearch();\n\t\t\n\t\tsearchHelper.open();\n\t\tsearchHelper.insertEntry(mPM.entries);\n\t\t/*for ( int i = 0; i < mPM.entries.size(); i++) {\n\t\t\tPwEntryV3 entry = mPM.entries.get(i);\n\t\t\tif ( ! entry.isMetaStream() ) {\n\t\t\t\tsearchHelper.insertEntry(entry);\n\t\t\t}\n\t\t} */\n\t\tsearchHelper.close();\n\t\t\n\t\tindexBuilt = true;\n\t\tDebug.stopMethodTracing();\n\t}\n\t\n\tpublic PwGroupV3 Search(String str) {\n\t\tsearchHelper.open();\n\t\tPwGroupV3 group = searchHelper.search(this, str);\n\t\tsearchHelper.close();\n\t\t\n\t\treturn group;\n\t\t\n\t}\n\t\n\tpublic void SaveData() throws IOException, PwDbOutputException {\n\t\tSaveData(mFilename);\n\t}\n\t\n\tpublic void SaveData(String filename) throws IOException, PwDbOutputException {\n\t\tFile tempFile = new File(filename + \".tmp\");\n\t\tFileOutputStream fos = new FileOutputStream(tempFile);\n\t\t//BufferedOutputStream bos = new BufferedOutputStream(fos);\n\t\t\n\t\t//PwDbV3Output pmo = new PwDbV3Output(mPM, bos, App.getCalendar());\n\t\tPwDbV3Output pmo = new PwDbV3Output(mPM, fos);\n\t\tpmo.output();\n\t\t//bos.flush();\n\t\t//bos.close();\n\t\tfos.close();\n\t\t\n\t\tFile orig = new File(filename);\n\t\torig.delete();\n\t\t\n\t\tif ( ! tempFile.renameTo(orig) ) {\n\t\t\tthrow new IOException(\"Failed to store database.\");\n\t\t}\n\t\t\n\t\tmFilename = filename;\n\t\t\n\t}\n\t\n\tprivate void populateGlobals(PwGroupV3 currentGroup) {\n\t\tif (currentGroup == null) {\n\t\t\tVector<PwGroupV3> rootChildGroups = mPM.getGrpRoots();\n\t\t\tfor (int i = 0; i < rootChildGroups.size(); i++ ){\n\t\t\t\tPwGroupV3 cur = rootChildGroups.elementAt(i);\n\t\t\t\tgRoot = cur.parent;\n\t\t\t\tgGroups.put(cur.groupId, new WeakReference<PwGroupV3>(cur));\n\t\t\t\tpopulateGlobals(cur);\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tVector<PwGroupV3> childGroups = currentGroup.childGroups;\n\t\tVector<PwEntryV3> childEntries = currentGroup.childEntries;\n\t\t\n\t\tfor (int i = 0; i < childEntries.size(); i++ ) {\n\t\t\tPwEntryV3 cur = childEntries.elementAt(i);\n\t\t\tgEntries.put(Types.bytestoUUID(cur.uuid), new WeakReference<PwEntryV3>(cur));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < childGroups.size(); i++ ) {\n\t\t\tPwGroupV3 cur = childGroups.elementAt(i);\n\t\t\tgGroups.put(cur.groupId, new WeakReference<PwGroupV3>(cur));\n\t\t\tpopulateGlobals(cur);\n\t\t}\n\t}\n\t\n\tpublic void clear() {\n\t\tinitSearch();\n\t\t\n\t\tindexBuilt = false;\n\t\tgGroups.clear();\n\t\tgEntries.clear();\n\t\tgRoot = null;\n\t\tmPM = null;\n\t\tmFilename = null;\n\t\tloaded = false;\n\t}\n\t\n\tpublic void initSearch() {\n\t\tif ( searchHelper != null ) {\n\t\t\tsearchHelper.open();\n\t\t\tsearchHelper.clear();\n\t\t\tsearchHelper.close();\n\t\t}\n\t}\n\t\n}\n","lineNo":102}
{"Smelly Sample":"/*\n` * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.keepasslib;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Calendar;\nimport java.util.Vector;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport com.keepassdroid.crypto.finalkey.AESProvider;\n\npublic class PwManagerOutput {\n\tprivate PwManager mPM;\n\tprivate OutputStream mOS;\n\tprivate final boolean mDebug;\n\tpublic static final boolean DEBUG = true;\n\tprivate Calendar mCal;\n\t\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = false;\n\t}\n\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal, boolean debug) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = debug;\n\t}\n\t\n\tpublic byte[] getFinalKey(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic byte[] getFinalKey2(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic void output() throws PwManagerOutputException {\n\t\t\n\t\t// Before we output the header, we should sort our list of groups and remove any orphaned nodes that are no longer part of the group hierarchy\n\t\tsortGroupsForOutput();\n\t\t\n\t\tPwDbHeader header = outputHeader(mOS);\n\t\t\n\t\tbyte[] finalKey = getFinalKey(header);\n\t\t\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", new AESProvider());\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwManagerOutputException(\"Algorithm not supported.\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, \"AES\" ), new IvParameterSpec(header.encryptionIV) );\n\t\t\tCipherOutputStream cos = new CipherOutputStream(mOS, cipher);\n\t\t\toutputPlanGroupAndEntries(cos);\n\t\t\tcos.close();\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid algorithm parameter.\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output final encrypted part.\");\n\t\t}\n\t}\n\t\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwManagerOutputException {\n\t\t// Build header\n\t\tPwDbHeader header = new PwDbHeader();\n\t\theader.signature1 = PwDbHeader.PWM_DBSIG_1;\n\t\theader.signature2 = PwDbHeader.PWM_DBSIG_2;\n\t\theader.flags = PwDbHeader.PWM_FLAG_SHA2;\n\t\t\n\t\tif ( mPM.getAlgorithm() == PwDbHeader.ALGO_AES ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_RIJNDAEL;\n\t\t} else if ( mPM.getAlgorithm() == PwDbHeader.ALGO_TWOFISH ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_TWOFISH;\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t} else {\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t}\n\t\t\n\t\theader.version = PwDbHeader.PWM_DBVER_DW;\n\t\theader.numGroups = mPM.groups.size();\n\t\theader.numEntries = mPM.entries.size();\n\t\theader.numKeyEncRounds = mPM.getNumKeyEncRecords();\n\t\t\n\t\t// Reuse random values to test equivalence in debug mode\n\t\tif ( mDebug ) {\n\t\t\tSystem.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, mPM.dbHeader.encryptionIV.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, mPM.dbHeader.masterSeed.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed2, 0, header.masterSeed2, 0, mPM.dbHeader.masterSeed2.length);\n\t\t} else {\n\t\t\tSecureRandom random;\n\t\t\ttry {\n\t\t\t\trandom = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Does not support secure random number generation.\");\n\t\t\t}\n\t\t\trandom.nextBytes(header.encryptionIV);\n\t\t\trandom.nextBytes(header.masterSeed);\n\t\t\trandom.nextBytes(header.masterSeed2);\n\t\t}\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\t\n\t\tNullOutputStream nos;\n\t\tnos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\ttry {\n\t\t\toutputPlanGroupAndEntries(dos);\n\t\t\tdos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to generate checksum.\");\n\t\t}\n\n\t\theader.contentsHash = md.digest();\n\t\t\n\t\t// Output header\n\t\tPwDbHeaderOutput pho = new PwDbHeaderOutput(header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output the header.\");\n\t\t}\n\n\t\treturn header;\n\t}\n\t\n\tpublic void outputPlanGroupAndEntries(OutputStream os) throws PwManagerOutputException  {\n\t\t//long size = 0;\n\t\t\n\t\t// Groups\n\t\tfor ( int i = 0; i < mPM.groups.size(); i++ ) {\n\t\t\tPwGroup pg = mPM.groups.get(i);\n\t\t\tPwGroupOutput pgo = new PwGroupOutput(pg, os, mCal);\n\t\t\ttry {\n\t\t\t\tpgo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output a group: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Entries\n\t\tfor (int i = 0; i < mPM.entries.size(); i++ ) {\n\t\t\tPwEntry pe = mPM.entries.get(i);\n\t\t\tPwEntryOutput peo = new PwEntryOutput(pe, os, mCal);\n\t\t\ttry {\n\t\t\t\tpeo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output an entry.\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void sortGroupsForOutput() {\n\t\tVector<PwGroup> groupList = new Vector<PwGroup>();\n\t\t\n\t\t// Rebuild list according to coalation sorting order removing any orphaned groups\n\t\tVector<PwGroup> roots = mPM.getGrpRoots();\n\t\tfor ( int i = 0; i < roots.size(); i++ ) {\n\t\t\tsortGroup(roots.get(i), groupList);\n\t\t}\n\t\t\n\t\tmPM.groups = groupList;\n\t}\n\t\n\tprivate void sortGroup(PwGroup group, Vector<PwGroup> groupList) {\n\t\t// Add current group\n\t\tgroupList.add(group);\n\t\t\n\t\t// Recurse over children\n\t\tfor ( int i = 0; i < group.childGroups.size(); i++ ) {\n\t\t\tsortGroup(group.childGroups.get(i), groupList);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n` * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.keepasslib;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Calendar;\nimport java.util.Vector;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport com.keepassdroid.crypto.finalkey.AESProvider;\n\npublic class PwManagerOutput {\n\tprivate PwManager mPM;\n\tprivate OutputStream mOS;\n\tprivate final boolean mDebug;\n\tpublic static final boolean DEBUG = true;\n\tprivate Calendar mCal;\n\t\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = false;\n\t}\n\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal, boolean debug) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = debug;\n\t}\n\t\n\tpublic byte[] getFinalKey(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic byte[] getFinalKey2(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic void output() throws PwManagerOutputException {\n\t\t\n\t\t// Before we output the header, we should sort our list of groups and remove any orphaned nodes that are no longer part of the group hierarchy\n\t\tsortGroupsForOutput();\n\t\t\n\t\tPwDbHeader header = outputHeader(mOS);\n\t\t\n\t\tbyte[] finalKey = getFinalKey(header);\n\t\t\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", new AESProvider());\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwManagerOutputException(\"Algorithm not supported.\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, \"AES\" ), new IvParameterSpec(header.encryptionIV) );\n\t\t\tCipherOutputStream cos = new CipherOutputStream(mOS, cipher);\n\t\t\tBufferedOutputStream bos = new BufferedOutputStream(cos);\n\t\t\toutputPlanGroupAndEntries(bos);\n\t\t\tbos.flush();\n\t\t\tbos.close();\n\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid algorithm parameter.\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output final encrypted part.\");\n\t\t}\n\t}\n\t\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwManagerOutputException {\n\t\t// Build header\n\t\tPwDbHeader header = new PwDbHeader();\n\t\theader.signature1 = PwDbHeader.PWM_DBSIG_1;\n\t\theader.signature2 = PwDbHeader.PWM_DBSIG_2;\n\t\theader.flags = PwDbHeader.PWM_FLAG_SHA2;\n\t\t\n\t\tif ( mPM.getAlgorithm() == PwDbHeader.ALGO_AES ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_RIJNDAEL;\n\t\t} else if ( mPM.getAlgorithm() == PwDbHeader.ALGO_TWOFISH ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_TWOFISH;\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t} else {\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t}\n\t\t\n\t\theader.version = PwDbHeader.PWM_DBVER_DW;\n\t\theader.numGroups = mPM.groups.size();\n\t\theader.numEntries = mPM.entries.size();\n\t\theader.numKeyEncRounds = mPM.getNumKeyEncRecords();\n\t\t\n\t\t// Reuse random values to test equivalence in debug mode\n\t\tif ( mDebug ) {\n\t\t\tSystem.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, mPM.dbHeader.encryptionIV.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, mPM.dbHeader.masterSeed.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed2, 0, header.masterSeed2, 0, mPM.dbHeader.masterSeed2.length);\n\t\t} else {\n\t\t\tSecureRandom random;\n\t\t\ttry {\n\t\t\t\trandom = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Does not support secure random number generation.\");\n\t\t\t}\n\t\t\trandom.nextBytes(header.encryptionIV);\n\t\t\trandom.nextBytes(header.masterSeed);\n\t\t\trandom.nextBytes(header.masterSeed2);\n\t\t}\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\t\n\t\tNullOutputStream nos;\n\t\tnos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\tBufferedOutputStream bos = new BufferedOutputStream(dos);\n\t\ttry {\n\t\t\toutputPlanGroupAndEntries(bos);\n\t\t\tbos.flush();\n\t\t\tbos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to generate checksum.\");\n\t\t}\n\n\t\theader.contentsHash = md.digest();\n\t\t\n\t\t// Output header\n\t\tPwDbHeaderOutput pho = new PwDbHeaderOutput(header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output the header.\");\n\t\t}\n\n\t\treturn header;\n\t}\n\t\n\tpublic void outputPlanGroupAndEntries(OutputStream os) throws PwManagerOutputException  {\n\t\t//long size = 0;\n\t\t\n\t\t// Groups\n\t\tfor ( int i = 0; i < mPM.groups.size(); i++ ) {\n\t\t\tPwGroup pg = mPM.groups.get(i);\n\t\t\tPwGroupOutput pgo = new PwGroupOutput(pg, os, mCal);\n\t\t\ttry {\n\t\t\t\tpgo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output a group: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Entries\n\t\tfor (int i = 0; i < mPM.entries.size(); i++ ) {\n\t\t\tPwEntry pe = mPM.entries.get(i);\n\t\t\tPwEntryOutput peo = new PwEntryOutput(pe, os, mCal);\n\t\t\ttry {\n\t\t\t\tpeo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output an entry.\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void sortGroupsForOutput() {\n\t\tVector<PwGroup> groupList = new Vector<PwGroup>();\n\t\t\n\t\t// Rebuild list according to coalation sorting order removing any orphaned groups\n\t\tVector<PwGroup> roots = mPM.getGrpRoots();\n\t\tfor ( int i = 0; i < roots.size(); i++ ) {\n\t\t\tsortGroup(roots.get(i), groupList);\n\t\t}\n\t\t\n\t\tmPM.groups = groupList;\n\t}\n\t\n\tprivate void sortGroup(PwGroup group, Vector<PwGroup> groupList) {\n\t\t// Add current group\n\t\tgroupList.add(group);\n\t\t\n\t\t// Recurse over children\n\t\tfor ( int i = 0; i < group.childGroups.size(); i++ ) {\n\t\t\tsortGroup(group.childGroups.get(i), groupList);\n\t\t}\n\t}\n}\n","lineNo":103}
{"Smelly Sample":"/*\n` * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.keepasslib;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Calendar;\nimport java.util.Vector;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport com.keepassdroid.crypto.finalkey.AESProvider;\n\npublic class PwManagerOutput {\n\tprivate PwManager mPM;\n\tprivate OutputStream mOS;\n\tprivate final boolean mDebug;\n\tpublic static final boolean DEBUG = true;\n\tprivate Calendar mCal;\n\t\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = false;\n\t}\n\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal, boolean debug) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = debug;\n\t}\n\t\n\tpublic byte[] getFinalKey(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic byte[] getFinalKey2(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic void output() throws PwManagerOutputException {\n\t\t\n\t\t// Before we output the header, we should sort our list of groups and remove any orphaned nodes that are no longer part of the group hierarchy\n\t\tsortGroupsForOutput();\n\t\t\n\t\tPwDbHeader header = outputHeader(mOS);\n\t\t\n\t\tbyte[] finalKey = getFinalKey(header);\n\t\t\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", new AESProvider());\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwManagerOutputException(\"Algorithm not supported.\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, \"AES\" ), new IvParameterSpec(header.encryptionIV) );\n\t\t\tCipherOutputStream cos = new CipherOutputStream(mOS, cipher);\n\t\t\toutputPlanGroupAndEntries(cos);\n\t\t\tcos.close();\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid algorithm parameter.\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output final encrypted part.\");\n\t\t}\n\t}\n\t\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwManagerOutputException {\n\t\t// Build header\n\t\tPwDbHeader header = new PwDbHeader();\n\t\theader.signature1 = PwDbHeader.PWM_DBSIG_1;\n\t\theader.signature2 = PwDbHeader.PWM_DBSIG_2;\n\t\theader.flags = PwDbHeader.PWM_FLAG_SHA2;\n\t\t\n\t\tif ( mPM.getAlgorithm() == PwDbHeader.ALGO_AES ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_RIJNDAEL;\n\t\t} else if ( mPM.getAlgorithm() == PwDbHeader.ALGO_TWOFISH ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_TWOFISH;\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t} else {\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t}\n\t\t\n\t\theader.version = PwDbHeader.PWM_DBVER_DW;\n\t\theader.numGroups = mPM.groups.size();\n\t\theader.numEntries = mPM.entries.size();\n\t\theader.numKeyEncRounds = mPM.getNumKeyEncRecords();\n\t\t\n\t\t// Reuse random values to test equivalence in debug mode\n\t\tif ( mDebug ) {\n\t\t\tSystem.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, mPM.dbHeader.encryptionIV.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, mPM.dbHeader.masterSeed.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed2, 0, header.masterSeed2, 0, mPM.dbHeader.masterSeed2.length);\n\t\t} else {\n\t\t\tSecureRandom random;\n\t\t\ttry {\n\t\t\t\trandom = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Does not support secure random number generation.\");\n\t\t\t}\n\t\t\trandom.nextBytes(header.encryptionIV);\n\t\t\trandom.nextBytes(header.masterSeed);\n\t\t\trandom.nextBytes(header.masterSeed2);\n\t\t}\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\t\n\t\tNullOutputStream nos;\n\t\tnos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\ttry {\n\t\t\toutputPlanGroupAndEntries(dos);\n\t\t\tdos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to generate checksum.\");\n\t\t}\n\n\t\theader.contentsHash = md.digest();\n\t\t\n\t\t// Output header\n\t\tPwDbHeaderOutput pho = new PwDbHeaderOutput(header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output the header.\");\n\t\t}\n\n\t\treturn header;\n\t}\n\t\n\tpublic void outputPlanGroupAndEntries(OutputStream os) throws PwManagerOutputException  {\n\t\t//long size = 0;\n\t\t\n\t\t// Groups\n\t\tfor ( int i = 0; i < mPM.groups.size(); i++ ) {\n\t\t\tPwGroup pg = mPM.groups.get(i);\n\t\t\tPwGroupOutput pgo = new PwGroupOutput(pg, os, mCal);\n\t\t\ttry {\n\t\t\t\tpgo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output a group: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Entries\n\t\tfor (int i = 0; i < mPM.entries.size(); i++ ) {\n\t\t\tPwEntry pe = mPM.entries.get(i);\n\t\t\tPwEntryOutput peo = new PwEntryOutput(pe, os, mCal);\n\t\t\ttry {\n\t\t\t\tpeo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output an entry.\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void sortGroupsForOutput() {\n\t\tVector<PwGroup> groupList = new Vector<PwGroup>();\n\t\t\n\t\t// Rebuild list according to coalation sorting order removing any orphaned groups\n\t\tVector<PwGroup> roots = mPM.getGrpRoots();\n\t\tfor ( int i = 0; i < roots.size(); i++ ) {\n\t\t\tsortGroup(roots.get(i), groupList);\n\t\t}\n\t\t\n\t\tmPM.groups = groupList;\n\t}\n\t\n\tprivate void sortGroup(PwGroup group, Vector<PwGroup> groupList) {\n\t\t// Add current group\n\t\tgroupList.add(group);\n\t\t\n\t\t// Recurse over children\n\t\tfor ( int i = 0; i < group.childGroups.size(); i++ ) {\n\t\t\tsortGroup(group.childGroups.get(i), groupList);\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n` * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.keepasslib;\n\nimport java.io.BufferedOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.util.Calendar;\nimport java.util.Vector;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport com.keepassdroid.crypto.finalkey.AESProvider;\n\npublic class PwManagerOutput {\n\tprivate PwManager mPM;\n\tprivate OutputStream mOS;\n\tprivate final boolean mDebug;\n\tpublic static final boolean DEBUG = true;\n\tprivate Calendar mCal;\n\t\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = false;\n\t}\n\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, Calendar cal, boolean debug) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmCal = cal;\n\t\tmDebug = debug;\n\t}\n\t\n\tpublic byte[] getFinalKey(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic byte[] getFinalKey2(PwDbHeader header) throws PwManagerOutputException {\n\t\ttry {\n\t\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Key creation failed: \" + e.getMessage());\n\t\t}\n\t}\n\t\n\tpublic void output() throws PwManagerOutputException {\n\t\t\n\t\t// Before we output the header, we should sort our list of groups and remove any orphaned nodes that are no longer part of the group hierarchy\n\t\tsortGroupsForOutput();\n\t\t\n\t\tPwDbHeader header = outputHeader(mOS);\n\t\t\n\t\tbyte[] finalKey = getFinalKey(header);\n\t\t\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\", new AESProvider());\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwManagerOutputException(\"Algorithm not supported.\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, \"AES\" ), new IvParameterSpec(header.encryptionIV) );\n\t\t\tCipherOutputStream cos = new CipherOutputStream(mOS, cipher);\n\t\t\tBufferedOutputStream bos = new BufferedOutputStream(cos);\n\t\t\toutputPlanGroupAndEntries(bos);\n\t\t\tbos.flush();\n\t\t\tbos.close();\n\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid algorithm parameter.\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output final encrypted part.\");\n\t\t}\n\t}\n\t\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwManagerOutputException {\n\t\t// Build header\n\t\tPwDbHeader header = new PwDbHeader();\n\t\theader.signature1 = PwDbHeader.PWM_DBSIG_1;\n\t\theader.signature2 = PwDbHeader.PWM_DBSIG_2;\n\t\theader.flags = PwDbHeader.PWM_FLAG_SHA2;\n\t\t\n\t\tif ( mPM.getAlgorithm() == PwDbHeader.ALGO_AES ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_RIJNDAEL;\n\t\t} else if ( mPM.getAlgorithm() == PwDbHeader.ALGO_TWOFISH ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_TWOFISH;\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t} else {\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t}\n\t\t\n\t\theader.version = PwDbHeader.PWM_DBVER_DW;\n\t\theader.numGroups = mPM.groups.size();\n\t\theader.numEntries = mPM.entries.size();\n\t\theader.numKeyEncRounds = mPM.getNumKeyEncRecords();\n\t\t\n\t\t// Reuse random values to test equivalence in debug mode\n\t\tif ( mDebug ) {\n\t\t\tSystem.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, mPM.dbHeader.encryptionIV.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, mPM.dbHeader.masterSeed.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed2, 0, header.masterSeed2, 0, mPM.dbHeader.masterSeed2.length);\n\t\t} else {\n\t\t\tSecureRandom random;\n\t\t\ttry {\n\t\t\t\trandom = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Does not support secure random number generation.\");\n\t\t\t}\n\t\t\trandom.nextBytes(header.encryptionIV);\n\t\t\trandom.nextBytes(header.masterSeed);\n\t\t\trandom.nextBytes(header.masterSeed2);\n\t\t}\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\t\n\t\tNullOutputStream nos;\n\t\tnos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\tBufferedOutputStream bos = new BufferedOutputStream(dos);\n\t\ttry {\n\t\t\toutputPlanGroupAndEntries(bos);\n\t\t\tbos.flush();\n\t\t\tbos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to generate checksum.\");\n\t\t}\n\n\t\theader.contentsHash = md.digest();\n\t\t\n\t\t// Output header\n\t\tPwDbHeaderOutput pho = new PwDbHeaderOutput(header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output the header.\");\n\t\t}\n\n\t\treturn header;\n\t}\n\t\n\tpublic void outputPlanGroupAndEntries(OutputStream os) throws PwManagerOutputException  {\n\t\t//long size = 0;\n\t\t\n\t\t// Groups\n\t\tfor ( int i = 0; i < mPM.groups.size(); i++ ) {\n\t\t\tPwGroup pg = mPM.groups.get(i);\n\t\t\tPwGroupOutput pgo = new PwGroupOutput(pg, os, mCal);\n\t\t\ttry {\n\t\t\t\tpgo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output a group: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Entries\n\t\tfor (int i = 0; i < mPM.entries.size(); i++ ) {\n\t\t\tPwEntry pe = mPM.entries.get(i);\n\t\t\tPwEntryOutput peo = new PwEntryOutput(pe, os, mCal);\n\t\t\ttry {\n\t\t\t\tpeo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output an entry.\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tprivate void sortGroupsForOutput() {\n\t\tVector<PwGroup> groupList = new Vector<PwGroup>();\n\t\t\n\t\t// Rebuild list according to coalation sorting order removing any orphaned groups\n\t\tVector<PwGroup> roots = mPM.getGrpRoots();\n\t\tfor ( int i = 0; i < roots.size(); i++ ) {\n\t\t\tsortGroup(roots.get(i), groupList);\n\t\t}\n\t\t\n\t\tmPM.groups = groupList;\n\t}\n\t\n\tprivate void sortGroup(PwGroup group, Vector<PwGroup> groupList) {\n\t\t// Add current group\n\t\tgroupList.add(group);\n\t\t\n\t\t// Recurse over children\n\t\tfor ( int i = 0; i < group.childGroups.size(); i++ ) {\n\t\t\tsortGroup(group.childGroups.get(i), groupList);\n\t\t}\n\t}\n}\n","lineNo":166}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\nimport com.keepassdroid.Database;\n\npublic class AddEntry extends RunnableOnFinish {\n\tprivate Database mDb;\n\tprivate PwEntry mEntry;\n\t\n\tpublic AddEntry(Database db, PwEntry entry, OnFinish finish) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmEntry = entry;\n\t\t\n\t\tmFinish = new AfterAdd(mFinish);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tPwGroup parent = mEntry.parent;\n\t\t\n\t\t// Add entry to group\n\t\tparent.childEntries.add(mEntry);\n\t\t\n\t\t// Add entry to PwManager\n\t\tmDb.mPM.entries.add(mEntry);\n\t\t\n\t\t// Sort entries\n\t\tparent.sortEntriesByName();\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterAdd extends OnFinish {\n\n\t\tpublic AfterAdd(OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tPwGroup parent = mEntry.parent;\n\n\t\t\t\t// Mark parent group dirty\n\t\t\t\tmDb.gDirty.put(parent, new WeakReference<PwGroup>(parent));\n\n\t\t\t\t// Add entry to global\n\t\t\t\tmDb.gEntries.put(Types.bytestoUUID(mEntry.uuid), new WeakReference<PwEntry>(mEntry));\n\t\t\t\t\n\t\t\t\t// Add entry to search index\n\t\t\t\tmDb.searchHelper.insertEntry(mEntry);\n\t\t\t} else {\n\t\t\t\t// Remove from group\n\t\t\t\tmEntry.parent.childEntries.removeElement(mEntry);\n\t\t\t\t\n\t\t\t\t// Remove from manager\n\t\t\t\tmDb.mPM.entries.removeElement(mEntry);\n\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\t}\n\t\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.search.SearchDbHelper;\n\npublic class AddEntry extends RunnableOnFinish {\n\tprivate Database mDb;\n\tprivate PwEntry mEntry;\n\t\n\tpublic AddEntry(Database db, PwEntry entry, OnFinish finish) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmEntry = entry;\n\t\t\n\t\tmFinish = new AfterAdd(mFinish);\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\tPwGroup parent = mEntry.parent;\n\t\t\n\t\t// Add entry to group\n\t\tparent.childEntries.add(mEntry);\n\t\t\n\t\t// Add entry to PwManager\n\t\tmDb.mPM.entries.add(mEntry);\n\t\t\n\t\t// Sort entries\n\t\tparent.sortEntriesByName();\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterAdd extends OnFinish {\n\n\t\tpublic AfterAdd(OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tPwGroup parent = mEntry.parent;\n\n\t\t\t\t// Mark parent group dirty\n\t\t\t\tmDb.gDirty.put(parent, new WeakReference<PwGroup>(parent));\n\n\t\t\t\t// Add entry to global\n\t\t\t\tmDb.gEntries.put(Types.bytestoUUID(mEntry.uuid), new WeakReference<PwEntry>(mEntry));\n\t\t\t\t\n\t\t\t\t// Add entry to search index\n\t\t\t\tSearchDbHelper helper = mDb.searchHelper;\n\t\t\t\thelper.open();\n\t\t\t\thelper.insertEntry(mEntry);\n\t\t\t\thelper.close();\n\t\t\t} else {\n\t\t\t\t// Remove from group\n\t\t\t\tmEntry.parent.childEntries.removeElement(mEntry);\n\t\t\t\t\n\t\t\t\t// Remove from manager\n\t\t\t\tmDb.mPM.entries.removeElement(mEntry);\n\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\t}\n\t\n\n}\n","lineNo":80}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport com.keepassdroid.Database;\n\npublic class UpdateEntry extends RunnableOnFinish {\n\tprivate Database mDb;\n\tprivate PwEntry mOldE;\n\tprivate PwEntry mNewE;\n\t\n\tpublic UpdateEntry(Database db, PwEntry oldE, PwEntry newE, OnFinish finish) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmOldE = oldE;\n\t\tmNewE = newE;\n\t\t\n\t\t// Keep backup of original values in case save fails\n\t\tPwEntry backup = new PwEntry(mOldE);\n\t\tmFinish = new AfterUpdate(backup, finish);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\t// Update entry with new values\n\t\tmOldE.assign(mNewE);\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterUpdate extends OnFinish {\n\t\tprivate PwEntry mBackup;\n\t\t\n\t\tpublic AfterUpdate(PwEntry backup, OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t\t\n\t\t\tmBackup = backup;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\t// Mark group dirty if title changes\n\t\t\t\tif ( ! mBackup.title.equals(mNewE.title) ) {\n\t\t\t\t\tPwGroup parent = mBackup.parent;\n\t\t\t\t\tif ( parent != null ) {\n\t\t\t\t\t\t// Resort entries\n\t\t\t\t\t\tparent.sortEntriesByName();\n\n\t\t\t\t\t\t// Mark parent group dirty\n\t\t\t\t\t\tmDb.gDirty.put(parent, new WeakReference<PwGroup>(parent));\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update search index\n\t\t\t\t\tmDb.searchHelper.updateEntry(mOldE);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we fail to save, back out changes to global structure\n\t\t\t\tmOldE.assign(mBackup);\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\t\t\n\t}\n\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid.database;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport com.keepassdroid.Database;\nimport com.keepassdroid.search.SearchDbHelper;\n\npublic class UpdateEntry extends RunnableOnFinish {\n\tprivate Database mDb;\n\tprivate PwEntry mOldE;\n\tprivate PwEntry mNewE;\n\t\n\tpublic UpdateEntry(Database db, PwEntry oldE, PwEntry newE, OnFinish finish) {\n\t\tsuper(finish);\n\t\t\n\t\tmDb = db;\n\t\tmOldE = oldE;\n\t\tmNewE = newE;\n\t\t\n\t\t// Keep backup of original values in case save fails\n\t\tPwEntry backup = new PwEntry(mOldE);\n\t\tmFinish = new AfterUpdate(backup, finish);\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\t// Update entry with new values\n\t\tmOldE.assign(mNewE);\n\t\t\n\t\t// Commit to disk\n\t\tSaveDB save = new SaveDB(mDb, mFinish);\n\t\tsave.run();\n\t}\n\t\n\tprivate class AfterUpdate extends OnFinish {\n\t\tprivate PwEntry mBackup;\n\t\t\n\t\tpublic AfterUpdate(PwEntry backup, OnFinish finish) {\n\t\t\tsuper(finish);\n\t\t\t\n\t\t\tmBackup = backup;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\t// Mark group dirty if title changes\n\t\t\t\tif ( ! mBackup.title.equals(mNewE.title) ) {\n\t\t\t\t\tPwGroup parent = mBackup.parent;\n\t\t\t\t\tif ( parent != null ) {\n\t\t\t\t\t\t// Resort entries\n\t\t\t\t\t\tparent.sortEntriesByName();\n\n\t\t\t\t\t\t// Mark parent group dirty\n\t\t\t\t\t\tmDb.gDirty.put(parent, new WeakReference<PwGroup>(parent));\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t// Update search index\n\t\t\t\t\tSearchDbHelper helper = mDb.searchHelper;\n\t\t\t\t\thelper.open();\n\t\t\t\t\thelper.updateEntry(mOldE);\n\t\t\t\t\thelper.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// If we fail to save, back out changes to global structure\n\t\t\t\tmOldE.assign(mBackup);\n\t\t\t}\n\t\t\t\n\t\t\tsuper.run();\n\t\t}\n\t\t\n\t}\n\n\n}\n","lineNo":82}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.AddEntry;\nimport com.keepassdroid.database.UpdateEntry;\n\npublic class EntryEditActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_PARENT = \"parent\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\n\tprivate PwEntry mEntry;\n\tprivate boolean mShowPassword = false;\n\tprivate boolean mIsNew;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\tpublic static void Launch(Activity act, PwGroup parent) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_PARENT, parent.groupId);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_edit);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( KeePass.db == null ) {\n\t\t\tfinish();\n\t\t}\n\n\t\tIntent i = getIntent();\n\t\tbyte[] uuidBytes = i.getByteArrayExtra(KEY_ENTRY);\n\n\t\tif ( uuidBytes == null ) {\n\t\t\tint groupId = i.getIntExtra(KEY_PARENT, -1);\n\n\t\t\tmEntry = new PwEntry(KeePass.db, groupId);\n\t\t\tmIsNew = true;\n\t\t\t\n\t\t} else {\n\t\t\tUUID uuid = Types.bytestoUUID(uuidBytes);\n\t\t\tassert(uuid != null);\n\n\t\t\tmEntry = KeePass.db.gEntries.get(uuid).get();\n\t\t\tmIsNew = false;\n\t\t\t\n\t\t\tfillData();\n\t\t} \n\t\n\t\tView scrollView = findViewById(R.id.entry_scroll);\n\t\tscrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\n\t\t// Save button\n\t\tButton save = (Button) findViewById(R.id.entry_save);\n\t\tsave.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity act = EntryEditActivity.this;\n\t\t\t\t\n\t\t\t\t// Require title\n\t\t\t\tString title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tif ( title.length() == 0 ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_title_required, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Validate password\n\t\t\t\tString pass = Util.getEditText(act, R.id.entry_password);\n\t\t\t\tString conf = Util.getEditText(act, R.id.entry_confpassword);\n\t\t\t\tif ( ! pass.equals(conf) ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPwEntry newEntry = new PwEntry();\n\t\t\t\t\n\t\t\t\tnewEntry.binaryDesc = mEntry.binaryDesc;\n\t\t\t\tnewEntry.groupId = mEntry.groupId;\n\t\t\t\tnewEntry.imageId = mEntry.imageId;\n\t\t\t\tnewEntry.parent = mEntry.parent;\n\t\t\t\tnewEntry.tCreation = mEntry.tCreation;\n\t\t\t\tnewEntry.tExpire = mEntry.tExpire;\n\t\t\t\tnewEntry.uuid = mEntry.uuid;\n\t\t\t\t\n\t\t\t\tDate now = Calendar.getInstance().getTime(); \n\t\t\t\tnewEntry.tLastAccess = now;\n\t\t\t\tnewEntry.tLastMod = now;\n\t\t\t\t\n\t\t\t\tbyte[] binaryData = mEntry.getBinaryData();\n\t\t\t\tif ( binaryData != null ) {\n\t\t\t\t\tnewEntry.setBinaryData(binaryData, 0, binaryData.length);\n\t\t\t\t}\n\n\t\t\t\tnewEntry.title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tnewEntry.url = Util.getEditText(act, R.id.entry_url);\n\t\t\t\tnewEntry.username = Util.getEditText(act, R.id.entry_user_name);\n\t\t\t\tnewEntry.additional = Util.getEditText(act, R.id.entry_comment);\n\t\t\t\tbyte[] password;\n\t\t\t\ttry {\n\t\t\t\t\tpassword = pass.getBytes(\"UTF-8\");\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\tassert false;\n\t\t\t\t\tpassword = pass.getBytes();\n\t\t\t\t}\n\t\t\t\tnewEntry.setPassword(password, 0, password.length);\n\n\t\t\t\tif ( newEntry.title.equals(mEntry.title) ) {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH_TITLE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRunnable task;\n\t\t\t\tif ( mIsNew ) {\n\t\t\t\t\ttask = new AddEntry(KeePass.db, act, newEntry, new Handler());\n\t\t\t\t} else {\n\t\t\t\t\ttask = new UpdateEntry(KeePass.db, act, mEntry, newEntry, new Handler());\n\t\t\t\t}\n\t\t\t\tProgressTask pt = new ProgressTask(act, task, act.new AfterSave());\n\t\t\t\tpt.run();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.entry_cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinish();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\t\tTextView confpassword = (TextView) findViewById(R.id.entry_confpassword);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t\tconfpassword.setTransformationMethod(null);\n\n\t\t} else {\n\t\t\tPasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();\n\t\t\tpassword.setTransformationMethod(ptm);\n\t\t\tconfpassword.setTransformationMethod(ptm);\n\t\t}\n\t}\n\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\t\n\t\tString password = new String(mEntry.getPassword());\n\t\tpopulateText(R.id.entry_password, password);\n\t\tpopulateText(R.id.entry_confpassword, password);\n\t\tsetPasswordStyle();\n\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\t\n\tprivate final class AfterSave implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tfinish();\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.AddEntry;\nimport com.keepassdroid.database.OnFinish;\nimport com.keepassdroid.database.RunnableOnFinish;\nimport com.keepassdroid.database.UpdateEntry;\n\npublic class EntryEditActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_PARENT = \"parent\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\n\tprivate PwEntry mEntry;\n\tprivate boolean mShowPassword = false;\n\tprivate boolean mIsNew;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\tpublic static void Launch(Activity act, PwGroup parent) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_PARENT, parent.groupId);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_edit);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( KeePass.db == null ) {\n\t\t\tfinish();\n\t\t}\n\n\t\tIntent i = getIntent();\n\t\tbyte[] uuidBytes = i.getByteArrayExtra(KEY_ENTRY);\n\n\t\tif ( uuidBytes == null ) {\n\t\t\tint groupId = i.getIntExtra(KEY_PARENT, -1);\n\n\t\t\tmEntry = new PwEntry(KeePass.db, groupId);\n\t\t\tmIsNew = true;\n\t\t\t\n\t\t} else {\n\t\t\tUUID uuid = Types.bytestoUUID(uuidBytes);\n\t\t\tassert(uuid != null);\n\n\t\t\tmEntry = KeePass.db.gEntries.get(uuid).get();\n\t\t\tmIsNew = false;\n\t\t\t\n\t\t\tfillData();\n\t\t} \n\t\n\t\tView scrollView = findViewById(R.id.entry_scroll);\n\t\tscrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\n\t\t// Save button\n\t\tButton save = (Button) findViewById(R.id.entry_save);\n\t\tsave.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity act = EntryEditActivity.this;\n\t\t\t\t\n\t\t\t\t// Require title\n\t\t\t\tString title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tif ( title.length() == 0 ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_title_required, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Validate password\n\t\t\t\tString pass = Util.getEditText(act, R.id.entry_password);\n\t\t\t\tString conf = Util.getEditText(act, R.id.entry_confpassword);\n\t\t\t\tif ( ! pass.equals(conf) ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPwEntry newEntry = new PwEntry();\n\t\t\t\t\n\t\t\t\tnewEntry.binaryDesc = mEntry.binaryDesc;\n\t\t\t\tnewEntry.groupId = mEntry.groupId;\n\t\t\t\tnewEntry.imageId = mEntry.imageId;\n\t\t\t\tnewEntry.parent = mEntry.parent;\n\t\t\t\tnewEntry.tCreation = mEntry.tCreation;\n\t\t\t\tnewEntry.tExpire = mEntry.tExpire;\n\t\t\t\tnewEntry.uuid = mEntry.uuid;\n\t\t\t\t\n\t\t\t\tDate now = Calendar.getInstance().getTime(); \n\t\t\t\tnewEntry.tLastAccess = now;\n\t\t\t\tnewEntry.tLastMod = now;\n\t\t\t\t\n\t\t\t\tbyte[] binaryData = mEntry.getBinaryData();\n\t\t\t\tif ( binaryData != null ) {\n\t\t\t\t\tnewEntry.setBinaryData(binaryData, 0, binaryData.length);\n\t\t\t\t}\n\n\t\t\t\tnewEntry.title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tnewEntry.url = Util.getEditText(act, R.id.entry_url);\n\t\t\t\tnewEntry.username = Util.getEditText(act, R.id.entry_user_name);\n\t\t\t\tnewEntry.additional = Util.getEditText(act, R.id.entry_comment);\n\t\t\t\tbyte[] password;\n\t\t\t\ttry {\n\t\t\t\t\tpassword = pass.getBytes(\"UTF-8\");\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\tassert false;\n\t\t\t\t\tpassword = pass.getBytes();\n\t\t\t\t}\n\t\t\t\tnewEntry.setPassword(password, 0, password.length);\n\n\t\t\t\tif ( newEntry.title.equals(mEntry.title) ) {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH_TITLE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRunnableOnFinish task;\n\t\t\t\tHandler handler = new Handler();\n\t\t\t\tOnFinish onFinish = act.new AfterSave(handler);\n\t\t\t\t\n\t\t\t\tif ( mIsNew ) {\n\t\t\t\t\ttask = new AddEntry(KeePass.db, newEntry, handler, onFinish);\n\t\t\t\t} else {\n\t\t\t\t\ttask = new UpdateEntry(KeePass.db, mEntry, newEntry, handler, onFinish);\n\t\t\t\t}\n\t\t\t\tProgressTask pt = new ProgressTask(act, task);\n\t\t\t\tpt.run();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.entry_cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinish();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\t\tTextView confpassword = (TextView) findViewById(R.id.entry_confpassword);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t\tconfpassword.setTransformationMethod(null);\n\n\t\t} else {\n\t\t\tPasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();\n\t\t\tpassword.setTransformationMethod(ptm);\n\t\t\tconfpassword.setTransformationMethod(ptm);\n\t\t}\n\t}\n\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\t\n\t\tString password = new String(mEntry.getPassword());\n\t\tpopulateText(R.id.entry_password, password);\n\t\tpopulateText(R.id.entry_confpassword, password);\n\t\tsetPasswordStyle();\n\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\t\n\tprivate final class AfterSave extends OnFinish {\n\n\t\tpublic AfterSave(Handler handler) {\n\t\t\tsuper(handler);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tfinish();\n\t\t\t} else {\n\t\t\t\tdisplayMessage(EntryEditActivity.this);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":172}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.AddEntry;\nimport com.keepassdroid.database.UpdateEntry;\n\npublic class EntryEditActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_PARENT = \"parent\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\n\tprivate PwEntry mEntry;\n\tprivate boolean mShowPassword = false;\n\tprivate boolean mIsNew;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\tpublic static void Launch(Activity act, PwGroup parent) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_PARENT, parent.groupId);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_edit);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( KeePass.db == null ) {\n\t\t\tfinish();\n\t\t}\n\n\t\tIntent i = getIntent();\n\t\tbyte[] uuidBytes = i.getByteArrayExtra(KEY_ENTRY);\n\n\t\tif ( uuidBytes == null ) {\n\t\t\tint groupId = i.getIntExtra(KEY_PARENT, -1);\n\n\t\t\tmEntry = new PwEntry(KeePass.db, groupId);\n\t\t\tmIsNew = true;\n\t\t\t\n\t\t} else {\n\t\t\tUUID uuid = Types.bytestoUUID(uuidBytes);\n\t\t\tassert(uuid != null);\n\n\t\t\tmEntry = KeePass.db.gEntries.get(uuid).get();\n\t\t\tmIsNew = false;\n\t\t\t\n\t\t\tfillData();\n\t\t} \n\t\n\t\tView scrollView = findViewById(R.id.entry_scroll);\n\t\tscrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\n\t\t// Save button\n\t\tButton save = (Button) findViewById(R.id.entry_save);\n\t\tsave.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity act = EntryEditActivity.this;\n\t\t\t\t\n\t\t\t\t// Require title\n\t\t\t\tString title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tif ( title.length() == 0 ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_title_required, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Validate password\n\t\t\t\tString pass = Util.getEditText(act, R.id.entry_password);\n\t\t\t\tString conf = Util.getEditText(act, R.id.entry_confpassword);\n\t\t\t\tif ( ! pass.equals(conf) ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPwEntry newEntry = new PwEntry();\n\t\t\t\t\n\t\t\t\tnewEntry.binaryDesc = mEntry.binaryDesc;\n\t\t\t\tnewEntry.groupId = mEntry.groupId;\n\t\t\t\tnewEntry.imageId = mEntry.imageId;\n\t\t\t\tnewEntry.parent = mEntry.parent;\n\t\t\t\tnewEntry.tCreation = mEntry.tCreation;\n\t\t\t\tnewEntry.tExpire = mEntry.tExpire;\n\t\t\t\tnewEntry.uuid = mEntry.uuid;\n\t\t\t\t\n\t\t\t\tDate now = Calendar.getInstance().getTime(); \n\t\t\t\tnewEntry.tLastAccess = now;\n\t\t\t\tnewEntry.tLastMod = now;\n\t\t\t\t\n\t\t\t\tbyte[] binaryData = mEntry.getBinaryData();\n\t\t\t\tif ( binaryData != null ) {\n\t\t\t\t\tnewEntry.setBinaryData(binaryData, 0, binaryData.length);\n\t\t\t\t}\n\n\t\t\t\tnewEntry.title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tnewEntry.url = Util.getEditText(act, R.id.entry_url);\n\t\t\t\tnewEntry.username = Util.getEditText(act, R.id.entry_user_name);\n\t\t\t\tnewEntry.additional = Util.getEditText(act, R.id.entry_comment);\n\t\t\t\tbyte[] password;\n\t\t\t\ttry {\n\t\t\t\t\tpassword = pass.getBytes(\"UTF-8\");\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\tassert false;\n\t\t\t\t\tpassword = pass.getBytes();\n\t\t\t\t}\n\t\t\t\tnewEntry.setPassword(password, 0, password.length);\n\n\t\t\t\tif ( newEntry.title.equals(mEntry.title) ) {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH_TITLE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRunnable task;\n\t\t\t\tif ( mIsNew ) {\n\t\t\t\t\ttask = new AddEntry(KeePass.db, act, newEntry, new Handler());\n\t\t\t\t} else {\n\t\t\t\t\ttask = new UpdateEntry(KeePass.db, act, mEntry, newEntry, new Handler());\n\t\t\t\t}\n\t\t\t\tProgressTask pt = new ProgressTask(act, task, act.new AfterSave());\n\t\t\t\tpt.run();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.entry_cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinish();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\t\tTextView confpassword = (TextView) findViewById(R.id.entry_confpassword);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t\tconfpassword.setTransformationMethod(null);\n\n\t\t} else {\n\t\t\tPasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();\n\t\t\tpassword.setTransformationMethod(ptm);\n\t\t\tconfpassword.setTransformationMethod(ptm);\n\t\t}\n\t}\n\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\t\n\t\tString password = new String(mEntry.getPassword());\n\t\tpopulateText(R.id.entry_password, password);\n\t\tpopulateText(R.id.entry_confpassword, password);\n\t\tsetPasswordStyle();\n\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\t\n\tprivate final class AfterSave implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tfinish();\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.UnsupportedEncodingException;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.AddEntry;\nimport com.keepassdroid.database.OnFinish;\nimport com.keepassdroid.database.RunnableOnFinish;\nimport com.keepassdroid.database.UpdateEntry;\n\npublic class EntryEditActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_PARENT = \"parent\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\n\tprivate PwEntry mEntry;\n\tprivate boolean mShowPassword = false;\n\tprivate boolean mIsNew;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\tpublic static void Launch(Activity act, PwGroup parent) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_PARENT, parent.groupId);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_edit);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\t// Likely the app has been killed exit the activity \n\t\tif ( KeePass.db == null ) {\n\t\t\tfinish();\n\t\t}\n\n\t\tIntent i = getIntent();\n\t\tbyte[] uuidBytes = i.getByteArrayExtra(KEY_ENTRY);\n\n\t\tif ( uuidBytes == null ) {\n\t\t\tint groupId = i.getIntExtra(KEY_PARENT, -1);\n\n\t\t\tmEntry = new PwEntry(KeePass.db, groupId);\n\t\t\tmIsNew = true;\n\t\t\t\n\t\t} else {\n\t\t\tUUID uuid = Types.bytestoUUID(uuidBytes);\n\t\t\tassert(uuid != null);\n\n\t\t\tmEntry = KeePass.db.gEntries.get(uuid).get();\n\t\t\tmIsNew = false;\n\t\t\t\n\t\t\tfillData();\n\t\t} \n\t\n\t\tView scrollView = findViewById(R.id.entry_scroll);\n\t\tscrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\n\t\t// Save button\n\t\tButton save = (Button) findViewById(R.id.entry_save);\n\t\tsave.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity act = EntryEditActivity.this;\n\t\t\t\t\n\t\t\t\t// Require title\n\t\t\t\tString title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tif ( title.length() == 0 ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_title_required, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Validate password\n\t\t\t\tString pass = Util.getEditText(act, R.id.entry_password);\n\t\t\t\tString conf = Util.getEditText(act, R.id.entry_confpassword);\n\t\t\t\tif ( ! pass.equals(conf) ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPwEntry newEntry = new PwEntry();\n\t\t\t\t\n\t\t\t\tnewEntry.binaryDesc = mEntry.binaryDesc;\n\t\t\t\tnewEntry.groupId = mEntry.groupId;\n\t\t\t\tnewEntry.imageId = mEntry.imageId;\n\t\t\t\tnewEntry.parent = mEntry.parent;\n\t\t\t\tnewEntry.tCreation = mEntry.tCreation;\n\t\t\t\tnewEntry.tExpire = mEntry.tExpire;\n\t\t\t\tnewEntry.uuid = mEntry.uuid;\n\t\t\t\t\n\t\t\t\tDate now = Calendar.getInstance().getTime(); \n\t\t\t\tnewEntry.tLastAccess = now;\n\t\t\t\tnewEntry.tLastMod = now;\n\t\t\t\t\n\t\t\t\tbyte[] binaryData = mEntry.getBinaryData();\n\t\t\t\tif ( binaryData != null ) {\n\t\t\t\t\tnewEntry.setBinaryData(binaryData, 0, binaryData.length);\n\t\t\t\t}\n\n\t\t\t\tnewEntry.title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tnewEntry.url = Util.getEditText(act, R.id.entry_url);\n\t\t\t\tnewEntry.username = Util.getEditText(act, R.id.entry_user_name);\n\t\t\t\tnewEntry.additional = Util.getEditText(act, R.id.entry_comment);\n\t\t\t\tbyte[] password;\n\t\t\t\ttry {\n\t\t\t\t\tpassword = pass.getBytes(\"UTF-8\");\n\t\t\t\t} catch (UnsupportedEncodingException e) {\n\t\t\t\t\tassert false;\n\t\t\t\t\tpassword = pass.getBytes();\n\t\t\t\t}\n\t\t\t\tnewEntry.setPassword(password, 0, password.length);\n\n\t\t\t\tif ( newEntry.title.equals(mEntry.title) ) {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH_TITLE);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tRunnableOnFinish task;\n\t\t\t\tHandler handler = new Handler();\n\t\t\t\tOnFinish onFinish = act.new AfterSave(handler);\n\t\t\t\t\n\t\t\t\tif ( mIsNew ) {\n\t\t\t\t\ttask = new AddEntry(KeePass.db, newEntry, handler, onFinish);\n\t\t\t\t} else {\n\t\t\t\t\ttask = new UpdateEntry(KeePass.db, mEntry, newEntry, handler, onFinish);\n\t\t\t\t}\n\t\t\t\tProgressTask pt = new ProgressTask(act, task);\n\t\t\t\tpt.run();\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.entry_cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinish();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\t\tTextView confpassword = (TextView) findViewById(R.id.entry_confpassword);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t\tconfpassword.setTransformationMethod(null);\n\n\t\t} else {\n\t\t\tPasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();\n\t\t\tpassword.setTransformationMethod(ptm);\n\t\t\tconfpassword.setTransformationMethod(ptm);\n\t\t}\n\t}\n\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\t\n\t\tString password = new String(mEntry.getPassword());\n\t\tpopulateText(R.id.entry_password, password);\n\t\tpopulateText(R.id.entry_confpassword, password);\n\t\tsetPasswordStyle();\n\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\t\n\tprivate final class AfterSave extends OnFinish {\n\n\t\tpublic AfterSave(Handler handler) {\n\t\t\tsuper(handler);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tfinish();\n\t\t\t} else {\n\t\t\t\tdisplayMessage(EntryEditActivity.this);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":173}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.view.ContextMenu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Button;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.AddGroup;\n\npublic class GroupActivity extends GroupBaseActivity {\n\t\n\tpublic static final int UNINIT = -1;\n\tpublic static final int VIEW_ONLY = 0;\n\tpublic static final int ADD_GROUP_ONLY = 1;\n\tpublic static final int FULL = 2;\n\t\n\tpublic static void Launch(Activity act, PwGroup group, int mode) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_MODE, mode);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tIntent intent = getIntent();\n\t\t\n\t\tint mode = intent.getIntExtra(KEY_MODE, UNINIT);\n\t\t\n\t\tswitch ( mode ) {\n\t\tcase FULL:\n\t\t\tsetContentView(R.layout.group_add_entry);\n\t\t\tbreak;\n\t\tcase ADD_GROUP_ONLY:\n\t\t\tsetContentView(R.layout.group_root);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsetContentView(R.layout.group_view_only);\n\t\t}\n\t\t\n\t\tint id = intent.getIntExtra(KEY_ENTRY, -1);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = KeePass.db.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = KeePass.db.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\n\t\tif ( mode == FULL || mode == ADD_GROUP_ONLY ) {\n\t\t\t// Add Group button\n\t\t\tButton addGroup = (Button) findViewById(R.id.add_group);\n\t\t\taddGroup.setOnClickListener(new GroupAddHandler(this, mGroup));\n\t\t}\n\t\t\n\t\tif ( mode == FULL ) {\n\t\t\t// Add Entry button\n\t\t\tButton addEntry = (Button) findViewById(R.id.add_entry);\n\t\t\taddEntry.setOnClickListener(new View.OnClickListener() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tEntryEditActivity.Launch(GroupActivity.this, mGroup);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsetGroupTitle();\n\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t\tregisterForContextMenu(getListView());\n\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v,\n\t\t\tContextMenuInfo menuInfo) {\n\t\t\n\t\tAdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;\n\t\tClickView cv = (ClickView) acmi.targetView;\n\t\tcv.onCreateMenu(menu, menuInfo);\n\t}\n\t\n\t\n\t\n\t@Override\n\tpublic boolean onContextItemSelected(MenuItem item) {\n\t\tAdapterContextMenuInfo acmi = (AdapterContextMenuInfo) item.getMenuInfo();\n\t\tClickView cv = (ClickView) acmi.targetView;\n\t\t\n\t\treturn cv.onContextItemSelected(item);\n\t}\n\n\n\n\tprivate class GroupAddHandler implements View.OnClickListener {\n\t\tprivate GroupBaseActivity mAct;\n\t\tprivate PwGroup mGroup;\n\t\tprivate GroupCreateDialog mDialog;\n\t\t\n\t\tGroupAddHandler(GroupBaseActivity act, PwGroup group) {\n\t\t\tmAct = act;\n\t\t\tmGroup = group;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tGroupCreateDialog dialog = new GroupCreateDialog(mAct);\n\t\t\tmDialog = dialog;\n\t\t\t\n\t\t\t// Register Listener\n\t\t\tdialog.setOnDismissListener(new Dialog.OnDismissListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onDismiss(DialogInterface dialog) {\n\t\t\t\t\tString res = mDialog.getResponse();\n\t\t\t\t\t\n\t\t\t\t\tif ( ! mDialog.canceled() && res.length() > 0 ) {\n\t\t\t\t\t\tGroupActivity act = GroupActivity.this;\n\t\t\t\t\t\tAddGroup task = new AddGroup(KeePass.db, act, res, mGroup, new Handler(), false);\n\t\t\t\t\t\tProgressTask pt = new ProgressTask(act, task, act.new RefreshTask());\n\t\t\t\t\t\tpt.run();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t// Show the dialog\n\t\t\tdialog.show();\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.view.ContextMenu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ContextMenu.ContextMenuInfo;\nimport android.widget.Button;\nimport android.widget.AdapterView.AdapterContextMenuInfo;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.AddGroup;\n\npublic class GroupActivity extends GroupBaseActivity {\n\t\n\tpublic static final int UNINIT = -1;\n\tpublic static final int VIEW_ONLY = 0;\n\tpublic static final int ADD_GROUP_ONLY = 1;\n\tpublic static final int FULL = 2;\n\t\n\tpublic static void Launch(Activity act, PwGroup group, int mode) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_MODE, mode);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tIntent intent = getIntent();\n\t\t\n\t\tint mode = intent.getIntExtra(KEY_MODE, UNINIT);\n\t\t\n\t\tswitch ( mode ) {\n\t\tcase FULL:\n\t\t\tsetContentView(R.layout.group_add_entry);\n\t\t\tbreak;\n\t\tcase ADD_GROUP_ONLY:\n\t\t\tsetContentView(R.layout.group_root);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsetContentView(R.layout.group_view_only);\n\t\t}\n\t\t\n\t\tint id = intent.getIntExtra(KEY_ENTRY, -1);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = KeePass.db.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = KeePass.db.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\n\t\tif ( mode == FULL || mode == ADD_GROUP_ONLY ) {\n\t\t\t// Add Group button\n\t\t\tButton addGroup = (Button) findViewById(R.id.add_group);\n\t\t\taddGroup.setOnClickListener(new GroupAddHandler(this, mGroup));\n\t\t}\n\t\t\n\t\tif ( mode == FULL ) {\n\t\t\t// Add Entry button\n\t\t\tButton addEntry = (Button) findViewById(R.id.add_entry);\n\t\t\taddEntry.setOnClickListener(new View.OnClickListener() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tEntryEditActivity.Launch(GroupActivity.this, mGroup);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsetGroupTitle();\n\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t\tregisterForContextMenu(getListView());\n\n\t}\n\n\t@Override\n\tpublic void onCreateContextMenu(ContextMenu menu, View v,\n\t\t\tContextMenuInfo menuInfo) {\n\t\t\n\t\tAdapterContextMenuInfo acmi = (AdapterContextMenuInfo) menuInfo;\n\t\tClickView cv = (ClickView) acmi.targetView;\n\t\tcv.onCreateMenu(menu, menuInfo);\n\t}\n\t\n\t\n\t\n\t@Override\n\tpublic boolean onContextItemSelected(MenuItem item) {\n\t\tAdapterContextMenuInfo acmi = (AdapterContextMenuInfo) item.getMenuInfo();\n\t\tClickView cv = (ClickView) acmi.targetView;\n\t\t\n\t\treturn cv.onContextItemSelected(item);\n\t}\n\n\n\n\tprivate class GroupAddHandler implements View.OnClickListener {\n\t\tprivate GroupBaseActivity mAct;\n\t\tprivate PwGroup mGroup;\n\t\tprivate GroupCreateDialog mDialog;\n\t\t\n\t\tGroupAddHandler(GroupBaseActivity act, PwGroup group) {\n\t\t\tmAct = act;\n\t\t\tmGroup = group;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tGroupCreateDialog dialog = new GroupCreateDialog(mAct);\n\t\t\tmDialog = dialog;\n\t\t\t\n\t\t\t// Register Listener\n\t\t\tdialog.setOnDismissListener(new Dialog.OnDismissListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onDismiss(DialogInterface dialog) {\n\t\t\t\t\tString res = mDialog.getResponse();\n\t\t\t\t\t\n\t\t\t\t\tif ( ! mDialog.canceled() && res.length() > 0 ) {\n\t\t\t\t\t\tGroupActivity act = GroupActivity.this;\n\t\t\t\t\t\tHandler handler = new Handler();\n\t\t\t\t\t\tAddGroup task = new AddGroup(KeePass.db, res, mGroup, handler, act.new RefreshTask(handler), false);\n\t\t\t\t\t\tProgressTask pt = new ProgressTask(act, task);\n\t\t\t\t\t\tpt.run();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t// Show the dialog\n\t\t\tdialog.show();\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":162}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.LoadDB;\nimport com.keepassdroid.fileselect.FileDbHelper;\nimport com.keepassdroid.intents.TimeoutIntents;\n\npublic class PasswordActivity extends Activity {\n\n\tprivate static final int MENU_ABOUT = Menu.FIRST;\n\tprivate static final String KEY_FILENAME = \"fileName\";\n\tprivate static final String KEY_KEYFILE = \"keyFile\";\n\tprivate static final String VIEW_INTENT = \"android.intent.action.VIEW\";\n\n\tprivate String mFileName;\n\tprivate String mKeyFile;\n\t\n\tpublic static void Launch(Activity act, String fileName) throws FileNotFoundException {\n\t\tLaunch(act,fileName,\"\");\n\t}\n\t\n\tpublic static void Launch(Activity act, String fileName, String keyFile) throws FileNotFoundException {\n\t\tFile dbFile = new File(fileName);\n\t\tif ( ! dbFile.exists() ) {\n\t\t\tthrow new FileNotFoundException();\n\t\t}\n\t\t\n\t\tIntent i = new Intent(act, PasswordActivity.class);\n\t\ti.putExtra(KEY_FILENAME, fileName);\n\t\ti.putExtra(KEY_KEYFILE, keyFile);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t\t\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == KeePass.EXIT_LOCK) {\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t}\n\t\t\n\t\tKeePass.db.clear(); \n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\n\t\tIntent i = getIntent();\n\t\tString action = i.getAction();\n\t\t\n\t\tif ( action != null && action.equals(VIEW_INTENT) ) {\n\t\t\tmFileName = i.getDataString();\n\n\t\t\tif ( ! mFileName.substring(0, 7).equals(\"file://\") ) {\n\t\t\t\tToast.makeText(this, R.string.error_can_not_handle_uri, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmFileName = mFileName.substring(7, mFileName.length());\n\t\t\t\t\t\t\n\t\t\tif ( mFileName.length() == 0 ) {\n\t\t\t\t// No file name\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tFile dbFile = new File(mFileName);\n\t\t\tif ( ! dbFile.exists() ) {\n\t\t\t\t// File does not exist\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmKeyFile = getKeyFile(mFileName);\n\t\t\t\n\t\t} else {\n\t\t\tmFileName = i.getStringExtra(KEY_FILENAME);\n\t\t\tmKeyFile = i.getStringExtra(KEY_KEYFILE);\n\t\t}\n\t\t\n\t\tsetContentView(R.layout.password);\n\t\tpopulateView();\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new ClickHandler());\n\t}\n\t\n\tprivate String getKeyFile(String filename) {\n\t\tFileDbHelper dbHelp = new FileDbHelper(this);\n\t\tdbHelp.open();\n\t\t\n\t\tString keyfile = dbHelp.getFileByName(filename);\n\t\t\n\t\tdbHelp.close();\n\t\t\n\t\treturn keyfile;\n\t}\n\t\n\tprivate void populateView() {\n\t\tsetEditText(R.id.pass_filename, mFileName);\n\t\tsetEditText(R.id.pass_keyfile, mKeyFile);\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Clear password on Database state\n\t\tsetEditText(R.id.pass_password, \"\");\n\t\t\n\t\tsendBroadcast(new Intent(TimeoutIntents.CANCEL));\n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t}\n\n\t@Override\n\tprotected void onPause() {\n\t\tsuper.onPause();\n\t\t\n\t\tsendBroadcast(new Intent(TimeoutIntents.START));\n\t}\n\n\t/*\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t*/\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class ClickHandler implements View.OnClickListener {\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.pass_password);\n\t\t\tString key = getEditText(R.id.pass_keyfile);\n\t\t\tif ( pass.length() == 0 && key.length() == 0 ) {\n\t\t\t\terrorMessage(R.string.error_nopass);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tString fileName = getEditText(R.id.pass_filename);\n\t\t\t\n\t\t\tLoadDB task = new LoadDB(KeePass.db, PasswordActivity.this, new Handler(), fileName, pass, key);\n\t\t\tProgressTask pt = new ProgressTask(PasswordActivity.this, task, new AfterLoad());\n\t\t\tpt.run();\n\t\t}\t\t\t\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\treturn Util.getEditText(this, resId);\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tTextView te =  (TextView) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_ABOUT, 0, R.string.menu_about);\n\t\tmenu.findItem(MENU_ABOUT).setIcon(android.R.drawable.ic_menu_help);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_ABOUT:\n\t\t\tAboutDialog dialog = new AboutDialog(this);\n\t\t\tdialog.show();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate final class AfterLoad implements Runnable {\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tGroupActivity.Launch(PasswordActivity.this, null, GroupActivity.ADD_GROUP_ONLY);\n\t\t}\n\t}\n\t\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.keepassdroid;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.KeePass;\nimport com.android.keepass.R;\nimport com.keepassdroid.database.LoadDB;\nimport com.keepassdroid.database.OnFinish;\nimport com.keepassdroid.fileselect.FileDbHelper;\nimport com.keepassdroid.intents.TimeoutIntents;\n\npublic class PasswordActivity extends Activity {\n\n\tprivate static final int MENU_ABOUT = Menu.FIRST;\n\tprivate static final String KEY_FILENAME = \"fileName\";\n\tprivate static final String KEY_KEYFILE = \"keyFile\";\n\tprivate static final String VIEW_INTENT = \"android.intent.action.VIEW\";\n\n\tprivate String mFileName;\n\tprivate String mKeyFile;\n\t\n\tpublic static void Launch(Activity act, String fileName) throws FileNotFoundException {\n\t\tLaunch(act,fileName,\"\");\n\t}\n\t\n\tpublic static void Launch(Activity act, String fileName, String keyFile) throws FileNotFoundException {\n\t\tFile dbFile = new File(fileName);\n\t\tif ( ! dbFile.exists() ) {\n\t\t\tthrow new FileNotFoundException();\n\t\t}\n\t\t\n\t\tIntent i = new Intent(act, PasswordActivity.class);\n\t\ti.putExtra(KEY_FILENAME, fileName);\n\t\ti.putExtra(KEY_KEYFILE, keyFile);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t\t\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == KeePass.EXIT_LOCK) {\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t}\n\t\t\n\t\tKeePass.db.clear(); \n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\n\t\tIntent i = getIntent();\n\t\tString action = i.getAction();\n\t\t\n\t\tif ( action != null && action.equals(VIEW_INTENT) ) {\n\t\t\tmFileName = i.getDataString();\n\n\t\t\tif ( ! mFileName.substring(0, 7).equals(\"file://\") ) {\n\t\t\t\tToast.makeText(this, R.string.error_can_not_handle_uri, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmFileName = mFileName.substring(7, mFileName.length());\n\t\t\t\t\t\t\n\t\t\tif ( mFileName.length() == 0 ) {\n\t\t\t\t// No file name\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tFile dbFile = new File(mFileName);\n\t\t\tif ( ! dbFile.exists() ) {\n\t\t\t\t// File does not exist\n\t\t\t\tToast.makeText(this, R.string.FileNotFound, Toast.LENGTH_LONG).show();\n\t\t\t\tfinish();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tmKeyFile = getKeyFile(mFileName);\n\t\t\t\n\t\t} else {\n\t\t\tmFileName = i.getStringExtra(KEY_FILENAME);\n\t\t\tmKeyFile = i.getStringExtra(KEY_KEYFILE);\n\t\t}\n\t\t\n\t\tsetContentView(R.layout.password);\n\t\tpopulateView();\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new ClickHandler());\n\t}\n\t\n\tprivate String getKeyFile(String filename) {\n\t\tFileDbHelper dbHelp = new FileDbHelper(this);\n\t\tdbHelp.open();\n\t\t\n\t\tString keyfile = dbHelp.getFileByName(filename);\n\t\t\n\t\tdbHelp.close();\n\t\t\n\t\treturn keyfile;\n\t}\n\t\n\tprivate void populateView() {\n\t\tsetEditText(R.id.pass_filename, mFileName);\n\t\tsetEditText(R.id.pass_keyfile, mKeyFile);\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Clear password on Database state\n\t\tsetEditText(R.id.pass_password, \"\");\n\t\t\n\t\tsendBroadcast(new Intent(TimeoutIntents.CANCEL));\n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t}\n\n\t@Override\n\tprotected void onPause() {\n\t\tsuper.onPause();\n\t\t\n\t\tsendBroadcast(new Intent(TimeoutIntents.START));\n\t}\n\n\t/*\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t*/\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class ClickHandler implements View.OnClickListener {\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.pass_password);\n\t\t\tString key = getEditText(R.id.pass_keyfile);\n\t\t\tif ( pass.length() == 0 && key.length() == 0 ) {\n\t\t\t\terrorMessage(R.string.error_nopass);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tString fileName = getEditText(R.id.pass_filename);\n\t\t\t\n\t\t\tHandler handler = new Handler();\n\t\t\tLoadDB task = new LoadDB(KeePass.db, PasswordActivity.this, handler, fileName, pass, key, new AfterLoad(handler));\n\t\t\tProgressTask pt = new ProgressTask(PasswordActivity.this, task);\n\t\t\tpt.run();\n\t\t}\t\t\t\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\treturn Util.getEditText(this, resId);\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tTextView te =  (TextView) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_ABOUT, 0, R.string.menu_about);\n\t\tmenu.findItem(MENU_ABOUT).setIcon(android.R.drawable.ic_menu_help);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_ABOUT:\n\t\t\tAboutDialog dialog = new AboutDialog(this);\n\t\t\tdialog.show();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\tprivate final class AfterLoad extends OnFinish {\n\t\t\n\t\tpublic AfterLoad(Handler handler) {\n\t\t\tsuper(handler);\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tif ( mSuccess ) {\n\t\t\t\tGroupActivity.Launch(PasswordActivity.this, null, GroupActivity.ADD_GROUP_ONLY);\n\t\t\t} else {\n\t\t\t\tdisplayMessage(PasswordActivity.this);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n","lineNo":193}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.os.Bundle;\n\npublic class GroupActivity extends GroupBaseActivity {\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.group_view_only);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tint id = getIntent().getIntExtra(KEY_ENTRY, -1);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = KeePass.db.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = KeePass.db.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\n\t\tsetGroupTitle();\n\t\t\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.app.Dialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.Toast;\n\nimport com.android.keepass.keepasslib.PwManagerOutputException;\n\npublic class GroupActivity extends GroupBaseActivity {\n\t\n\tpublic static final int UNINIT = -1;\n\tpublic static final int VIEW_ONLY = 0;\n\tpublic static final int ADD_GROUP_ONLY = 1;\n\tpublic static final int FULL = 2;\n\t\n\tpublic static void Launch(Activity act, PwGroup group, int mode) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\ti.putExtra(KEY_MODE, mode);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\n\t\tIntent intent = getIntent();\n\t\t\n\t\tint mode = intent.getIntExtra(KEY_MODE, UNINIT);\n\t\t\n\t\tswitch ( mode ) {\n\t\tcase FULL:\n\t\t\tsetContentView(R.layout.group_add_entry);\n\t\t\tbreak;\n\t\tcase ADD_GROUP_ONLY:\n\t\t\tsetContentView(R.layout.group_root);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tsetContentView(R.layout.group_view_only);\n\t\t}\n\t\t\n\t\tint id = intent.getIntExtra(KEY_ENTRY, -1);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = KeePass.db.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = KeePass.db.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\n\t\tif ( mode == FULL || mode == ADD_GROUP_ONLY ) {\n\t\t\t// Add Group button\n\t\t\tButton addGroup = (Button) findViewById(R.id.add_group);\n\t\t\taddGroup.setOnClickListener(new GroupAddHandler(this, mGroup));\n\t\t}\n\t\t\n\t\tif ( mode == FULL ) {\n\t\t\t// Add Entry button\n\t\t\tButton addEntry = (Button) findViewById(R.id.add_entry);\n\t\t\taddEntry.setOnClickListener(new View.OnClickListener() {\n\t\n\t\t\t\t@Override\n\t\t\t\tpublic void onClick(View v) {\n\t\t\t\t\tEntryEditActivity.Launch(GroupActivity.this, mGroup);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tsetGroupTitle();\n\t\t\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t}\n\t\n\tprivate class GroupAddHandler implements View.OnClickListener {\n\t\tprivate GroupBaseActivity mAct;\n\t\tprivate PwGroup mGroup;\n\t\tprivate GroupCreateDialog mDialog;\n\t\t\n\t\tGroupAddHandler(GroupBaseActivity act, PwGroup group) {\n\t\t\tmAct = act;\n\t\t\tmGroup = group;\n\t\t}\n\n\t\t@Override\n\t\tpublic void onClick(View v) {\n\t\t\tGroupCreateDialog dialog = new GroupCreateDialog(mAct);\n\t\t\tmDialog = dialog;\n\t\t\t\n\t\t\t// Register Listener\n\t\t\tdialog.setOnDismissListener(new Dialog.OnDismissListener() {\n\n\t\t\t\t@Override\n\t\t\t\tpublic void onDismiss(DialogInterface dialog) {\n\t\t\t\t\tString res = mDialog.getResponse();\n\t\t\t\t\ttry {\n\t\t\t\t\t\tKeePass.db.NewGroup(res, mGroup);\n\t\t\t\t\t} catch (PwManagerOutputException e) {\n\t\t\t\t\t\tToast.makeText(mAct, R.string.error_could_not_create_group, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\tToast.makeText(mAct, R.string.error_could_not_create_group, Toast.LENGTH_LONG).show();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tmAct.refreshIfDirty();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\tdialog.show();\n\t\t}\n\t\t\n\t\t\n\t}\n\n}\n","lineNo":62}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.text.DateFormat;\nimport java.util.Calendar;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.Types;\n\nimport android.app.Activity;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\npublic class EntryActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_REFRESH_POS = \"refresh_pos\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\tprivate static final int MENU_GOTO_URL = Menu.FIRST + 1;\n\tprivate static final int MENU_COPY_USER = Menu.FIRST + 2;\n\tprivate static final int MENU_COPY_PASS = Menu.FIRST + 3;\n\tprivate static final int MENU_LOCK = Menu.FIRST + 4; \n\t\n\tprivate static final long CLIP_CLEAR_TIME = 30 * 1000;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw, int pos) {\n\t\tIntent i = new Intent(act, EntryActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\ti.putExtra(KEY_REFRESH_POS, pos);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\tprivate PwEntry mEntry;\n\tprivate Timer mTimer = new Timer();\n\tprivate boolean mShowPassword = false;\n\tprivate int mPos;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_view);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tIntent i = getIntent();\n\t\tUUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));\n\t\tmPos = i.getIntExtra(KEY_REFRESH_POS, -1);\n\t\tassert(uuid != null);\n\t\t\n\t\tmEntry = KeePass.db.gEntries.get(uuid).get();\n\t\t\n\t\t// Update last access time.\n\t\tCalendar cal = Calendar.getInstance();\n\t\tmEntry.tLastAccess = cal.getTime();\n\t\tfillData();\n\n\t\tView scroll = findViewById(R.id.entry_scroll);\n\t\tscroll.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\t\t\n\t\tButton edit = (Button) findViewById(R.id.entry_edit);\n\t\tedit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity.Launch(EntryActivity.this, mEntry);\n\t\t\t}\n\t\t\t\n\t\t});\n\t}\n\t\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\tpopulateText(R.id.entry_password, new String(mEntry.getPassword()));\n\t\tsetPasswordStyle();\n\t\t\n\t\tDateFormat df = DateFormat.getInstance();\n\t\tpopulateText(R.id.entry_created, df.format(mEntry.tCreation));\n\t\tpopulateText(R.id.entry_modified, df.format(mEntry.tLastMod));\n\t\tpopulateText(R.id.entry_accessed, df.format(mEntry.tLastAccess));\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t}\n\t\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\tfillData();\n\t\t\tif ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\t\tIntent ret = new Intent();\n\t\t\t\tret.putExtra(KEY_REFRESH_POS, mPos);\n\t\t\t\tsetResult(KeePass.EXIT_REFRESH, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\tmenu.add(0, MENU_GOTO_URL, 0, R.string.menu_url);\n\t\tmenu.findItem(MENU_GOTO_URL).setIcon(android.R.drawable.ic_menu_upload);\n\t\tmenu.add(0, MENU_COPY_USER, 0, R.string.menu_copy_user);\n\t\tmenu.findItem(MENU_COPY_USER).setIcon(android.R.drawable.ic_menu_set_as);\n\t\tmenu.add(0, MENU_COPY_PASS, 0, R.string.menu_copy_pass);\n\t\tmenu.findItem(MENU_COPY_PASS).setIcon(android.R.drawable.ic_menu_agenda);\n\t\tmenu.add(0, MENU_LOCK, 0, R.string.menu_lock);\n\t\tmenu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t} else {\n\t\t\tpassword.setTransformationMethod(PasswordTransformationMethod.getInstance());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\n\t\t\treturn true;\n\t\t\t\n\t\tcase MENU_GOTO_URL:\n\t\t\tUtil.gotoUrl(this, mEntry.url);\n\t\t\treturn true;\n\t\tcase MENU_COPY_USER:\n\t\t\ttimeoutCopyToClipboard(mEntry.username);\n\t\t\treturn true;\n\t\tcase MENU_COPY_PASS:\n\t\t\ttimeoutCopyToClipboard(new String(mEntry.getPassword()));\n\t\t\treturn true;\n\t\tcase MENU_LOCK:\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void timeoutCopyToClipboard(String text) {\n\t\tUtil.copyToClipboard(this, text);\n\t\tmTimer.schedule(new ClearClipboardTask(this, text), CLIP_CLEAR_TIME);\n\t}\n\t\n\n\t// Setup to allow the toast to happen in the foreground\n\tfinal Handler uiThreadCallback = new Handler();\n\n\t// Task which clears the clipboard, and sends a toast to the foreground.\n\tprivate class ClearClipboardTask extends TimerTask {\n\t\t\n\t\tprivate final String mClearText;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tClearClipboardTask(Context ctx, String clearText) {\n\t\t\tmClearText = clearText;\n\t\t\tmCtx = ctx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tString currentClip = Util.getClipboard(mCtx);\n\t\t\t\n\t\t\tif ( currentClip.equals(mClearText) ) {\n\t\t\t\tUtil.copyToClipboard(mCtx, \"\");\n\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));\n\t\t\t}\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.text.DateFormat;\nimport java.util.Calendar;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.Types;\n\nimport android.app.Activity;\nimport android.content.ActivityNotFoundException;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class EntryActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_REFRESH_POS = \"refresh_pos\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\tprivate static final int MENU_GOTO_URL = Menu.FIRST + 1;\n\tprivate static final int MENU_COPY_USER = Menu.FIRST + 2;\n\tprivate static final int MENU_COPY_PASS = Menu.FIRST + 3;\n\tprivate static final int MENU_LOCK = Menu.FIRST + 4; \n\t\n\tprivate static final long CLIP_CLEAR_TIME = 30 * 1000;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw, int pos) {\n\t\tIntent i = new Intent(act, EntryActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\ti.putExtra(KEY_REFRESH_POS, pos);\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\t\n\tprivate PwEntry mEntry;\n\tprivate Timer mTimer = new Timer();\n\tprivate boolean mShowPassword = false;\n\tprivate int mPos;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_view);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tIntent i = getIntent();\n\t\tUUID uuid = Types.bytestoUUID(i.getByteArrayExtra(KEY_ENTRY));\n\t\tmPos = i.getIntExtra(KEY_REFRESH_POS, -1);\n\t\tassert(uuid != null);\n\t\t\n\t\tmEntry = KeePass.db.gEntries.get(uuid).get();\n\t\t\n\t\t// Update last access time.\n\t\tCalendar cal = Calendar.getInstance();\n\t\tmEntry.tLastAccess = cal.getTime();\n\t\tfillData();\n\n\t\tView scroll = findViewById(R.id.entry_scroll);\n\t\tscroll.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\t\t\n\t\tButton edit = (Button) findViewById(R.id.entry_edit);\n\t\tedit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity.Launch(EntryActivity.this, mEntry);\n\t\t\t}\n\t\t\t\n\t\t});\n\t}\n\t\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\tpopulateText(R.id.entry_password, new String(mEntry.getPassword()));\n\t\tsetPasswordStyle();\n\t\t\n\t\tDateFormat df = DateFormat.getInstance();\n\t\tpopulateText(R.id.entry_created, df.format(mEntry.tCreation));\n\t\tpopulateText(R.id.entry_modified, df.format(mEntry.tLastMod));\n\t\tpopulateText(R.id.entry_accessed, df.format(mEntry.tLastAccess));\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t}\n\t\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\tif ( resultCode == KeePass.EXIT_REFRESH || resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\tfillData();\n\t\t\tif ( resultCode == KeePass.EXIT_REFRESH_TITLE ) {\n\t\t\t\tIntent ret = new Intent();\n\t\t\t\tret.putExtra(KEY_REFRESH_POS, mPos);\n\t\t\t\tsetResult(KeePass.EXIT_REFRESH, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\tmenu.add(0, MENU_GOTO_URL, 0, R.string.menu_url);\n\t\tmenu.findItem(MENU_GOTO_URL).setIcon(android.R.drawable.ic_menu_upload);\n\t\tmenu.add(0, MENU_COPY_USER, 0, R.string.menu_copy_user);\n\t\tmenu.findItem(MENU_COPY_USER).setIcon(android.R.drawable.ic_menu_set_as);\n\t\tmenu.add(0, MENU_COPY_PASS, 0, R.string.menu_copy_pass);\n\t\tmenu.findItem(MENU_COPY_PASS).setIcon(android.R.drawable.ic_menu_agenda);\n\t\tmenu.add(0, MENU_LOCK, 0, R.string.menu_lock);\n\t\tmenu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t} else {\n\t\t\tpassword.setTransformationMethod(PasswordTransformationMethod.getInstance());\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\n\t\t\treturn true;\n\t\t\t\n\t\tcase MENU_GOTO_URL:\n\t\t\tString url;\n\t\t\turl = mEntry.url;\n\t\t\t\n\t\t\t// Default http:// if no protocol specified\n\t\t\tif ( ! url.contains(\"://\") ) {\n\t\t\t\turl = \"http://\" + url;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tUtil.gotoUrl(this, url);\n\t\t\t} catch (ActivityNotFoundException e) {\n\t\t\t\tToast.makeText(this, R.string.no_url_handler, Toast.LENGTH_LONG).show();\n\t\t\t}\n\t\t\treturn true;\n\t\tcase MENU_COPY_USER:\n\t\t\ttimeoutCopyToClipboard(mEntry.username);\n\t\t\treturn true;\n\t\tcase MENU_COPY_PASS:\n\t\t\ttimeoutCopyToClipboard(new String(mEntry.getPassword()));\n\t\t\treturn true;\n\t\tcase MENU_LOCK:\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void timeoutCopyToClipboard(String text) {\n\t\tUtil.copyToClipboard(this, text);\n\t\tmTimer.schedule(new ClearClipboardTask(this, text), CLIP_CLEAR_TIME);\n\t}\n\t\n\n\t// Setup to allow the toast to happen in the foreground\n\tfinal Handler uiThreadCallback = new Handler();\n\n\t// Task which clears the clipboard, and sends a toast to the foreground.\n\tprivate class ClearClipboardTask extends TimerTask {\n\t\t\n\t\tprivate final String mClearText;\n\t\tprivate final Context mCtx;\n\t\t\n\t\tClearClipboardTask(Context ctx, String clearText) {\n\t\t\tmClearText = clearText;\n\t\t\tmCtx = ctx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tString currentClip = Util.getClipboard(mCtx);\n\t\t\t\n\t\t\tif ( currentClip.equals(mClearText) ) {\n\t\t\t\tUtil.copyToClipboard(mCtx, \"\");\n\t\t\t\tuiThreadCallback.post(new UIToastTask(mCtx, R.string.ClearClipboard));\n\t\t\t}\n\t\t}\n\t}\n}\n","lineNo":179}
{"Smelly Sample":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage org.phoneid.keepassj2me;\n\n// Java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.util.Vector;\n\nimport org.bouncycastle.crypto.digests.SHA256Digest;\n\nimport com.android.keepass.keepasslib.InvalidKeyFileException;\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwManager {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    public Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Last modified entry, use GetLastEditedEntry() to get it\n    // PwEntry          lastEditedEntry        = null;\n    // Pseudo-random number generator\n    //CNewRandom m_random;\n    // Used for in-memory encryption of passwords\n    // private byte     sessionKey[]           = new byte[PWM_SESSION_KEY_SIZE];\n    // Master key used to encrypt the whole database\n    public byte             masterKey[]            = new byte[32];\n    // Algorithm used to encrypt the database\n    int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeader dbHeader;\n    public long paddingBytes;\n    public byte[] finalKey;\n\n    // root group\n    PwGroup rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public void setMasterKey( String key, String keyFileName ) throws InvalidKeyFileException, IOException {\n    \tassert( key != null && keyFileName != null );\n    \t\n    \tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n    \t\tsetCompositeKey(key, keyFileName);\n    \t} else if ( key.length() > 0 ) {\n    \t\tsetPasswordKey(key);\n    \t} else if ( keyFileName.length() > 0 ) {\n    \t\tsetFileKey(keyFileName);\n    \t} else {\n    \t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n    \t}\n    }\n    \n    private void setCompositeKey( String key, String keyFileName) throws InvalidKeyFileException, IOException {\n    \tassert(key != null && keyFileName != null);\n    \t\n    \tbyte[] fileKey = new byte[32];\n    \tsetFileKey(keyFileName);\n    \tSystem.arraycopy(masterKey, 0, fileKey, 0, 32);\n    \t\n    \tbyte[] passwordKey = new byte[32];\n    \tsetPasswordKey(key);\n    \tSystem.arraycopy(masterKey, 0, passwordKey, 0, 32);\n    \t\n    \tSHA256Digest md = new SHA256Digest();\n    \tmd.update(passwordKey, 0, 32);\n    \tmd.update(fileKey, 0, 32);\n    \tmasterKey = new byte[md.getDigestSize()];\n    \tmd.doFinal(masterKey, 0);\n    \t\n    }\n    \n    private void setFileKey(String fileName) throws InvalidKeyFileException, IOException {\n\t\tassert(fileName != null);\n\t\t\n\t\tFile keyfile = new File(fileName);\n\t\tlong fileSize = keyfile.length();\n\t\n\t\tif ( ! keyfile.exists() ) {\n\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t}\n\t\t\n\t\t\n\t\tFileInputStream fis;\n\t\ttry {\n\t\t\tfis = new FileInputStream(keyfile);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t}\n\t\t\n\t\tif ( fileSize == 0 ) {\n\t\t\tthrow new InvalidKeyFileException(\"Key file is empty.\");\n\t\t} else if ( fileSize == 32 ) {\n\t\t\tmasterKey = new byte[32];\n\t\t\tif ( fis.read(masterKey, 0, 32) != 32 ) {\n\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t} else if ( fileSize == 64 ) {\n\t\t\tbyte[] hex = new byte[64];\n\t\t\t\n\t\t\tif ( fis.read(hex, 0, 64) != 64 ) {\n\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t}\n\n\t\t\tmasterKey = hexStringToByteArray(new String(hex));\n\t\t\treturn;\n\t\t}\n\t\n\t\tSHA256Digest md = new SHA256Digest();\n\t\tbyte[] buffer = new byte[2048];\n\t\tint offset = 0;\n\t\t\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tint bytesRead = fis.read(buffer, 0, 2048);\n\t\t\t\tif ( bytesRead == -1 ) break;  // End of file\n\t\t\t\t\n\t\t\t\tmd.update(buffer, 0, bytesRead);\n\t\t\t\toffset += bytesRead;\n\t\t\t\t\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.toString());\n\t\t}\n\t\tmasterKey = new byte[md.getDigestSize()];\n\t\tmd.doFinal(masterKey, 0);\n    }\n    \n    \n    public static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                                 + Character.digit(s.charAt(i+1), 16));\n        }\n        return data;\n    }\n   \n    private void setPasswordKey(String key ) {\n    \tassert(key!=null);\n    \t\n\t\tif ( key.length() == 0 )\n\t\t    throw new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t\n\t\tSHA256Digest md = new SHA256Digest();\n\t\tmd.update( key.getBytes(), 0, key.getBytes().length );\n\t\tmasterKey = new byte[md.getDigestSize()];\n\t\tmd.doFinal(masterKey, 0);\n    }\n    \t\n  /*\n  //\n  // Erase all members and buffers, then null pointers.\n  // Ensures no memory (that we control) contains leftover keys.\n  //\n  void secureErase() {\n    // TODO finish this!\n  }\n\n    */\n\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroup grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroup grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroup> getGrpChildren( PwGroup parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroup grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntry> getEntries( PwGroup parent ) {\n\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntry ent = (PwEntry)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntry ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroup group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntry entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroup currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroup();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n}\n","Method after Refactoring":"/*\n\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; either version 2 \n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage org.phoneid.keepassj2me;\n\n// Java\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Vector;\n\nimport org.bouncycastle.crypto.digests.SHA256Digest;\n\nimport com.android.keepass.keepasslib.InvalidKeyFileException;\n\n/**\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n * @author Dominik Reichl <dominik.reichl@t-online.de>\n */\npublic class PwManager {\n\t// TODO: delete ME\n\tpublic byte[] postHeader;\n\t\n    // Constants\n    // private static final int PWM_SESSION_KEY_SIZE = 12;\n\n    // Descriptive name for database, used in GUI.\n    public  String   name = \"KeePass database\";\n  \n    // Special entry for settings\n    public PwEntry   metaInfo;\n\n    // all entries\n    public Vector<PwEntry> entries = new Vector<PwEntry>();\n    // all groups\n    public Vector<PwGroup> groups = new Vector<PwGroup>();\n    // Last modified entry, use GetLastEditedEntry() to get it\n    // PwEntry          lastEditedEntry        = null;\n    // Pseudo-random number generator\n    //CNewRandom m_random;\n    // Used for in-memory encryption of passwords\n    // private byte     sessionKey[]           = new byte[PWM_SESSION_KEY_SIZE];\n    // Master key used to encrypt the whole database\n    public byte             masterKey[]            = new byte[32];\n    // Algorithm used to encrypt the database\n    int              algorithm;\n    public int              numKeyEncRounds;\n    \n    // Debugging entries\n    public PwDbHeader dbHeader;\n    public long paddingBytes;\n    public byte[] finalKey;\n\n    // root group\n    PwGroup rootGroup;\n   \n    public int getAlgorithm() {\n    \treturn algorithm;\n    }\n    \n    public int getNumKeyEncRecords() {\n    \treturn numKeyEncRounds;\n    }\n    \n    public void setMasterKey( String key, String keyFileName ) throws InvalidKeyFileException, IOException {\n    \tassert( key != null && keyFileName != null );\n    \t\n    \tif ( key.length() > 0 && keyFileName.length() > 0 ) {\n    \t\tsetCompositeKey(key, keyFileName);\n    \t} else if ( key.length() > 0 ) {\n    \t\tsetPasswordKey(key);\n    \t} else if ( keyFileName.length() > 0 ) {\n    \t\tsetFileKey(keyFileName);\n    \t} else {\n    \t\tthrow new IllegalArgumentException( \"Key cannot be empty.\" );\n    \t}\n    }\n    \n    private void setCompositeKey( String key, String keyFileName) throws InvalidKeyFileException, IOException {\n    \tassert(key != null && keyFileName != null);\n    \t\n    \tbyte[] fileKey = new byte[32];\n    \tsetFileKey(keyFileName);\n    \tSystem.arraycopy(masterKey, 0, fileKey, 0, 32);\n    \t\n    \tbyte[] passwordKey = new byte[32];\n    \tsetPasswordKey(key);\n    \tSystem.arraycopy(masterKey, 0, passwordKey, 0, 32);\n    \t\n    \tSHA256Digest md = new SHA256Digest();\n    \tmd.update(passwordKey, 0, 32);\n    \tmd.update(fileKey, 0, 32);\n    \tmasterKey = new byte[md.getDigestSize()];\n    \tmd.doFinal(masterKey, 0);\n    \t\n    }\n    \n    private void setFileKey(String fileName) throws InvalidKeyFileException, IOException {\n\t\tassert(fileName != null);\n\t\t\n\t\tFile keyfile = new File(fileName);\n\t\tlong fileSize = keyfile.length();\n\t\n\t\tif ( ! keyfile.exists() ) {\n\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t}\n\t\t\n\t\t\n\t\tFileInputStream fis;\n\t\ttry {\n\t\t\tfis = new FileInputStream(keyfile);\n\t\t} catch (FileNotFoundException e) {\n\t\t\tthrow new InvalidKeyFileException(\"Key file does not exist.\");\n\t\t}\n\t\t\n\t\tif ( fileSize == 0 ) {\n\t\t\tthrow new InvalidKeyFileException(\"Key file is empty.\");\n\t\t} else if ( fileSize == 32 ) {\n\t\t\tmasterKey = new byte[32];\n\t\t\tif ( fis.read(masterKey, 0, 32) != 32 ) {\n\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t}\n\t\t\t\n\t\t\treturn;\n\t\t} else if ( fileSize == 64 ) {\n\t\t\tbyte[] hex = new byte[64];\n\t\t\t\n\t\t\tif ( fis.read(hex, 0, 64) != 64 ) {\n\t\t\t\tthrow new IOException(\"Error reading key.\");\n\t\t\t}\n\n\t\t\tmasterKey = hexStringToByteArray(new String(hex));\n\t\t\treturn;\n\t\t}\n\t\n\t\tSHA256Digest md = new SHA256Digest();\n\t\tbyte[] buffer = new byte[2048];\n\t\tint offset = 0;\n\t\t\n\t\ttry {\n\t\t\twhile (true) {\n\t\t\t\tint bytesRead = fis.read(buffer, 0, 2048);\n\t\t\t\tif ( bytesRead == -1 ) break;  // End of file\n\t\t\t\t\n\t\t\t\tmd.update(buffer, 0, bytesRead);\n\t\t\t\toffset += bytesRead;\n\t\t\t\t\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e.toString());\n\t\t}\n\t\tmasterKey = new byte[md.getDigestSize()];\n\t\tmd.doFinal(masterKey, 0);\n    }\n    \n    \n    public static byte[] hexStringToByteArray(String s) {\n        int len = s.length();\n        byte[] data = new byte[len / 2];\n        for (int i = 0; i < len; i += 2) {\n            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4)\n                                 + Character.digit(s.charAt(i+1), 16));\n        }\n        return data;\n    }\n   \n    private void setPasswordKey(String key ) {\n    \tassert(key!=null);\n    \t\n\t\tif ( key.length() == 0 )\n\t\t    throw new IllegalArgumentException( \"Key cannot be empty.\" );\n\t\t\n\t\tSHA256Digest md = new SHA256Digest();\n\t\tbyte[] bKey;\n\t\ttry {\n\t\t\tbKey = key.getBytes(\"ISO-8859-1\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tassert false;\n\t\t\tbKey = key.getBytes();\n\t\t}\n\t\tmd.update(bKey, 0, bKey.length );\n\t\tmasterKey = new byte[md.getDigestSize()];\n\t\tmd.doFinal(masterKey, 0);\n    }\n    \t\n  /*\n  //\n  // Erase all members and buffers, then null pointers.\n  // Ensures no memory (that we control) contains leftover keys.\n  //\n  void secureErase() {\n    // TODO finish this!\n  }\n\n    */\n\n    public Vector<PwGroup> getGrpRoots() {\n\tint target = 0;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\tfor( int i=0; i < groups.size(); i++ ) {\n\t    PwGroup grp = groups.elementAt( i );\n\t    if( grp.level == target )\n\t\tkids.addElement( grp );\n\t}\n\treturn kids;\n    }\n    \n    public int getRootGroupId() {\n    \tfor ( int i = 0; i < groups.size(); i++ ) {\n    \t\tPwGroup grp = groups.elementAt(i);\n    \t\tif ( grp.level == 0 ) {\n    \t\t\treturn grp.groupId;\n    \t\t}\n    \t}\n    \t\n    \treturn -1;\n    }\n\n    public Vector<PwGroup> getGrpChildren( PwGroup parent ) {\n\tint idx = groups.indexOf( parent );\n\tint target = parent.level + 1;\n\tVector<PwGroup> kids = new Vector<PwGroup>();\n\twhile( ++idx < groups.size() ) {\n\t    PwGroup grp = groups.elementAt( idx );\n\t    if( grp.level < target )\n\t\tbreak;\n\t    else\n\t\tif( grp.level == target )\n\t\t    kids.addElement( grp );\n\t}\n\treturn kids;\n    }\n\n    public Vector<PwEntry> getEntries( PwGroup parent ) {\n\tVector<PwEntry> kids = new Vector<PwEntry>();\n\t/*for( Iterator i = entries.iterator(); i.hasNext(); ) {\n\t    PwEntry ent = (PwEntry)i.next();\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.add( ent );\n\t\t}*/\n\tfor (int i=0; i<entries.size(); i++) {\n\t    PwEntry ent = entries.elementAt(i);\n\t    if( ent.groupId == parent.groupId )\n\t\tkids.addElement( ent );\n\t}\n\treturn kids;\n    }\n\n  public String toString() {\n    return name;\n  }\n\n\n\n    public void addGroup(PwGroup group)\n    {\n\tgroups.addElement(group);\n    }\n    \n    public void addEntry(PwEntry entry)\n    {\n\tentries.addElement(entry);\n    }\n    \n    public void constructTree(PwGroup currentGroup)\n    {\n\t// I'm in root\n\tif (currentGroup == null) {\n\t    rootGroup = new PwGroup();\n\t\t\n\t    Vector<PwGroup> rootChildGroups = getGrpRoots();\n\t    rootGroup.childGroups = rootChildGroups;\n\t    rootGroup.childEntries = new Vector<PwEntry>();\n\t    for (int i=0; i<rootChildGroups.size(); i++) {\n\t\trootChildGroups.elementAt(i).parent = rootGroup;\n\t\tconstructTree(rootChildGroups.elementAt(i));\n\t    }\n\t    return;\n\t}\n\n\t// I'm in non-root\n\t// get child groups\n\tcurrentGroup.childGroups = getGrpChildren(currentGroup);\n\tcurrentGroup.childEntries = getEntries(currentGroup);\n\n\t// set parent in child entries\n\tfor (int i=0; i<currentGroup.childEntries.size(); i++) {\n\t    currentGroup.childEntries.elementAt(i).parent = currentGroup;\n\t}\n\t// recursively construct child groups\n\tfor (int i=0; i<currentGroup.childGroups.size(); i++) {\n\t    currentGroup.childGroups.elementAt(i).parent = currentGroup;\n\t    constructTree(currentGroup.childGroups.elementAt(i));\n\t}\n\treturn;\n    }\n}\n","lineNo":199}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\n\nimport android.app.Activity;\nimport android.app.ProgressDialog;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.text.method.ScrollingMovementMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class EntryEditActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\n\tprivate PwEntry mEntry;\n\tprivate boolean mShowPassword = false;\n\tprivate ProgressDialog mPd;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_edit);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tIntent i = getIntent();\n\t\tUUID uuid = UUID.nameUUIDFromBytes(i.getByteArrayExtra(KEY_ENTRY));\n\t\tassert(uuid != null);\n\n\t\tmEntry = Database.gEntries.get(uuid).get();\n\t\n\t\tView scrollView = findViewById(R.id.entry_scroll);\n\t\tscrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\t\t\n\t\t\n\t\tfillData();\n\t\t\n\t\tButton save = (Button) findViewById(R.id.entry_save);\n\t\tsave.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity act = EntryEditActivity.this;\n\t\t\t\t\n\t\t\t\t// Validate password\n\t\t\t\tString pass = Util.getEditText(act, R.id.entry_password);\n\t\t\t\tString conf = Util.getEditText(act, R.id.entry_confpassword);\n\t\t\t\tif ( ! pass.equals(conf) ) {\n\t\t\t\t\tToast.makeText(act, \"Passwords do not match.\", Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPwEntry newEntry = new PwEntry();\n\t\t\t\t\n\t\t\t\tnewEntry.binaryDesc = mEntry.binaryDesc;\n\t\t\t\tnewEntry.groupId = mEntry.groupId;\n\t\t\t\tnewEntry.imageId = mEntry.imageId;\n\t\t\t\tnewEntry.parent = mEntry.parent;\n\t\t\t\tnewEntry.tCreation = mEntry.tCreation;\n\t\t\t\tnewEntry.tExpire = mEntry.tExpire;\n\t\t\t\tnewEntry.uuid = mEntry.uuid;\n\t\t\t\t\n\t\t\t\tDate now = Calendar.getInstance().getTime(); \n\t\t\t\tnewEntry.tLastAccess = now;\n\t\t\t\tnewEntry.tLastMod = now;\n\t\t\t\t\n\t\t\t\tbyte[] binaryData = mEntry.getBinaryData();\n\t\t\t\tnewEntry.setBinaryData(binaryData, 0, binaryData.length);\n\n\t\t\t\tnewEntry.title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tnewEntry.url = Util.getEditText(act, R.id.entry_url);\n\t\t\t\tnewEntry.username = Util.getEditText(act, R.id.entry_user_name);\n\t\t\t\tnewEntry.additional = Util.getEditText(act, R.id.entry_comment);\n\t\t\t\tbyte[] password = pass.getBytes();\n\t\t\t\tnewEntry.setPassword(password, 0, password.length);\n\n\t\t\t\tif ( newEntry.title.equals(mEntry.title) ) {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH_TITLE);\n\t\t\t\t}\n\n\t\t\t\tmPd = ProgressDialog.show(EntryEditActivity.this, \"Working...\", \"Saving database\", true, false);\n\t\t\t\tThread bkgStore = new Thread(new BackgroundUpdateEntry(mEntry, newEntry));\n\t\t\t\tbkgStore.start();\n\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tButton cancel = (Button) findViewById(R.id.entry_cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinish();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\t\tTextView confpassword = (TextView) findViewById(R.id.entry_confpassword);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t\tconfpassword.setTransformationMethod(null);\n\n\t\t} else {\n\t\t\tPasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();\n\t\t\tpassword.setTransformationMethod(ptm);\n\t\t\tconfpassword.setTransformationMethod(ptm);\n\t\t}\n\t}\n\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\t\n\t\tString password = new String(mEntry.getPassword());\n\t\tpopulateText(R.id.entry_password, password);\n\t\tpopulateText(R.id.entry_confpassword, password);\n\t\tsetPasswordStyle();\n\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t\tTextView comment = (TextView)findViewById(R.id.entry_comment);\n\t\tcomment.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\t\tcomment.setMovementMethod(new ScrollingMovementMethod());\n\t\t\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\t\n\tprivate final Handler uiHandler = new Handler();\n\t\n\tpublic final class AfterSave implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmPd.dismiss();\n\t\t\tfinish();\n\t\t}\n\t\t\n\t}\n\t\n\tpublic final class BackgroundUpdateEntry implements Runnable {\n\n\t\tprivate final PwEntry mOld;\n\t\tprivate final PwEntry mNew;\n\t\t\n\t\tpublic BackgroundUpdateEntry(PwEntry oldE, PwEntry newE) {\n\t\t\tmOld = oldE;\n\t\t\tmNew = newE;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tDatabase.UpdateEntry(mOld, mNew);\n\t\t\t\tuiHandler.post(new AfterSave());\n\t\t\t} catch (Exception e) {\n\t\t\t\tuiHandler.post(new UIToastTask(EntryEditActivity.this, \"Failed to store database.\"));\n\t\t\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.UUID;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.app.ProgressDialog;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.text.method.PasswordTransformationMethod;\nimport android.text.method.ScrollingMovementMethod;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\npublic class EntryEditActivity extends LockingActivity {\n\tpublic static final String KEY_ENTRY = \"entry\";\n\tpublic static final String KEY_PARENT = \"parent\";\n\n\tprivate static final int MENU_PASS = Menu.FIRST;\n\n\tprivate PwEntry mEntry;\n\tprivate boolean mShowPassword = false;\n\tprivate boolean mIsNew;\n\tprivate ProgressDialog mPd;\n\t\n\tpublic static void Launch(Activity act, PwEntry pw) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_ENTRY, pw.uuid);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\tpublic static void Launch(Activity act, PwGroup parent) {\n\t\tIntent i = new Intent(act, EntryEditActivity.class);\n\t\t\n\t\ti.putExtra(KEY_PARENT, parent.groupId);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t}\n\t\n\t\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.entry_edit);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tIntent i = getIntent();\n\t\tbyte[] uuidBytes = i.getByteArrayExtra(KEY_ENTRY);\n\n\t\tif ( uuidBytes == null ) {\n\t\t\tint groupId = i.getIntExtra(KEY_PARENT, -1);\n\n\t\t\tmEntry = new PwEntry(groupId);\n\t\t\tmIsNew = true;\n\t\t\t\n\t\t} else {\n\t\t\tUUID uuid = UUID.nameUUIDFromBytes(uuidBytes);\n\t\t\tassert(uuid != null);\n\n\t\t\tmEntry = Database.gEntries.get(uuid).get();\n\t\t\tmIsNew = false;\n\t\t\t\n\t\t\tfillData();\n\t\t} \n\t\n\t\tView scrollView = findViewById(R.id.entry_scroll);\n\t\tscrollView.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\n\t\t// Save button\n\t\tButton save = (Button) findViewById(R.id.entry_save);\n\t\tsave.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tEntryEditActivity act = EntryEditActivity.this;\n\t\t\t\t\n\t\t\t\t// Require title\n\t\t\t\tString title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tif ( title.length() == 0 ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_title_required, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Validate password\n\t\t\t\tString pass = Util.getEditText(act, R.id.entry_password);\n\t\t\t\tString conf = Util.getEditText(act, R.id.entry_confpassword);\n\t\t\t\tif ( ! pass.equals(conf) ) {\n\t\t\t\t\tToast.makeText(act, R.string.error_pass_match, Toast.LENGTH_LONG).show();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPwEntry newEntry = new PwEntry();\n\t\t\t\t\n\t\t\t\tnewEntry.binaryDesc = mEntry.binaryDesc;\n\t\t\t\tnewEntry.groupId = mEntry.groupId;\n\t\t\t\tnewEntry.imageId = mEntry.imageId;\n\t\t\t\tnewEntry.parent = mEntry.parent;\n\t\t\t\tnewEntry.tCreation = mEntry.tCreation;\n\t\t\t\tnewEntry.tExpire = mEntry.tExpire;\n\t\t\t\tnewEntry.uuid = mEntry.uuid;\n\t\t\t\t\n\t\t\t\tDate now = Calendar.getInstance().getTime(); \n\t\t\t\tnewEntry.tLastAccess = now;\n\t\t\t\tnewEntry.tLastMod = now;\n\t\t\t\t\n\t\t\t\tbyte[] binaryData = mEntry.getBinaryData();\n\t\t\t\tif ( binaryData != null ) {\n\t\t\t\t\tnewEntry.setBinaryData(binaryData, 0, binaryData.length);\n\t\t\t\t}\n\n\t\t\t\tnewEntry.title = Util.getEditText(act, R.id.entry_title);\n\t\t\t\tnewEntry.url = Util.getEditText(act, R.id.entry_url);\n\t\t\t\tnewEntry.username = Util.getEditText(act, R.id.entry_user_name);\n\t\t\t\tnewEntry.additional = Util.getEditText(act, R.id.entry_comment);\n\t\t\t\tbyte[] password = pass.getBytes();\n\t\t\t\tnewEntry.setPassword(password, 0, password.length);\n\n\t\t\t\tif ( newEntry.title.equals(mEntry.title) ) {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH);\n\t\t\t\t} else {\n\t\t\t\t\tsetResult(KeePass.EXIT_REFRESH_TITLE);\n\t\t\t\t}\n\n\t\t\t\tmPd = ProgressDialog.show(EntryEditActivity.this, \"Working...\", \"Saving database\", true, false);\n\t\t\t\tThread bkgStore = new Thread(new BackgroundUpdateEntry(mEntry, newEntry));\n\t\t\t\tbkgStore.start();\n\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\t// Cancel button\n\t\tButton cancel = (Button) findViewById(R.id.entry_cancel);\n\t\tcancel.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tfinish();\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_PASS, 0, R.string.menu_show_password);\n\t\tmenu.findItem(MENU_PASS).setIcon(android.R.drawable.ic_menu_view);\n\t\t\n\t\treturn true;\n\t}\n\t\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_PASS:\n\t\t\tif ( mShowPassword ) {\n\t\t\t\titem.setTitle(R.string.menu_hide_password);\n\t\t\t\tmShowPassword = false;\n\t\t\t} else {\n\t\t\t\titem.setTitle(R.string.menu_show_password);\n\t\t\t\tmShowPassword = true;\n\t\t\t}\n\t\t\tsetPasswordStyle();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\t\n\tprivate void setPasswordStyle() {\n\t\tTextView password = (TextView) findViewById(R.id.entry_password);\n\t\tTextView confpassword = (TextView) findViewById(R.id.entry_confpassword);\n\n\t\tif ( mShowPassword ) {\n\t\t\tpassword.setTransformationMethod(null);\n\t\t\tconfpassword.setTransformationMethod(null);\n\n\t\t} else {\n\t\t\tPasswordTransformationMethod ptm = PasswordTransformationMethod.getInstance();\n\t\t\tpassword.setTransformationMethod(ptm);\n\t\t\tconfpassword.setTransformationMethod(ptm);\n\t\t}\n\t}\n\n\tprivate void fillData() {\n\t\tpopulateText(R.id.entry_title, mEntry.title);\n\t\tpopulateText(R.id.entry_user_name, mEntry.username);\n\t\tpopulateText(R.id.entry_url, mEntry.url);\n\t\t\n\t\tString password = new String(mEntry.getPassword());\n\t\tpopulateText(R.id.entry_password, password);\n\t\tpopulateText(R.id.entry_confpassword, password);\n\t\tsetPasswordStyle();\n\n\t\tpopulateText(R.id.entry_comment, mEntry.additional);\n\t\tTextView comment = (TextView)findViewById(R.id.entry_comment);\n\t\tcomment.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\t\tcomment.setMovementMethod(new ScrollingMovementMethod());\n\t\t\n\t}\n\n\tprivate void populateText(int viewId, String text) {\n\t\tTextView tv = (TextView) findViewById(viewId);\n\t\ttv.setText(text);\n\t}\n\t\n\tprivate final Handler uiHandler = new Handler();\n\t\n\tpublic final class AfterSave implements Runnable {\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tmPd.dismiss();\n\t\t\tfinish();\n\t\t}\n\t\t\n\t}\n\t\n\tpublic final class BackgroundUpdateEntry implements Runnable {\n\n\t\tprivate final PwEntry mOld;\n\t\tprivate final PwEntry mNew;\n\t\t\n\t\tpublic BackgroundUpdateEntry(PwEntry oldE, PwEntry newE) {\n\t\t\tmOld = oldE;\n\t\t\tmNew = newE;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void run() {\n\t\t\ttry {\n\t\t\t\tif ( mIsNew ) {\n\t\t\t\t\tDatabase.NewEntry(mNew);\n\t\t\t\t} else {\n\t\t\t\t\tDatabase.UpdateEntry(mOld, mNew);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tuiHandler.post(new AfterSave());\n\t\t\t} catch (Exception e) {\n\t\t\t\tuiHandler.post(new UIToastTask(EntryEditActivity.this, \"Failed to store database.\"));\n\t\t\t\tmPd.dismiss();\n\t\t\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n","lineNo":78}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass.keepasslib;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PKCS7Padding;\nimport org.bouncycastle.crypto.paddings.PaddedBufferedBlockCipher;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\npublic class PwManagerOutput {\n\tprivate PwManager mPM;\n\tprivate OutputStream mOS;\n\tprivate final boolean mDebug;\n\tpublic static final boolean DEBUG = true;\n\t\n\tpublic PwManagerOutput(PwManager pm, OutputStream os) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmDebug = false;\n\t}\n\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, boolean debug) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmDebug = debug;\n\t}\n\t\n\tpublic void close() throws PwManagerOutputException {\n\t\ttry {\n\t\t\tmOS.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to close stream.\");\n\t\t}\n\t}\n\t\n\tpublic void output() throws PwManagerOutputException, IOException {\n\t\t\n\t\tPwDbHeader header = outputHeader(mOS);\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tassert true;\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\t\n\t\tbyte[] transformedMasterKey = ImporterV3.transformMasterKey(header.masterSeed2, mPM.masterKey, header.numKeyEncRounds); \n\t\ttry {\n\t\t\tdos.write(header.masterSeed);\n\t\t\tdos.write(transformedMasterKey);\n\t\t\tdos.close();\n\t\t\tnos.close();\n\t\t} catch ( IOException e ) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to build final key.\");\n\t\t}\n\t\t\n\t\tbyte[] finalKey = md.digest();\n\t\t// Bouncy Castle implementation\n\t\tPaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESEngine()), new PKCS7Padding());\n\t\tcipher.init(true, new ParametersWithIV(new KeyParameter(finalKey), header.encryptionIV));\n\t\tBufferedBlockCipherOutputStream bbcos = new BufferedBlockCipherOutputStream(mOS, cipher);\n\t\toutputPlanGroupAndEntries(bbcos);\n\n\t\tbbcos.close();\n\t\t/*\n\t\ttry {\n\t\t\tbbcos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to close encryption stream.\");\n\t\t}\n\t\t*/\n\t\t\n\t    /* Why doesn't java native work?\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwManagerOutputException(\"Algorithm not supported.\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(finalKey, \"AES\" ), new IvParameterSpec(header.encryptionIV) );\n\t\t\tCipherOutputStream cos = new CipherOutputStream(mOS, cipher);\n\t\t\toutputPlanGroupAndEntries(cos);\n\t\t\tcos.close();\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid algorithm parameter.\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output final encrypted part.\");\n\t\t}\n\t\t*/\n\t}\n\t\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwManagerOutputException {\n\t\t// Build header\n\t\tPwDbHeader header = new PwDbHeader();\n\t\theader.signature1 = PwDbHeader.PWM_DBSIG_1;\n\t\theader.signature2 = PwDbHeader.PWM_DBSIG_2;\n\t\theader.flags = PwDbHeader.PWM_FLAG_SHA2;\n\t\t\n\t\tif ( mPM.getAlgorithm() == PwDbHeader.ALGO_AES ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_RIJNDAEL;\n\t\t} else if ( mPM.getAlgorithm() == PwDbHeader.ALGO_TWOFISH ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_TWOFISH;\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t} else {\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t}\n\t\t\n\t\theader.version = PwDbHeader.PWM_DBVER_DW;\n\t\theader.numGroups = mPM.groups.size();\n\t\theader.numEntries = mPM.entries.size();\n\t\theader.numKeyEncRounds = mPM.getNumKeyEncRecords();\n\t\t\n\t\t// Reuse random values to test equivalence in debug mode\n\t\tif ( mDebug ) {\n\t\t\tSystem.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, header.encryptionIV.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, header.masterSeed.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed2, 0, header.masterSeed2, 0, header.masterSeed2.length);\n\t\t} else {\n\t\t\tSecureRandom random;\n\t\t\ttry {\n\t\t\t\trandom = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Does not support secure random number generation.\");\n\t\t\t}\n\t\t\trandom.nextBytes(header.encryptionIV);\n\t\t\trandom.nextBytes(header.masterSeed);\n\t\t\trandom.nextBytes(header.masterSeed2);\n\t\t}\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tassert true;\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\t\n\t\tNullOutputStream nos;\n\t\tnos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\ttry {\n\t\t\toutputPlanGroupAndEntries(dos);\n\t\t\tdos.close();\n\t\t\tnos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to generate checksum.\");\n\t\t}\n\n\t\theader.contentsHash = md.digest();\n\n\t\t\n\t\t// Output header\n\t\tPwDbHeaderOutput pho = new PwDbHeaderOutput(header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t\tpho.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output the header.\");\n\t\t}\n\n\t\treturn header;\n\t}\n\t\n\tpublic void outputPlanGroupAndEntries(OutputStream os) throws PwManagerOutputException  {\n\t\t//long size = 0;\n\t\t\n\t\t// Groups\n\t\tfor (int i = 0; i < mPM.groups.size(); i++ ) {\n\t\t\tPwGroup pg = mPM.groups.get(i);\n\t\t\tPwGroupOutput pgo = new PwGroupOutput(pg, os);\n\t\t\ttry {\n\t\t\t\tpgo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output a group.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Entries\n\t\tfor (int i = 0; i < mPM.entries.size(); i++ ) {\n\t\t\tPwEntry pe = mPM.entries.get(i);\n\t\t\tPwEntryOutput peo = new PwEntryOutput(pe, os);\n\t\t\ttry {\n\t\t\t\tpeo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output an entry.\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic class PwManagerOutputException extends Exception {\n\n\t\tpublic PwManagerOutputException(String string) {\n\t\t\tsuper(string);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = 3321212743159473368L;\n\t\t\n\t\t\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass.keepasslib;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.security.DigestOutputStream;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\n\nimport javax.crypto.Cipher;\nimport javax.crypto.CipherOutputStream;\nimport javax.crypto.spec.IvParameterSpec;\nimport javax.crypto.spec.SecretKeySpec;\n\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\npublic class PwManagerOutput {\n\tprivate PwManager mPM;\n\tprivate OutputStream mOS;\n\tprivate final boolean mDebug;\n\tpublic static final boolean DEBUG = true;\n\t\n\tpublic PwManagerOutput(PwManager pm, OutputStream os) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmDebug = false;\n\t}\n\n\tpublic PwManagerOutput(PwManager pm, OutputStream os, boolean debug) {\n\t\tmPM = pm;\n\t\tmOS = os;\n\t\tmDebug = debug;\n\t}\n\t\n\t/*\n\tpublic void close() throws PwManagerOutputException {\n\t\ttry {\n\t\t\tmOS.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to close stream.\");\n\t\t}\n\t}\n\t*/\n\n\tpublic byte[] getFinalKey(PwDbHeader header) throws PwManagerOutputException {\n\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tassert true;\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\tNullOutputStream nos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\n\t\tbyte[] transformedMasterKey = ImporterV3.transformMasterKey(header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds); \n\t\ttry {\n\t\t\tdos.write(header.masterSeed);\n\t\t\tdos.write(transformedMasterKey);\n\t\t} catch ( IOException e ) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to build final key.\");\n\t\t}\n\t\t\n\t\treturn md.digest();\n\t\t\n\t}\n\t\n\tpublic byte[] getFinalKey2(PwDbHeader header) {\n\t\treturn ImporterV3.makeFinalKey(header.masterSeed, header.masterSeed2, mPM.masterKey, mPM.numKeyEncRounds);\n\t}\n\t\n\tpublic void output() throws PwManagerOutputException, IOException {\n\t\t\n\t\tPwDbHeader header = outputHeader(mOS);\n\t\t\n\t\tbyte[] finalKey = getFinalKey(header);\n\t\t\n\t\t/*\n\t\t// Bouncy Castle implementation\n\t\tPaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESEngine()), new PKCS7Padding());\n\t\tcipher.init(true, new ParametersWithIV(new KeyParameter(finalKey), header.encryptionIV));\n\n\t\tByteArrayOutputStream bos = new ByteArrayOutputStream();\n\t\toutputPlanGroupAndEntries(bos);\n\t\tbos.close();\n\t\t\n\t\tbyte[] output = bos.toByteArray();\n\t\tbyte[] encrypted = new byte[cipher.getOutputSize(output.length)];\n\t\tint bytes = cipher.processBytes(output, 0, output.length, encrypted, 0);\n\t\ttry {\n\t\t\tbytes += cipher.doFinal(encrypted, bytes);\n\t\t} catch (DataLengthException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (IllegalStateException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (InvalidCipherTextException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\tmOS.write(encrypted, 0, bytes);\n\t\t*/\n\t\t\n\t\t/*\n\t\tBufferedBlockCipherOutputStream bbcos = new BufferedBlockCipherOutputStream(mOS, cipher);\n\t\toutputPlanGroupAndEntries(bbcos);\n\t\tbbcos.close();\n\t\t*/\n\t\t/*\n\t\ttry {\n\t\t\tbbcos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to close encryption stream.\");\n\t\t}\n\t\t*/\n\t\t\n\t\tCipher cipher;\n\t\ttry {\n\t\t\tcipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\");\n\t\t} catch (Exception e) {\n\t\t\tthrow new PwManagerOutputException(\"Algorithm not supported.\");\n\t\t}\n\n\t\ttry {\n\t\t\tcipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec(mPM.finalKey, \"AES\" ), new IvParameterSpec(header.encryptionIV) );\n\t\t\tCipherOutputStream cos = new CipherOutputStream(mOS, cipher);\n\t\t\toutputPlanGroupAndEntries(cos);\n\t\t\tcos.close();\n\t\t} catch (InvalidKeyException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid key\");\n\t\t} catch (InvalidAlgorithmParameterException e) {\n\t\t\tthrow new PwManagerOutputException(\"Invalid algorithm parameter.\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output final encrypted part.\");\n\t\t}\n\t\t//\n\t}\n\t\n\tpublic PwDbHeader outputHeader(OutputStream os) throws PwManagerOutputException {\n\t\t// Build header\n\t\tPwDbHeader header = new PwDbHeader();\n\t\theader.signature1 = PwDbHeader.PWM_DBSIG_1;\n\t\theader.signature2 = PwDbHeader.PWM_DBSIG_2;\n\t\theader.flags = PwDbHeader.PWM_FLAG_SHA2;\n\t\t\n\t\tif ( mPM.getAlgorithm() == PwDbHeader.ALGO_AES ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_RIJNDAEL;\n\t\t} else if ( mPM.getAlgorithm() == PwDbHeader.ALGO_TWOFISH ) {\n\t\t\theader.flags |= PwDbHeader.PWM_FLAG_TWOFISH;\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t} else {\n\t\t\tthrow new PwManagerOutputException(\"Unsupported algorithm.\");\n\t\t}\n\t\t\n\t\theader.version = PwDbHeader.PWM_DBVER_DW;\n\t\theader.numGroups = mPM.groups.size();\n\t\theader.numEntries = mPM.entries.size();\n\t\theader.numKeyEncRounds = mPM.getNumKeyEncRecords();\n\t\t\n\t\t// Reuse random values to test equivalence in debug mode\n\t\tif ( mDebug ) {\n\t\t\tSystem.arraycopy(mPM.dbHeader.encryptionIV, 0, header.encryptionIV, 0, mPM.dbHeader.encryptionIV.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed, 0, header.masterSeed, 0, mPM.dbHeader.masterSeed.length);\n\t\t\tSystem.arraycopy(mPM.dbHeader.masterSeed2, 0, header.masterSeed2, 0, mPM.dbHeader.masterSeed2.length);\n\t\t} else {\n\t\t\tSecureRandom random;\n\t\t\ttry {\n\t\t\t\trandom = SecureRandom.getInstance(\"SHA1PRNG\");\n\t\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Does not support secure random number generation.\");\n\t\t\t}\n\t\t\trandom.nextBytes(header.encryptionIV);\n\t\t\trandom.nextBytes(header.masterSeed);\n\t\t\trandom.nextBytes(header.masterSeed2);\n\t\t}\n\t\t\n\t\t// Write checksum Checksum\n\t\tMessageDigest md = null;\n\t\ttry {\n\t\t\tmd = MessageDigest.getInstance(\"SHA-256\");\n\t\t} catch (NoSuchAlgorithmException e) {\n\t\t\tassert true;\n\t\t\tthrow new PwManagerOutputException(\"SHA-256 not implemented here.\");\n\t\t}\n\t\t\n\t\tNullOutputStream nos;\n\t\tnos = new NullOutputStream();\n\t\tDigestOutputStream dos = new DigestOutputStream(nos, md);\n\t\ttry {\n\t\t\toutputPlanGroupAndEntries(dos);\n\t\t\tdos.close();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to generate checksum.\");\n\t\t}\n\n\t\theader.contentsHash = md.digest();\n\n\t\t\n\t\t// Output header\n\t\tPwDbHeaderOutput pho = new PwDbHeaderOutput(header, os);\n\t\ttry {\n\t\t\tpho.output();\n\t\t} catch (IOException e) {\n\t\t\tthrow new PwManagerOutputException(\"Failed to output the header.\");\n\t\t}\n\n\t\treturn header;\n\t}\n\t\n\tpublic void outputPlanGroupAndEntries(OutputStream os) throws PwManagerOutputException  {\n\t\t//long size = 0;\n\t\t\n\t\t// Groups\n\t\tfor (int i = 0; i < mPM.groups.size(); i++ ) {\n\t\t\tPwGroup pg = mPM.groups.get(i);\n\t\t\tPwGroupOutput pgo = new PwGroupOutput(pg, os);\n\t\t\ttry {\n\t\t\t\tpgo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output a group: \" + e.getMessage());\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Entries\n\t\tfor (int i = 0; i < mPM.entries.size(); i++ ) {\n\t\t\tPwEntry pe = mPM.entries.get(i);\n\t\t\tPwEntryOutput peo = new PwEntryOutput(pe, os);\n\t\t\ttry {\n\t\t\t\tpeo.output();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new PwManagerOutputException(\"Failed to output an entry.\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic class PwManagerOutputException extends Exception {\n\n\t\tpublic PwManagerOutputException(String string) {\n\t\t\tsuper(string);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = 3321212743159473368L;\n\t\t\n\t\t\n\t}\n}\n","lineNo":155}
{"Smelly Sample":"/*\n* Copyright 2009 Brian Pellin.\n*\n* This file is part of KeePassDroid.\n*\n* KeePassDroid is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* KeePassDroid is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with KeePassDroid. If not, see <http://www.gnu.org/licenses/>.\n*\n*/\npackage com.android.keepass.tests;\n \nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport junit.framework.TestCase;\n\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport com.android.keepass.keepasslib.PwDbHeaderOutput;\nimport com.android.keepass.keepasslib.PwManagerOutput;\nimport com.android.keepass.keepasslib.PwManagerOutput.PwManagerOutputException;\n \npublic class PwManagerOutputTest extends TestCase {\n  PwManager mPM;\n  \n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    \n    mPM = TestData.GetTest1();\n    \n  }\n  \n  public void testPlainContent() throws IOException, PwManagerOutputException {\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n \n    PwManagerOutput pos = new PwManagerOutput(mPM, bos, PwManagerOutput.DEBUG);\n    pos.outputPlanGroupAndEntries(bos);\n    \n    assertArrayEquals(\"Group and entry output doesn't match.\", mPM.postHeader, bos.toByteArray());\n \n  }\n \n  public void testChecksum() throws NoSuchAlgorithmException, IOException, PwManagerOutputException {\n    FileOutputStream fos = new FileOutputStream(\"/dev/null\");\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    \n    DigestOutputStream dos = new DigestOutputStream(fos, md);\n  \n    PwManagerOutput pos = new PwManagerOutput(mPM, dos, PwManagerOutput.DEBUG);\n    pos.outputPlanGroupAndEntries(dos);\n    \n    assertArrayEquals(\"Hash of groups and entries failed.\", md.digest(), mPM.dbHeader.contentsHash);\n  }\n  \n  public void testHeader() throws PwManagerOutputException, IOException {\n\tByteArrayOutputStream bActual = new ByteArrayOutputStream();\n    PwManagerOutput pActual = new PwManagerOutput(mPM, bActual, PwManagerOutput.DEBUG);\n    pActual.outputHeader(bActual);\n    \n    ByteArrayOutputStream bExpected = new ByteArrayOutputStream();\n    PwDbHeaderOutput outExpected = new PwDbHeaderOutput(mPM.dbHeader, bExpected);\n    outExpected.output();\n    \n    assertArrayEquals(\"Header does not match.\", bExpected.toByteArray(), bActual.toByteArray()); \n  }\n  \n  public void testFullWrite() throws IOException, PwManagerOutputException  {\n\tFile file = new File(\"/sdcard/test1.kdb\");\n\t\n\tFileInputStream fis = new FileInputStream(file);\n\n\t// Pull file into byte array (for streaming fun)\n\tByteArrayOutputStream bExpected = new ByteArrayOutputStream();\n\twhile (true) {\n\t\tint data = fis.read();\n\t\tif ( data == -1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tbExpected.write(data);\n\t}\n\t\n\tByteArrayOutputStream bActual = new ByteArrayOutputStream();\n\tPwManagerOutput pActual = new PwManagerOutput(mPM, bActual, PwManagerOutput.DEBUG);\n\tpActual.output();\n\tpActual.close();\n\tbActual.close();\n\t\n\tassertArrayEquals(\"Databases do not match.\", bExpected.toByteArray(), bActual.toByteArray());\n  \n  }\n  \n}\n","Method after Refactoring":"/*\n* Copyright 2009 Brian Pellin.\n*\n* This file is part of KeePassDroid.\n*\n* KeePassDroid is free software: you can redistribute it and/or modify\n* it under the terms of the GNU General Public License as published by\n* the Free Software Foundation, either version 3 of the License, or\n* (at your option) any later version.\n*\n* KeePassDroid is distributed in the hope that it will be useful,\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n* GNU General Public License for more details.\n*\n* You should have received a copy of the GNU General Public License\n* along with KeePassDroid. If not, see <http://www.gnu.org/licenses/>.\n*\n*/\npackage com.android.keepass.tests;\n \nimport static org.junit.Assert.assertArrayEquals;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.security.DigestOutputStream;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport junit.framework.TestCase;\n\nimport org.phoneid.keepassj2me.PwDbHeader;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport com.android.keepass.keepasslib.NullOutputStream;\nimport com.android.keepass.keepasslib.PwDbHeaderOutput;\nimport com.android.keepass.keepasslib.PwManagerOutput;\nimport com.android.keepass.keepasslib.PwManagerOutput.PwManagerOutputException;\n \npublic class PwManagerOutputTest extends TestCase {\n  PwManager mPM;\n  \n  @Override\n  protected void setUp() throws Exception {\n    super.setUp();\n    \n    mPM = TestData.GetTest1();\n    \n  }\n  \n  public void testPlainContent() throws IOException, PwManagerOutputException {\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\n \n    PwManagerOutput pos = new PwManagerOutput(mPM, bos, PwManagerOutput.DEBUG);\n    pos.outputPlanGroupAndEntries(bos);\n    \n    assertTrue(\"No output\", bos.toByteArray().length > 0);\n    assertArrayEquals(\"Group and entry output doesn't match.\", mPM.postHeader, bos.toByteArray());\n \n  }\n \n  public void testChecksum() throws NoSuchAlgorithmException, IOException, PwManagerOutputException {\n    //FileOutputStream fos = new FileOutputStream(\"/dev/null\");\n\tNullOutputStream nos = new NullOutputStream();\n    MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n    \n    DigestOutputStream dos = new DigestOutputStream(nos, md);\n  \n    PwManagerOutput pos = new PwManagerOutput(mPM, dos, PwManagerOutput.DEBUG);\n    pos.outputPlanGroupAndEntries(dos);\n    dos.close();\n    \n    byte[] digest = md.digest();\n    assertTrue(\"No output\", digest.length > 0);\n    assertArrayEquals(\"Hash of groups and entries failed.\", mPM.dbHeader.contentsHash, digest);\n  }\n \n  private void assertHeadersEquals(PwDbHeader expected, PwDbHeader actual) {\n\t  assertEquals(\"Flags unequal\", expected.flags, actual.flags);\n\t  assertEquals(\"Entries unequal\", expected.numEntries, actual.numEntries);\n\t  assertEquals(\"Groups unequal\", expected.numGroups, actual.numGroups);\n\t  assertEquals(\"Key Rounds unequal\", expected.numKeyEncRounds, actual.numKeyEncRounds);\n\t  assertEquals(\"Signature1 unequal\", expected.signature1, actual.signature1);\n\t  assertEquals(\"Signature2 unequal\", expected.signature2, actual.signature2);\n\t  assertEquals(\"Version unequal\", expected.version, actual.version);\n\t  assertArrayEquals(\"Hash unequal\", expected.contentsHash, actual.contentsHash);\n\t  assertArrayEquals(\"IV unequal\", expected.encryptionIV, actual.encryptionIV);\n\t  assertArrayEquals(\"Seed unequal\", expected.masterSeed, actual.masterSeed);\n\t  assertArrayEquals(\"Seed2 unequal\", expected.masterSeed2, actual.masterSeed2);\n  }\n  \n  public void testHeader() throws PwManagerOutputException, IOException {\n\tByteArrayOutputStream bActual = new ByteArrayOutputStream();\n    PwManagerOutput pActual = new PwManagerOutput(mPM, bActual, PwManagerOutput.DEBUG);\n    PwDbHeader header = pActual.outputHeader(bActual);\n    \n    ByteArrayOutputStream bExpected = new ByteArrayOutputStream();\n    PwDbHeaderOutput outExpected = new PwDbHeaderOutput(mPM.dbHeader, bExpected);\n    outExpected.output();\n    \n    assertHeadersEquals(mPM.dbHeader, header);    \n    assertTrue(\"No output\", bActual.toByteArray().length > 0);\n    assertArrayEquals(\"Header does not match.\", bExpected.toByteArray(), bActual.toByteArray()); \n  }\n  \n  public void testFinalKey() throws PwManagerOutputException {\n\tByteArrayOutputStream bActual = new ByteArrayOutputStream();\n    PwManagerOutput pActual = new PwManagerOutput(mPM, bActual, PwManagerOutput.DEBUG);\n    PwDbHeader hActual = pActual.outputHeader(bActual);\n    byte[] finalKey = pActual.getFinalKey2(hActual);\n    \n    assertArrayEquals(\"Keys mismatched\", mPM.finalKey, finalKey);\n\t  \n  }\n  \n  public void testFullWrite() throws IOException, PwManagerOutputException  {\n\tFile file = new File(\"/sdcard/test1.kdb\");\n\t\n\tFileInputStream fis = new FileInputStream(file);\n\n\t// Pull file into byte array (for streaming fun)\n\tByteArrayOutputStream bExpected = new ByteArrayOutputStream();\n\twhile (true) {\n\t\tint data = fis.read();\n\t\tif ( data == -1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tbExpected.write(data);\n\t}\n\t\n\tByteArrayOutputStream bActual = new ByteArrayOutputStream();\n\tPwManagerOutput pActual = new PwManagerOutput(mPM, bActual, PwManagerOutput.DEBUG);\n\tpActual.output();\n\t//pActual.close();\n\n\tFileOutputStream fos = new FileOutputStream(\"/sdcard/test1_out.kdb\");\n\tfos.write(bActual.toByteArray());\n\tfos.close();\n\tassertArrayEquals(\"Databases do not match.\", bExpected.toByteArray(), bActual.toByteArray());\n  \n  }\n  \n}\n","lineNo":76}
{"Smelly Sample":"/*\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage org.phoneid.keepassj2me;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport org.bouncycastle1.crypto.BufferedBlockCipher;\nimport org.bouncycastle1.crypto.InvalidCipherTextException;\nimport org.bouncycastle1.crypto.digests.SHA256Digest;\nimport org.bouncycastle1.crypto.engines.AESEngine;\nimport org.bouncycastle1.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle1.crypto.paddings.PKCS7Padding;\nimport org.bouncycastle1.crypto.params.KeyParameter;\nimport org.bouncycastle1.crypto.params.ParametersWithIV;\nimport org.phoneid.PhoneIDUtil;\n\nimport android.util.Log;\n\nimport com.android.keepass.keepasslib.InvalidKeyFileException;\n\n/**\n * Load a v3 database file.\n *\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n */\npublic class ImporterV3 {\n  \n\tpublic static final boolean DEBUG = true;\n\t\n\tprivate final boolean mDebug;\n\t\n    public ImporterV3() {\n      mDebug = false;\n    }\n    \n    public ImporterV3(boolean debug) {\n    \tmDebug = debug;\n    }\n\n \n  /**\n   * Load a v3 database file, return contents in a new PwManager.\n   * \n   * @param infile  Existing file to load.\n   * @param password Pass phrase for infile.\n   * @param pRepair (unused)\n   * @return new PwManager container.\n   * \n   * @throws IOException on any file error.\n   * @throws InvalidKeyFileException \n   * @throws InvalidKeyException on a decryption error, or possible internal bug.\n   * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.\n   * @throws BadPaddingException on a decryption error, or possible internal bug.\n   * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.\n   * @throws NoSuchPaddingException on a decryption error, or possible internal bug.\n   * @throws InvalidAlgorithmParameterException if error decrypting main file body. \n   * @throws ShortBufferException if error decrypting main file body.\n   */\n  public PwManager openDatabase( InputStream inStream, String password, String keyfile )\n      throws IOException, InvalidCipherTextException, InvalidKeyFileException\n    {\n    PwManager        newManager;\n    SHA256Digest    md;\n    /** Master key encrypted several times */\n    byte[]           transformedMasterKey;\n    byte[]           finalKey;\n\n\n    // Load entire file, most of it's encrypted.\n    // InputStream in = new FileInputStream( infile );\n    byte[] filebuf = new byte[(int)inStream.available()];\n    inStream.read( filebuf, 0, (int)inStream.available());\n    inStream.close();\n\n    // Parse header (unencrypted)\n    if( filebuf.length < PwDbHeader.BUF_SIZE )\n      throw new IOException( \"File too short for header\" );\n    PwDbHeader hdr = new PwDbHeader( filebuf, 0 );\n\n    if( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeader.PWM_DBSIG_2) ) {\n\t//KeePassMIDlet.logS ( \"Bad database file signature\" );\n\tthrow new IOException( \"Bad database file signature\" );\n    }\n\n    if( hdr.version != PwDbHeader.PWM_DBVER_DW ) {\n\t//KeePassMIDlet.logS ( \"Bad database file version\");\n\t//throw new IOException( \"Bad database file version\" );\n    }\n\n    newManager = new PwManager();\n    newManager.setMasterKey( password, keyfile );\n    \n    // Select algorithm\n    if( (hdr.flags & PwDbHeader.PWM_FLAG_RIJNDAEL) != 0 ) {\n\t//KeePassMIDlet.logS ( \"Algorithm AES\");\n\tnewManager.algorithm = PwDbHeader.ALGO_AES;\n    } else if( (hdr.flags & PwDbHeader.PWM_FLAG_TWOFISH) != 0 ) {\n\t//KeePassMIDlet.logS ( \"Algorithm TWOFISH\");\n\tnewManager.algorithm = PwDbHeader.ALGO_TWOFISH;\n    } else {\n\tthrow new IOException( \"Unknown algorithm.\" );\n    }\n\n    if( newManager.algorithm == PwDbHeader.ALGO_TWOFISH )\n\tthrow new IOException( \"TwoFish algorithm is not supported\" );\n\n    if ( mDebug ) {\n    \tnewManager.dbHeader = hdr;\n    }\n    \n    newManager.numKeyEncRounds = hdr.numKeyEncRounds;\n    \n    // testRijndael_JCE();\n\n    newManager.name = \"KeePass Password Manager\";\n\n    // Generate transformedMasterKey from masterKey\n    //KeePassMIDlet.logS (\"masterSeed2: \" + new String(Hex.encode(hdr.masterSeed2)));\n    \n    transformedMasterKey = transformMasterKey( hdr.masterSeed2,\n                                               newManager.masterKey,\n                                               newManager.numKeyEncRounds );\n    \n    // Hash the master password with the salt in the file\n    md = new SHA256Digest();\n    md.update( hdr.masterSeed, 0, hdr.masterSeed.length );\n    md.update( transformedMasterKey, 0, transformedMasterKey.length );\n    finalKey = new byte[md.getDigestSize()];\n    md.doFinal ( finalKey, 0);\n\n    // NI\n    //KeePassMIDlet.logS (\"finalKey: \" + new String(Hex.encode(finalKey)));\n    \n    // Initialize Rijndael algorithm\n\n    // Cipher cipher = Cipher.getInstance( \"AES/CBC/PKCS5Padding\" );\n    //PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESEngine()));\n    BufferedBlockCipher cipher = new BufferedBlockCipher(new CBCBlockCipher(new AESEngine()));\n    \n    //cipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( finalKey, \"AES\" ), new IvParameterSpec( hdr.encryptionIV ) );\n\n    cipher.init(false, new ParametersWithIV(new KeyParameter(finalKey), hdr.encryptionIV));\n    // Decrypt! The first bytes aren't encrypted (that's the header)\n    //int encryptedPartSize = cipher.doFinal( filebuf, PwDbHeader.BUF_SIZE, filebuf.length - PwDbHeader.BUF_SIZE, filebuf, PwDbHeader.BUF_SIZE );\n    //int encryptedPartSize\n    int paddedEncryptedPartSize = cipher.processBytes(filebuf, PwDbHeader.BUF_SIZE, filebuf.length - PwDbHeader.BUF_SIZE, filebuf, PwDbHeader.BUF_SIZE );\n\n    int encryptedPartSize = 0;\n    //try {\n    PKCS7Padding padding = new PKCS7Padding();\n    encryptedPartSize = paddedEncryptedPartSize - padding.padCount(filebuf);\n    //} catch (Exception e) {\n    //}\n    // NI\n    /*\n    byte[] plainContent = new byte[encryptedPartSize];\n    System.arraycopy(filebuf, PwDbHeader.BUF_SIZE, plainContent, 0, encryptedPartSize);\n    */\n    \n    if ( mDebug ) {\n\t    newManager.postHeader = new byte[encryptedPartSize];\n\t    System.arraycopy(filebuf, PwDbHeader.BUF_SIZE, newManager.postHeader, 0, encryptedPartSize);\n    }\n    \n    //if( pRepair == null ) {\n    md = new SHA256Digest();\n    md.update( filebuf, PwDbHeader.BUF_SIZE, encryptedPartSize );\n    md.doFinal (finalKey, 0);\n    \n    if( PhoneIDUtil.compare( finalKey, hdr.contentsHash ) == false) {\n\t//KeePassMIDlet.logS ( \"Database file did not decrypt correctly. (checksum code is broken)\" );\n    \t\n    \tLog.w(\"KeePassDroid\",\"Database file did not decrypt correctly. (checksum code is broken)\");\n    // }\n    }\n    \n    // Import all groups\n    \n    int pos = PwDbHeader.BUF_SIZE;\n    PwGroup newGrp = new PwGroup();\n    for( int i = 0; i < hdr.numGroups; ) {\n\t\tint fieldType = Types.readShort( filebuf, pos );\n\t\tpos += 2;\n\t\tint fieldSize = Types.readInt( filebuf, pos );\n\t\tpos += 4;\n\n      if( fieldType == 0xFFFF ) {\n        //KeePassMIDlet.logS ( newGrp.level + \" \" + newGrp.name );\n\n        // End-Group record.  Save group and count it.\n\t    //newManager.groups.add( newGrp );\n\t    newManager.addGroup( newGrp );\n        newGrp = new PwGroup();\n        i++;\n      }\n      else {\n        readGroupField( newGrp, fieldType, filebuf, pos );\n      }\n      pos += fieldSize;\n    }\n    //    fixGroups( groups );\n\n    // Import all entries\n    PwEntry newEnt = new PwEntry();\n    for( int i = 0; i < hdr.numEntries; ) {\n      int fieldType = Types.readShort( filebuf, pos );\n      int fieldSize = Types.readInt( filebuf, pos + 2 );\n\n      if( fieldType == 0xFFFF ) {\n        // End-Group record.  Save group and count it.\n\t  newManager.addEntry( newEnt );\n\t  //KeePassMIDlet.logS( newEnt.title );\n        newEnt = new PwEntry();\n        i++;\n      }\n      else {\n        readEntryField( newEnt, filebuf, pos );\n      }\n      pos += 2 + 4 + fieldSize;\n    }\n    \n    // Keep the Meta-Info entry separate\n    /*\n    for( int i=0; i<newManager.entries.size(); i++) {\n\tPwEntry ent = (PwEntry)newManager.entries.elementAt(i);\n\t\tif( ent.title.equals( \"Meta-Info\" )\n\t\t    && ent.url.equals( \"$\" )\n\t\t    && ent.username.equals( \"SYSTEM\" ) ) {\n\t\t    newManager.metaInfo = ent;\n\t\t    newManager.entries.removeElementAt(i);\n\t\t}\n    }\n    */\n    \n    return newManager;\n }\n\n\n  /**\n   * KeePass's custom pad style.\n   * \n   * @param data buffer to pad.\n   * @return addtional bytes to append to data[] to make\n   *    a properly padded array.\n   */\n  public static byte[] makePad( byte[] data ) {\n    //custom pad method\n    //TODO //WRZ doesn't work (yet)\n\n    // append 0x80 plus zeros to a multiple of 4 bytes\n    int thisblk = 32 - data.length % 32;  // bytes needed to finish blk\n    int nextblk = 0;                      // 32 if we need another block\n    // need 9 bytes; add new block if no room\n    if( thisblk < 9 ) {\n      nextblk = 32;\n    }\n    \n    // all bytes are zeroed for free\n    byte[] pad = new byte[ thisblk + nextblk ];\n    pad[0] = (byte)0x80;\n\n    // write length*8 to end of final block\n    int ix = thisblk + nextblk - 8;\n    Types.writeInt( data.length>>29, pad, ix );\n    bsw32( pad, ix );\n    ix += 4;\n    Types.writeInt( data.length<<3, pad, ix );\n    bsw32( pad, ix );\n    \n    return pad;\n  }\n\n  public static void bsw32( byte[] ary, int offset ) {\n    byte t = ary[offset];\n    ary[offset] = ary[offset+3];\n    ary[offset+3] = t;\n    t = ary[offset+1];\n    ary[offset+1] = ary[offset+2];\n    ary[offset+2] = t;\n  }\n  \n\n  /**\n   * Encrypt the master key a few times to make brute-force key-search harder\n   * @throws NoSuchPaddingException \n   * @throws NoSuchAlgorithmException \n   * @throws ShortBufferException\n   */\n\n  static byte[] transformMasterKey( byte[] pKeySeed, byte[] pKey, int rounds )\n      /*throws InvalidKeyException,\n\t     IllegalBlockSizeException,\n\t     BadPaddingException,\n\t     NoSuchAlgorithmException,\n\t     NoSuchPaddingException, ShortBufferException*/ {\n      //KeePassMIDlet.logS(\"transformMasterKey, rounds=\" + rounds);\n      //KeePassMIDlet.logS(\"transformMasterKey, pkey=\" + new String(Hex.encode(pKey)));\n\t  \n      byte[] newKey = new byte[pKey.length];\n      int i;\n\n      \n      BufferedBlockCipher cipher = new BufferedBlockCipher(new AESEngine());\n      cipher.init(true, new KeyParameter(pKeySeed));\n\n      newKey = pKey;\n      for( i = 0; i < rounds; i++ )\n\t  cipher.processBytes (newKey, 0, newKey.length, newKey, 0);\n\n      // Hash once with SHA-256\n      SHA256Digest md = new SHA256Digest();\n      md.update(newKey, 0, newKey.length );\n      //newKey = md.digest( newKey );\n      md.doFinal(newKey, 0);\n\n      return newKey;\n  }\n\n\n\n\n  /**\n   * Parse and save one record from binary file.\n   * @param buf\n   * @param offset\n   * @return If >0, \n   */\n  void readGroupField( PwGroup grp, int fieldType, byte[] buf, int offset ) {\n    switch( fieldType ) {\n      case 0x0000 :\n        // Ignore field\n        break;\n      case 0x0001 :\n        grp.groupId = Types.readInt( buf, offset );\n        break;\n      case 0x0002 :\n        grp.name = new String( buf, offset, Types.strlen( buf, offset ) );\n        break;\n      case 0x0003 :\n        grp.tCreation = Types.readTime( buf, offset );\n        break;\n      case 0x0004 :\n        grp.tLastMod = Types.readTime( buf, offset );\n        break;\n      case 0x0005 :\n        grp.tLastAccess = Types.readTime( buf, offset );\n        break;\n      case 0x0006 :\n        grp.tExpire = Types.readTime( buf, offset );\n        break;\n      case 0x0007 :\n        grp.imageId = Types.readInt( buf, offset );\n        break;\n      case 0x0008 :\n        grp.level = Types.readShort( buf, offset );\n        break;\n      case 0x0009 :\n        grp.flags = Types.readInt( buf, offset );\n        break;\n    }\n  }\n\n\n\n  void readEntryField( PwEntry ent, byte[] buf, int offset )\n      throws UnsupportedEncodingException\n    {\n    int fieldType = Types.readShort( buf, offset );\n    offset += 2;\n    int fieldSize = Types.readInt( buf, offset );\n    offset += 4;\n\n    switch( fieldType ) {\n      case 0x0000 :\n        // Ignore field\n        break;\n      case 0x0001 :\n        System.arraycopy( buf, offset, ent.uuid, 0, 16 );\n        break;\n      case 0x0002 :\n        ent.groupId = Types.readInt( buf, offset );\n        break;\n      case 0x0003 :\n        ent.imageId = Types.readInt( buf, offset );\n        break;\n      case 0x0004 :\n        ent.title = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0005 :\n        ent.url = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0006 :\n        ent.username = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0007 :\n        ent.setPassword( buf, offset, Types.strlen( buf, offset ) );\n        break;\n      case 0x0008 :\n        ent.additional = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0009 :\n        ent.tCreation = Types.readTime( buf, offset );\n        break;\n      case 0x000A :\n        ent.tLastMod = Types.readTime( buf, offset );\n        break;\n      case 0x000B :\n        ent.tLastAccess = Types.readTime( buf, offset );\n        break;\n      case 0x000C :\n        ent.tExpire = Types.readTime( buf, offset );\n        break;\n      case 0x000D :\n        ent.binaryDesc = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x000E :\n        ent.setBinaryData( buf, offset, fieldSize );\n        break;\n    }\n  }\n  \n  \n  \n  /**\n   * Attach groups to parent groups.\n   * \n   * @param groups\n   * @return root group.\n   *//*\n  private PwGroup fixGroups( List groups ) {\n    int   curLevel = -1;\n    Stack parents = new Stack();\n    PwGroup root;\n    \n    root = new PwGroup();\n    root.level = curLevel;\n    parents.push( root );\n\n    for( Iterator iter = groups.iterator(); iter.hasNext(); ) {\n      PwGroup group = (PwGroup)iter.next();\n\n      while( group.level <= curLevel ){\n        parents.pop();\n        curLevel = ((PwGroup)parents.peek()).level;\n      }\n\n      if( group.level >= curLevel ) {\n        if( !parents.isEmpty() )\n          ((PwGroup)parents.peek()).children.add( group );\n        parents.push( group );\n        curLevel = group.level;\n      }\n    }\n\n    return root;\n  }*/\n\n\n\n  /**\n   * Test the BouncyCastle lib.\n   */\n  /* -- we're not using BouncyCastle\n  static void testRijndael_Bouncy() {\n    byte[] aKey = new byte[32];\n    byte[] aTest = new byte[16];\n    byte[] aRef = new byte[16];\n    // The Rijndael class will be tested, that's the expected ciphertext\n    int[] aRef_int = {\n        0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89\n    };\n    int i;\n\n    // Do a quick test if the Rijndael class worked correctly\n    for( i = 0; i < 32; i++ ) {\n      aKey[i] = (byte)i;\n    }\n    for( i = 0; i < 16; i++ ) {\n      aTest[i] = (byte)((i << 4) | i);\n      aRef[i] = (byte)aRef_int[i];\n    }\n\n    RijndaelEngine rijndael = new RijndaelEngine( 128 );\n    rijndael.init( true, new KeyParameter( aKey ) );\n    rijndael.processBlock( aTest, 0, aTest, 0 );\n\n    if( !Arrays.equals( aTest, aRef ) )\n      throw new RuntimeException( \"RijndaelEngine failed test\" );\n  }\n*/\n\n\n  /**\n   * Test Sun's JCE.\n   * Note you need the \"unlimited security\" policy files from Sun.\n   * They're where you download the JDK, i.e.\n   * <a href=\"http://java.sun.com/j2se/1.5.0/download.jsp\"\n   * >http://java.sun.com/j2se/1.5.0/download.jsp<\/a>\n   * @throws NoSuchPaddingException \n   * @throws NoSuchAlgorithmException \n   */\n  static void testRijndael_JCE() {\n    byte[] aKey = new byte[32];\n    byte[] aTest = new byte[16];\n    byte[] aRef = new byte[16];\n    // The Rijndael class will be tested, that's the expected ciphertext\n    int[] aRef_int = {\n        0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89\n    };\n    int i;\n\n    // Do a quick test if the Rijndael class worked correctly\n    for( i = 0; i < 32; i++ ) {\n      aKey[i] = (byte)i;\n    }\n    for( i = 0; i < 16; i++ ) {\n      aTest[i] = (byte)((i << 4) | i);\n      aRef[i] = (byte)aRef_int[i];\n    }\n\n    try {\n\t// Cipher cipher = Cipher.getInstance( \"AES/ECB/NoPadding\" );\n\tBufferedBlockCipher cipher = new BufferedBlockCipher(new AESEngine());\n\t//cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec( aKey, \"AES\" ) );\n\tcipher.init(true, new KeyParameter(aKey));\n\t//aTest = cipher.doFinal( aTest );\n\tcipher.processBytes(aTest, 0, aTest.length, aTest, 0);\n    }\n    catch (Exception ex) {\n\tex.printStackTrace();\n\tthrow new RuntimeException( \"JCE failed test\" );\n    }\n\n    if( PhoneIDUtil.compare (aTest, aRef) == false)\n\tthrow new RuntimeException( \"JCE failed test\" );\n  }\n}\n    \n\n\n/*\nNIST.gov states the following:\n\nSuppose that the length of the message, M, is l bits. Append the bit \u201c1\u201d to the end of the\nmessage, followed by k zero bits, where k is the smallest, non-negative solution to the equation\nl +1+ k  448mod 512 . Then append the 64-bit block that is equal to the number l expressed\nusing a binary representation. For example, the (8-bit ASCII) message \u201cabc\u201d has length\n83 = 24, so the message is padded with a one bit, then 448 - (24 +1) = 423 zero bits, and then\nthe message length, to become the 512-bit padded message\n\n                              423     64\n01100001 01100010 01100011 1 00\u202600 00\u2026011000\n  \u201ca\u201d      \u201cb\u201d      \u201cc\u201d               l = 24\n\nThe length of the padded message should now be a multiple of 512 bits.\n*/\n","Method after Refactoring":"/*\nKeePass for J2ME\n\nCopyright 2007 Naomaru Itoi <nao@phoneid.org>\n\nThis file was derived from \n\nJava clone of KeePass - A KeePass file viewer for Java\nCopyright 2006 Bill Zwicky <billzwicky@users.sourceforge.net>\n\nThis program is free software; you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation; version 2\n\nThis program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this program; if not, write to the Free Software\nFoundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\npackage org.phoneid.keepassj2me;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.UnsupportedEncodingException;\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.InvalidKeyException;\nimport java.security.NoSuchAlgorithmException;\n\nimport javax.crypto.BadPaddingException;\nimport javax.crypto.IllegalBlockSizeException;\nimport javax.crypto.NoSuchPaddingException;\nimport javax.crypto.ShortBufferException;\n\nimport org.bouncycastle.crypto.BufferedBlockCipher;\nimport org.bouncycastle.crypto.InvalidCipherTextException;\nimport org.bouncycastle.crypto.digests.SHA256Digest;\nimport org.bouncycastle.crypto.engines.AESEngine;\nimport org.bouncycastle.crypto.modes.CBCBlockCipher;\nimport org.bouncycastle.crypto.paddings.PKCS7Padding;\nimport org.bouncycastle.crypto.params.KeyParameter;\nimport org.bouncycastle.crypto.params.ParametersWithIV;\nimport org.phoneid.PhoneIDUtil;\n\nimport android.util.Log;\n\nimport com.android.keepass.keepasslib.InvalidKeyFileException;\n\n/**\n * Load a v3 database file.\n *\n * @author Naomaru Itoi <nao@phoneid.org>\n * @author Bill Zwicky <wrzwicky@pobox.com>\n */\npublic class ImporterV3 {\n  \n\tpublic static final boolean DEBUG = true;\n\t\n\tprivate final boolean mDebug;\n\t\n    public ImporterV3() {\n      mDebug = false;\n    }\n    \n    public ImporterV3(boolean debug) {\n    \tmDebug = debug;\n    }\n\n \n  /**\n   * Load a v3 database file, return contents in a new PwManager.\n   * \n   * @param infile  Existing file to load.\n   * @param password Pass phrase for infile.\n   * @param pRepair (unused)\n   * @return new PwManager container.\n   * \n   * @throws IOException on any file error.\n   * @throws InvalidKeyFileException \n   * @throws InvalidKeyException on a decryption error, or possible internal bug.\n   * @throws IllegalBlockSizeException on a decryption error, or possible internal bug.\n   * @throws BadPaddingException on a decryption error, or possible internal bug.\n   * @throws NoSuchAlgorithmException on a decryption error, or possible internal bug.\n   * @throws NoSuchPaddingException on a decryption error, or possible internal bug.\n   * @throws InvalidAlgorithmParameterException if error decrypting main file body. \n   * @throws ShortBufferException if error decrypting main file body.\n   */\n  public PwManager openDatabase( InputStream inStream, String password, String keyfile )\n      throws IOException, InvalidCipherTextException, InvalidKeyFileException\n    {\n    PwManager        newManager;\n    SHA256Digest    md;\n    /** Master key encrypted several times */\n    byte[]           transformedMasterKey;\n    byte[]           finalKey;\n\n\n    // Load entire file, most of it's encrypted.\n    // InputStream in = new FileInputStream( infile );\n    byte[] filebuf = new byte[(int)inStream.available()];\n    inStream.read( filebuf, 0, (int)inStream.available());\n    inStream.close();\n\n    // Parse header (unencrypted)\n    if( filebuf.length < PwDbHeader.BUF_SIZE )\n      throw new IOException( \"File too short for header\" );\n    PwDbHeader hdr = new PwDbHeader( filebuf, 0 );\n\n    if( (hdr.signature1 != PwDbHeader.PWM_DBSIG_1) || (hdr.signature2 != PwDbHeader.PWM_DBSIG_2) ) {\n\t//KeePassMIDlet.logS ( \"Bad database file signature\" );\n\tthrow new IOException( \"Bad database file signature\" );\n    }\n\n    if( hdr.version != PwDbHeader.PWM_DBVER_DW ) {\n\t//KeePassMIDlet.logS ( \"Bad database file version\");\n\t//throw new IOException( \"Bad database file version\" );\n    }\n\n    newManager = new PwManager();\n    newManager.setMasterKey( password, keyfile );\n    \n    // Select algorithm\n    if( (hdr.flags & PwDbHeader.PWM_FLAG_RIJNDAEL) != 0 ) {\n\t//KeePassMIDlet.logS ( \"Algorithm AES\");\n\tnewManager.algorithm = PwDbHeader.ALGO_AES;\n    } else if( (hdr.flags & PwDbHeader.PWM_FLAG_TWOFISH) != 0 ) {\n\t//KeePassMIDlet.logS ( \"Algorithm TWOFISH\");\n\tnewManager.algorithm = PwDbHeader.ALGO_TWOFISH;\n    } else {\n\tthrow new IOException( \"Unknown algorithm.\" );\n    }\n\n    if( newManager.algorithm == PwDbHeader.ALGO_TWOFISH )\n\tthrow new IOException( \"TwoFish algorithm is not supported\" );\n\n    if ( mDebug ) {\n    \tnewManager.dbHeader = hdr;\n    }\n    \n    newManager.numKeyEncRounds = hdr.numKeyEncRounds;\n    \n    // testRijndael_JCE();\n\n    newManager.name = \"KeePass Password Manager\";\n\n    // Generate transformedMasterKey from masterKey\n    //KeePassMIDlet.logS (\"masterSeed2: \" + new String(Hex.encode(hdr.masterSeed2)));\n    \n    transformedMasterKey = transformMasterKey( hdr.masterSeed2,\n                                               newManager.masterKey,\n                                               newManager.numKeyEncRounds );\n    \n    // Hash the master password with the salt in the file\n    md = new SHA256Digest();\n    md.update( hdr.masterSeed, 0, hdr.masterSeed.length );\n    md.update( transformedMasterKey, 0, transformedMasterKey.length );\n    finalKey = new byte[md.getDigestSize()];\n    md.doFinal ( finalKey, 0);\n\n    // NI\n    //KeePassMIDlet.logS (\"finalKey: \" + new String(Hex.encode(finalKey)));\n    \n    // Initialize Rijndael algorithm\n\n    // Cipher cipher = Cipher.getInstance( \"AES/CBC/PKCS5Padding\" );\n    //PaddedBufferedBlockCipher cipher = new PaddedBufferedBlockCipher(new CBCBlockCipher(new AESEngine()));\n    BufferedBlockCipher cipher = new BufferedBlockCipher(new CBCBlockCipher(new AESEngine()));\n    \n    //cipher.init( Cipher.DECRYPT_MODE, new SecretKeySpec( finalKey, \"AES\" ), new IvParameterSpec( hdr.encryptionIV ) );\n\n    cipher.init(false, new ParametersWithIV(new KeyParameter(finalKey), hdr.encryptionIV));\n    // Decrypt! The first bytes aren't encrypted (that's the header)\n    //int encryptedPartSize = cipher.doFinal( filebuf, PwDbHeader.BUF_SIZE, filebuf.length - PwDbHeader.BUF_SIZE, filebuf, PwDbHeader.BUF_SIZE );\n    //int encryptedPartSize\n    int paddedEncryptedPartSize = cipher.processBytes(filebuf, PwDbHeader.BUF_SIZE, filebuf.length - PwDbHeader.BUF_SIZE, filebuf, PwDbHeader.BUF_SIZE );\n\n    int encryptedPartSize = 0;\n    //try {\n    PKCS7Padding padding = new PKCS7Padding();\n    int paddingSize = padding.padCount(filebuf);\n    encryptedPartSize = paddedEncryptedPartSize - paddingSize;\n    if ( mDebug ) {\n    \tnewManager.paddingBytes = paddingSize;\n    }\n    \n    //} catch (Exception e) {\n    //}\n    // NI\n    /*\n    byte[] plainContent = new byte[encryptedPartSize];\n    System.arraycopy(filebuf, PwDbHeader.BUF_SIZE, plainContent, 0, encryptedPartSize);\n    */\n    \n    if ( mDebug ) {\n\t    newManager.postHeader = new byte[encryptedPartSize];\n\t    System.arraycopy(filebuf, PwDbHeader.BUF_SIZE, newManager.postHeader, 0, encryptedPartSize);\n    }\n    \n    //if( pRepair == null ) {\n    md = new SHA256Digest();\n    md.update( filebuf, PwDbHeader.BUF_SIZE, encryptedPartSize );\n    md.doFinal (finalKey, 0);\n    \n    if( PhoneIDUtil.compare( finalKey, hdr.contentsHash ) == false) {\n\t//KeePassMIDlet.logS ( \"Database file did not decrypt correctly. (checksum code is broken)\" );\n    \t\n    \tLog.w(\"KeePassDroid\",\"Database file did not decrypt correctly. (checksum code is broken)\");\n    // }\n    }\n    \n    // Import all groups\n    \n    int pos = PwDbHeader.BUF_SIZE;\n    PwGroup newGrp = new PwGroup();\n    for( int i = 0; i < hdr.numGroups; ) {\n\t\tint fieldType = Types.readShort( filebuf, pos );\n\t\tpos += 2;\n\t\tint fieldSize = Types.readInt( filebuf, pos );\n\t\tpos += 4;\n\n      if( fieldType == 0xFFFF ) {\n        //KeePassMIDlet.logS ( newGrp.level + \" \" + newGrp.name );\n\n        // End-Group record.  Save group and count it.\n\t    //newManager.groups.add( newGrp );\n\t    newManager.addGroup( newGrp );\n        newGrp = new PwGroup();\n        i++;\n      }\n      else {\n        readGroupField( newGrp, fieldType, filebuf, pos );\n      }\n      pos += fieldSize;\n    }\n    //    fixGroups( groups );\n\n    // Import all entries\n    PwEntry newEnt = new PwEntry();\n    for( int i = 0; i < hdr.numEntries; ) {\n      int fieldType = Types.readShort( filebuf, pos );\n      int fieldSize = Types.readInt( filebuf, pos + 2 );\n\n      if( fieldType == 0xFFFF ) {\n        // End-Group record.  Save group and count it.\n\t  newManager.addEntry( newEnt );\n\t  //KeePassMIDlet.logS( newEnt.title );\n        newEnt = new PwEntry();\n        i++;\n      }\n      else {\n        readEntryField( newEnt, filebuf, pos );\n      }\n      pos += 2 + 4 + fieldSize;\n    }\n    \n    // Keep the Meta-Info entry separate\n    /*\n    for( int i=0; i<newManager.entries.size(); i++) {\n\tPwEntry ent = (PwEntry)newManager.entries.elementAt(i);\n\t\tif( ent.title.equals( \"Meta-Info\" )\n\t\t    && ent.url.equals( \"$\" )\n\t\t    && ent.username.equals( \"SYSTEM\" ) ) {\n\t\t    newManager.metaInfo = ent;\n\t\t    newManager.entries.removeElementAt(i);\n\t\t}\n    }\n    */\n    \n    return newManager;\n }\n\n\n  /**\n   * KeePass's custom pad style.\n   * \n   * @param data buffer to pad.\n   * @return addtional bytes to append to data[] to make\n   *    a properly padded array.\n   */\n  public static byte[] makePad( byte[] data ) {\n    //custom pad method\n    //TODO //WRZ doesn't work (yet)\n\n    // append 0x80 plus zeros to a multiple of 4 bytes\n    int thisblk = 32 - data.length % 32;  // bytes needed to finish blk\n    int nextblk = 0;                      // 32 if we need another block\n    // need 9 bytes; add new block if no room\n    if( thisblk < 9 ) {\n      nextblk = 32;\n    }\n    \n    // all bytes are zeroed for free\n    byte[] pad = new byte[ thisblk + nextblk ];\n    pad[0] = (byte)0x80;\n\n    // write length*8 to end of final block\n    int ix = thisblk + nextblk - 8;\n    Types.writeInt( data.length>>29, pad, ix );\n    bsw32( pad, ix );\n    ix += 4;\n    Types.writeInt( data.length<<3, pad, ix );\n    bsw32( pad, ix );\n    \n    return pad;\n  }\n\n  public static void bsw32( byte[] ary, int offset ) {\n    byte t = ary[offset];\n    ary[offset] = ary[offset+3];\n    ary[offset+3] = t;\n    t = ary[offset+1];\n    ary[offset+1] = ary[offset+2];\n    ary[offset+2] = t;\n  }\n  \n\n  /**\n   * Encrypt the master key a few times to make brute-force key-search harder\n   * @throws NoSuchPaddingException \n   * @throws NoSuchAlgorithmException \n   * @throws ShortBufferException\n   */\n\n  public static byte[] transformMasterKey( byte[] pKeySeed, byte[] pKey, int rounds )\n      /*throws InvalidKeyException,\n\t     IllegalBlockSizeException,\n\t     BadPaddingException,\n\t     NoSuchAlgorithmException,\n\t     NoSuchPaddingException, ShortBufferException*/ {\n      //KeePassMIDlet.logS(\"transformMasterKey, rounds=\" + rounds);\n      //KeePassMIDlet.logS(\"transformMasterKey, pkey=\" + new String(Hex.encode(pKey)));\n\t  \n      byte[] newKey = new byte[pKey.length];\n      int i;\n\n      \n      BufferedBlockCipher cipher = new BufferedBlockCipher(new AESEngine());\n      cipher.init(true, new KeyParameter(pKeySeed));\n\n      newKey = pKey;\n      for( i = 0; i < rounds; i++ )\n\t  cipher.processBytes (newKey, 0, newKey.length, newKey, 0);\n\n      // Hash once with SHA-256\n      SHA256Digest md = new SHA256Digest();\n      md.update(newKey, 0, newKey.length );\n      //newKey = md.digest( newKey );\n      md.doFinal(newKey, 0);\n\n      return newKey;\n  }\n\n\n\n\n  /**\n   * Parse and save one record from binary file.\n   * @param buf\n   * @param offset\n   * @return If >0, \n   */\n  void readGroupField( PwGroup grp, int fieldType, byte[] buf, int offset ) {\n    switch( fieldType ) {\n      case 0x0000 :\n        // Ignore field\n        break;\n      case 0x0001 :\n        grp.groupId = Types.readInt( buf, offset );\n        break;\n      case 0x0002 :\n        grp.name = new String( buf, offset, Types.strlen( buf, offset ) );\n        break;\n      case 0x0003 :\n        grp.tCreation = Types.readTime( buf, offset );\n        break;\n      case 0x0004 :\n        grp.tLastMod = Types.readTime( buf, offset );\n        break;\n      case 0x0005 :\n        grp.tLastAccess = Types.readTime( buf, offset );\n        break;\n      case 0x0006 :\n        grp.tExpire = Types.readTime( buf, offset );\n        break;\n      case 0x0007 :\n        grp.imageId = Types.readInt( buf, offset );\n        break;\n      case 0x0008 :\n        grp.level = Types.readShort( buf, offset );\n        break;\n      case 0x0009 :\n        grp.flags = Types.readInt( buf, offset );\n        break;\n    }\n  }\n\n\n\n  void readEntryField( PwEntry ent, byte[] buf, int offset )\n      throws UnsupportedEncodingException\n    {\n    int fieldType = Types.readShort( buf, offset );\n    offset += 2;\n    int fieldSize = Types.readInt( buf, offset );\n    offset += 4;\n\n    switch( fieldType ) {\n      case 0x0000 :\n        // Ignore field\n        break;\n      case 0x0001 :\n        System.arraycopy( buf, offset, ent.uuid, 0, 16 );\n        break;\n      case 0x0002 :\n        ent.groupId = Types.readInt( buf, offset );\n        break;\n      case 0x0003 :\n        ent.imageId = Types.readInt( buf, offset );\n        break;\n      case 0x0004 :\n        ent.title = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0005 :\n        ent.url = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0006 :\n        ent.username = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0007 :\n        ent.setPassword( buf, offset, Types.strlen( buf, offset ) );\n        break;\n      case 0x0008 :\n        ent.additional = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x0009 :\n        ent.tCreation = Types.readTime( buf, offset );\n        break;\n      case 0x000A :\n        ent.tLastMod = Types.readTime( buf, offset );\n        break;\n      case 0x000B :\n        ent.tLastAccess = Types.readTime( buf, offset );\n        break;\n      case 0x000C :\n        ent.tExpire = Types.readTime( buf, offset );\n        break;\n      case 0x000D :\n        ent.binaryDesc = new String( buf, offset, Types.strlen( buf, offset ), \"UTF-8\" );\n        break;\n      case 0x000E :\n        ent.setBinaryData( buf, offset, fieldSize );\n        break;\n    }\n  }\n  \n  \n  \n  /**\n   * Attach groups to parent groups.\n   * \n   * @param groups\n   * @return root group.\n   *//*\n  private PwGroup fixGroups( List groups ) {\n    int   curLevel = -1;\n    Stack parents = new Stack();\n    PwGroup root;\n    \n    root = new PwGroup();\n    root.level = curLevel;\n    parents.push( root );\n\n    for( Iterator iter = groups.iterator(); iter.hasNext(); ) {\n      PwGroup group = (PwGroup)iter.next();\n\n      while( group.level <= curLevel ){\n        parents.pop();\n        curLevel = ((PwGroup)parents.peek()).level;\n      }\n\n      if( group.level >= curLevel ) {\n        if( !parents.isEmpty() )\n          ((PwGroup)parents.peek()).children.add( group );\n        parents.push( group );\n        curLevel = group.level;\n      }\n    }\n\n    return root;\n  }*/\n\n\n\n  /**\n   * Test the BouncyCastle lib.\n   */\n  /* -- we're not using BouncyCastle\n  static void testRijndael_Bouncy() {\n    byte[] aKey = new byte[32];\n    byte[] aTest = new byte[16];\n    byte[] aRef = new byte[16];\n    // The Rijndael class will be tested, that's the expected ciphertext\n    int[] aRef_int = {\n        0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89\n    };\n    int i;\n\n    // Do a quick test if the Rijndael class worked correctly\n    for( i = 0; i < 32; i++ ) {\n      aKey[i] = (byte)i;\n    }\n    for( i = 0; i < 16; i++ ) {\n      aTest[i] = (byte)((i << 4) | i);\n      aRef[i] = (byte)aRef_int[i];\n    }\n\n    RijndaelEngine rijndael = new RijndaelEngine( 128 );\n    rijndael.init( true, new KeyParameter( aKey ) );\n    rijndael.processBlock( aTest, 0, aTest, 0 );\n\n    if( !Arrays.equals( aTest, aRef ) )\n      throw new RuntimeException( \"RijndaelEngine failed test\" );\n  }\n*/\n\n\n  /**\n   * Test Sun's JCE.\n   * Note you need the \"unlimited security\" policy files from Sun.\n   * They're where you download the JDK, i.e.\n   * <a href=\"http://java.sun.com/j2se/1.5.0/download.jsp\"\n   * >http://java.sun.com/j2se/1.5.0/download.jsp<\/a>\n   * @throws NoSuchPaddingException \n   * @throws NoSuchAlgorithmException \n   */\n  static void testRijndael_JCE() {\n    byte[] aKey = new byte[32];\n    byte[] aTest = new byte[16];\n    byte[] aRef = new byte[16];\n    // The Rijndael class will be tested, that's the expected ciphertext\n    int[] aRef_int = {\n        0x8e, 0xa2, 0xb7, 0xca, 0x51, 0x67, 0x45, 0xbf, 0xea, 0xfc, 0x49, 0x90, 0x4b, 0x49, 0x60, 0x89\n    };\n    int i;\n\n    // Do a quick test if the Rijndael class worked correctly\n    for( i = 0; i < 32; i++ ) {\n      aKey[i] = (byte)i;\n    }\n    for( i = 0; i < 16; i++ ) {\n      aTest[i] = (byte)((i << 4) | i);\n      aRef[i] = (byte)aRef_int[i];\n    }\n\n    try {\n\t// Cipher cipher = Cipher.getInstance( \"AES/ECB/NoPadding\" );\n\tBufferedBlockCipher cipher = new BufferedBlockCipher(new AESEngine());\n\t//cipher.init( Cipher.ENCRYPT_MODE, new SecretKeySpec( aKey, \"AES\" ) );\n\tcipher.init(true, new KeyParameter(aKey));\n\t//aTest = cipher.doFinal( aTest );\n\tcipher.processBytes(aTest, 0, aTest.length, aTest, 0);\n    }\n    catch (Exception ex) {\n\tex.printStackTrace();\n\tthrow new RuntimeException( \"JCE failed test\" );\n    }\n\n    if( PhoneIDUtil.compare (aTest, aRef) == false)\n\tthrow new RuntimeException( \"JCE failed test\" );\n  }\n}\n    \n\n\n/*\nNIST.gov states the following:\n\nSuppose that the length of the message, M, is l bits. Append the bit \u201c1\u201d to the end of the\nmessage, followed by k zero bits, where k is the smallest, non-negative solution to the equation\nl +1+ k  448mod 512 . Then append the 64-bit block that is equal to the number l expressed\nusing a binary representation. For example, the (8-bit ASCII) message \u201cabc\u201d has length\n83 = 24, so the message is padded with a one bit, then 448 - (24 +1) = 423 zero bits, and then\nthe message length, to become the 512-bit padded message\n\n                              423     64\n01100001 01100010 01100011 1 00\u202600 00\u2026011000\n  \u201ca\u201d      \u201cb\u201d      \u201cc\u201d               l = 24\n\nThe length of the padded message should now be a multiple of 512 bits.\n*/\n","lineNo":184}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass.keepasslib;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\npublic class PwGroupOutput {\n\tprivate OutputStream mOS;\n\tprivate PwGroup mPG;\n\t\n\t/** Output the PwGroup to the stream\n\t * @param pg\n\t * @param os\n\t */\n\tpublic PwGroupOutput(PwGroup pg, OutputStream os) {\n\t\tmPG = pg;\n\t\tmOS = os;\n\t}\n\n\t//NOTE: Need be to careful about using ints.  The actual type written to file is a unsigned int\n\tpublic void output() throws IOException {\n\t\t// Group ID\n\t\tmOS.write(GROUPID_FIELD_TYPE);\n\t\tmOS.write(GROUPID_FIELD_SIZE);\n\t\tmOS.write(Types.writeInt(mPG.groupId));\n\t\t\n\t\t// Name\n\t\tmOS.write(NAME_FIELD_TYPE);\n\t\tmOS.write(Types.writeInt(mPG.name.length()));\n\t\tmOS.write(mPG.name.getBytes(\"UTF-8\"));\n\t\t\n\t\t// Create date\n\t\tmOS.write(CREATE_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tCreation));\n\t\t\n\t\t// Modification date\n\t\tmOS.write(MOD_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tLastMod));\n\t\t\n\t\t// Access date\n\t\tmOS.write(ACCESS_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tLastAccess));\n\t\t\n\t\t// Expiration date\n\t\tmOS.write(EXPIRE_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tExpire));\n\t\t\n\t\t// Image ID\n\t\tmOS.write(IMAGEID_FIELD_TYPE);\n\t\tmOS.write(IMAGEID_FIELD_SIZE);\n\t\tmOS.write(Types.writeInt(mPG.imageId));\n\t\t\n\t\t// Level\n\t\tmOS.write(LEVEL_FIELD_TYPE);\n\t\tmOS.write(LEVEL_FIELD_SIZE);\n\t\tmOS.write(Types.writeShort(mPG.level));\n\t\t\n\t\t// Flags\n\t\tmOS.write(FLAGS_FIELD_TYPE);\n\t\tmOS.write(FLAGS_FIELD_SIZE);\n\t\tmOS.write(Types.writeInt(mPG.flags));\n\n\t\t// End\n\t\tmOS.write(END_FIELD_TYPE);\n\t\tmOS.write(ZERO_FIELD_SIZE);\n\t}\n\n\tpublic static final byte[] GROUPID_FIELD_TYPE = { 0x00, 0x01};\n\tpublic static final byte[] NAME_FIELD_TYPE =    { 0x00, 0x02};\n\tpublic static final byte[] CREATE_FIELD_TYPE =  { 0x00, 0x03};\n\tpublic static final byte[] MOD_FIELD_TYPE =     { 0x00, 0x04};\n\tpublic static final byte[] ACCESS_FIELD_TYPE =  { 0x00, 0x05};\n\tpublic static final byte[] EXPIRE_FIELD_TYPE =  { 0x00, 0x06};\n\tpublic static final byte[] IMAGEID_FIELD_TYPE = { 0x00, 0x07};\n\tpublic static final byte[] LEVEL_FIELD_TYPE =   { 0x00, 0x08};\n\tpublic static final byte[] FLAGS_FIELD_TYPE =   { 0x00, 0x09};\n\tpublic static final byte[] END_FIELD_TYPE =     Types.writeUByte(0xFFFF);\n\tpublic static final byte[] LONG_FOUR = { 0x00, 0x00, 0x00, 0x04};\n\tpublic static final byte[] GROUPID_FIELD_SIZE =  LONG_FOUR;\n\tpublic static final byte[] DATE_FIELD_SIZE =    { 0x00, 0x00, 0x00, 0x05};\n\tpublic static final byte[] IMAGEID_FIELD_SIZE = LONG_FOUR;\n\tpublic static final byte[] LEVEL_FIELD_SIZE =   { 0x00, 0x00, 0x00, 0x02};\n\tpublic static final byte[] FLAGS_FIELD_SIZE =   LONG_FOUR;\n\tpublic static final byte[] ZERO_FIELD_SIZE    = { 0x00, 0x00, 0x00, 0x00};\n\t\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass.keepasslib;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.Types;\n\npublic class PwGroupOutput {\n\tprivate OutputStream mOS;\n\tprivate PwGroup mPG;\n\t\n\t/** Output the PwGroup to the stream\n\t * @param pg\n\t * @param os\n\t */\n\tpublic PwGroupOutput(PwGroup pg, OutputStream os) {\n\t\tmPG = pg;\n\t\tmOS = os;\n\t}\n\n\t//NOTE: Need be to careful about using ints.  The actual type written to file is a unsigned int\n\tpublic void output() throws IOException {\n\t\t// Group ID\n\t\tmOS.write(GROUPID_FIELD_TYPE);\n\t\tmOS.write(GROUPID_FIELD_SIZE);\n\t\tmOS.write(Types.writeInt(mPG.groupId));\n\t\t\n\t\t// Name\n\t\tbyte[] name = mPG.name.getBytes(\"UTF-8\");\n\t\tmOS.write(NAME_FIELD_TYPE);\n\t\tmOS.write(name.length);\n\t\tmOS.write(name);\n\t\t\n\t\t// Create date\n\t\tmOS.write(CREATE_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tCreation));\n\t\t\n\t\t// Modification date\n\t\tmOS.write(MOD_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tLastMod));\n\t\t\n\t\t// Access date\n\t\tmOS.write(ACCESS_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tLastAccess));\n\t\t\n\t\t// Expiration date\n\t\tmOS.write(EXPIRE_FIELD_TYPE);\n\t\tmOS.write(DATE_FIELD_SIZE);\n\t\tmOS.write(Types.writeTime(mPG.tExpire));\n\t\t\n\t\t// Image ID\n\t\tmOS.write(IMAGEID_FIELD_TYPE);\n\t\tmOS.write(IMAGEID_FIELD_SIZE);\n\t\tmOS.write(Types.writeInt(mPG.imageId));\n\t\t\n\t\t// Level\n\t\tmOS.write(LEVEL_FIELD_TYPE);\n\t\tmOS.write(LEVEL_FIELD_SIZE);\n\t\tmOS.write(Types.writeShort(mPG.level));\n\t\t\n\t\t// Flags\n\t\tmOS.write(FLAGS_FIELD_TYPE);\n\t\tmOS.write(FLAGS_FIELD_SIZE);\n\t\tmOS.write(Types.writeInt(mPG.flags));\n\n\t\t// End\n\t\tmOS.write(END_FIELD_TYPE);\n\t\tmOS.write(ZERO_FIELD_SIZE);\n\t}\n\n\tpublic static final byte[] GROUPID_FIELD_TYPE = Types.writeShort(1);\n\tpublic static final byte[] NAME_FIELD_TYPE =    Types.writeShort(2);\n\tpublic static final byte[] CREATE_FIELD_TYPE =  Types.writeShort(3);\n\tpublic static final byte[] MOD_FIELD_TYPE =     Types.writeShort(4);\n\tpublic static final byte[] ACCESS_FIELD_TYPE =  Types.writeShort(5);\n\tpublic static final byte[] EXPIRE_FIELD_TYPE =  Types.writeShort(6);\n\tpublic static final byte[] IMAGEID_FIELD_TYPE = Types.writeShort(7);\n\tpublic static final byte[] LEVEL_FIELD_TYPE =   Types.writeShort(8);\n\tpublic static final byte[] FLAGS_FIELD_TYPE =   Types.writeShort(9);\n\tpublic static final byte[] END_FIELD_TYPE =     Types.writeUByte(0xFFFF);\n\tpublic static final byte[] LONG_FOUR = Types.writeInt(4);\n\tpublic static final byte[] GROUPID_FIELD_SIZE =  LONG_FOUR;\n\tpublic static final byte[] DATE_FIELD_SIZE =    Types.writeInt(5);\n\tpublic static final byte[] IMAGEID_FIELD_SIZE = LONG_FOUR;\n\tpublic static final byte[] LEVEL_FIELD_SIZE =   Types.writeInt(2);\n\tpublic static final byte[] FLAGS_FIELD_SIZE =   LONG_FOUR;\n\tpublic static final byte[] ZERO_FIELD_SIZE    = Types.writeInt(0);\n\t\n\n}\n","lineNo":49}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.ListView;\nimport android.widget.TextView;\n\npublic class GroupActivity extends LockingListActivity {\n\n\tpublic static final String KEY_ENTRY = \"entry\";\n\t\n\tprivate static final int MENU_LOCK = Menu.FIRST;\n\t\n\tprivate PwGroup mGroup;\n\n\tpublic static void Launch(Activity act, PwGroup group) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\n\tprivate int mId;\n\t\n\t@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\t\tint size = mGroup.childGroups.size();\n\t\tif (position < size ) {\n\t\t\tPwGroup group = (PwGroup) mGroup.childGroups.elementAt(position);\n\t\t\tPwGroupView gv = new PwGroupView(this, group);\n\t\t\tgv.onClick();\n\t\t} else {\n\t\t\tPwEntry entry = (PwEntry) mGroup.childEntries.elementAt(position - size);\n\t\t\tPwEntryView pe = new PwEntryView(this, entry);\n\t\t\tpe.onClick();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.list);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\n\t\tint id = getIntent().getIntExtra(KEY_ENTRY, -1);\n\t\tassert(mId >= 0);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = Database.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = Database.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\n\t\tsetGroupTitle();\n\t\t\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t\tgetListView().setTextFilterEnabled(true);\n\n\t}\n\t\n\tprivate void setGroupTitle() {\n\t\tif ( mGroup != null ) {\n\t\t\tString name = mGroup.name;\n\t\t\tif ( name != null && name.length() > 0 ) {\n\t\t\t\tTextView tv = (TextView) findViewById(R.id.group_header);\n\t\t\t\ttv.setText(getText(R.string.current_group) + \" \" + name);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_LOCK, 0, R.string.menu_lock);\n\t\tmenu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_LOCK:\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == KeePass.EXIT_LOCK ) {\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t}\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.lang.ref.WeakReference;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.ListView;\nimport android.widget.TextView;\n\npublic class GroupActivity extends LockingListActivity {\n\n\tpublic static final String KEY_ENTRY = \"entry\";\n\t\n\tprivate static final int MENU_LOCK = Menu.FIRST;\n\t\n\tprivate PwGroup mGroup;\n\n\tpublic static void Launch(Activity act, PwGroup group) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\t\n\t\tact.startActivityForResult(i,0);\n\t}\n\n\tprivate int mId;\n\t\n\t@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\t\tint size = mGroup.childGroups.size();\n\t\tif (position < size ) {\n\t\t\tPwGroup group = (PwGroup) mGroup.childGroups.elementAt(position);\n\t\t\tPwGroupView gv = new PwGroupView(this, group);\n\t\t\tgv.onClick();\n\t\t} else {\n\t\t\tPwEntry entry = (PwEntry) mGroup.childEntries.elementAt(position - size);\n\t\t\tPwEntryView pe = new PwEntryView(this, entry);\n\t\t\tpe.onClick();\n\t\t}\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.list);\n\t\tsetResult(KeePass.EXIT_NORMAL);\n\t\t\n\t\tint id = getIntent().getIntExtra(KEY_ENTRY, -1);\n\t\tassert(mId >= 0);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = Database.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = Database.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\n\t\tsetGroupTitle();\n\t\t\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t\tListView lv = getListView();\n\t\tlv.setScrollBarStyle(View.SCROLLBARS_INSIDE_INSET);\n\t\tlv.setTextFilterEnabled(true);\n\n\t}\n\t\n\tprivate void setGroupTitle() {\n\t\tif ( mGroup != null ) {\n\t\t\tString name = mGroup.name;\n\t\t\tif ( name != null && name.length() > 0 ) {\n\t\t\t\tTextView tv = (TextView) findViewById(R.id.group_header);\n\t\t\t\ttv.setText(getText(R.string.current_group) + \" \" + name);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_LOCK, 0, R.string.menu_lock);\n\t\tmenu.findItem(MENU_LOCK).setIcon(android.R.drawable.ic_lock_lock);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_LOCK:\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == KeePass.EXIT_LOCK ) {\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t}\n\t}\n}\n","lineNo":92}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\nimport org.bouncycastle1.crypto.InvalidCipherTextException;\n\nimport com.android.keepass.keepasslib.InvalidKeyFileException;\n\nimport android.app.Activity;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\npublic class PasswordActivity extends Activity {\n\n\tpublic static final String LAST_FILENAME = \"lastFile\";\n\tpublic static final String LAST_KEYFILE = \"lastKey\";\n\t\n\tprivate static final int MENU_HOMEPAGE = Menu.FIRST;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.password);\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new ClickHandler(this));\n\t\t\n\t\tloadDefaultPrefs();\n\t\t\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Clear password on Database state\n\t\tsetEditText(R.id.pass_password, \"\");\n\t\tDatabase.clear(); \n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t}\n\n\tprivate void loadDefaultPrefs() {\n\t\tSharedPreferences settings = getPreferences(MODE_PRIVATE);\n\t\tString lastFile = settings.getString(LAST_FILENAME, \"\");\n\t\tString lastKey = settings.getString(LAST_KEYFILE,\"\");\n\t\t\n\t\tif (lastFile == \"\") {\n\t\t\tlastFile = \"/sdcard/keepass/keepass.kdb\";\n\t\t}\n\t\t\n\t\tsetEditText(R.id.pass_filename, lastFile);\n\t\tsetEditText(R.id.pass_keyfile, lastKey);\n\t}\n\t\n\tprivate void saveDefaultPrefs() {\n\t\tSharedPreferences settings = getPreferences(MODE_PRIVATE);\n\t\tSharedPreferences.Editor editor = settings.edit();\n\t\teditor.putString(LAST_FILENAME, getEditText(R.id.pass_filename));\n\t\teditor.putString(LAST_KEYFILE, getEditText(R.id.pass_keyfile));\n\t\teditor.commit();\n\t}\n\t\n\t\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class ClickHandler implements View.OnClickListener {\n\t\tprivate Activity mAct;\n\t\t\t\t\n\t\tClickHandler(Activity act) {\n\t\t\tmAct = act;\n\t\t}\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.pass_password);\n\t\t\tString key = getEditText(R.id.pass_keyfile);\n\t\t\tif ( pass.length() == 0 && key.length() == 0 ) {\n\t\t\t\terrorMessage(R.string.error_nopass);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\n\t\t\t\tDatabase.LoadData(getEditText(R.id.pass_filename), pass, key);\n\t\t\t\tsaveDefaultPrefs();\n\t\t\t\tGroupActivity.Launch(mAct, null);\n\n\t\t\t} catch (InvalidCipherTextException e) {\n\t\t\t\terrorMessage(R.string.InvalidPassword);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\terrorMessage(R.string.FileNotFound);\n\t\t\t} catch (IOException e) {\n\t\t\t\terrorMessage(\"Unknown error.\");\n\t\t\t} catch (InvalidKeyFileException e) {\n\t\t\t\terrorMessage(e.getMessage());\n\t\t\t}\n\t\t}\t\t\t\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\tEditText te =  (EditText) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tEditText te =  (EditText) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_HOMEPAGE, 0, R.string.menu_homepage);\n\t\tmenu.findItem(MENU_HOMEPAGE).setIcon(android.R.drawable.ic_menu_upload);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_HOMEPAGE:\n\t\t\tUtil.gotoUrl(this, getText(R.string.homepage).toString());\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\nimport org.bouncycastle1.crypto.InvalidCipherTextException;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.android.keepass.fileselect.FileDbHelper;\nimport com.android.keepass.keepasslib.InvalidKeyFileException;\n\npublic class PasswordActivity extends Activity {\n\n\tprivate static final int MENU_HOMEPAGE = Menu.FIRST;\n\tprivate static final String KEY_FILENAME = \"fileName\";\n\tprivate static final String KEY_KEYFILE = \"keyFile\";\n\n\tprivate String mFileName;\n\tprivate String mKeyFile;\n\t\n\tpublic static void Launch(Activity act, String fileName) throws FileNotFoundException {\n\t\tLaunch(act,fileName,\"\");\n\t}\n\t\n\tpublic static void Launch(Activity act, String fileName, String keyFile) throws FileNotFoundException {\n\t\tFile dbFile = new File(fileName);\n\t\tif ( ! dbFile.exists() ) {\n\t\t\tthrow new FileNotFoundException();\n\t\t\t//Toast.makeText(act, R.string.FileNotFound, Toast.LENGTH_LONG);\n\t\t\t//return;\n\t\t}\n\t\t\n\t\tIntent i = new Intent(act, PasswordActivity.class);\n\t\ti.putExtra(KEY_FILENAME, fileName);\n\t\ti.putExtra(KEY_KEYFILE, keyFile);\n\t\t\n\t\tact.startActivityForResult(i, 0);\n\t\t\n\t}\n\t\n\t@Override\n\tprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tsuper.onActivityResult(requestCode, resultCode, data);\n\t\t\n\t\tif (resultCode == KeePass.EXIT_LOCK) {\n\t\t\tsetResult(KeePass.EXIT_LOCK);\n\t\t\tfinish();\n\t\t}\n\t\t\n\t\tDatabase.clear(); \n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\n\t\tIntent i = getIntent();\n\t\tmFileName = i.getStringExtra(KEY_FILENAME);\n\t\tmKeyFile = i.getStringExtra(KEY_KEYFILE);\n\t\t\n\t\tsetContentView(R.layout.password);\n\t\tpopulateView();\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new ClickHandler(this));\n\t}\n\t\n\tprivate void populateView() {\n\t\tsetEditText(R.id.pass_filename, mFileName);\n\t\tsetEditText(R.id.pass_keyfile, mKeyFile);\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Clear password on Database state\n\t\tsetEditText(R.id.pass_password, \"\");\n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t}\n\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class ClickHandler implements View.OnClickListener {\n\t\tprivate Activity mAct;\n\t\t\t\t\n\t\tClickHandler(Activity act) {\n\t\t\tmAct = act;\n\t\t}\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.pass_password);\n\t\t\tString key = getEditText(R.id.pass_keyfile);\n\t\t\tif ( pass.length() == 0 && key.length() == 0 ) {\n\t\t\t\terrorMessage(R.string.error_nopass);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tString fileName = getEditText(R.id.pass_filename);\n\t\t\t\tDatabase.LoadData(fileName, pass, key);\n\t\t\t\tsaveFileData(fileName, key);\n\t\t\t\tGroupActivity.Launch(mAct, null);\n\n\t\t\t} catch (InvalidCipherTextException e) {\n\t\t\t\terrorMessage(R.string.InvalidPassword);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\terrorMessage(R.string.FileNotFound);\n\t\t\t} catch (IOException e) {\n\t\t\t\terrorMessage(\"Unknown error.\");\n\t\t\t} catch (InvalidKeyFileException e) {\n\t\t\t\terrorMessage(e.getMessage());\n\t\t\t}\n\t\t}\t\t\t\n\t}\n\t\n\tprivate void saveFileData(String fileName, String key) {\n\t\tFileDbHelper db = new FileDbHelper(this);\n\t\tdb.open();\n\t\t\n\t\tdb.createFile(fileName, key);\n\t\t\n\t\tdb.close();\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\treturn Util.getEditText(this, resId);\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tTextView te =  (TextView) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_HOMEPAGE, 0, R.string.menu_homepage);\n\t\tmenu.findItem(MENU_HOMEPAGE).setIcon(android.R.drawable.ic_menu_upload);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_HOMEPAGE:\n\t\t\tUtil.gotoUrl(this, getText(R.string.homepage).toString());\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n}\n","lineNo":142}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport org.bouncycastle1.crypto.InvalidCipherTextException;\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport java.io.*;\nimport java.lang.ref.WeakReference;\nimport java.util.HashMap;\nimport java.util.UUID;\nimport java.util.Vector;\n\npublic class KeePass extends Activity {\n\n\tpublic static final int EXIT_NORMAL = 0;\n\tpublic static final int EXIT_LOCK = 1;\n\t\n\tprivate static final int MENU_HOMEPAGE = Menu.FIRST;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.password);\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new ClickHandler(this));\n\t\t\n\t\tloadDefaultPrefs();\n\t\t\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Clear password on Database state\n\t\tsetEditText(R.id.pass_password, \"\");\n\t\tDatabase.clear(); \n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t}\n\n\tprivate void loadDefaultPrefs() {\n\t\tSharedPreferences settings = getPreferences(MODE_PRIVATE);\n\t\tString lastfn = settings.getString(\"lastFile\", \"\");\n\t\t\n\t\tif (lastfn == \"\") {\n\t\t\tlastfn = \"/sdcard/keepass/keepass.kdb\";\n\t\t}\n\t\t\n\t\tsetEditText(R.id.pass_filename, lastfn);\n\t}\n\t\n\tprivate void saveDefaultPrefs() {\n\t\tSharedPreferences settings = getPreferences(MODE_PRIVATE);\n\t\tSharedPreferences.Editor editor = settings.edit();\n\t\teditor.putString(\"lastFile\", getEditText(R.id.pass_filename));\n\t\teditor.commit();\n\t}\n\t\n\t\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class ClickHandler implements View.OnClickListener {\n\t\tprivate Activity mAct;\n\t\t\t\t\n\t\tClickHandler(Activity act) {\n\t\t\tmAct = act;\n\t\t}\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tint result = Database.LoadData(getEditText(R.id.pass_filename),getEditText(R.id.pass_password));\n\t\t\t\n\t\t\tswitch (result) {\n\t\t\tcase 0:\n\t\t\t\tsaveDefaultPrefs();\n\t\t\t\tGroupActivity.Launch(mAct, null);\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\terrorMessage(\"Unknown error.\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrorMessage(result);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\tEditText te =  (EditText) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tEditText te =  (EditText) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_HOMEPAGE, 0, R.string.menu_homepage);\n\t\tmenu.findItem(MENU_HOMEPAGE).setIcon(android.R.drawable.ic_menu_upload);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_HOMEPAGE:\n\t\t\tUtil.gotoUrl(this, getText(R.string.homepage).toString());\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport org.bouncycastle1.crypto.InvalidCipherTextException;\nimport org.phoneid.keepassj2me.ImporterV3;\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\nimport org.phoneid.keepassj2me.PwManager;\n\nimport android.app.Activity;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.Toast;\n\nimport java.io.*;\nimport java.lang.ref.WeakReference;\nimport java.util.HashMap;\nimport java.util.UUID;\nimport java.util.Vector;\n\npublic class KeePass extends Activity {\n\n\tpublic static final int EXIT_NORMAL = 0;\n\tpublic static final int EXIT_LOCK = 1;\n\t\n\tprivate static final int MENU_HOMEPAGE = Menu.FIRST;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.password);\n\n\t\tButton confirmButton = (Button) findViewById(R.id.pass_ok);\n\t\tconfirmButton.setOnClickListener(new ClickHandler(this));\n\t\t\n\t\tloadDefaultPrefs();\n\t\t\n\t}\n\t\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\t\n\t\t// Clear password on Database state\n\t\tsetEditText(R.id.pass_password, \"\");\n\t\tDatabase.clear(); \n\t}\n\n\t@Override\n\tprotected void onStop() {\n\t\tsuper.onStop();\n\t\t\n\t}\n\n\tprivate void loadDefaultPrefs() {\n\t\tSharedPreferences settings = getPreferences(MODE_PRIVATE);\n\t\tString lastfn = settings.getString(\"lastFile\", \"\");\n\t\t\n\t\tif (lastfn == \"\") {\n\t\t\tlastfn = \"/sdcard/keepass/keepass.kdb\";\n\t\t}\n\t\t\n\t\tsetEditText(R.id.pass_filename, lastfn);\n\t}\n\t\n\tprivate void saveDefaultPrefs() {\n\t\tSharedPreferences settings = getPreferences(MODE_PRIVATE);\n\t\tSharedPreferences.Editor editor = settings.edit();\n\t\teditor.putString(\"lastFile\", getEditText(R.id.pass_filename));\n\t\teditor.commit();\n\t}\n\t\n\t\n\tprivate void errorMessage(CharSequence text)\n\t{\n\t\tToast.makeText(this, text, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate void errorMessage(int resId)\n\t{\n\t\tToast.makeText(this, resId, Toast.LENGTH_LONG).show();\n\t}\n\t\n\tprivate class ClickHandler implements View.OnClickListener {\n\t\tprivate Activity mAct;\n\t\t\t\t\n\t\tClickHandler(Activity act) {\n\t\t\tmAct = act;\n\t\t}\n\t\t\n\t\tpublic void onClick(View view) {\n\t\t\tString pass = getEditText(R.id.pass_password);\n\t\t\tif ( pass.length() == 0 ) {\n\t\t\t\terrorMessage(R.string.error_nopass);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint result = Database.LoadData(getEditText(R.id.pass_filename),pass);\n\t\t\t\n\t\t\tswitch (result) {\n\t\t\tcase 0:\n\t\t\t\tsaveDefaultPrefs();\n\t\t\t\tGroupActivity.Launch(mAct, null);\n\t\t\t\tbreak;\n\t\t\tcase -1:\n\t\t\t\terrorMessage(\"Unknown error.\");\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\terrorMessage(result);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t}\n\t\n\tprivate String getEditText(int resId) {\n\t\tEditText te =  (EditText) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\treturn te.getText().toString();\n\t\t} else {\n\t\t\treturn \"\";\n\t\t}\n\t}\n\t\n\tprivate void setEditText(int resId, String str) {\n\t\tEditText te =  (EditText) findViewById(resId);\n\t\tassert(te == null);\n\t\t\n\t\tif (te != null) {\n\t\t\tte.setText(str);\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\t\n\t\tmenu.add(0, MENU_HOMEPAGE, 0, R.string.menu_homepage);\n\t\tmenu.findItem(MENU_HOMEPAGE).setIcon(android.R.drawable.ic_menu_upload);\n\t\t\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch ( item.getItemId() ) {\n\t\tcase MENU_HOMEPAGE:\n\t\t\tUtil.gotoUrl(this, getText(R.string.homepage).toString());\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n}\n","lineNo":116}
{"Smelly Sample":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.util.Vector;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.app.ListActivity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.ListView;\n\npublic class GroupActivity extends ListActivity {\n\n\tpublic static final String KEY_ENTRY = \"entry\";\n\t\n\tprivate PwGroup mGroup;\n\n\tpublic static void Launch(Activity act, PwGroup group) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\t\n\t\tact.startActivity(i);\n\t}\n\n\tprivate int mId;\n\t\n\t@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\t\tint size = mGroup.childGroups.size();\n\t\tPwItemView iv;\n\t\tif (position < size ) {\n\t\t\tPwGroup group = (PwGroup) mGroup.childGroups.elementAt(position);\n\t\t\tiv = new PwGroupView(this, group);\n\t\t} else {\n\t\t\tPwEntry entry = (PwEntry) mGroup.childEntries.elementAt(position - size);\n\t\t\tiv = new PwEntryView(this, entry);\n\t\t}\n\t\tiv.onClick();\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.list);\n\n\t\tint id = getIntent().getIntExtra(KEY_ENTRY, -1);\n\t\tassert(mId >= 0);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = Database.gRoot;\n\t\t} else {\n\t\t\tmGroup = Database.gGroups.get(id).get();\n\t\t}\n\t\tassert(mGroup != null);\n\t\t\n\t\t\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t\tgetListView().setTextFilterEnabled(true);\n\n\t}\n\n}\n","Method after Refactoring":"/*\n * Copyright 2009 Brian Pellin.\n *     \n * This file is part of KeePassDroid.\n *\n *  KeePassDroid is free software: you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation, either version 3 of the License, or\n *  (at your option) any later version.\n *\n *  KeePassDroid is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with KeePassDroid.  If not, see <http://www.gnu.org/licenses/>.\n *\n */\npackage com.android.keepass;\n\nimport java.lang.ref.WeakReference;\nimport java.util.Vector;\n\nimport org.phoneid.keepassj2me.PwEntry;\nimport org.phoneid.keepassj2me.PwGroup;\n\nimport android.app.Activity;\nimport android.app.ListActivity;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.ListView;\n\npublic class GroupActivity extends ListActivity {\n\n\tpublic static final String KEY_ENTRY = \"entry\";\n\t\n\tprivate PwGroup mGroup;\n\n\tpublic static void Launch(Activity act, PwGroup group) {\n\t\tIntent i = new Intent(act, GroupActivity.class);\n\t\t\n\t\tif ( group != null ) {\n\t\t\ti.putExtra(KEY_ENTRY, group.groupId);\n\t\t}\n\t\t\n\t\t\n\t\tact.startActivity(i);\n\t}\n\n\tprivate int mId;\n\t\n\t@Override\n\tprotected void onListItemClick(ListView l, View v, int position, long id) {\n\t\tsuper.onListItemClick(l, v, position, id);\n\t\tint size = mGroup.childGroups.size();\n\t\tPwItemView iv;\n\t\tif (position < size ) {\n\t\t\tPwGroup group = (PwGroup) mGroup.childGroups.elementAt(position);\n\t\t\tiv = new PwGroupView(this, group);\n\t\t} else {\n\t\t\tPwEntry entry = (PwEntry) mGroup.childEntries.elementAt(position - size);\n\t\t\tiv = new PwEntryView(this, entry);\n\t\t}\n\t\tiv.onClick();\n\t}\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.list);\n\n\t\tint id = getIntent().getIntExtra(KEY_ENTRY, -1);\n\t\tassert(mId >= 0);\n\t\t\n\t\tif ( id == -1 ) {\n\t\t\tmGroup = Database.gRoot;\n\t\t} else {\n\t\t\tWeakReference<PwGroup> wPw = Database.gGroups.get(id);\n\t\t\tmGroup = wPw.get();\n\t\t}\n\t\tassert(mGroup != null);\n\t\t\n\t\t\n\t\tsetListAdapter(new PwListAdapter(this, mGroup));\n\t\tgetListView().setTextFilterEnabled(true);\n\n\t}\n\n}\n","lineNo":80}
