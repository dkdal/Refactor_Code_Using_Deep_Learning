{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.os.Environment.buildExternalStorageAndroidObbDirs;\nimport static android.os.Environment.buildExternalStorageAppDataDirs;\nimport static android.os.Environment.buildExternalStorageAppMediaDirs;\nimport static android.os.Environment.buildExternalStorageAppObbDirs;\nimport static android.os.Environment.buildExternalStoragePublicDirs;\nimport static android.os.Process.INVALID_UID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.FLAG_REQUIRES_CHARGING;\nimport static android.provider.Downloads.Impl.FLAG_REQUIRES_DEVICE_IDLE;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.job.JobInfo;\nimport android.app.job.JobScheduler;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.webkit.MimeTypeMap;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.util.ArrayUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.System;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Some helper functions for the download manager\n */\npublic class Helpers {\n    public static Random sRandom = new Random(SystemClock.uptimeMillis());\n\n    /** Regex used to parse content-disposition headers */\n    private static final Pattern CONTENT_DISPOSITION_PATTERN =\n            Pattern.compile(\"attachment;\\\\s*filename\\\\s*=\\\\s*\\\"([^\\\"]*)\\\"\");\n\n    private static final Pattern PATTERN_ANDROID_DIRS =\n            Pattern.compile(\"(?i)^/storage/[^/]+(?:/[0-9]+)?/Android/(?:data|obb|media)/.+\");\n\n    private static final Pattern PATTERN_ANDROID_PRIVATE_DIRS =\n            Pattern.compile(\"(?i)^/storage/[^/]+(?:/[0-9]+)?/Android/(data|obb)/.+\");\n\n    private static final Pattern PATTERN_PUBLIC_DIRS =\n            Pattern.compile(\"(?i)^/storage/[^/]+(?:/[0-9]+)?/([^/]+)/.+\");\n\n    @VisibleForTesting\n    static final String DEFAULT_DOWNLOAD_FILE_NAME_PREFIX = \"Download_\";\n\n    private static final Object sUniqueLock = new Object();\n\n    private static HandlerThread sAsyncHandlerThread;\n    private static Handler sAsyncHandler;\n\n    private static SystemFacade sSystemFacade;\n    private static DownloadNotifier sNotifier;\n\n    private Helpers() {\n    }\n\n    public synchronized static Handler getAsyncHandler() {\n        if (sAsyncHandlerThread == null) {\n            sAsyncHandlerThread = new HandlerThread(\"sAsyncHandlerThread\",\n                    Process.THREAD_PRIORITY_BACKGROUND);\n            sAsyncHandlerThread.start();\n            sAsyncHandler = new Handler(sAsyncHandlerThread.getLooper());\n        }\n        return sAsyncHandler;\n    }\n\n    @VisibleForTesting\n    public synchronized static void setSystemFacade(SystemFacade systemFacade) {\n        sSystemFacade = systemFacade;\n    }\n\n    public synchronized static SystemFacade getSystemFacade(Context context) {\n        if (sSystemFacade == null) {\n            sSystemFacade = new RealSystemFacade(context);\n        }\n        return sSystemFacade;\n    }\n\n    public synchronized static DownloadNotifier getDownloadNotifier(Context context) {\n        if (sNotifier == null) {\n            sNotifier = new DownloadNotifier(context);\n        }\n        return sNotifier;\n    }\n\n    public static String getString(Cursor cursor, String col) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(col));\n    }\n\n    public static int getInt(Cursor cursor, String col) {\n        return cursor.getInt(cursor.getColumnIndexOrThrow(col));\n    }\n\n    public static void scheduleJob(Context context, long downloadId) {\n        final boolean scheduled = scheduleJob(context,\n                DownloadInfo.queryDownloadInfo(context, downloadId));\n        if (!scheduled) {\n            // If we didn't schedule a future job, kick off a notification\n            // update pass immediately\n            getDownloadNotifier(context).update();\n        }\n    }\n\n    /**\n     * Schedule (or reschedule) a job for the given {@link DownloadInfo} using\n     * its current state to define job constraints.\n     */\n    public static boolean scheduleJob(Context context, DownloadInfo info) {\n        if (info == null) return false;\n\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        // Tear down any existing job for this download\n        final int jobId = (int) info.mId;\n        scheduler.cancel(jobId);\n\n        // Skip scheduling if download is paused or finished\n        if (!info.isReadyToSchedule()) return false;\n\n        final JobInfo.Builder builder = new JobInfo.Builder(jobId,\n                new ComponentName(context, DownloadJobService.class));\n\n        // When this download will show a notification, run with a higher\n        // bias, since it's effectively a foreground service\n        if (info.isVisible()) {\n            builder.setBias(JobInfo.BIAS_FOREGROUND_SERVICE);\n            builder.setFlags(JobInfo.FLAG_WILL_BE_FOREGROUND);\n        }\n\n        // We might have a backoff constraint due to errors\n        final long latency = info.getMinimumLatency();\n        if (latency > 0) {\n            builder.setMinimumLatency(latency);\n        }\n\n        // We always require a network, but the type of network might be further\n        // restricted based on download request or user override\n        builder.setRequiredNetworkType(info.getRequiredNetworkType(info.mTotalBytes));\n\n        if ((info.mFlags & FLAG_REQUIRES_CHARGING) != 0) {\n            builder.setRequiresCharging(true);\n        }\n        if ((info.mFlags & FLAG_REQUIRES_DEVICE_IDLE) != 0) {\n            builder.setRequiresDeviceIdle(true);\n        }\n\n        // Provide estimated network size, when possible\n        if (info.mTotalBytes > 0) {\n            if (info.mCurrentBytes > 0 && !TextUtils.isEmpty(info.mETag)) {\n                // If we're resuming an in-progress download, we only need to\n                // download the remaining bytes.\n                builder.setEstimatedNetworkBytes(info.mTotalBytes - info.mCurrentBytes,\n                        JobInfo.NETWORK_BYTES_UNKNOWN);\n            } else {\n                builder.setEstimatedNetworkBytes(info.mTotalBytes, JobInfo.NETWORK_BYTES_UNKNOWN);\n            }\n        }\n\n        // If package name was filtered during insert (probably due to being\n        // invalid), blame based on the requesting UID instead\n        String packageName = info.mPackage;\n        if (packageName == null) {\n            packageName = context.getPackageManager().getPackagesForUid(info.mUid)[0];\n        }\n\n        scheduler.scheduleAsPackage(builder.build(), packageName, UserHandle.myUserId(), TAG);\n        return true;\n    }\n\n    /*\n     * Parse the Content-Disposition HTTP Header. The format of the header\n     * is defined here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html\n     * This header provides a filename for content that is going to be\n     * downloaded to the file system. We only support the attachment type.\n     */\n    private static String parseContentDisposition(String contentDisposition) {\n        try {\n            Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);\n            if (m.find()) {\n                return m.group(1);\n            }\n        } catch (IllegalStateException ex) {\n             // This function is defined as returning null when it can't parse the header\n        }\n        return null;\n    }\n\n    /**\n     * Creates a filename (where the file should be saved) from info about a download.\n     * This file will be touched to reserve it.\n     */\n    static String generateSaveFile(Context context, String url, String hint,\n            String contentDisposition, String contentLocation, String mimeType, int destination)\n            throws IOException {\n\n        final File parent;\n        final File[] parentTest;\n        String name = null;\n\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            final File file = new File(Uri.parse(hint).getPath());\n            parent = file.getParentFile().getAbsoluteFile();\n            parentTest = new File[] { parent };\n            name = file.getName();\n        } else {\n            parent = getRunningDestinationDirectory(context, destination);\n            parentTest = new File[] {\n                    parent,\n                    getSuccessDestinationDirectory(context, destination)\n            };\n            name = chooseFilename(url, hint, contentDisposition, contentLocation);\n        }\n\n        // Ensure target directories are ready\n        for (File test : parentTest) {\n            if (!(test.isDirectory() || test.mkdirs())) {\n                throw new IOException(\"Failed to create parent for \" + test);\n            }\n        }\n\n        if (DownloadDrmHelper.isDrmConvertNeeded(mimeType)) {\n            name = DownloadDrmHelper.modifyDrmFwLockFileExtension(name);\n        }\n\n        final String prefix;\n        final String suffix;\n        final int dotIndex = name.lastIndexOf('.');\n        final boolean missingExtension = dotIndex < 0;\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            // Destination is explicitly set - do not change the extension\n            if (missingExtension) {\n                prefix = name;\n                suffix = \"\";\n            } else {\n                prefix = name.substring(0, dotIndex);\n                suffix = name.substring(dotIndex);\n            }\n        } else {\n            // Split filename between base and extension\n            // Add an extension if filename does not have one\n            if (missingExtension) {\n                prefix = name;\n                suffix = chooseExtensionFromMimeType(mimeType, true);\n            } else {\n                prefix = name.substring(0, dotIndex);\n                suffix = chooseExtensionFromFilename(mimeType, destination, name, dotIndex);\n            }\n        }\n\n        synchronized (sUniqueLock) {\n            name = generateAvailableFilenameLocked(parentTest, prefix, suffix);\n\n            // Claim this filename inside lock to prevent other threads from\n            // clobbering us. We're not paranoid enough to use O_EXCL.\n            final File file = new File(parent, name);\n            file.createNewFile();\n            return file.getAbsolutePath();\n        }\n    }\n\n    private static String chooseFilename(String url, String hint, String contentDisposition,\n            String contentLocation) {\n        String filename = null;\n\n        // First, try to use the hint from the application, if there's one\n        if (filename == null && hint != null && !hint.endsWith(\"/\")) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"getting filename from hint\");\n            }\n            int index = hint.lastIndexOf('/') + 1;\n            if (index > 0) {\n                filename = hint.substring(index);\n            } else {\n                filename = hint;\n            }\n        }\n\n        // If we couldn't do anything with the hint, move toward the content disposition\n        if (filename == null && contentDisposition != null) {\n            filename = parseContentDisposition(contentDisposition);\n            if (filename != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-disposition\");\n                }\n                int index = filename.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = filename.substring(index);\n                }\n            }\n        }\n\n        // If we still have nothing at this point, try the content location\n        if (filename == null && contentLocation != null) {\n            String decodedContentLocation = Uri.decode(contentLocation);\n            if (decodedContentLocation != null\n                    && !decodedContentLocation.endsWith(\"/\")\n                    && decodedContentLocation.indexOf('?') < 0) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-location\");\n                }\n                int index = decodedContentLocation.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = decodedContentLocation.substring(index);\n                } else {\n                    filename = decodedContentLocation;\n                }\n            }\n        }\n\n        // If all the other http-related approaches failed, use the plain uri\n        if (filename == null) {\n            String decodedUrl = Uri.decode(url);\n            if (decodedUrl != null\n                    && !decodedUrl.endsWith(\"/\") && decodedUrl.indexOf('?') < 0) {\n                int index = decodedUrl.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"getting filename from uri\");\n                    }\n                    filename = decodedUrl.substring(index);\n                }\n            }\n        }\n\n        // Finally, if couldn't get filename from URI, get a generic filename\n        if (filename == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"using default filename\");\n            }\n            filename = Constants.DEFAULT_DL_FILENAME;\n        }\n\n        // The VFAT file system is assumed as target for downloads.\n        // Replace invalid characters according to the specifications of VFAT.\n        filename = FileUtils.buildValidFatFilename(filename);\n\n        return filename;\n    }\n\n    private static String chooseExtensionFromMimeType(String mimeType, boolean useDefaults) {\n        String extension = null;\n        if (mimeType != null) {\n            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);\n            if (extension != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding extension from type\");\n                }\n                extension = \".\" + extension;\n            } else {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                }\n            }\n        }\n        if (extension == null) {\n            if (mimeType != null && mimeType.toLowerCase().startsWith(\"text/\")) {\n                if (mimeType.equalsIgnoreCase(\"text/html\")) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default html extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_HTML_EXTENSION;\n                } else if (useDefaults) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default text extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_TEXT_EXTENSION;\n                }\n            } else if (useDefaults) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding default binary extension\");\n                }\n                extension = Constants.DEFAULT_DL_BINARY_EXTENSION;\n            }\n        }\n        return extension;\n    }\n\n    private static String chooseExtensionFromFilename(String mimeType, int destination,\n            String filename, int lastDotIndex) {\n        String extension = null;\n        if (mimeType != null) {\n            // Compare the last segment of the extension against the mime type.\n            // If there's a mismatch, discard the entire extension.\n            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                    filename.substring(lastDotIndex + 1));\n            if (typeFromExt == null || !typeFromExt.equalsIgnoreCase(mimeType)) {\n                extension = chooseExtensionFromMimeType(mimeType, false);\n                if (extension != null) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"substituting extension from type\");\n                    }\n                } else {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                    }\n                }\n            }\n        }\n        if (extension == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"keeping extension\");\n            }\n            extension = filename.substring(lastDotIndex);\n        }\n        return extension;\n    }\n\n    private static boolean isFilenameAvailableLocked(File[] parents, String name) {\n        if (Constants.RECOVERY_DIRECTORY.equalsIgnoreCase(name)) return false;\n\n        for (File parent : parents) {\n            if (new File(parent, name).exists()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static String generateAvailableFilenameLocked(\n            File[] parents, String prefix, String suffix) throws IOException {\n        String name = prefix + suffix;\n        name = removeInvalidCharsAndGenerateName(name);\n        if (isFilenameAvailableLocked(parents, name)) {\n            return name;\n        }\n\n        /*\n        * This number is used to generate partially randomized filenames to avoid\n        * collisions.\n        * It starts at 1.\n        * The next 9 iterations increment it by 1 at a time (up to 10).\n        * The next 9 iterations increment it by 1 to 10 (random) at a time.\n        * The next 9 iterations increment it by 1 to 100 (random) at a time.\n        * ... Up to the point where it increases by 100000000 at a time.\n        * (the maximum value that can be reached is 1000000000)\n        * As soon as a number is reached that generates a filename that doesn't exist,\n        *     that filename is used.\n        * If the filename coming in is [base].[ext], the generated filenames are\n        *     [base]-[sequence].[ext].\n        */\n        int sequence = 1;\n        for (int magnitude = 1; magnitude < 1000000000; magnitude *= 10) {\n            for (int iteration = 0; iteration < 9; ++iteration) {\n                name = prefix + Constants.FILENAME_SEQUENCE_SEPARATOR + sequence + suffix;\n                name = removeInvalidCharsAndGenerateName(name);\n                if (isFilenameAvailableLocked(parents, name)) {\n                    return name;\n                }\n                sequence += sRandom.nextInt(magnitude) + 1;\n            }\n        }\n\n        throw new IOException(\"Failed to generate an available filename\");\n    }\n\n    public static Uri convertToMediaStoreDownloadsUri(Uri mediaStoreUri) {\n        final String volumeName = MediaStore.getVolumeName(mediaStoreUri);\n        final long id = android.content.ContentUris.parseId(mediaStoreUri);\n        return MediaStore.Downloads.getContentUri(volumeName, id);\n    }\n\n    public static Uri triggerMediaScan(android.content.ContentProviderClient mediaProviderClient,\n            File file) {\n        return MediaStore.scanFile(ContentResolver.wrap(mediaProviderClient), file);\n    }\n\n    public static final Uri getContentUriForPath(Context context, String path) {\n        final StorageManager sm = context.getSystemService(StorageManager.class);\n        final String volumeName = sm.getStorageVolume(new File(path)).getMediaStoreVolumeName();\n        return MediaStore.Downloads.getContentUri(volumeName);\n    }\n\n    public static boolean isFileInExternalAndroidDirs(String filePath) {\n        return PATTERN_ANDROID_DIRS.matcher(filePath).matches();\n    }\n\n    static boolean isFilenameValid(Context context, File file) {\n        return isFilenameValid(context, file, true);\n    }\n\n    static boolean isFilenameValidInExternal(Context context, File file) {\n        return isFilenameValid(context, file, false);\n    }\n\n    /**\n     * Test if given file exists in one of the package-specific external storage\n     * directories that are always writable to apps, regardless of storage\n     * permission.\n     */\n    static boolean isFilenameValidInExternalPackage(File file, String packageName) {\n        try {\n            if (containsCanonical(buildExternalStorageAppDataDirs(packageName), file) ||\n                    containsCanonical(buildExternalStorageAppObbDirs(packageName), file) ||\n                    containsCanonical(buildExternalStorageAppMediaDirs(packageName), file)) {\n                return true;\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    static boolean isFilenameValidInExternalObbDir(File file) {\n        try {\n            if (containsCanonical(buildExternalStorageAndroidObbDirs(), file)) {\n                return true;\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if given file exists in one of the private package-specific external storage\n     * directories.\n     */\n    static boolean isFileInPrivateExternalAndroidDirs(File file) {\n        try {\n            return PATTERN_ANDROID_PRIVATE_DIRS.matcher(file.getCanonicalPath()).matches();\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks destination file path restrictions adhering to App privacy restrictions\n     *\n     * Note: This method is extracted to a static method for better test coverage.\n     */\n    @VisibleForTesting\n    static void checkDestinationFilePathRestrictions(File file, String callingPackage,\n            Context context, AppOpsManager appOpsManager, String callingAttributionTag,\n            boolean isLegacyMode, boolean allowDownloadsDirOnly) {\n        boolean isFileNameValid = allowDownloadsDirOnly ? isFilenameValidInPublicDownloadsDir(file)\n                : isFilenameValidInKnownPublicDir(file.getAbsolutePath());\n        if (isFilenameValidInExternalPackage(file, callingPackage) || isFileNameValid) {\n            // No permissions required for paths belonging to calling package or\n            // public downloads dir.\n            return;\n        } else if (isFilenameValidInExternalObbDir(file) &&\n                isCallingAppInstaller(context, appOpsManager, callingPackage)) {\n            // Installers are allowed to download in OBB dirs, even outside their own package\n            return;\n        } else if (isFileInPrivateExternalAndroidDirs(file)) {\n            // Positive cases of writing to external Android dirs is covered in the if blocks above.\n            // If the caller made it this far, then it cannot write to this path as it is restricted\n            // from writing to other app's external Android dirs.\n            throw new SecurityException(\"Unsupported path \" + file);\n        } else if (isLegacyMode && isFilenameValidInExternal(context, file)) {\n            // Otherwise we require write permission\n            context.enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            if (appOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    callingPackage, Binder.getCallingUid(), callingAttributionTag, null)\n                    != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private static boolean isCallingAppInstaller(Context context, AppOpsManager appOpsManager,\n            String callingPackage) {\n        return (appOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\")\n                == AppOpsManager.MODE_ALLOWED)\n                || (context.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES)\n                == PackageManager.PERMISSION_GRANTED);\n    }\n\n    static boolean isFilenameValidInPublicDownloadsDir(File file) {\n        try {\n            if (containsCanonical(buildExternalStoragePublicDirs(\n                    Environment.DIRECTORY_DOWNLOADS), file)) {\n                return true;\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    @com.android.internal.annotations.VisibleForTesting\n    public static boolean isFilenameValidInKnownPublicDir(@Nullable String filePath) {\n        if (filePath == null) {\n            return false;\n        }\n        final Matcher matcher = PATTERN_PUBLIC_DIRS.matcher(filePath);\n        if (matcher.matches()) {\n            final String publicDir = matcher.group(1);\n            return ArrayUtils.contains(Environment.STANDARD_DIRECTORIES, publicDir);\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the filename looks legitimate for security purposes. This\n     * prevents us from opening files that aren't actually downloads.\n     */\n    static boolean isFilenameValid(Context context, File file, boolean allowInternal) {\n        try {\n            if (allowInternal) {\n                if (containsCanonical(context.getFilesDir(), file)\n                        || containsCanonical(context.getCacheDir(), file)\n                        || containsCanonical(Environment.getDownloadCacheDirectory(), file)) {\n                    return true;\n                }\n            }\n\n            final StorageVolume[] volumes = StorageManager.getVolumeList(UserHandle.myUserId(),\n                    StorageManager.FLAG_FOR_WRITE);\n            for (StorageVolume volume : volumes) {\n                if (containsCanonical(volume.getPathFile(), file)) {\n                    return true;\n                }\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    private static final Pattern PATTERN_RELATIVE_PATH = Pattern.compile(\n            \"(?i)^/storage/(?:emulated/[0-9]+/|[^/]+/)(Android/sandbox/([^/]+)/)?\");\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    private static final Pattern PATTERN_VOLUME_NAME = Pattern.compile(\n            \"(?i)^/storage/([^/]+)\");\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    private static @Nullable String normalizeUuid(@Nullable String fsUuid) {\n        return fsUuid != null ? fsUuid.toLowerCase(Locale.ROOT) : null;\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    public static @Nullable String extractVolumeName(@Nullable String data) {\n        if (data == null) return null;\n        final Matcher matcher = PATTERN_VOLUME_NAME.matcher(data);\n        if (matcher.find()) {\n            final String volumeName = matcher.group(1);\n            if (volumeName.equals(\"emulated\")) {\n                return MediaStore.VOLUME_EXTERNAL_PRIMARY;\n            } else {\n                return normalizeUuid(volumeName);\n            }\n        } else {\n            return MediaStore.VOLUME_INTERNAL;\n        }\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    public static @Nullable String extractRelativePath(@Nullable String data) {\n        if (data == null) return null;\n        final Matcher matcher = PATTERN_RELATIVE_PATH.matcher(data);\n        if (matcher.find()) {\n            final int lastSlash = data.lastIndexOf('/');\n            if (lastSlash == -1 || lastSlash < matcher.end()) {\n                // This is a file in the top-level directory, so relative path is \"/\"\n                // which is different than null, which means unknown path\n                return \"/\";\n            } else {\n                return data.substring(matcher.end(), lastSlash + 1);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    public static @Nullable String extractDisplayName(@Nullable String data) {\n        if (data == null) return null;\n        if (data.indexOf('/') == -1) {\n            return data;\n        }\n        if (data.endsWith(\"/\")) {\n            data = data.substring(0, data.length() - 1);\n        }\n        return data.substring(data.lastIndexOf('/') + 1);\n    }\n\n    private static boolean containsCanonical(File dir, File file) throws IOException {\n        return FileUtils.contains(dir.getCanonicalFile(), file);\n    }\n\n    private static boolean containsCanonical(File[] dirs, File file) throws IOException {\n        for (File dir : dirs) {\n            if (containsCanonical(dir, file)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static File getRunningDestinationDirectory(Context context, int destination)\n            throws IOException {\n        return getDestinationDirectory(context, destination, true);\n    }\n\n    public static File getSuccessDestinationDirectory(Context context, int destination)\n            throws IOException {\n        return getDestinationDirectory(context, destination, false);\n    }\n\n    private static File getDestinationDirectory(Context context, int destination, boolean running)\n            throws IOException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                if (running) {\n                    return context.getFilesDir();\n                } else {\n                    return context.getCacheDir();\n                }\n\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                final File target = new File(\n                        Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS);\n                if (!target.isDirectory() && target.mkdirs()) {\n                    throw new IOException(\"unable to create external downloads directory\");\n                }\n                return target;\n\n            default:\n                throw new IllegalStateException(\"unexpected destination: \" + destination);\n        }\n    }\n\n    @VisibleForTesting\n    public static void handleRemovedUidEntries(@NonNull Context context,\n            ContentProvider downloadProvider, int removedUid) {\n        final SparseArray<String> knownUids = new SparseArray<>();\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        final ArrayList<Long> idsToOrphan = new ArrayList<>();\n        final String selection = removedUid == INVALID_UID ? Constants.UID + \" IS NOT NULL\"\n                : Constants.UID + \"=\" + removedUid;\n        try (Cursor cursor = downloadProvider.query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._ID, Constants.UID, COLUMN_DESTINATION, _DATA },\n                selection, null, null)) {\n            while (cursor.moveToNext()) {\n                final long downloadId = cursor.getLong(0);\n                final int uid = cursor.getInt(1);\n\n                final String ownerPackageName;\n                final int index = knownUids.indexOfKey(uid);\n                if (index >= 0) {\n                    ownerPackageName = knownUids.valueAt(index);\n                } else {\n                    ownerPackageName = getPackageForUid(context, uid);\n                    knownUids.put(uid, ownerPackageName);\n                }\n\n                if (ownerPackageName == null) {\n                    final int destination = cursor.getInt(2);\n                    final String filePath = cursor.getString(3);\n\n                    if ((destination == DESTINATION_EXTERNAL\n                            || destination == DESTINATION_FILE_URI\n                            || destination == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                            && isFilenameValidInKnownPublicDir(filePath)) {\n                        idsToOrphan.add(downloadId);\n                    } else {\n                        idsToDelete.add(downloadId);\n                    }\n                }\n            }\n        }\n\n        if (idsToOrphan.size() > 0) {\n            Log.i(Constants.TAG, \"Orphaning downloads with ids \"\n                    + Arrays.toString(idsToOrphan.toArray()) + \" as owner package is removed\");\n            final ContentValues values = new ContentValues();\n            values.putNull(Constants.UID);\n            downloadProvider.update(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, values,\n                    buildQueryWithIds(idsToOrphan), null);\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG, \"Deleting downloads with ids \"\n                    + Arrays.toString(idsToDelete.toArray()) + \" as owner package is removed\");\n            downloadProvider.delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    buildQueryWithIds(idsToDelete), null);\n        }\n    }\n\n    public static String buildQueryWithIds(ArrayList<Long> downloadIds) {\n        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + \" in (\");\n        final int size = downloadIds.size();\n        for (int i = 0; i < size; i++) {\n            queryBuilder.append(downloadIds.get(i));\n            queryBuilder.append((i == size - 1) ? \")\" : \",\");\n        }\n        return queryBuilder.toString();\n    }\n\n    public static String getPackageForUid(Context context, int uid) {\n        String[] packages = context.getPackageManager().getPackagesForUid(uid);\n        if (packages == null || packages.length == 0) {\n            return null;\n        }\n        // For permission related purposes, any package belonging to the given uid should work.\n        return packages[0];\n    }\n\n    public static String removeInvalidCharsAndGenerateName(String name) {\n        String newValue = name.replaceAll(\"[*/:<>?\\\\|]\", \"_\");\n        if (onlyContainsUnderscore(newValue)) {\n            newValue = DEFAULT_DOWNLOAD_FILE_NAME_PREFIX + System.currentTimeMillis();\n        }\n        return newValue;\n    }\n\n    private static boolean onlyContainsUnderscore(String name) {\n        return name != null && name.replaceAll(\"_\",\"\").trim().isEmpty();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.os.Environment.buildExternalStorageAndroidObbDirs;\nimport static android.os.Environment.buildExternalStorageAppDataDirs;\nimport static android.os.Environment.buildExternalStorageAppMediaDirs;\nimport static android.os.Environment.buildExternalStorageAppObbDirs;\nimport static android.os.Environment.buildExternalStoragePublicDirs;\nimport static android.os.Process.INVALID_UID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.FLAG_REQUIRES_CHARGING;\nimport static android.provider.Downloads.Impl.FLAG_REQUIRES_DEVICE_IDLE;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.job.JobInfo;\nimport android.app.job.JobScheduler;\nimport android.content.ComponentName;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.os.UserHandle;\nimport android.os.storage.StorageManager;\nimport android.os.storage.StorageVolume;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.SparseArray;\nimport android.webkit.MimeTypeMap;\n\nimport com.android.internal.annotations.VisibleForTesting;\nimport com.android.internal.util.ArrayUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.System;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Some helper functions for the download manager\n */\npublic class Helpers {\n    public static Random sRandom = new Random(SystemClock.uptimeMillis());\n\n    /** Regex used to parse content-disposition headers */\n    private static final Pattern CONTENT_DISPOSITION_PATTERN =\n            Pattern.compile(\"attachment;\\\\s*filename\\\\s*=\\\\s*\\\"([^\\\"]*)\\\"\");\n\n    private static final Pattern PATTERN_ANDROID_DIRS =\n            Pattern.compile(\"(?i)^/storage/[^/]+(?:/[0-9]+)?/Android/(?:data|obb|media)/.+\");\n\n    private static final Pattern PATTERN_ANDROID_PRIVATE_DIRS =\n            Pattern.compile(\"(?i)^/storage/[^/]+(?:/[0-9]+)?/Android/(data|obb)/.+\");\n\n    private static final Pattern PATTERN_PUBLIC_DIRS =\n            Pattern.compile(\"(?i)^/storage/[^/]+(?:/[0-9]+)?/([^/]+)/.+\");\n\n    @VisibleForTesting\n    static final String DEFAULT_DOWNLOAD_FILE_NAME_PREFIX = \"Download_\";\n\n    private static final Object sUniqueLock = new Object();\n\n    private static HandlerThread sAsyncHandlerThread;\n    private static Handler sAsyncHandler;\n\n    private static SystemFacade sSystemFacade;\n    private static DownloadNotifier sNotifier;\n\n    private Helpers() {\n    }\n\n    public synchronized static Handler getAsyncHandler() {\n        if (sAsyncHandlerThread == null) {\n            sAsyncHandlerThread = new HandlerThread(\"sAsyncHandlerThread\",\n                    Process.THREAD_PRIORITY_BACKGROUND);\n            sAsyncHandlerThread.start();\n            sAsyncHandler = new Handler(sAsyncHandlerThread.getLooper());\n        }\n        return sAsyncHandler;\n    }\n\n    @VisibleForTesting\n    public synchronized static void setSystemFacade(SystemFacade systemFacade) {\n        sSystemFacade = systemFacade;\n    }\n\n    public synchronized static SystemFacade getSystemFacade(Context context) {\n        if (sSystemFacade == null) {\n            sSystemFacade = new RealSystemFacade(context);\n        }\n        return sSystemFacade;\n    }\n\n    public synchronized static DownloadNotifier getDownloadNotifier(Context context) {\n        if (sNotifier == null) {\n            sNotifier = new DownloadNotifier(context);\n        }\n        return sNotifier;\n    }\n\n    public static String getString(Cursor cursor, String col) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(col));\n    }\n\n    public static int getInt(Cursor cursor, String col) {\n        return cursor.getInt(cursor.getColumnIndexOrThrow(col));\n    }\n\n    public static void scheduleJob(Context context, long downloadId) {\n        final boolean scheduled = scheduleJob(context,\n                DownloadInfo.queryDownloadInfo(context, downloadId));\n        if (!scheduled) {\n            // If we didn't schedule a future job, kick off a notification\n            // update pass immediately\n            getDownloadNotifier(context).update();\n        }\n    }\n\n    /**\n     * Schedule (or reschedule) a job for the given {@link DownloadInfo} using\n     * its current state to define job constraints.\n     */\n    public static boolean scheduleJob(Context context, DownloadInfo info) {\n        if (info == null) return false;\n\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        // Tear down any existing job for this download\n        final int jobId = (int) info.mId;\n        scheduler.cancel(jobId);\n\n        // Skip scheduling if download is paused or finished\n        if (!info.isReadyToSchedule()) return false;\n\n        final JobInfo.Builder builder = new JobInfo.Builder(jobId,\n                new ComponentName(context, DownloadJobService.class));\n\n        // When this download will show a notification, run with a higher\n        // bias, since it's effectively a foreground service\n        if (info.isVisible()) {\n            builder.setBias(JobInfo.BIAS_FOREGROUND_SERVICE);\n            builder.setFlags(JobInfo.FLAG_WILL_BE_FOREGROUND);\n        }\n\n        // We might have a backoff constraint due to errors\n        final long latency = info.getMinimumLatency();\n        if (latency > 0) {\n            builder.setMinimumLatency(latency);\n        }\n\n        // We always require a network, but the type of network might be further\n        // restricted based on download request or user override\n        builder.setRequiredNetworkType(info.getRequiredNetworkType(info.mTotalBytes));\n\n        if ((info.mFlags & FLAG_REQUIRES_CHARGING) != 0) {\n            builder.setRequiresCharging(true);\n        }\n        if ((info.mFlags & FLAG_REQUIRES_DEVICE_IDLE) != 0) {\n            builder.setRequiresDeviceIdle(true);\n        }\n\n        // Provide estimated network size, when possible\n        if (info.mTotalBytes > 0) {\n            if (info.mCurrentBytes > 0 && !TextUtils.isEmpty(info.mETag)) {\n                // If we're resuming an in-progress download, we only need to\n                // download the remaining bytes.\n                final long remainingBytes;\n                if (info.mTotalBytes > info.mCurrentBytes) {\n                    remainingBytes = info.mTotalBytes - info.mCurrentBytes;\n                } else {\n                    // We've downloaded more than we expected. We no longer know how much is left.\n                    Log.i(TAG, \"Downloaded more than expected during previous executions\");\n                    remainingBytes = JobInfo.NETWORK_BYTES_UNKNOWN;\n                }\n                builder.setEstimatedNetworkBytes(remainingBytes,\n                        JobInfo.NETWORK_BYTES_UNKNOWN);\n            } else {\n                builder.setEstimatedNetworkBytes(info.mTotalBytes, JobInfo.NETWORK_BYTES_UNKNOWN);\n            }\n        }\n\n        // If package name was filtered during insert (probably due to being\n        // invalid), blame based on the requesting UID instead\n        String packageName = info.mPackage;\n        if (packageName == null) {\n            packageName = context.getPackageManager().getPackagesForUid(info.mUid)[0];\n        }\n\n        scheduler.scheduleAsPackage(builder.build(), packageName, UserHandle.myUserId(), TAG);\n        return true;\n    }\n\n    /*\n     * Parse the Content-Disposition HTTP Header. The format of the header\n     * is defined here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html\n     * This header provides a filename for content that is going to be\n     * downloaded to the file system. We only support the attachment type.\n     */\n    private static String parseContentDisposition(String contentDisposition) {\n        try {\n            Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);\n            if (m.find()) {\n                return m.group(1);\n            }\n        } catch (IllegalStateException ex) {\n             // This function is defined as returning null when it can't parse the header\n        }\n        return null;\n    }\n\n    /**\n     * Creates a filename (where the file should be saved) from info about a download.\n     * This file will be touched to reserve it.\n     */\n    static String generateSaveFile(Context context, String url, String hint,\n            String contentDisposition, String contentLocation, String mimeType, int destination)\n            throws IOException {\n\n        final File parent;\n        final File[] parentTest;\n        String name = null;\n\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            final File file = new File(Uri.parse(hint).getPath());\n            parent = file.getParentFile().getAbsoluteFile();\n            parentTest = new File[] { parent };\n            name = file.getName();\n        } else {\n            parent = getRunningDestinationDirectory(context, destination);\n            parentTest = new File[] {\n                    parent,\n                    getSuccessDestinationDirectory(context, destination)\n            };\n            name = chooseFilename(url, hint, contentDisposition, contentLocation);\n        }\n\n        // Ensure target directories are ready\n        for (File test : parentTest) {\n            if (!(test.isDirectory() || test.mkdirs())) {\n                throw new IOException(\"Failed to create parent for \" + test);\n            }\n        }\n\n        if (DownloadDrmHelper.isDrmConvertNeeded(mimeType)) {\n            name = DownloadDrmHelper.modifyDrmFwLockFileExtension(name);\n        }\n\n        final String prefix;\n        final String suffix;\n        final int dotIndex = name.lastIndexOf('.');\n        final boolean missingExtension = dotIndex < 0;\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            // Destination is explicitly set - do not change the extension\n            if (missingExtension) {\n                prefix = name;\n                suffix = \"\";\n            } else {\n                prefix = name.substring(0, dotIndex);\n                suffix = name.substring(dotIndex);\n            }\n        } else {\n            // Split filename between base and extension\n            // Add an extension if filename does not have one\n            if (missingExtension) {\n                prefix = name;\n                suffix = chooseExtensionFromMimeType(mimeType, true);\n            } else {\n                prefix = name.substring(0, dotIndex);\n                suffix = chooseExtensionFromFilename(mimeType, destination, name, dotIndex);\n            }\n        }\n\n        synchronized (sUniqueLock) {\n            name = generateAvailableFilenameLocked(parentTest, prefix, suffix);\n\n            // Claim this filename inside lock to prevent other threads from\n            // clobbering us. We're not paranoid enough to use O_EXCL.\n            final File file = new File(parent, name);\n            file.createNewFile();\n            return file.getAbsolutePath();\n        }\n    }\n\n    private static String chooseFilename(String url, String hint, String contentDisposition,\n            String contentLocation) {\n        String filename = null;\n\n        // First, try to use the hint from the application, if there's one\n        if (filename == null && hint != null && !hint.endsWith(\"/\")) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"getting filename from hint\");\n            }\n            int index = hint.lastIndexOf('/') + 1;\n            if (index > 0) {\n                filename = hint.substring(index);\n            } else {\n                filename = hint;\n            }\n        }\n\n        // If we couldn't do anything with the hint, move toward the content disposition\n        if (filename == null && contentDisposition != null) {\n            filename = parseContentDisposition(contentDisposition);\n            if (filename != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-disposition\");\n                }\n                int index = filename.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = filename.substring(index);\n                }\n            }\n        }\n\n        // If we still have nothing at this point, try the content location\n        if (filename == null && contentLocation != null) {\n            String decodedContentLocation = Uri.decode(contentLocation);\n            if (decodedContentLocation != null\n                    && !decodedContentLocation.endsWith(\"/\")\n                    && decodedContentLocation.indexOf('?') < 0) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-location\");\n                }\n                int index = decodedContentLocation.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = decodedContentLocation.substring(index);\n                } else {\n                    filename = decodedContentLocation;\n                }\n            }\n        }\n\n        // If all the other http-related approaches failed, use the plain uri\n        if (filename == null) {\n            String decodedUrl = Uri.decode(url);\n            if (decodedUrl != null\n                    && !decodedUrl.endsWith(\"/\") && decodedUrl.indexOf('?') < 0) {\n                int index = decodedUrl.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"getting filename from uri\");\n                    }\n                    filename = decodedUrl.substring(index);\n                }\n            }\n        }\n\n        // Finally, if couldn't get filename from URI, get a generic filename\n        if (filename == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"using default filename\");\n            }\n            filename = Constants.DEFAULT_DL_FILENAME;\n        }\n\n        // The VFAT file system is assumed as target for downloads.\n        // Replace invalid characters according to the specifications of VFAT.\n        filename = FileUtils.buildValidFatFilename(filename);\n\n        return filename;\n    }\n\n    private static String chooseExtensionFromMimeType(String mimeType, boolean useDefaults) {\n        String extension = null;\n        if (mimeType != null) {\n            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);\n            if (extension != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding extension from type\");\n                }\n                extension = \".\" + extension;\n            } else {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                }\n            }\n        }\n        if (extension == null) {\n            if (mimeType != null && mimeType.toLowerCase().startsWith(\"text/\")) {\n                if (mimeType.equalsIgnoreCase(\"text/html\")) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default html extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_HTML_EXTENSION;\n                } else if (useDefaults) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default text extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_TEXT_EXTENSION;\n                }\n            } else if (useDefaults) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding default binary extension\");\n                }\n                extension = Constants.DEFAULT_DL_BINARY_EXTENSION;\n            }\n        }\n        return extension;\n    }\n\n    private static String chooseExtensionFromFilename(String mimeType, int destination,\n            String filename, int lastDotIndex) {\n        String extension = null;\n        if (mimeType != null) {\n            // Compare the last segment of the extension against the mime type.\n            // If there's a mismatch, discard the entire extension.\n            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                    filename.substring(lastDotIndex + 1));\n            if (typeFromExt == null || !typeFromExt.equalsIgnoreCase(mimeType)) {\n                extension = chooseExtensionFromMimeType(mimeType, false);\n                if (extension != null) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"substituting extension from type\");\n                    }\n                } else {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                    }\n                }\n            }\n        }\n        if (extension == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"keeping extension\");\n            }\n            extension = filename.substring(lastDotIndex);\n        }\n        return extension;\n    }\n\n    private static boolean isFilenameAvailableLocked(File[] parents, String name) {\n        if (Constants.RECOVERY_DIRECTORY.equalsIgnoreCase(name)) return false;\n\n        for (File parent : parents) {\n            if (new File(parent, name).exists()) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    private static String generateAvailableFilenameLocked(\n            File[] parents, String prefix, String suffix) throws IOException {\n        String name = prefix + suffix;\n        name = removeInvalidCharsAndGenerateName(name);\n        if (isFilenameAvailableLocked(parents, name)) {\n            return name;\n        }\n\n        /*\n        * This number is used to generate partially randomized filenames to avoid\n        * collisions.\n        * It starts at 1.\n        * The next 9 iterations increment it by 1 at a time (up to 10).\n        * The next 9 iterations increment it by 1 to 10 (random) at a time.\n        * The next 9 iterations increment it by 1 to 100 (random) at a time.\n        * ... Up to the point where it increases by 100000000 at a time.\n        * (the maximum value that can be reached is 1000000000)\n        * As soon as a number is reached that generates a filename that doesn't exist,\n        *     that filename is used.\n        * If the filename coming in is [base].[ext], the generated filenames are\n        *     [base]-[sequence].[ext].\n        */\n        int sequence = 1;\n        for (int magnitude = 1; magnitude < 1000000000; magnitude *= 10) {\n            for (int iteration = 0; iteration < 9; ++iteration) {\n                name = prefix + Constants.FILENAME_SEQUENCE_SEPARATOR + sequence + suffix;\n                name = removeInvalidCharsAndGenerateName(name);\n                if (isFilenameAvailableLocked(parents, name)) {\n                    return name;\n                }\n                sequence += sRandom.nextInt(magnitude) + 1;\n            }\n        }\n\n        throw new IOException(\"Failed to generate an available filename\");\n    }\n\n    public static Uri convertToMediaStoreDownloadsUri(Uri mediaStoreUri) {\n        final String volumeName = MediaStore.getVolumeName(mediaStoreUri);\n        final long id = android.content.ContentUris.parseId(mediaStoreUri);\n        return MediaStore.Downloads.getContentUri(volumeName, id);\n    }\n\n    public static Uri triggerMediaScan(android.content.ContentProviderClient mediaProviderClient,\n            File file) {\n        return MediaStore.scanFile(ContentResolver.wrap(mediaProviderClient), file);\n    }\n\n    public static final Uri getContentUriForPath(Context context, String path) {\n        final StorageManager sm = context.getSystemService(StorageManager.class);\n        final String volumeName = sm.getStorageVolume(new File(path)).getMediaStoreVolumeName();\n        return MediaStore.Downloads.getContentUri(volumeName);\n    }\n\n    public static boolean isFileInExternalAndroidDirs(String filePath) {\n        return PATTERN_ANDROID_DIRS.matcher(filePath).matches();\n    }\n\n    static boolean isFilenameValid(Context context, File file) {\n        return isFilenameValid(context, file, true);\n    }\n\n    static boolean isFilenameValidInExternal(Context context, File file) {\n        return isFilenameValid(context, file, false);\n    }\n\n    /**\n     * Test if given file exists in one of the package-specific external storage\n     * directories that are always writable to apps, regardless of storage\n     * permission.\n     */\n    static boolean isFilenameValidInExternalPackage(File file, String packageName) {\n        try {\n            if (containsCanonical(buildExternalStorageAppDataDirs(packageName), file) ||\n                    containsCanonical(buildExternalStorageAppObbDirs(packageName), file) ||\n                    containsCanonical(buildExternalStorageAppMediaDirs(packageName), file)) {\n                return true;\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    static boolean isFilenameValidInExternalObbDir(File file) {\n        try {\n            if (containsCanonical(buildExternalStorageAndroidObbDirs(), file)) {\n                return true;\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if given file exists in one of the private package-specific external storage\n     * directories.\n     */\n    static boolean isFileInPrivateExternalAndroidDirs(File file) {\n        try {\n            return PATTERN_ANDROID_PRIVATE_DIRS.matcher(file.getCanonicalPath()).matches();\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks destination file path restrictions adhering to App privacy restrictions\n     *\n     * Note: This method is extracted to a static method for better test coverage.\n     */\n    @VisibleForTesting\n    static void checkDestinationFilePathRestrictions(File file, String callingPackage,\n            Context context, AppOpsManager appOpsManager, String callingAttributionTag,\n            boolean isLegacyMode, boolean allowDownloadsDirOnly) {\n        boolean isFileNameValid = allowDownloadsDirOnly ? isFilenameValidInPublicDownloadsDir(file)\n                : isFilenameValidInKnownPublicDir(file.getAbsolutePath());\n        if (isFilenameValidInExternalPackage(file, callingPackage) || isFileNameValid) {\n            // No permissions required for paths belonging to calling package or\n            // public downloads dir.\n            return;\n        } else if (isFilenameValidInExternalObbDir(file) &&\n                isCallingAppInstaller(context, appOpsManager, callingPackage)) {\n            // Installers are allowed to download in OBB dirs, even outside their own package\n            return;\n        } else if (isFileInPrivateExternalAndroidDirs(file)) {\n            // Positive cases of writing to external Android dirs is covered in the if blocks above.\n            // If the caller made it this far, then it cannot write to this path as it is restricted\n            // from writing to other app's external Android dirs.\n            throw new SecurityException(\"Unsupported path \" + file);\n        } else if (isLegacyMode && isFilenameValidInExternal(context, file)) {\n            // Otherwise we require write permission\n            context.enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            if (appOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    callingPackage, Binder.getCallingUid(), callingAttributionTag, null)\n                    != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private static boolean isCallingAppInstaller(Context context, AppOpsManager appOpsManager,\n            String callingPackage) {\n        return (appOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\")\n                == AppOpsManager.MODE_ALLOWED)\n                || (context.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES)\n                == PackageManager.PERMISSION_GRANTED);\n    }\n\n    static boolean isFilenameValidInPublicDownloadsDir(File file) {\n        try {\n            if (containsCanonical(buildExternalStoragePublicDirs(\n                    Environment.DIRECTORY_DOWNLOADS), file)) {\n                return true;\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    @com.android.internal.annotations.VisibleForTesting\n    public static boolean isFilenameValidInKnownPublicDir(@Nullable String filePath) {\n        if (filePath == null) {\n            return false;\n        }\n        final Matcher matcher = PATTERN_PUBLIC_DIRS.matcher(filePath);\n        if (matcher.matches()) {\n            final String publicDir = matcher.group(1);\n            return ArrayUtils.contains(Environment.STANDARD_DIRECTORIES, publicDir);\n        }\n        return false;\n    }\n\n    /**\n     * Checks whether the filename looks legitimate for security purposes. This\n     * prevents us from opening files that aren't actually downloads.\n     */\n    static boolean isFilenameValid(Context context, File file, boolean allowInternal) {\n        try {\n            if (allowInternal) {\n                if (containsCanonical(context.getFilesDir(), file)\n                        || containsCanonical(context.getCacheDir(), file)\n                        || containsCanonical(Environment.getDownloadCacheDirectory(), file)) {\n                    return true;\n                }\n            }\n\n            final StorageVolume[] volumes = StorageManager.getVolumeList(UserHandle.myUserId(),\n                    StorageManager.FLAG_FOR_WRITE);\n            for (StorageVolume volume : volumes) {\n                if (containsCanonical(volume.getPathFile(), file)) {\n                    return true;\n                }\n            }\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + file.getAbsolutePath(), e);\n            return false;\n        }\n\n        return false;\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    private static final Pattern PATTERN_RELATIVE_PATH = Pattern.compile(\n            \"(?i)^/storage/(?:emulated/[0-9]+/|[^/]+/)(Android/sandbox/([^/]+)/)?\");\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    private static final Pattern PATTERN_VOLUME_NAME = Pattern.compile(\n            \"(?i)^/storage/([^/]+)\");\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    private static @Nullable String normalizeUuid(@Nullable String fsUuid) {\n        return fsUuid != null ? fsUuid.toLowerCase(Locale.ROOT) : null;\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    public static @Nullable String extractVolumeName(@Nullable String data) {\n        if (data == null) return null;\n        final Matcher matcher = PATTERN_VOLUME_NAME.matcher(data);\n        if (matcher.find()) {\n            final String volumeName = matcher.group(1);\n            if (volumeName.equals(\"emulated\")) {\n                return MediaStore.VOLUME_EXTERNAL_PRIMARY;\n            } else {\n                return normalizeUuid(volumeName);\n            }\n        } else {\n            return MediaStore.VOLUME_INTERNAL;\n        }\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    public static @Nullable String extractRelativePath(@Nullable String data) {\n        if (data == null) return null;\n        final Matcher matcher = PATTERN_RELATIVE_PATH.matcher(data);\n        if (matcher.find()) {\n            final int lastSlash = data.lastIndexOf('/');\n            if (lastSlash == -1 || lastSlash < matcher.end()) {\n                // This is a file in the top-level directory, so relative path is \"/\"\n                // which is different than null, which means unknown path\n                return \"/\";\n            } else {\n                return data.substring(matcher.end(), lastSlash + 1);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Shamelessly borrowed from\n     * {@code packages/providers/MediaProvider/src/com/android/providers/media/util/FileUtils.java}.\n     */\n    public static @Nullable String extractDisplayName(@Nullable String data) {\n        if (data == null) return null;\n        if (data.indexOf('/') == -1) {\n            return data;\n        }\n        if (data.endsWith(\"/\")) {\n            data = data.substring(0, data.length() - 1);\n        }\n        return data.substring(data.lastIndexOf('/') + 1);\n    }\n\n    private static boolean containsCanonical(File dir, File file) throws IOException {\n        return FileUtils.contains(dir.getCanonicalFile(), file);\n    }\n\n    private static boolean containsCanonical(File[] dirs, File file) throws IOException {\n        for (File dir : dirs) {\n            if (containsCanonical(dir, file)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static File getRunningDestinationDirectory(Context context, int destination)\n            throws IOException {\n        return getDestinationDirectory(context, destination, true);\n    }\n\n    public static File getSuccessDestinationDirectory(Context context, int destination)\n            throws IOException {\n        return getDestinationDirectory(context, destination, false);\n    }\n\n    private static File getDestinationDirectory(Context context, int destination, boolean running)\n            throws IOException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                if (running) {\n                    return context.getFilesDir();\n                } else {\n                    return context.getCacheDir();\n                }\n\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                final File target = new File(\n                        Environment.getExternalStorageDirectory(), Environment.DIRECTORY_DOWNLOADS);\n                if (!target.isDirectory() && target.mkdirs()) {\n                    throw new IOException(\"unable to create external downloads directory\");\n                }\n                return target;\n\n            default:\n                throw new IllegalStateException(\"unexpected destination: \" + destination);\n        }\n    }\n\n    @VisibleForTesting\n    public static void handleRemovedUidEntries(@NonNull Context context,\n            ContentProvider downloadProvider, int removedUid) {\n        final SparseArray<String> knownUids = new SparseArray<>();\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        final ArrayList<Long> idsToOrphan = new ArrayList<>();\n        final String selection = removedUid == INVALID_UID ? Constants.UID + \" IS NOT NULL\"\n                : Constants.UID + \"=\" + removedUid;\n        try (Cursor cursor = downloadProvider.query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._ID, Constants.UID, COLUMN_DESTINATION, _DATA },\n                selection, null, null)) {\n            while (cursor.moveToNext()) {\n                final long downloadId = cursor.getLong(0);\n                final int uid = cursor.getInt(1);\n\n                final String ownerPackageName;\n                final int index = knownUids.indexOfKey(uid);\n                if (index >= 0) {\n                    ownerPackageName = knownUids.valueAt(index);\n                } else {\n                    ownerPackageName = getPackageForUid(context, uid);\n                    knownUids.put(uid, ownerPackageName);\n                }\n\n                if (ownerPackageName == null) {\n                    final int destination = cursor.getInt(2);\n                    final String filePath = cursor.getString(3);\n\n                    if ((destination == DESTINATION_EXTERNAL\n                            || destination == DESTINATION_FILE_URI\n                            || destination == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                            && isFilenameValidInKnownPublicDir(filePath)) {\n                        idsToOrphan.add(downloadId);\n                    } else {\n                        idsToDelete.add(downloadId);\n                    }\n                }\n            }\n        }\n\n        if (idsToOrphan.size() > 0) {\n            Log.i(Constants.TAG, \"Orphaning downloads with ids \"\n                    + Arrays.toString(idsToOrphan.toArray()) + \" as owner package is removed\");\n            final ContentValues values = new ContentValues();\n            values.putNull(Constants.UID);\n            downloadProvider.update(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, values,\n                    buildQueryWithIds(idsToOrphan), null);\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG, \"Deleting downloads with ids \"\n                    + Arrays.toString(idsToDelete.toArray()) + \" as owner package is removed\");\n            downloadProvider.delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    buildQueryWithIds(idsToDelete), null);\n        }\n    }\n\n    public static String buildQueryWithIds(ArrayList<Long> downloadIds) {\n        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + \" in (\");\n        final int size = downloadIds.size();\n        for (int i = 0; i < size; i++) {\n            queryBuilder.append(downloadIds.get(i));\n            queryBuilder.append((i == size - 1) ? \")\" : \",\");\n        }\n        return queryBuilder.toString();\n    }\n\n    public static String getPackageForUid(Context context, int uid) {\n        String[] packages = context.getPackageManager().getPackagesForUid(uid);\n        if (packages == null || packages.length == 0) {\n            return null;\n        }\n        // For permission related purposes, any package belonging to the given uid should work.\n        return packages[0];\n    }\n\n    public static String removeInvalidCharsAndGenerateName(String name) {\n        String newValue = name.replaceAll(\"[*/:<>?\\\\|]\", \"_\");\n        if (onlyContainsUnderscore(newValue)) {\n            newValue = DEFAULT_DOWNLOAD_FILE_NAME_PREFIX + System.currentTimeMillis();\n        }\n        return newValue;\n    }\n\n    private static boolean onlyContainsUnderscore(String name) {\n        return name != null && name.replaceAll(\"_\",\"\").trim().isEmpty();\n    }\n}\n","lineNo":206}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        IoUtils.deleteContents(getContext().getFilesDir());\n        IoUtils.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_permissionLess() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions(String filePath, boolean isLegacyMode) {\n        final Context context = getContext();\n        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, TAG, context, appOpsManager,\n                callingAttributionTag, isLegacyMode, /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        IoUtils.deleteContents(getContext().getFilesDir());\n        IoUtils.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_noPermission() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions_noPermission(String filePath,\n            boolean isLegacyMode) {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","lineNo":420}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        IoUtils.deleteContents(getContext().getFilesDir());\n        IoUtils.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_permissionLess() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions(String filePath, boolean isLegacyMode) {\n        final Context context = getContext();\n        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, TAG, context, appOpsManager,\n                callingAttributionTag, isLegacyMode, /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        IoUtils.deleteContents(getContext().getFilesDir());\n        IoUtils.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_noPermission() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions_noPermission(String filePath,\n            boolean isLegacyMode) {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","lineNo":420}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_permissionLess() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions(String filePath, boolean isLegacyMode) {\n        final Context context = getContext();\n        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, TAG, context, appOpsManager,\n                callingAttributionTag, isLegacyMode, /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_noPermission() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions_noPermission(String filePath,\n            boolean isLegacyMode) {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","lineNo":418}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_permissionLess() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions(String filePath, boolean isLegacyMode) {\n        final Context context = getContext();\n        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, TAG, context, appOpsManager,\n                callingAttributionTag, isLegacyMode, /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_noPermission() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions_noPermission(String filePath,\n            boolean isLegacyMode) {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","lineNo":418}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_permissionLess() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions(String filePath, boolean isLegacyMode) {\n        final Context context = getContext();\n        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, TAG, context, appOpsManager,\n                callingAttributionTag, isLegacyMode, /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_noPermission() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions_noPermission(String filePath,\n            boolean isLegacyMode) {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","lineNo":418}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_permissionLess() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions(String filePath, boolean isLegacyMode) {\n        final Context context = getContext();\n        final AppOpsManager appOpsManager = context.getSystemService(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, TAG, context, appOpsManager,\n                callingAttributionTag, isLegacyMode, /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\nimport static android.provider.Downloads.Impl._ID;\n\nimport static com.android.internal.util.ArrayUtils.contains;\n\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.argThat;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.ArgumentMatchers.isNull;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.reset;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.when;\n\nimport android.app.AppOpsManager;\nimport android.content.ContentProvider;\nimport android.content.Context;\nimport android.content.pm.PackageManager;\nimport android.database.MatrixCursor;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Process;\nimport android.provider.Downloads;\n\nimport android.test.AndroidTestCase;\nimport android.test.suitebuilder.annotation.SmallTest;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport java.io.File;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * This test exercises methods in the {@Helpers} utility class.\n */\n@SmallTest\npublic class HelpersTest extends AndroidTestCase {\n    private static final String TAG = \"DownloadManagerHelpersTest\";\n\n    private final static int TEST_UID1 = 11111;\n    private final static int TEST_UID2 = 11112;\n    private final static int TEST_UID3 = 11113;\n\n    private final MockitoHelper mMockitoHelper = new MockitoHelper();\n\n    @Override\n    protected void setUp() throws Exception {\n        super.setUp();\n        // This is necessary for mockito to work\n        System.setProperty(\"dexmaker.dexcache\", mContext.getCacheDir().toString());\n        mMockitoHelper.setUp(getClass());\n    }\n\n    @Override\n    protected void tearDown() throws Exception {\n        mMockitoHelper.tearDown();\n        FsHelper.deleteContents(getContext().getFilesDir());\n        FsHelper.deleteContents(getContext().getCacheDir());\n\n        super.tearDown();\n    }\n\n    public void testGenerateSaveFile() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDupes() throws Exception {\n        final File expected1 = new File(getContext().getFilesDir(), \"file.txt\");\n        final String actual1 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        final File expected2 = new File(getContext().getFilesDir(), \"file-1.txt\");\n        final String actual2 = Helpers.generateSaveFile(getContext(), \"http://example.com/file.txt\",\n                null, null, null, null, Downloads.Impl.DESTINATION_CACHE_PARTITION);\n\n        assertEquals(expected1.getAbsolutePath(), actual1);\n        assertEquals(expected2.getAbsolutePath(), actual2);\n    }\n\n    public void testGenerateSaveFileNoExtension() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"file.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file\", null, null, null,\n                \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileHint() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"meow\");\n        final String hint = Uri.fromFile(expected).toString();\n\n        // Test that we never change requested filename.\n        final String actual = Helpers.generateSaveFile(getContext(), \"url\", hint,\n                \"dispo\", \"locat\", \"video/mp4\", Downloads.Impl.DESTINATION_FILE_URI);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testGenerateSaveFileDisposition() throws Exception {\n        final File expected = new File(getContext().getFilesDir(), \"real.mp4\");\n        final String actual = Helpers.generateSaveFile(getContext(),\n                \"http://example.com/file.txt\", null, \"attachment; filename=\\\"subdir/real.pdf\\\"\",\n                null, \"video/mp4\", Downloads.Impl.DESTINATION_CACHE_PARTITION);\n        assertEquals(expected.getAbsolutePath(), actual);\n    }\n\n    public void testIsFileInExternalAndroidDirs() throws Exception {\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertTrue(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(Helpers.isFileInExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    public void testCheckDestinationFilePathRestrictions_noPermission() throws Exception {\n        // Downloading to our own private app directory should always be allowed, even for\n        // permission-less app\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/data/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/obb/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\n                \"/storage/emulated/0/Android/media/DownloadManagerHelpersTest/test\",\n                /* isLegacyMode */ true);\n\n        // All apps can write to Environment.STANDARD_DIRECTORIES\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n\n        // Apps can never access other app's private directories (Android/data, Android/obb) paths\n        // (unless they are installers in which case they can access Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/obb/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_noPermission(\n                    \"/storage/emulated/0/Android/media/foo\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_installer() throws Exception {\n        // Downloading to other obb dirs should be allowed as installer\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ false);\n        checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/obb/foo/test\",\n                /* isLegacyMode */ true);\n\n        // Installer apps can not access other app's Android/data private dirs\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\n                    \"/storage/emulated/0/Android/data/foo/test\", /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps require WRITE_EXTERNAL_STORAGE permission to access Android/ or Android/media\n        // dirs.\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/ as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_installer(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot write to Android/media as it does not\"\n                    + \" have WRITE_EXTERNAL_STORAGE permission\");\n        } catch (SecurityException expected) {\n        }\n    }\n\n    public void testCheckDestinationFilePathRestrictions_WES() throws Exception {\n        // Apps with WRITE_EXTERNAL_STORAGE can not access other app's private dirs\n        // (Android/data and Android/obb paths)\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/data/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/obb/foo/test\",\n                    /* isLegacyMode */ true);\n            fail(\"Expected SecurityException as caller cannot access other app's private packages\"\n                    + \" even in legacy mode\");\n        } catch (SecurityException expected) {\n        }\n\n        // Non-legacy apps can never access Android/ or Android/media dirs for other packages.\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        try {\n            checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                    /* isLegacyMode */ false);\n            fail(\"Expected SecurityException as caller cannot write to Android dir\");\n        } catch (SecurityException expected) {\n        }\n\n        // Legacy apps with WRITE_EXTERNAL_STORAGE can access shared storage file path including\n        // Android/ and Android/media dirs\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Pictures/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Download/test\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/\",\n                /* isLegacyMode */ true);\n        checkDestinationFilePathRestrictions_WES(\"/storage/emulated/0/Android/media/foo\",\n                /* isLegacyMode */ true);\n    }\n\n    private void checkDestinationFilePathRestrictions_noPermission(String filePath,\n            boolean isLegacyMode) {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_installer(String filePath,\n            boolean isLegacyMode) throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final String callingAttributionTag = \"test\";\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    private void checkDestinationFilePathRestrictions_WES(String filePath, boolean isLegacyMode)\n            throws Exception {\n        final Context mockContext = mock(Context.class);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.WRITE_EXTERNAL_STORAGE))\n                .thenReturn(PackageManager.PERMISSION_GRANTED);\n        when(mockContext.checkCallingOrSelfPermission(\n                android.Manifest.permission.REQUEST_INSTALL_PACKAGES))\n                .thenReturn(PackageManager.PERMISSION_DENIED);\n\n        final AppOpsManager mockAppOpsManager = mock(AppOpsManager.class);\n        final String callingAttributionTag = \"test\";\n        final String callingPackage = TAG;\n        when(mockAppOpsManager.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                callingPackage, Binder.getCallingUid(), callingAttributionTag, null))\n                .thenReturn(AppOpsManager.MODE_ALLOWED);\n        when(mockAppOpsManager.noteOp(AppOpsManager.OP_REQUEST_INSTALL_PACKAGES,\n                Binder.getCallingUid(), callingPackage, null, \"obb_download\"))\n                .thenReturn(AppOpsManager.MODE_ERRORED);\n        File file = new File(filePath);\n\n        Helpers.checkDestinationFilePathRestrictions(file, callingPackage, mockContext,\n                mockAppOpsManager, callingAttributionTag, isLegacyMode,\n                /* allowDownloadsDirOnly */ false);\n    }\n\n    public void testIsFileInPrivateExternalAndroidDirs() throws Exception {\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/data/com.example/colors.txt\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/obb/com.example/file.mp4\"));\n        assertTrue(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/obb/com.example/file.mp4\"));\n\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Android/\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/AAAA-FFFF/Android/media/com.example/file.mp4\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/emulated/0/Download/foo.pdf\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\n                \"/storage/emulated/0/Download/dir/bar.html\"));\n        assertFalse(isFileInPrivateExternalAndroidDirs(\"/storage/AAAA-FFFF/Download/dir/bar.html\"));\n    }\n\n    private static boolean isFileInPrivateExternalAndroidDirs(String filePath) {\n        return Helpers.isFileInPrivateExternalAndroidDirs(new File(filePath));\n    }\n\n    public void testIsFilenameValidinKnownPublicDir() throws Exception {\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Download/dir/file.txt\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Music/foo.mp4\"));\n        assertTrue(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/DCIM/vacation/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Testing/foo.mp4\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Misc/Download/bar.jpg\"));\n        assertFalse(Helpers.isFilenameValidInKnownPublicDir(\n                \"/storage/emulated/0/Android/data/com.example/bar.jpg\"));\n    }\n\n    public void testHandleRemovedUidEntries() throws Exception {\n        // Prepare\n        final int[] testUids = {\n                TEST_UID1, TEST_UID2, TEST_UID3\n        };\n        final int[] unknownUids = {\n                TEST_UID1, TEST_UID2\n        };\n        final Context context = mock(Context.class);\n        final PackageManager packageManager = mock(PackageManager.class);\n        when(context.getPackageManager()).thenReturn(packageManager);\n        for (int uid : testUids) {\n            when(packageManager.getPackagesForUid(uid)).thenReturn(\n                    contains(unknownUids, uid) ? null : new String[] {\"com.example\" + uid}\n            );\n        }\n\n        final LongArray idsToRemove = new LongArray();\n        final LongArray idsToOrphan = new LongArray();\n        final LongSparseArray<String> validEntries = new LongSparseArray<>();\n        final MatrixCursor cursor = prepareData(testUids, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n\n        final ContentProvider downloadProvider = mock(ContentProvider.class);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, Process.INVALID_UID);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n\n\n        // Reset\n        idsToOrphan.clear();\n        idsToRemove.clear();\n        validEntries.clear();\n        reset(downloadProvider);\n\n        // Prepare\n        final MatrixCursor cursor2 = prepareData(new int[] {TEST_UID2}, unknownUids,\n                idsToOrphan, idsToRemove, validEntries);\n        when(downloadProvider.query(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                any(String[].class), any(String.class),isNull(), isNull())).thenReturn(cursor2);\n\n        // Call\n        Helpers.handleRemovedUidEntries(context, downloadProvider, TEST_UID2);\n\n        // Verify\n        verify(downloadProvider).update(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(values -> values.get(Constants.UID) == null),\n                argThat(selection -> Arrays.equals(\n                        idsToOrphan.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n        verify(downloadProvider).delete(eq(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI),\n                argThat(selection -> Arrays.equals(\n                        idsToRemove.toArray(), extractIdsFromSelection(selection))),\n                isNull());\n    }\n\n    private MatrixCursor prepareData(int[] uids, int[] unknownUids,\n            final LongArray idsToOrphan, final LongArray idsToRemove,\n            LongSparseArray<String> validEntries) {\n        final MatrixCursor cursor = new MatrixCursor(\n                new String[] {_ID, Constants.UID, COLUMN_DESTINATION, _DATA});\n        final int[] destinations = {\n                DESTINATION_EXTERNAL,\n                DESTINATION_FILE_URI,\n                DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD,\n                DESTINATION_CACHE_PARTITION_PURGEABLE\n        };\n        long counter = 0;\n        for (int uid : uids) {\n            for (int destination : destinations) {\n                final String fileName = uid + \"_\" + destination + \".txt\";\n                switch (destination) {\n                    case DESTINATION_EXTERNAL: {\n                        final File file = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOWNLOADS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_FILE_URI: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD: {\n                        final File file1 = new File(Environment.getExternalStoragePublicDirectory(\n                                Environment.DIRECTORY_DOCUMENTS), fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file1.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToOrphan.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                        final File file2 = new File(getContext().getExternalFilesDir(null),\n                                fileName);\n                        cursor.addRow(new Object[]{++counter, uid, destination, file2.getPath()});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                    case DESTINATION_CACHE_PARTITION_PURGEABLE: {\n                        final File file = new File(getContext().getCacheDir(), fileName);\n                        final String filePath = file.getPath().replace(\n                                getContext().getPackageName(), \"com.android.providers.downloads\");\n                        cursor.addRow(new Object[]{++counter, uid, destination, filePath});\n                        if (contains(unknownUids, uid)) {\n                            idsToRemove.add(counter);\n                        } else {\n                            validEntries.put(counter, \"com.example\" + uid);\n                        }\n                    } break;\n                }\n            }\n        }\n        return cursor;\n    }\n\n    private long[] extractIdsFromSelection(String selection) {\n        final Pattern uidsListPattern = Pattern.compile(\".*\\\\((.+)\\\\)\");\n        final Matcher matcher = uidsListPattern.matcher(selection);\n        assertTrue(matcher.matches());\n        return Arrays.stream(matcher.group(1).split(\",\"))\n                .mapToLong(Long::valueOf).sorted().toArray();\n    }\n}\n","lineNo":418}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIASTORE_URI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNABLE;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNED;\nimport static android.provider.Downloads.Impl.MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.TranslatingCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\nimport android.util.SparseArray;\n\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 113;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                case 112:\n                    updateMediaStoreUrisFromFilesToDownloads(db);\n                    break;\n\n                case 113:\n                    canonicalizeDataPaths(db);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final ContentValues mediaValues;\n                    try {\n                        mediaValues = convertToMediaProviderValues(info);\n                    } catch (IllegalArgumentException e) {\n                        Log.e(Constants.TAG, \"Error getting media content values from \" + info, e);\n                        continue;\n                    }\n                    final Uri mediaStoreUri = updateMediaProvider(client, mediaValues);\n                    if (mediaStoreUri != null) {\n                        updateValues.clear();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * DownloadProvider has been updated to use MediaStore.Downloads based uris\n         * for COLUMN_MEDIASTORE_URI but the existing entries would still have MediaStore.Files\n         * based uris. It's possible that in the future we might incorrectly assume that all the\n         * uris are MediaStore.DownloadColumns based and end up querying some\n         * MediaStore.Downloads specific columns. To avoid this, update the existing entries to\n         * use MediaStore.Downloads based uris only.\n         */\n        private void updateMediaStoreUrisFromFilesToDownloads(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, COLUMN_MEDIASTORE_URI },\n                    COLUMN_MEDIASTORE_URI + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final Uri mediaStoreFilesUri = Uri.parse(cursor.getString(1));\n\n                    final long mediaStoreId = ContentUris.parseId(mediaStoreFilesUri);\n                    final String volumeName = MediaStore.getVolumeName(mediaStoreFilesUri);\n                    final Uri mediaStoreDownloadsUri\n                            = MediaStore.Downloads.getContentUri(volumeName, mediaStoreId);\n\n                    updateValues.clear();\n                    updateValues.put(COLUMN_MEDIASTORE_URI, mediaStoreDownloadsUri.toString());\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        private void canonicalizeDataPaths(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, Downloads.Impl._DATA},\n                    Downloads.Impl._DATA + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final String filePath = cursor.getString(1);\n                    final String canonicalPath;\n                    try {\n                        canonicalPath = new File(filePath).getCanonicalPath();\n                    } catch (IOException e) {\n                        Log.e(Constants.TAG, \"Found invalid path='\" + filePath + \"' for id=\" + id);\n                        continue;\n                    }\n\n                    updateValues.clear();\n                    updateValues.put(Downloads.Impl._DATA, canonicalPath);\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        reconcileRemovedUidEntries();\n        return true;\n    }\n\n    private void reconcileRemovedUidEntries() {\n        // Grant access permissions for all known downloads to the owning apps\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        final ArrayList<Long> idsToOrphan = new ArrayList<>();\n        final LongSparseArray<String> idsToGrantPermission = new LongSparseArray<>();\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        try (Cursor cursor = db.query(DB_TABLE,\n                new String[] { Downloads.Impl._ID, Constants.UID, COLUMN_DESTINATION, _DATA },\n                Constants.UID + \" IS NOT NULL\", null, null, null, null)) {\n            Helpers.handleRemovedUidEntries(getContext(), cursor,\n                    idsToDelete, idsToOrphan, idsToGrantPermission);\n        }\n        for (int i = 0; i < idsToGrantPermission.size(); ++i) {\n            final long downloadId = idsToGrantPermission.keyAt(i);\n            final String ownerPackageName = idsToGrantPermission.valueAt(i);\n            grantAllDownloadsPermission(ownerPackageName, downloadId);\n        }\n        if (idsToOrphan.size() > 0) {\n            Log.i(Constants.TAG, \"Orphaning downloads with ids \"\n                    + Arrays.toString(idsToOrphan.toArray()) + \" as owner package is missing\");\n            final ContentValues values = new ContentValues();\n            values.putNull(Constants.UID);\n            update(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, values,\n                    Helpers.buildQueryWithIds(idsToOrphan), null);\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG, \"Deleting downloads with ids \"\n                    + Arrays.toString(idsToDelete.toArray()) + \" as owner package is missing\");\n            delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    Helpers.buildQueryWithIds(idsToDelete), null);\n        }\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        switch (method) {\n            case Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED: {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED);\n                final long[] deletedDownloadIds = extras.getLongArray(Downloads.EXTRA_IDS);\n                final String[] mimeTypes = extras.getStringArray(Downloads.EXTRA_MIME_TYPES);\n                DownloadStorageProvider.onMediaProviderDownloadsDelete(getContext(),\n                        deletedDownloadIds, mimeTypes);\n                return null;\n            }\n            case Downloads.CALL_CREATE_EXTERNAL_PUBLIC_DIR: {\n                final String dirType = extras.getString(Downloads.DIR_TYPE);\n                if (!ArrayUtils.contains(Environment.STANDARD_DIRECTORIES, dirType)) {\n                    throw new IllegalStateException(\"Not one of standard directories: \" + dirType);\n                }\n                final File file = Environment.getExternalStoragePublicDirectory(dirType);\n                if (file.exists()) {\n                    if (!file.isDirectory()) {\n                        throw new IllegalStateException(file.getAbsolutePath() +\n                                \" already exists and is not a directory\");\n                    }\n                } else if (!file.mkdirs()) {\n                    throw new IllegalStateException(\"Unable to create directory: \" +\n                            file.getAbsolutePath());\n                }\n                return null;\n            }\n            case Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS : {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS);\n                DownloadStorageProvider.revokeAllMediaStoreUriPermissions(getContext());\n                return null;\n            }\n            default:\n                throw new UnsupportedOperationException(\"Unsupported call: \" + method);\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n            } else if (dest == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                checkDownloadedFilePath(values);\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        ensureDefaultColumns(values);\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        copyBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        final Integer mediaScanned = values.getAsInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        filteredValues.put(COLUMN_MEDIA_SCANNED,\n                mediaScanned == null ? MEDIA_NOT_SCANNED : mediaScanned);\n\n        final boolean shouldBeVisibleToUser\n                = filteredValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)\n                        || filteredValues.getAsInteger(COLUMN_MEDIA_SCANNED) == MEDIA_NOT_SCANNED;\n        if (shouldBeVisibleToUser && filteredValues.getAsInteger(COLUMN_DESTINATION)\n                == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            final CallingIdentity token = clearCallingIdentity();\n            try (ContentProviderClient client = getContext().getContentResolver()\n                    .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                final Uri mediaStoreUri = updateMediaProvider(client,\n                        convertToMediaProviderValues(filteredValues));\n                if (mediaStoreUri != null) {\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                }\n                MediaStore.scanFile(getContext(),\n                        new File(filteredValues.getAsString(Downloads.Impl._DATA)));\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = Helpers.getPackageForUid(getContext(),\n                Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @NonNull ContentValues mediaValues) {\n        final String filePath = mediaValues.getAsString(MediaStore.DownloadColumns.DATA);\n        Uri mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(\n                        MediaStore.Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = MediaStore.setIncludePending(\n                MediaStore.Files.getContentUriForPath(filePath));\n        try (Cursor cursor = mediaProvider.query(filesUri,\n                new String[] { MediaStore.Files.FileColumns._ID },\n                MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final String filePath;\n        try {\n            filePath = new File(info.mFileName).getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,  filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE, info.mTotalBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING,\n                Downloads.Impl.isStatusSuccess(info.mStatus) ? 0 : 1);\n        mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                Helpers.getPackageForUid(getContext(), info.mUid));\n        mediaValues.put(MediaStore.Files.FileColumns.IS_DOWNLOAD, info.mIsVisibleInDownloadsUi);\n        return mediaValues;\n    }\n\n    private ContentValues convertToMediaProviderValues(ContentValues downloadValues) {\n        final String filePath;\n        try {\n            filePath = new File(downloadValues.getAsString(Downloads.Impl._DATA))\n                    .getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA, filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadValues.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_URI));\n        mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_MIME_TYPE));\n        final boolean isPending = downloadValues.getAsInteger(Downloads.Impl.COLUMN_STATUS)\n                != Downloads.Impl.STATUS_SUCCESS;\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, isPending ? 1 : 0);\n        mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                Helpers.getPackageForUid(getContext(), downloadValues.getAsInteger(Constants.UID)));\n        mediaValues.put(MediaStore.Files.FileColumns.IS_DOWNLOAD,\n                downloadValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI));\n        return mediaValues;\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private void ensureDefaultColumns(ContentValues values) {\n        final Integer dest = values.getAsInteger(COLUMN_DESTINATION);\n        if (dest != null) {\n            final int mediaScannable;\n            final boolean visibleInDownloadsUi;\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                mediaScannable = MEDIA_NOT_SCANNED;\n                visibleInDownloadsUi = true;\n            } else if (dest != DESTINATION_FILE_URI\n                    && dest != DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                mediaScannable = MEDIA_NOT_SCANNABLE;\n                visibleInDownloadsUi = false;\n            } else {\n                final File file;\n                if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                    final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                    file = new File(getFileUri(fileUri).getPath());\n                } else {\n                    file = new File(values.getAsString(Downloads.Impl._DATA));\n                }\n\n                if (Helpers.isFileInExternalAndroidDirs(file.getAbsolutePath())) {\n                    mediaScannable = MEDIA_NOT_SCANNABLE;\n                    visibleInDownloadsUi = false;\n                } else if (Helpers.isFilenameValidInPublicDownloadsDir(file)) {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = true;\n                } else {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = false;\n                }\n            }\n            values.put(COLUMN_MEDIA_SCANNED, mediaScannable);\n            values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, visibleInDownloadsUi);\n        } else {\n            if (!values.containsKey(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n                values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, true);\n            }\n        }\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, Uri.fromFile(file).toString());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())\n                || Helpers.isFilenameValidInKnownPublicDir(file.getAbsolutePath())) {\n            // No permissions required for paths belonging to calling package or\n            // public downloads dir.\n            return;\n        } else if (targetSdkVersion < Build.VERSION_CODES.Q\n                && Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private void checkDownloadedFilePath(ContentValues values) {\n        final String path = values.getAsString(Downloads.Impl._DATA);\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file path: \"\n                    + (path == null ? \"null\" : path));\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl._DATA, file.getPath());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (!file.exists()) {\n            throw new IllegalArgumentException(\"File doesn't exist: \" + file);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n        final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);\n        final boolean runningLegacyMode = appOpsManager.checkOp(AppOpsManager.OP_LEGACY_STORAGE,\n                Binder.getCallingUid(), getCallingPackage()) == AppOpsManager.MODE_ALLOWED;\n\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        } else if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package.\n            return;\n        } else if ((runningLegacyMode && Helpers.isFilenameValidInPublicDownloadsDir(file))\n                || (targetSdkVersion < Build.VERSION_CODES.Q\n                        && Helpers.isFilenameValidInExternal(getContext(), file))) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private int getCallingPackageTargetSdkVersion() {\n        final String callingPackage = getCallingPackage();\n        if (callingPackage != null) {\n            ApplicationInfo ai = null;\n            try {\n                ai = getContext().getPackageManager()\n                        .getApplicationInfo(callingPackage, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n            }\n            if (ai != null) {\n                return ai.targetSdkVersion;\n            }\n        }\n        return Build.VERSION_CODES.CUR_DEVELOPMENT;\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        final Cursor ret = qb.query(db, projection, selection, selectionArgs, null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid()\n                && callingUid != mSystemUid\n                && callingUid != Process.SHELL_UID\n                && callingUid != Process.ROOT_UID;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                try {\n                    filteredValues.put(Downloads.Impl._DATA, new File(filename).getCanonicalPath());\n                } catch (IOException e) {\n                    throw new IllegalStateException(\"Invalid path: \" + filename);\n                }\n\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    final ContentValues updateValues = new ContentValues();\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        final boolean visibleToUser = info.mIsVisibleInDownloadsUi\n                                || (info.mMediaScanned != MEDIA_NOT_SCANNABLE);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                // If there was a mediastore entry, it would be deleted in it's\n                                // next idle pass.\n                                updateValues.clear();\n                                updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        } else if ((info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                                && visibleToUser) {\n                            final Uri mediaStoreUri = updateMediaProvider(client,\n                                    convertToMediaProviderValues(info));\n                            if (!TextUtils.equals(info.mMediaStoreUri,\n                                    mediaStoreUri == null ? null : mediaStoreUri.toString())) {\n                                updateValues.clear();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_NOT_SCANNED);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                            if (Downloads.Impl.isStatusSuccess(info.mStatus)) {\n                                MediaStore.scanFile(getContext(), new File(info.mFileName));\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true);\n        qb.setTables(table);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                    deleteMediaStoreEntry(file);\n                                } else {\n                                    Log.d(Constants.TAG, \"Ignoring invalid file: \" + file);\n                                }\n                            } catch (IOException e) {\n                                Log.e(Constants.TAG, \"Couldn't delete file: \" + path, e);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    private void deleteMediaStoreEntry(File file) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final String path = file.getAbsolutePath();\n            final Uri.Builder builder = MediaStore.setIncludePending(\n                    MediaStore.Files.getContentUriForPath(path).buildUpon());\n            builder.appendQueryParameter(MediaStore.PARAM_DELETE_DATA, \"false\");\n\n            final Uri filesUri = builder.build();\n            getContext().getContentResolver().delete(filesUri,\n                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { path });\n        } catch (Exception e) {\n            Log.d(Constants.TAG, \"Failed to delete mediastore entry for file:\" + file, e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != Downloads.Impl.MEDIA_NOT_SCANNABLE;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIASTORE_URI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_EXTERNAL;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNABLE;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNED;\nimport static android.provider.Downloads.Impl.MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport static com.android.providers.downloads.Helpers.convertToMediaStoreDownloadsUri;\nimport static com.android.providers.downloads.Helpers.triggerMediaScan;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.TranslatingCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\nimport android.util.SparseArray;\n\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 114;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                case 112:\n                    updateMediaStoreUrisFromFilesToDownloads(db);\n                    break;\n\n                case 113:\n                    canonicalizeDataPaths(db);\n                    break;\n\n                case 114:\n                    nullifyMediaStoreUris(db);\n                    MediaScanTriggerJob.schedule(getContext());\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final ContentValues mediaValues;\n                    try {\n                        mediaValues = convertToMediaProviderValues(info);\n                    } catch (IllegalArgumentException e) {\n                        Log.e(Constants.TAG, \"Error getting media content values from \" + info, e);\n                        continue;\n                    }\n                    final Uri mediaStoreUri = updateMediaProvider(client, mediaValues);\n                    if (mediaStoreUri != null) {\n                        updateValues.clear();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * DownloadProvider has been updated to use MediaStore.Downloads based uris\n         * for COLUMN_MEDIASTORE_URI but the existing entries would still have MediaStore.Files\n         * based uris. It's possible that in the future we might incorrectly assume that all the\n         * uris are MediaStore.DownloadColumns based and end up querying some\n         * MediaStore.Downloads specific columns. To avoid this, update the existing entries to\n         * use MediaStore.Downloads based uris only.\n         */\n        private void updateMediaStoreUrisFromFilesToDownloads(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, COLUMN_MEDIASTORE_URI },\n                    COLUMN_MEDIASTORE_URI + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final Uri mediaStoreFilesUri = Uri.parse(cursor.getString(1));\n\n                    final long mediaStoreId = ContentUris.parseId(mediaStoreFilesUri);\n                    final String volumeName = MediaStore.getVolumeName(mediaStoreFilesUri);\n                    final Uri mediaStoreDownloadsUri\n                            = MediaStore.Downloads.getContentUri(volumeName, mediaStoreId);\n\n                    updateValues.clear();\n                    updateValues.put(COLUMN_MEDIASTORE_URI, mediaStoreDownloadsUri.toString());\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        private void canonicalizeDataPaths(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, Downloads.Impl._DATA},\n                    Downloads.Impl._DATA + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final String filePath = cursor.getString(1);\n                    final String canonicalPath;\n                    try {\n                        canonicalPath = new File(filePath).getCanonicalPath();\n                    } catch (IOException e) {\n                        Log.e(Constants.TAG, \"Found invalid path='\" + filePath + \"' for id=\" + id);\n                        continue;\n                    }\n\n                    updateValues.clear();\n                    updateValues.put(Downloads.Impl._DATA, canonicalPath);\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        /**\n         * Set mediastore uri column to null before the clean-up job and fill it again while\n         * running the job so that if the clean-up job gets preempted, we could use it\n         * as a way to know the entries which are already handled when the job gets restarted.\n         */\n        private void nullifyMediaStoreUris(SQLiteDatabase db) {\n            final String whereClause = Downloads.Impl._DATA + \" IS NOT NULL\"\n                    + \" AND (\" + COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI + \"=1\"\n                    + \" OR \" + COLUMN_MEDIA_SCANNED + \"=\" + MEDIA_SCANNED + \")\"\n                    + \" AND (\" + COLUMN_DESTINATION + \"=\" + Downloads.Impl.DESTINATION_EXTERNAL\n                    + \" OR \" + COLUMN_DESTINATION + \"=\" + DESTINATION_FILE_URI\n                    + \" OR \" + COLUMN_DESTINATION + \"=\" + DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                    + \")\";\n            final ContentValues values = new ContentValues();\n            values.putNull(COLUMN_MEDIASTORE_URI);\n            db.update(DB_TABLE, values, whereClause, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        reconcileRemovedUidEntries();\n        return true;\n    }\n\n    private void reconcileRemovedUidEntries() {\n        // Grant access permissions for all known downloads to the owning apps\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        final ArrayList<Long> idsToOrphan = new ArrayList<>();\n        final LongSparseArray<String> idsToGrantPermission = new LongSparseArray<>();\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        try (Cursor cursor = db.query(DB_TABLE,\n                new String[] { Downloads.Impl._ID, Constants.UID, COLUMN_DESTINATION, _DATA },\n                Constants.UID + \" IS NOT NULL\", null, null, null, null)) {\n            Helpers.handleRemovedUidEntries(getContext(), cursor,\n                    idsToDelete, idsToOrphan, idsToGrantPermission);\n        }\n        for (int i = 0; i < idsToGrantPermission.size(); ++i) {\n            final long downloadId = idsToGrantPermission.keyAt(i);\n            final String ownerPackageName = idsToGrantPermission.valueAt(i);\n            grantAllDownloadsPermission(ownerPackageName, downloadId);\n        }\n        if (idsToOrphan.size() > 0) {\n            Log.i(Constants.TAG, \"Orphaning downloads with ids \"\n                    + Arrays.toString(idsToOrphan.toArray()) + \" as owner package is missing\");\n            final ContentValues values = new ContentValues();\n            values.putNull(Constants.UID);\n            update(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, values,\n                    Helpers.buildQueryWithIds(idsToOrphan), null);\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG, \"Deleting downloads with ids \"\n                    + Arrays.toString(idsToDelete.toArray()) + \" as owner package is missing\");\n            delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    Helpers.buildQueryWithIds(idsToDelete), null);\n        }\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        switch (method) {\n            case Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED: {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED);\n                final long[] deletedDownloadIds = extras.getLongArray(Downloads.EXTRA_IDS);\n                final String[] mimeTypes = extras.getStringArray(Downloads.EXTRA_MIME_TYPES);\n                DownloadStorageProvider.onMediaProviderDownloadsDelete(getContext(),\n                        deletedDownloadIds, mimeTypes);\n                return null;\n            }\n            case Downloads.CALL_CREATE_EXTERNAL_PUBLIC_DIR: {\n                final String dirType = extras.getString(Downloads.DIR_TYPE);\n                if (!ArrayUtils.contains(Environment.STANDARD_DIRECTORIES, dirType)) {\n                    throw new IllegalStateException(\"Not one of standard directories: \" + dirType);\n                }\n                final File file = Environment.getExternalStoragePublicDirectory(dirType);\n                if (file.exists()) {\n                    if (!file.isDirectory()) {\n                        throw new IllegalStateException(file.getAbsolutePath() +\n                                \" already exists and is not a directory\");\n                    }\n                } else if (!file.mkdirs()) {\n                    throw new IllegalStateException(\"Unable to create directory: \" +\n                            file.getAbsolutePath());\n                }\n                return null;\n            }\n            case Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS : {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS);\n                DownloadStorageProvider.revokeAllMediaStoreUriPermissions(getContext());\n                return null;\n            }\n            default:\n                throw new UnsupportedOperationException(\"Unsupported call: \" + method);\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n            } else if (dest == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                checkDownloadedFilePath(values);\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        ensureDefaultColumns(values);\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        copyBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        final Integer mediaScanned = values.getAsInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        filteredValues.put(COLUMN_MEDIA_SCANNED,\n                mediaScanned == null ? MEDIA_NOT_SCANNED : mediaScanned);\n\n        final boolean shouldBeVisibleToUser\n                = filteredValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)\n                        || filteredValues.getAsInteger(COLUMN_MEDIA_SCANNED) == MEDIA_NOT_SCANNED;\n        if (shouldBeVisibleToUser && filteredValues.getAsInteger(COLUMN_DESTINATION)\n                == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            final CallingIdentity token = clearCallingIdentity();\n            try {\n                final Uri mediaStoreUri = MediaStore.scanFile(getContext(),\n                        new File(filteredValues.getAsString(Downloads.Impl._DATA)));\n                if (mediaStoreUri != null) {\n                    final ContentValues mediaValues = new ContentValues();\n                    mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                            filteredValues.getAsString(Downloads.Impl.COLUMN_URI));\n                    mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                            filteredValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n                    mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                            Helpers.getPackageForUid(getContext(),\n                                    filteredValues.getAsInteger(Constants.UID)));\n                    getContext().getContentResolver().update(\n                            convertToMediaStoreDownloadsUri(mediaStoreUri),\n                            mediaValues, null, null);\n\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = Helpers.getPackageForUid(getContext(),\n                Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @NonNull ContentValues mediaValues) {\n        final String filePath = mediaValues.getAsString(MediaStore.DownloadColumns.DATA);\n        Uri mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(\n                        MediaStore.Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = MediaStore.setIncludePending(\n                MediaStore.Files.getContentUriForPath(filePath));\n        try (Cursor cursor = mediaProvider.query(filesUri,\n                new String[] { MediaStore.Files.FileColumns._ID },\n                MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final String filePath;\n        try {\n            filePath = new File(info.mFileName).getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final boolean downloadCompleted = Downloads.Impl.isStatusCompleted(info.mStatus);\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,  filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadCompleted ? info.mTotalBytes : info.mCurrentBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, downloadCompleted ? 0 : 1);\n        mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                Helpers.getPackageForUid(getContext(), info.mUid));\n        mediaValues.put(MediaStore.Files.FileColumns.IS_DOWNLOAD, info.mIsVisibleInDownloadsUi);\n        return mediaValues;\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private void ensureDefaultColumns(ContentValues values) {\n        final Integer dest = values.getAsInteger(COLUMN_DESTINATION);\n        if (dest != null) {\n            final int mediaScannable;\n            final boolean visibleInDownloadsUi;\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                mediaScannable = MEDIA_NOT_SCANNED;\n                visibleInDownloadsUi = true;\n            } else if (dest != DESTINATION_FILE_URI\n                    && dest != DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                mediaScannable = MEDIA_NOT_SCANNABLE;\n                visibleInDownloadsUi = false;\n            } else {\n                final File file;\n                if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                    final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                    file = new File(getFileUri(fileUri).getPath());\n                } else {\n                    file = new File(values.getAsString(Downloads.Impl._DATA));\n                }\n\n                if (Helpers.isFileInExternalAndroidDirs(file.getAbsolutePath())) {\n                    mediaScannable = MEDIA_NOT_SCANNABLE;\n                    visibleInDownloadsUi = false;\n                } else if (Helpers.isFilenameValidInPublicDownloadsDir(file)) {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = true;\n                } else {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = false;\n                }\n            }\n            values.put(COLUMN_MEDIA_SCANNED, mediaScannable);\n            values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, visibleInDownloadsUi);\n        } else {\n            if (!values.containsKey(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n                values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, true);\n            }\n        }\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, Uri.fromFile(file).toString());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())\n                || Helpers.isFilenameValidInKnownPublicDir(file.getAbsolutePath())) {\n            // No permissions required for paths belonging to calling package or\n            // public downloads dir.\n            return;\n        } else if (targetSdkVersion < Build.VERSION_CODES.Q\n                && Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private void checkDownloadedFilePath(ContentValues values) {\n        final String path = values.getAsString(Downloads.Impl._DATA);\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file path: \"\n                    + (path == null ? \"null\" : path));\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl._DATA, file.getPath());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (!file.exists()) {\n            throw new IllegalArgumentException(\"File doesn't exist: \" + file);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n        final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);\n        final boolean runningLegacyMode = appOpsManager.checkOp(AppOpsManager.OP_LEGACY_STORAGE,\n                Binder.getCallingUid(), getCallingPackage()) == AppOpsManager.MODE_ALLOWED;\n\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        } else if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package.\n            return;\n        } else if ((runningLegacyMode && Helpers.isFilenameValidInPublicDownloadsDir(file))\n                || (targetSdkVersion < Build.VERSION_CODES.Q\n                        && Helpers.isFilenameValidInExternal(getContext(), file))) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private int getCallingPackageTargetSdkVersion() {\n        final String callingPackage = getCallingPackage();\n        if (callingPackage != null) {\n            ApplicationInfo ai = null;\n            try {\n                ai = getContext().getPackageManager()\n                        .getApplicationInfo(callingPackage, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n            }\n            if (ai != null) {\n                return ai.targetSdkVersion;\n            }\n        }\n        return Build.VERSION_CODES.CUR_DEVELOPMENT;\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        final Cursor ret = qb.query(db, projection, selection, selectionArgs, null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid()\n                && callingUid != mSystemUid\n                && callingUid != Process.SHELL_UID\n                && callingUid != Process.ROOT_UID;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                try {\n                    filteredValues.put(Downloads.Impl._DATA, new File(filename).getCanonicalPath());\n                } catch (IOException e) {\n                    throw new IllegalStateException(\"Invalid path: \" + filename);\n                }\n\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    final ContentValues updateValues = new ContentValues();\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        final boolean visibleToUser = info.mIsVisibleInDownloadsUi\n                                || (info.mMediaScanned != MEDIA_NOT_SCANNABLE);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                // If there was a mediastore entry, it would be deleted in it's\n                                // next idle pass.\n                                updateValues.clear();\n                                updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        } else if ((info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                                && visibleToUser) {\n                            final ContentValues mediaValues = convertToMediaProviderValues(info);\n                            final Uri mediaStoreUri;\n                            if (Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                                // Set size to 0 to ensure MediaScanner will scan this file.\n                                mediaValues.put(MediaStore.Downloads.SIZE, 0);\n                                updateMediaProvider(client, mediaValues);\n                                mediaStoreUri = triggerMediaScan(client, new File(info.mFileName));\n                            } else {\n                                mediaStoreUri = updateMediaProvider(client, mediaValues);\n                            }\n                            if (!TextUtils.equals(info.mMediaStoreUri,\n                                    mediaStoreUri == null ? null : mediaStoreUri.toString())) {\n                                updateValues.clear();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_NOT_SCANNED);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true);\n        qb.setTables(table);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                    deleteMediaStoreEntry(file);\n                                } else {\n                                    Log.d(Constants.TAG, \"Ignoring invalid file: \" + file);\n                                }\n                            } catch (IOException e) {\n                                Log.e(Constants.TAG, \"Couldn't delete file: \" + path, e);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    private void deleteMediaStoreEntry(File file) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final String path = file.getAbsolutePath();\n            final Uri.Builder builder = MediaStore.setIncludePending(\n                    MediaStore.Files.getContentUriForPath(path).buildUpon());\n            builder.appendQueryParameter(MediaStore.PARAM_DELETE_DATA, \"false\");\n\n            final Uri filesUri = builder.build();\n            getContext().getContentResolver().delete(filesUri,\n                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { path });\n        } catch (Exception e) {\n            Log.d(Constants.TAG, \"Failed to delete mediastore entry for file:\" + file, e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != Downloads.Impl.MEDIA_NOT_SCANNABLE;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","lineNo":1545}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIASTORE_URI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNABLE;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNED;\nimport static android.provider.Downloads.Impl.MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.Log;\n\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\n\nimport libcore.io.IoUtils;\n\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 113;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static void addMapping(Map<String, String> map, String column) {\n        if (!map.containsKey(column)) {\n            map.put(column, column);\n        }\n    }\n\n    private static void addMapping(Map<String, String> map, String column, String rawColumn) {\n        if (!map.containsKey(column)) {\n            map.put(column, rawColumn + \" AS \" + column);\n        }\n    }\n\n    private static final Map<String, String> sDownloadsMap = new ArrayMap<>();\n    static {\n        final Map<String, String> map = sDownloadsMap;\n\n        // Columns defined by public API\n        addMapping(map, DownloadManager.COLUMN_ID,\n                Downloads.Impl._ID);\n        addMapping(map, DownloadManager.COLUMN_LOCAL_FILENAME,\n                Downloads.Impl._DATA);\n        addMapping(map, DownloadManager.COLUMN_MEDIAPROVIDER_URI);\n        addMapping(map, DownloadManager.COLUMN_DESTINATION);\n        addMapping(map, DownloadManager.COLUMN_TITLE);\n        addMapping(map, DownloadManager.COLUMN_DESCRIPTION);\n        addMapping(map, DownloadManager.COLUMN_URI);\n        addMapping(map, DownloadManager.COLUMN_STATUS);\n        addMapping(map, DownloadManager.COLUMN_FILE_NAME_HINT);\n        addMapping(map, DownloadManager.COLUMN_MEDIA_TYPE,\n                Downloads.Impl.COLUMN_MIME_TYPE);\n        addMapping(map, DownloadManager.COLUMN_TOTAL_SIZE_BYTES,\n                Downloads.Impl.COLUMN_TOTAL_BYTES);\n        addMapping(map, DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        addMapping(map, DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR,\n                Downloads.Impl.COLUMN_CURRENT_BYTES);\n        addMapping(map, DownloadManager.COLUMN_ALLOW_WRITE);\n        addMapping(map, DownloadManager.COLUMN_LOCAL_URI,\n                \"'placeholder'\");\n        addMapping(map, DownloadManager.COLUMN_REASON,\n                \"'placeholder'\");\n\n        // Columns defined by OpenableColumns\n        addMapping(map, OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE);\n        addMapping(map, OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES);\n\n        // Allow references to all other columns to support DownloadInfo.Reader;\n        // we're already using SQLiteQueryBuilder to block access to other rows\n        // that don't belong to the calling UID.\n        addMapping(map, Downloads.Impl._ID);\n        addMapping(map, Downloads.Impl._DATA);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOW_METERED);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOW_WRITE);\n        addMapping(map, Downloads.Impl.COLUMN_APP_DATA);\n        addMapping(map, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n        addMapping(map, Downloads.Impl.COLUMN_CONTROL);\n        addMapping(map, Downloads.Impl.COLUMN_COOKIE_DATA);\n        addMapping(map, Downloads.Impl.COLUMN_CURRENT_BYTES);\n        addMapping(map, Downloads.Impl.COLUMN_DELETED);\n        addMapping(map, Downloads.Impl.COLUMN_DESCRIPTION);\n        addMapping(map, Downloads.Impl.COLUMN_DESTINATION);\n        addMapping(map, Downloads.Impl.COLUMN_ERROR_MSG);\n        addMapping(map, Downloads.Impl.COLUMN_FAILED_CONNECTIONS);\n        addMapping(map, Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        addMapping(map, Downloads.Impl.COLUMN_FLAGS);\n        addMapping(map, Downloads.Impl.COLUMN_IS_PUBLIC_API);\n        addMapping(map, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        addMapping(map, Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        addMapping(map, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n        addMapping(map, Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        addMapping(map, Downloads.Impl.COLUMN_MEDIASTORE_URI);\n        addMapping(map, Downloads.Impl.COLUMN_MIME_TYPE);\n        addMapping(map, Downloads.Impl.COLUMN_NO_INTEGRITY);\n        addMapping(map, Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        addMapping(map, Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS);\n        addMapping(map, Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        addMapping(map, Downloads.Impl.COLUMN_OTHER_UID);\n        addMapping(map, Downloads.Impl.COLUMN_REFERER);\n        addMapping(map, Downloads.Impl.COLUMN_STATUS);\n        addMapping(map, Downloads.Impl.COLUMN_TITLE);\n        addMapping(map, Downloads.Impl.COLUMN_TOTAL_BYTES);\n        addMapping(map, Downloads.Impl.COLUMN_URI);\n        addMapping(map, Downloads.Impl.COLUMN_USER_AGENT);\n        addMapping(map, Downloads.Impl.COLUMN_VISIBILITY);\n\n        addMapping(map, Constants.ETAG);\n        addMapping(map, Constants.RETRY_AFTER_X_REDIRECT_COUNT);\n        addMapping(map, Constants.UID);\n    }\n\n    private static final Map<String, String> sHeadersMap = new ArrayMap<>();\n    static {\n        final Map<String, String> map = sHeadersMap;\n        addMapping(map, \"id\");\n        addMapping(map, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID);\n        addMapping(map, Downloads.Impl.RequestHeaders.COLUMN_HEADER);\n        addMapping(map, Downloads.Impl.RequestHeaders.COLUMN_VALUE);\n    }\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                case 112:\n                    updateMediaStoreUrisFromFilesToDownloads(db);\n                    break;\n\n                case 113:\n                    canonicalizeDataPaths(db);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final ContentValues mediaValues;\n                    try {\n                        mediaValues = convertToMediaProviderValues(info);\n                    } catch (IllegalArgumentException e) {\n                        Log.e(Constants.TAG, \"Error getting media content values from \" + info, e);\n                        continue;\n                    }\n                    final Uri mediaStoreUri = updateMediaProvider(client, mediaValues);\n                    if (mediaStoreUri != null) {\n                        updateValues.clear();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * DownloadProvider has been updated to use MediaStore.Downloads based uris\n         * for COLUMN_MEDIASTORE_URI but the existing entries would still have MediaStore.Files\n         * based uris. It's possible that in the future we might incorrectly assume that all the\n         * uris are MediaStore.DownloadColumns based and end up querying some\n         * MediaStore.Downloads specific columns. To avoid this, update the existing entries to\n         * use MediaStore.Downloads based uris only.\n         */\n        private void updateMediaStoreUrisFromFilesToDownloads(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, COLUMN_MEDIASTORE_URI },\n                    COLUMN_MEDIASTORE_URI + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final Uri mediaStoreFilesUri = Uri.parse(cursor.getString(1));\n\n                    final long mediaStoreId = ContentUris.parseId(mediaStoreFilesUri);\n                    final String volumeName = MediaStore.getVolumeName(mediaStoreFilesUri);\n                    final Uri mediaStoreDownloadsUri\n                            = MediaStore.Downloads.getContentUri(volumeName, mediaStoreId);\n\n                    updateValues.clear();\n                    updateValues.put(COLUMN_MEDIASTORE_URI, mediaStoreDownloadsUri.toString());\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        private void canonicalizeDataPaths(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, Downloads.Impl._DATA},\n                    Downloads.Impl._DATA + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final String filePath = cursor.getString(1);\n                    final String canonicalPath;\n                    try {\n                        canonicalPath = new File(filePath).getCanonicalPath();\n                    } catch (IOException e) {\n                        Log.e(Constants.TAG, \"Found invalid path='\" + filePath + \"' for id=\" + id);\n                        continue;\n                    }\n\n                    updateValues.clear();\n                    updateValues.put(Downloads.Impl._DATA, canonicalPath);\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        reconcileRemovedUidEntries();\n        return true;\n    }\n\n    private void reconcileRemovedUidEntries() {\n        Helpers.handleRemovedUidEntries(getContext(), this, -1, this::grantAllDownloadsPermission);\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        switch (method) {\n            case Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED: {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED);\n                final long[] deletedDownloadIds = extras.getLongArray(Downloads.EXTRA_IDS);\n                final String[] mimeTypes = extras.getStringArray(Downloads.EXTRA_MIME_TYPES);\n                DownloadStorageProvider.onMediaProviderDownloadsDelete(getContext(),\n                        deletedDownloadIds, mimeTypes);\n                return null;\n            }\n            case Downloads.CALL_CREATE_EXTERNAL_PUBLIC_DIR: {\n                final String dirType = extras.getString(Downloads.DIR_TYPE);\n                if (!ArrayUtils.contains(Environment.STANDARD_DIRECTORIES, dirType)) {\n                    throw new IllegalStateException(\"Not one of standard directories: \" + dirType);\n                }\n                final File file = Environment.getExternalStoragePublicDirectory(dirType);\n                if (file.exists()) {\n                    if (!file.isDirectory()) {\n                        throw new IllegalStateException(file.getAbsolutePath() +\n                                \" already exists and is not a directory\");\n                    }\n                } else if (!file.mkdirs()) {\n                    throw new IllegalStateException(\"Unable to create directory: \" +\n                            file.getAbsolutePath());\n                }\n                return null;\n            }\n            case Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS : {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS);\n                DownloadStorageProvider.revokeAllMediaStoreUriPermissions(getContext());\n                return null;\n            }\n            default:\n                throw new UnsupportedOperationException(\"Unsupported call: \" + method);\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n            } else if (dest == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                checkDownloadedFilePath(values);\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        ensureDefaultColumns(values);\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        copyBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        final Integer mediaScanned = values.getAsInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        filteredValues.put(COLUMN_MEDIA_SCANNED,\n                mediaScanned == null ? MEDIA_NOT_SCANNED : mediaScanned);\n\n        final boolean shouldBeVisibleToUser\n                = filteredValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)\n                        || filteredValues.getAsInteger(COLUMN_MEDIA_SCANNED) == MEDIA_NOT_SCANNED;\n        if (shouldBeVisibleToUser && filteredValues.getAsInteger(COLUMN_DESTINATION)\n                == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            final CallingIdentity token = clearCallingIdentity();\n            try (ContentProviderClient client = getContext().getContentResolver()\n                    .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                final Uri mediaStoreUri = updateMediaProvider(client,\n                        convertToMediaProviderValues(filteredValues));\n                if (mediaStoreUri != null) {\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                }\n                MediaStore.scanFile(getContext(),\n                        new File(filteredValues.getAsString(Downloads.Impl._DATA)));\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = Helpers.getPackageForUid(getContext(),\n                Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @NonNull ContentValues mediaValues) {\n        final String filePath = mediaValues.getAsString(MediaStore.DownloadColumns.DATA);\n        Uri mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(\n                        MediaStore.Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = MediaStore.setIncludePending(\n                MediaStore.Files.getContentUriForPath(filePath));\n        try (Cursor cursor = mediaProvider.query(filesUri,\n                new String[] { MediaStore.Files.FileColumns._ID },\n                MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final String filePath;\n        try {\n            filePath = new File(info.mFileName).getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,  filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE, info.mTotalBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING,\n                Downloads.Impl.isStatusSuccess(info.mStatus) ? 0 : 1);\n        mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                Helpers.getPackageForUid(getContext(), info.mUid));\n        mediaValues.put(MediaStore.Files.FileColumns.IS_DOWNLOAD, info.mIsVisibleInDownloadsUi);\n        return mediaValues;\n    }\n\n    private ContentValues convertToMediaProviderValues(ContentValues downloadValues) {\n        final String filePath;\n        try {\n            filePath = new File(downloadValues.getAsString(Downloads.Impl._DATA))\n                    .getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA, filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadValues.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_URI));\n        mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_MIME_TYPE));\n        final boolean isPending = downloadValues.getAsInteger(Downloads.Impl.COLUMN_STATUS)\n                != Downloads.Impl.STATUS_SUCCESS;\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, isPending ? 1 : 0);\n        mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                Helpers.getPackageForUid(getContext(), downloadValues.getAsInteger(Constants.UID)));\n        mediaValues.put(MediaStore.Files.FileColumns.IS_DOWNLOAD,\n                downloadValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI));\n        return mediaValues;\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private void ensureDefaultColumns(ContentValues values) {\n        final Integer dest = values.getAsInteger(COLUMN_DESTINATION);\n        if (dest != null) {\n            final int mediaScannable;\n            final boolean visibleInDownloadsUi;\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                mediaScannable = MEDIA_NOT_SCANNED;\n                visibleInDownloadsUi = true;\n            } else if (dest != DESTINATION_FILE_URI\n                    && dest != DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                mediaScannable = MEDIA_NOT_SCANNABLE;\n                visibleInDownloadsUi = false;\n            } else {\n                final File file;\n                if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                    final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                    file = new File(getFileUri(fileUri).getPath());\n                } else {\n                    file = new File(values.getAsString(Downloads.Impl._DATA));\n                }\n\n                if (Helpers.isFileInExternalAndroidDirs(file.getAbsolutePath())) {\n                    mediaScannable = MEDIA_NOT_SCANNABLE;\n                    visibleInDownloadsUi = false;\n                } else if (Helpers.isFilenameValidInPublicDownloadsDir(file)) {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = true;\n                } else {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = false;\n                }\n            }\n            values.put(COLUMN_MEDIA_SCANNED, mediaScannable);\n            values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, visibleInDownloadsUi);\n        } else {\n            if (!values.containsKey(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n                values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, true);\n            }\n        }\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, Uri.fromFile(file).toString());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())\n                || Helpers.isFilenameValidInKnownPublicDir(file.getAbsolutePath())) {\n            // No permissions required for paths belonging to calling package or\n            // public downloads dir.\n            return;\n        } else if (targetSdkVersion < Build.VERSION_CODES.Q\n                && Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private void checkDownloadedFilePath(ContentValues values) {\n        final String path = values.getAsString(Downloads.Impl._DATA);\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file path: \"\n                    + (path == null ? \"null\" : path));\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl._DATA, file.getPath());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (!file.exists()) {\n            throw new IllegalArgumentException(\"File doesn't exist: \" + file);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n        final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);\n        final boolean runningLegacyMode = appOpsManager.checkOp(AppOpsManager.OP_LEGACY_STORAGE,\n                Binder.getCallingUid(), getCallingPackage()) == AppOpsManager.MODE_ALLOWED;\n\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        } else if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package.\n            return;\n        } else if ((runningLegacyMode && Helpers.isFilenameValidInPublicDownloadsDir(file))\n                || (targetSdkVersion < Build.VERSION_CODES.Q\n                        && Helpers.isFilenameValidInExternal(getContext(), file))) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private int getCallingPackageTargetSdkVersion() {\n        final String callingPackage = getCallingPackage();\n        if (callingPackage != null) {\n            ApplicationInfo ai = null;\n            try {\n                ai = getContext().getPackageManager()\n                        .getApplicationInfo(callingPackage, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n            }\n            if (ai != null) {\n                return ai.targetSdkVersion;\n            }\n        }\n        return Build.VERSION_CODES.CUR_DEVELOPMENT;\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        final Cursor ret = qb.query(db, projection, selection, selectionArgs, null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                try {\n                    filteredValues.put(Downloads.Impl._DATA, new File(filename).getCanonicalPath());\n                } catch (IOException e) {\n                    throw new IllegalStateException(\"Invalid path: \" + filename);\n                }\n\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    final ContentValues updateValues = new ContentValues();\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        final boolean visibleToUser = info.mIsVisibleInDownloadsUi\n                                || (info.mMediaScanned != MEDIA_NOT_SCANNABLE);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                // If there was a mediastore entry, it would be deleted in it's\n                                // next idle pass.\n                                updateValues.clear();\n                                updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        } else if ((info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                                && visibleToUser) {\n                            final Uri mediaStoreUri = updateMediaProvider(client,\n                                    convertToMediaProviderValues(info));\n                            if (!TextUtils.equals(info.mMediaStoreUri,\n                                    mediaStoreUri == null ? null : mediaStoreUri.toString())) {\n                                updateValues.clear();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_NOT_SCANNED);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                            if (Downloads.Impl.isStatusSuccess(info.mStatus)) {\n                                MediaStore.scanFile(getContext(), new File(info.mFileName));\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final Map<String, String> projectionMap;\n\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                projectionMap = sDownloadsMap;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                projectionMap = sDownloadsMap;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                projectionMap = sHeadersMap;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setTables(table);\n        qb.setProjectionMap(projectionMap);\n        qb.setStrict(true);\n        qb.setStrictColumns(true);\n        qb.setStrictGrammar(true);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                    deleteMediaStoreEntry(file);\n                                } else {\n                                    Log.d(Constants.TAG, \"Ignoring invalid file: \" + file);\n                                }\n                            } catch (IOException e) {\n                                Log.e(Constants.TAG, \"Couldn't delete file: \" + path, e);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    private void deleteMediaStoreEntry(File file) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final String path = file.getAbsolutePath();\n            final Uri.Builder builder = MediaStore.setIncludePending(\n                    MediaStore.Files.getContentUriForPath(path).buildUpon());\n            builder.appendQueryParameter(MediaStore.PARAM_DELETE_DATA, \"false\");\n\n            final Uri filesUri = builder.build();\n            getContext().getContentResolver().delete(filesUri,\n                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { path });\n        } catch (Exception e) {\n            Log.d(Constants.TAG, \"Failed to delete mediastore entry for file:\" + file, e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != Downloads.Impl.MEDIA_NOT_SCANNABLE;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIASTORE_URI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_FILE_URI;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNABLE;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNED;\nimport static android.provider.Downloads.Impl.MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\n\nimport static com.android.providers.downloads.Helpers.convertToMediaStoreDownloadsUri;\nimport static com.android.providers.downloads.Helpers.triggerMediaScan;\n\nimport android.annotation.NonNull;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.Log;\n\nimport com.android.internal.util.ArrayUtils;\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.android.internal.util.Preconditions;\n\nimport libcore.io.IoUtils;\n\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 114;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static void addMapping(Map<String, String> map, String column) {\n        if (!map.containsKey(column)) {\n            map.put(column, column);\n        }\n    }\n\n    private static void addMapping(Map<String, String> map, String column, String rawColumn) {\n        if (!map.containsKey(column)) {\n            map.put(column, rawColumn + \" AS \" + column);\n        }\n    }\n\n    private static final Map<String, String> sDownloadsMap = new ArrayMap<>();\n    static {\n        final Map<String, String> map = sDownloadsMap;\n\n        // Columns defined by public API\n        addMapping(map, DownloadManager.COLUMN_ID,\n                Downloads.Impl._ID);\n        addMapping(map, DownloadManager.COLUMN_LOCAL_FILENAME,\n                Downloads.Impl._DATA);\n        addMapping(map, DownloadManager.COLUMN_MEDIAPROVIDER_URI);\n        addMapping(map, DownloadManager.COLUMN_DESTINATION);\n        addMapping(map, DownloadManager.COLUMN_TITLE);\n        addMapping(map, DownloadManager.COLUMN_DESCRIPTION);\n        addMapping(map, DownloadManager.COLUMN_URI);\n        addMapping(map, DownloadManager.COLUMN_STATUS);\n        addMapping(map, DownloadManager.COLUMN_FILE_NAME_HINT);\n        addMapping(map, DownloadManager.COLUMN_MEDIA_TYPE,\n                Downloads.Impl.COLUMN_MIME_TYPE);\n        addMapping(map, DownloadManager.COLUMN_TOTAL_SIZE_BYTES,\n                Downloads.Impl.COLUMN_TOTAL_BYTES);\n        addMapping(map, DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        addMapping(map, DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR,\n                Downloads.Impl.COLUMN_CURRENT_BYTES);\n        addMapping(map, DownloadManager.COLUMN_ALLOW_WRITE);\n        addMapping(map, DownloadManager.COLUMN_LOCAL_URI,\n                \"'placeholder'\");\n        addMapping(map, DownloadManager.COLUMN_REASON,\n                \"'placeholder'\");\n\n        // Columns defined by OpenableColumns\n        addMapping(map, OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE);\n        addMapping(map, OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES);\n\n        // Allow references to all other columns to support DownloadInfo.Reader;\n        // we're already using SQLiteQueryBuilder to block access to other rows\n        // that don't belong to the calling UID.\n        addMapping(map, Downloads.Impl._ID);\n        addMapping(map, Downloads.Impl._DATA);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOW_METERED);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        addMapping(map, Downloads.Impl.COLUMN_ALLOW_WRITE);\n        addMapping(map, Downloads.Impl.COLUMN_APP_DATA);\n        addMapping(map, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n        addMapping(map, Downloads.Impl.COLUMN_CONTROL);\n        addMapping(map, Downloads.Impl.COLUMN_COOKIE_DATA);\n        addMapping(map, Downloads.Impl.COLUMN_CURRENT_BYTES);\n        addMapping(map, Downloads.Impl.COLUMN_DELETED);\n        addMapping(map, Downloads.Impl.COLUMN_DESCRIPTION);\n        addMapping(map, Downloads.Impl.COLUMN_DESTINATION);\n        addMapping(map, Downloads.Impl.COLUMN_ERROR_MSG);\n        addMapping(map, Downloads.Impl.COLUMN_FAILED_CONNECTIONS);\n        addMapping(map, Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        addMapping(map, Downloads.Impl.COLUMN_FLAGS);\n        addMapping(map, Downloads.Impl.COLUMN_IS_PUBLIC_API);\n        addMapping(map, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        addMapping(map, Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        addMapping(map, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n        addMapping(map, Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        addMapping(map, Downloads.Impl.COLUMN_MEDIASTORE_URI);\n        addMapping(map, Downloads.Impl.COLUMN_MIME_TYPE);\n        addMapping(map, Downloads.Impl.COLUMN_NO_INTEGRITY);\n        addMapping(map, Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        addMapping(map, Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS);\n        addMapping(map, Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        addMapping(map, Downloads.Impl.COLUMN_OTHER_UID);\n        addMapping(map, Downloads.Impl.COLUMN_REFERER);\n        addMapping(map, Downloads.Impl.COLUMN_STATUS);\n        addMapping(map, Downloads.Impl.COLUMN_TITLE);\n        addMapping(map, Downloads.Impl.COLUMN_TOTAL_BYTES);\n        addMapping(map, Downloads.Impl.COLUMN_URI);\n        addMapping(map, Downloads.Impl.COLUMN_USER_AGENT);\n        addMapping(map, Downloads.Impl.COLUMN_VISIBILITY);\n\n        addMapping(map, Constants.ETAG);\n        addMapping(map, Constants.RETRY_AFTER_X_REDIRECT_COUNT);\n        addMapping(map, Constants.UID);\n    }\n\n    private static final Map<String, String> sHeadersMap = new ArrayMap<>();\n    static {\n        final Map<String, String> map = sHeadersMap;\n        addMapping(map, \"id\");\n        addMapping(map, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID);\n        addMapping(map, Downloads.Impl.RequestHeaders.COLUMN_HEADER);\n        addMapping(map, Downloads.Impl.RequestHeaders.COLUMN_VALUE);\n    }\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                case 112:\n                    updateMediaStoreUrisFromFilesToDownloads(db);\n                    break;\n\n                case 113:\n                    canonicalizeDataPaths(db);\n                    break;\n\n                case 114:\n                    nullifyMediaStoreUris(db);\n                    MediaScanTriggerJob.schedule(getContext());\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final ContentValues mediaValues;\n                    try {\n                        mediaValues = convertToMediaProviderValues(info);\n                    } catch (IllegalArgumentException e) {\n                        Log.e(Constants.TAG, \"Error getting media content values from \" + info, e);\n                        continue;\n                    }\n                    final Uri mediaStoreUri = updateMediaProvider(client, mediaValues);\n                    if (mediaStoreUri != null) {\n                        updateValues.clear();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * DownloadProvider has been updated to use MediaStore.Downloads based uris\n         * for COLUMN_MEDIASTORE_URI but the existing entries would still have MediaStore.Files\n         * based uris. It's possible that in the future we might incorrectly assume that all the\n         * uris are MediaStore.DownloadColumns based and end up querying some\n         * MediaStore.Downloads specific columns. To avoid this, update the existing entries to\n         * use MediaStore.Downloads based uris only.\n         */\n        private void updateMediaStoreUrisFromFilesToDownloads(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, COLUMN_MEDIASTORE_URI },\n                    COLUMN_MEDIASTORE_URI + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final Uri mediaStoreFilesUri = Uri.parse(cursor.getString(1));\n\n                    final long mediaStoreId = ContentUris.parseId(mediaStoreFilesUri);\n                    final String volumeName = MediaStore.getVolumeName(mediaStoreFilesUri);\n                    final Uri mediaStoreDownloadsUri\n                            = MediaStore.Downloads.getContentUri(volumeName, mediaStoreId);\n\n                    updateValues.clear();\n                    updateValues.put(COLUMN_MEDIASTORE_URI, mediaStoreDownloadsUri.toString());\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        private void canonicalizeDataPaths(SQLiteDatabase db) {\n            try (Cursor cursor = db.query(DB_TABLE,\n                    new String[] { Downloads.Impl._ID, Downloads.Impl._DATA},\n                    Downloads.Impl._DATA + \" IS NOT NULL\", null, null, null, null)) {\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    final long id = cursor.getLong(0);\n                    final String filePath = cursor.getString(1);\n                    final String canonicalPath;\n                    try {\n                        canonicalPath = new File(filePath).getCanonicalPath();\n                    } catch (IOException e) {\n                        Log.e(Constants.TAG, \"Found invalid path='\" + filePath + \"' for id=\" + id);\n                        continue;\n                    }\n\n                    updateValues.clear();\n                    updateValues.put(Downloads.Impl._DATA, canonicalPath);\n                    db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                            new String[] { Long.toString(id) });\n                }\n            }\n        }\n\n        /**\n         * Set mediastore uri column to null before the clean-up job and fill it again while\n         * running the job so that if the clean-up job gets preempted, we could use it\n         * as a way to know the entries which are already handled when the job gets restarted.\n         */\n        private void nullifyMediaStoreUris(SQLiteDatabase db) {\n            final String whereClause = Downloads.Impl._DATA + \" IS NOT NULL\"\n                    + \" AND (\" + COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI + \"=1\"\n                    + \" OR \" + COLUMN_MEDIA_SCANNED + \"=\" + MEDIA_SCANNED + \")\"\n                    + \" AND (\" + COLUMN_DESTINATION + \"=\" + Downloads.Impl.DESTINATION_EXTERNAL\n                    + \" OR \" + COLUMN_DESTINATION + \"=\" + DESTINATION_FILE_URI\n                    + \" OR \" + COLUMN_DESTINATION + \"=\" + DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                    + \")\";\n            final ContentValues values = new ContentValues();\n            values.putNull(COLUMN_MEDIASTORE_URI);\n            db.update(DB_TABLE, values, whereClause, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        reconcileRemovedUidEntries();\n        return true;\n    }\n\n    private void reconcileRemovedUidEntries() {\n        Helpers.handleRemovedUidEntries(getContext(), this, -1, this::grantAllDownloadsPermission);\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        switch (method) {\n            case Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED: {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_MEDIASTORE_DOWNLOADS_DELETED);\n                final long[] deletedDownloadIds = extras.getLongArray(Downloads.EXTRA_IDS);\n                final String[] mimeTypes = extras.getStringArray(Downloads.EXTRA_MIME_TYPES);\n                DownloadStorageProvider.onMediaProviderDownloadsDelete(getContext(),\n                        deletedDownloadIds, mimeTypes);\n                return null;\n            }\n            case Downloads.CALL_CREATE_EXTERNAL_PUBLIC_DIR: {\n                final String dirType = extras.getString(Downloads.DIR_TYPE);\n                if (!ArrayUtils.contains(Environment.STANDARD_DIRECTORIES, dirType)) {\n                    throw new IllegalStateException(\"Not one of standard directories: \" + dirType);\n                }\n                final File file = Environment.getExternalStoragePublicDirectory(dirType);\n                if (file.exists()) {\n                    if (!file.isDirectory()) {\n                        throw new IllegalStateException(file.getAbsolutePath() +\n                                \" already exists and is not a directory\");\n                    }\n                } else if (!file.mkdirs()) {\n                    throw new IllegalStateException(\"Unable to create directory: \" +\n                            file.getAbsolutePath());\n                }\n                return null;\n            }\n            case Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS : {\n                Preconditions.checkArgument(Binder.getCallingUid() == Process.myUid(),\n                        \"Not allowed to call \" + Downloads.CALL_REVOKE_MEDIASTORE_URI_PERMS);\n                DownloadStorageProvider.revokeAllMediaStoreUriPermissions(getContext());\n                return null;\n            }\n            default:\n                throw new UnsupportedOperationException(\"Unsupported call: \" + method);\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n            } else if (dest == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                checkDownloadedFilePath(values);\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        ensureDefaultColumns(values);\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        copyBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        final Integer mediaScanned = values.getAsInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        filteredValues.put(COLUMN_MEDIA_SCANNED,\n                mediaScanned == null ? MEDIA_NOT_SCANNED : mediaScanned);\n\n        final boolean shouldBeVisibleToUser\n                = filteredValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)\n                        || filteredValues.getAsInteger(COLUMN_MEDIA_SCANNED) == MEDIA_NOT_SCANNED;\n        if (shouldBeVisibleToUser && filteredValues.getAsInteger(COLUMN_DESTINATION)\n                == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            final CallingIdentity token = clearCallingIdentity();\n            try {\n                final Uri mediaStoreUri = MediaStore.scanFile(getContext(),\n                        new File(filteredValues.getAsString(Downloads.Impl._DATA)));\n                if (mediaStoreUri != null) {\n                    final ContentValues mediaValues = new ContentValues();\n                    mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                            filteredValues.getAsString(Downloads.Impl.COLUMN_URI));\n                    mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                            filteredValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n                    mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                            Helpers.getPackageForUid(getContext(),\n                                    filteredValues.getAsInteger(Constants.UID)));\n                    getContext().getContentResolver().update(\n                            convertToMediaStoreDownloadsUri(mediaStoreUri),\n                            mediaValues, null, null);\n\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = Helpers.getPackageForUid(getContext(),\n                Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @NonNull ContentValues mediaValues) {\n        final String filePath = mediaValues.getAsString(MediaStore.DownloadColumns.DATA);\n        Uri mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(\n                        MediaStore.Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = MediaStore.setIncludePending(\n                MediaStore.Files.getContentUriForPath(filePath));\n        try (Cursor cursor = mediaProvider.query(filesUri,\n                new String[] { MediaStore.Files.FileColumns._ID },\n                MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final String filePath;\n        try {\n            filePath = new File(info.mFileName).getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final boolean downloadCompleted = Downloads.Impl.isStatusCompleted(info.mStatus);\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,  filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadCompleted ? info.mTotalBytes : info.mCurrentBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, downloadCompleted ? 0 : 1);\n        mediaValues.put(MediaStore.Downloads.OWNER_PACKAGE_NAME,\n                Helpers.getPackageForUid(getContext(), info.mUid));\n        mediaValues.put(MediaStore.Files.FileColumns.IS_DOWNLOAD, info.mIsVisibleInDownloadsUi);\n        return mediaValues;\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private void ensureDefaultColumns(ContentValues values) {\n        final Integer dest = values.getAsInteger(COLUMN_DESTINATION);\n        if (dest != null) {\n            final int mediaScannable;\n            final boolean visibleInDownloadsUi;\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                mediaScannable = MEDIA_NOT_SCANNED;\n                visibleInDownloadsUi = true;\n            } else if (dest != DESTINATION_FILE_URI\n                    && dest != DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                mediaScannable = MEDIA_NOT_SCANNABLE;\n                visibleInDownloadsUi = false;\n            } else {\n                final File file;\n                if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                    final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                    file = new File(getFileUri(fileUri).getPath());\n                } else {\n                    file = new File(values.getAsString(Downloads.Impl._DATA));\n                }\n\n                if (Helpers.isFileInExternalAndroidDirs(file.getAbsolutePath())) {\n                    mediaScannable = MEDIA_NOT_SCANNABLE;\n                    visibleInDownloadsUi = false;\n                } else if (Helpers.isFilenameValidInPublicDownloadsDir(file)) {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = true;\n                } else {\n                    mediaScannable = MEDIA_NOT_SCANNED;\n                    visibleInDownloadsUi = false;\n                }\n            }\n            values.put(COLUMN_MEDIA_SCANNED, mediaScannable);\n            values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, visibleInDownloadsUi);\n        } else {\n            if (!values.containsKey(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n                values.put(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, true);\n            }\n        }\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, Uri.fromFile(file).toString());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())\n                || Helpers.isFilenameValidInKnownPublicDir(file.getAbsolutePath())) {\n            // No permissions required for paths belonging to calling package or\n            // public downloads dir.\n            return;\n        } else if (targetSdkVersion < Build.VERSION_CODES.Q\n                && Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private void checkDownloadedFilePath(ContentValues values) {\n        final String path = values.getAsString(Downloads.Impl._DATA);\n        if (path == null || path.contains(\"..\")) {\n            throw new IllegalArgumentException(\"Invalid file path: \"\n                    + (path == null ? \"null\" : path));\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n            values.put(Downloads.Impl._DATA, file.getPath());\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (!file.exists()) {\n            throw new IllegalArgumentException(\"File doesn't exist: \" + file);\n        }\n\n        final int targetSdkVersion = getCallingPackageTargetSdkVersion();\n        final AppOpsManager appOpsManager = getContext().getSystemService(AppOpsManager.class);\n        final boolean runningLegacyMode = appOpsManager.checkOp(AppOpsManager.OP_LEGACY_STORAGE,\n                Binder.getCallingUid(), getCallingPackage()) == AppOpsManager.MODE_ALLOWED;\n\n        if (Binder.getCallingPid() == Process.myPid()) {\n            return;\n        } else if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package.\n            return;\n        } else if ((runningLegacyMode && Helpers.isFilenameValidInPublicDownloadsDir(file))\n                || (targetSdkVersion < Build.VERSION_CODES.Q\n                        && Helpers.isFilenameValidInExternal(getContext(), file))) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    private int getCallingPackageTargetSdkVersion() {\n        final String callingPackage = getCallingPackage();\n        if (callingPackage != null) {\n            ApplicationInfo ai = null;\n            try {\n                ai = getContext().getPackageManager()\n                        .getApplicationInfo(callingPackage, 0);\n            } catch (PackageManager.NameNotFoundException ignored) {\n            }\n            if (ai != null) {\n                return ai.targetSdkVersion;\n            }\n        }\n        return Build.VERSION_CODES.CUR_DEVELOPMENT;\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        final Cursor ret = qb.query(db, projection, selection, selectionArgs, null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                try {\n                    filteredValues.put(Downloads.Impl._DATA, new File(filename).getCanonicalPath());\n                } catch (IOException e) {\n                    throw new IllegalStateException(\"Invalid path: \" + filename);\n                }\n\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    final ContentValues updateValues = new ContentValues();\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        final boolean visibleToUser = info.mIsVisibleInDownloadsUi\n                                || (info.mMediaScanned != MEDIA_NOT_SCANNABLE);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                // If there was a mediastore entry, it would be deleted in it's\n                                // next idle pass.\n                                updateValues.clear();\n                                updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        } else if ((info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                                && visibleToUser) {\n                            final ContentValues mediaValues = convertToMediaProviderValues(info);\n                            final Uri mediaStoreUri;\n                            if (Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                                // Set size to 0 to ensure MediaScanner will scan this file.\n                                mediaValues.put(MediaStore.Downloads.SIZE, 0);\n                                updateMediaProvider(client, mediaValues);\n                                mediaStoreUri = triggerMediaScan(client, new File(info.mFileName));\n                            } else {\n                                mediaStoreUri = updateMediaProvider(client, mediaValues);\n                            }\n                            if (!TextUtils.equals(info.mMediaStoreUri,\n                                    mediaStoreUri == null ? null : mediaStoreUri.toString())) {\n                                updateValues.clear();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_NOT_SCANNED);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final Map<String, String> projectionMap;\n\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                projectionMap = sDownloadsMap;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                projectionMap = sDownloadsMap;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                projectionMap = sHeadersMap;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setTables(table);\n        qb.setProjectionMap(projectionMap);\n        qb.setStrict(true);\n        qb.setStrictColumns(true);\n        qb.setStrictGrammar(true);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                    deleteMediaStoreEntry(file);\n                                } else {\n                                    Log.d(Constants.TAG, \"Ignoring invalid file: \" + file);\n                                }\n                            } catch (IOException e) {\n                                Log.e(Constants.TAG, \"Couldn't delete file: \" + path, e);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    private void deleteMediaStoreEntry(File file) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final String path = file.getAbsolutePath();\n            final Uri.Builder builder = MediaStore.setIncludePending(\n                    MediaStore.Files.getContentUriForPath(path).buildUpon());\n            builder.appendQueryParameter(MediaStore.PARAM_DELETE_DATA, \"false\");\n\n            final Uri filesUri = builder.build();\n            getContext().getContentResolver().delete(filesUri,\n                    MediaStore.Files.FileColumns.DATA + \"=?\", new String[] { path });\n        } catch (Exception e) {\n            Log.d(Constants.TAG, \"Failed to delete mediastore entry for file:\" + file, e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != Downloads.Impl.MEDIA_NOT_SCANNABLE;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","lineNo":1525}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION;\n\nimport static com.android.providers.downloads.Constants.TAG;\nimport static com.android.providers.downloads.Helpers.getAsyncHandler;\nimport static com.android.providers.downloads.Helpers.getDownloadNotifier;\nimport static com.android.providers.downloads.Helpers.getInt;\nimport static com.android.providers.downloads.Helpers.getString;\nimport static com.android.providers.downloads.Helpers.getSystemFacade;\n\nimport android.app.DownloadManager;\nimport android.app.NotificationManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.widget.Toast;\n\n/**\n * Receives system broadcasts (boot, network connectivity)\n */\npublic class DownloadReceiver extends BroadcastReceiver {\n    /**\n     * Intent extra included with {@link Constants#ACTION_CANCEL} intents,\n     * indicating the IDs (as array of long) of the downloads that were\n     * canceled.\n     */\n    public static final String EXTRA_CANCELED_DOWNLOAD_IDS =\n            \"com.android.providers.downloads.extra.CANCELED_DOWNLOAD_IDS\";\n\n    /**\n     * Intent extra included with {@link Constants#ACTION_CANCEL} intents,\n     * indicating the tag of the notification corresponding to the download(s)\n     * that were canceled; this notification must be canceled.\n     */\n    public static final String EXTRA_CANCELED_DOWNLOAD_NOTIFICATION_TAG =\n            \"com.android.providers.downloads.extra.CANCELED_DOWNLOAD_NOTIFICATION_TAG\";\n\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        final String action = intent.getAction();\n        if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                || Intent.ACTION_MEDIA_MOUNTED.equals(action)) {\n            final PendingResult result = goAsync();\n            getAsyncHandler().post(new Runnable() {\n                @Override\n                public void run() {\n                    handleBootCompleted(context);\n                    result.finish();\n                }\n            });\n        } else if (Intent.ACTION_UID_REMOVED.equals(action)) {\n            final PendingResult result = goAsync();\n            getAsyncHandler().post(new Runnable() {\n                @Override\n                public void run() {\n                    handleUidRemoved(context, intent);\n                    result.finish();\n                }\n            });\n\n        } else if (Constants.ACTION_OPEN.equals(action)\n                || Constants.ACTION_LIST.equals(action)\n                || Constants.ACTION_HIDE.equals(action)) {\n\n            final PendingResult result = goAsync();\n            if (result == null) {\n                // TODO: remove this once test is refactored\n                handleNotificationBroadcast(context, intent);\n            } else {\n                getAsyncHandler().post(new Runnable() {\n                    @Override\n                    public void run() {\n                        handleNotificationBroadcast(context, intent);\n                        result.finish();\n                    }\n                });\n            }\n        } else if (Constants.ACTION_CANCEL.equals(action)) {\n            long[] downloadIds = intent.getLongArrayExtra(\n                    DownloadReceiver.EXTRA_CANCELED_DOWNLOAD_IDS);\n            DownloadManager manager = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            manager.remove(downloadIds);\n\n            String notifTag = intent.getStringExtra(\n                    DownloadReceiver.EXTRA_CANCELED_DOWNLOAD_NOTIFICATION_TAG);\n            NotificationManager notifManager = (NotificationManager) context.getSystemService(\n                    Context.NOTIFICATION_SERVICE);\n            notifManager.cancel(notifTag, 0);\n        }\n    }\n\n    private void handleBootCompleted(Context context) {\n        // Show any relevant notifications for completed downloads\n        getDownloadNotifier(context).update();\n\n        // Schedule all downloads that are ready\n        final ContentResolver resolver = context.getContentResolver();\n        try (Cursor cursor = resolver.query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, null,\n                null, null)) {\n            final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n            final DownloadInfo info = new DownloadInfo(context);\n            while (cursor.moveToNext()) {\n                reader.updateFromDatabase(info);\n                Helpers.scheduleJob(context, info);\n            }\n        }\n\n        // Schedule idle pass to clean up orphaned files\n        DownloadIdleService.scheduleIdlePass(context);\n    }\n\n    private void handleUidRemoved(Context context, Intent intent) {\n        final ContentResolver resolver = context.getContentResolver();\n        final int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);\n\n        // First, disown any downloads that live in shared storage\n        final ContentValues values = new ContentValues();\n        values.putNull(Constants.UID);\n        final int disowned = resolver.update(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, values,\n                Constants.UID + \"=\" + uid + \" AND \" + Downloads.Impl.COLUMN_DESTINATION + \" IN (\"\n                        + Downloads.Impl.DESTINATION_EXTERNAL + \",\"\n                        + Downloads.Impl.DESTINATION_FILE_URI + \")\",\n                null);\n\n        // Finally, delete any remaining downloads owned by UID\n        final int deleted = resolver.delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                Constants.UID + \"=\" + uid, null);\n\n        if ((disowned + deleted) > 0) {\n            Slog.d(TAG, \"Disowned \" + disowned + \" and deleted \" + deleted\n                    + \" downloads owned by UID \" + uid);\n        }\n    }\n\n    /**\n     * Handle any broadcast related to a system notification.\n     */\n    private void handleNotificationBroadcast(Context context, Intent intent) {\n        final String action = intent.getAction();\n        if (Constants.ACTION_LIST.equals(action)) {\n            final long[] ids = intent.getLongArrayExtra(\n                    DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS);\n            sendNotificationClickedIntent(context, ids);\n\n        } else if (Constants.ACTION_OPEN.equals(action)) {\n            final long id = ContentUris.parseId(intent.getData());\n            openDownload(context, id);\n            hideNotification(context, id);\n\n        } else if (Constants.ACTION_HIDE.equals(action)) {\n            final long id = ContentUris.parseId(intent.getData());\n            hideNotification(context, id);\n        }\n    }\n\n    /**\n     * Mark the given {@link DownloadManager#COLUMN_ID} as being acknowledged by\n     * user so it's not renewed later.\n     */\n    private void hideNotification(Context context, long id) {\n        final int status;\n        final int visibility;\n\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                status = getInt(cursor, Downloads.Impl.COLUMN_STATUS);\n                visibility = getInt(cursor, Downloads.Impl.COLUMN_VISIBILITY);\n            } else {\n                Log.w(TAG, \"Missing details for download \" + id);\n                return;\n            }\n        } finally {\n            cursor.close();\n        }\n\n        if (Downloads.Impl.isStatusCompleted(status) &&\n                (visibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED\n                || visibility == VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION)) {\n            final ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_VISIBILITY,\n                    Downloads.Impl.VISIBILITY_VISIBLE);\n            context.getContentResolver().update(uri, values, null, null);\n        }\n    }\n\n    /**\n     * Start activity to display the file represented by the given\n     * {@link DownloadManager#COLUMN_ID}.\n     */\n    private void openDownload(Context context, long id) {\n        if (!OpenHelper.startViewIntent(context, id, Intent.FLAG_ACTIVITY_NEW_TASK)) {\n            Toast.makeText(context, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                    .show();\n        }\n    }\n\n    /**\n     * Notify the owner of a running download that its notification was clicked.\n     */\n    private void sendNotificationClickedIntent(Context context, long[] ids) {\n        final String packageName;\n        final String clazz;\n        final boolean isPublicApi;\n\n        final Uri uri = ContentUris.withAppendedId(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, ids[0]);\n        final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                packageName = getString(cursor, Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n                clazz = getString(cursor, Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n                isPublicApi = getInt(cursor, Downloads.Impl.COLUMN_IS_PUBLIC_API) != 0;\n            } else {\n                Log.w(TAG, \"Missing details for download \" + ids[0]);\n                return;\n            }\n        } finally {\n            cursor.close();\n        }\n\n        if (TextUtils.isEmpty(packageName)) {\n            Log.w(TAG, \"Missing package; skipping broadcast\");\n            return;\n        }\n\n        Intent appIntent = null;\n        if (isPublicApi) {\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setPackage(packageName);\n            appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, ids);\n\n        } else { // legacy behavior\n            if (TextUtils.isEmpty(clazz)) {\n                Log.w(TAG, \"Missing class; skipping broadcast\");\n                return;\n            }\n\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setClassName(packageName, clazz);\n            appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, ids);\n\n            if (ids.length == 1) {\n                appIntent.setData(uri);\n            } else {\n                appIntent.setData(Downloads.Impl.CONTENT_URI);\n            }\n        }\n\n        getSystemFacade(context).sendBroadcast(appIntent);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION;\n\nimport static com.android.providers.downloads.Constants.TAG;\nimport static com.android.providers.downloads.Helpers.getAsyncHandler;\nimport static com.android.providers.downloads.Helpers.getDownloadNotifier;\nimport static com.android.providers.downloads.Helpers.getInt;\nimport static com.android.providers.downloads.Helpers.getString;\nimport static com.android.providers.downloads.Helpers.getSystemFacade;\n\nimport android.app.DownloadManager;\nimport android.app.NotificationManager;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\nimport android.widget.Toast;\n\nimport java.util.regex.Pattern;\n\n/**\n * Receives system broadcasts (boot, network connectivity)\n */\npublic class DownloadReceiver extends BroadcastReceiver {\n    /**\n     * Intent extra included with {@link Constants#ACTION_CANCEL} intents,\n     * indicating the IDs (as array of long) of the downloads that were\n     * canceled.\n     */\n    public static final String EXTRA_CANCELED_DOWNLOAD_IDS =\n            \"com.android.providers.downloads.extra.CANCELED_DOWNLOAD_IDS\";\n\n    /**\n     * Intent extra included with {@link Constants#ACTION_CANCEL} intents,\n     * indicating the tag of the notification corresponding to the download(s)\n     * that were canceled; this notification must be canceled.\n     */\n    public static final String EXTRA_CANCELED_DOWNLOAD_NOTIFICATION_TAG =\n            \"com.android.providers.downloads.extra.CANCELED_DOWNLOAD_NOTIFICATION_TAG\";\n\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        final String action = intent.getAction();\n        if (Intent.ACTION_BOOT_COMPLETED.equals(action)\n                || Intent.ACTION_MEDIA_MOUNTED.equals(action)) {\n            final PendingResult result = goAsync();\n            getAsyncHandler().post(new Runnable() {\n                @Override\n                public void run() {\n                    handleBootCompleted(context);\n                    result.finish();\n                }\n            });\n        } else if (Intent.ACTION_UID_REMOVED.equals(action)) {\n            final PendingResult result = goAsync();\n            getAsyncHandler().post(new Runnable() {\n                @Override\n                public void run() {\n                    handleUidRemoved(context, intent);\n                    result.finish();\n                }\n            });\n\n        } else if (Constants.ACTION_OPEN.equals(action)\n                || Constants.ACTION_LIST.equals(action)\n                || Constants.ACTION_HIDE.equals(action)) {\n\n            final PendingResult result = goAsync();\n            if (result == null) {\n                // TODO: remove this once test is refactored\n                handleNotificationBroadcast(context, intent);\n            } else {\n                getAsyncHandler().post(new Runnable() {\n                    @Override\n                    public void run() {\n                        handleNotificationBroadcast(context, intent);\n                        result.finish();\n                    }\n                });\n            }\n        } else if (Constants.ACTION_CANCEL.equals(action)) {\n            long[] downloadIds = intent.getLongArrayExtra(\n                    DownloadReceiver.EXTRA_CANCELED_DOWNLOAD_IDS);\n            DownloadManager manager = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            manager.remove(downloadIds);\n\n            String notifTag = intent.getStringExtra(\n                    DownloadReceiver.EXTRA_CANCELED_DOWNLOAD_NOTIFICATION_TAG);\n            NotificationManager notifManager = (NotificationManager) context.getSystemService(\n                    Context.NOTIFICATION_SERVICE);\n            notifManager.cancel(notifTag, 0);\n        }\n    }\n\n    private void handleBootCompleted(Context context) {\n        // Show any relevant notifications for completed downloads\n        getDownloadNotifier(context).update();\n\n        // Schedule all downloads that are ready\n        final ContentResolver resolver = context.getContentResolver();\n        try (Cursor cursor = resolver.query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, null,\n                null, null)) {\n            final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n            final DownloadInfo info = new DownloadInfo(context);\n            while (cursor.moveToNext()) {\n                reader.updateFromDatabase(info);\n                Helpers.scheduleJob(context, info);\n            }\n        }\n\n        // Schedule idle pass to clean up orphaned files\n        DownloadIdleService.scheduleIdlePass(context);\n    }\n\n    private void handleUidRemoved(Context context, Intent intent) {\n        final ContentResolver resolver = context.getContentResolver();\n        final int uid = intent.getIntExtra(Intent.EXTRA_UID, -1);\n\n        // First, disown any downloads that live in shared storage\n        final ContentValues values = new ContentValues();\n        values.putNull(Constants.UID);\n\n        final StringBuilder queryString = new StringBuilder(Constants.UID + \"=\" + uid);\n        queryString.append(\" AND \").append(Downloads.Impl.COLUMN_DESTINATION + \" IN (\"\n                + Downloads.Impl.DESTINATION_EXTERNAL + \",\"\n                + Downloads.Impl.DESTINATION_FILE_URI + \",\"\n                + Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD + \")\");\n        queryString.append(\" AND \").append(Downloads.Impl._DATA\n                + \" REGEXP '\" + MediaStore.Downloads.PATTERN_DOWNLOADS_FILE.pattern() + \"'\");\n\n        final int disowned = resolver.update(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, values,\n                queryString.toString(), null);\n\n        // Finally, delete any remaining downloads owned by UID\n        final int deleted = resolver.delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                Constants.UID + \"=\" + uid, null);\n\n        if ((disowned + deleted) > 0) {\n            Slog.d(TAG, \"Disowned \" + disowned + \" and deleted \" + deleted\n                    + \" downloads owned by UID \" + uid);\n        }\n    }\n\n    /**\n     * Handle any broadcast related to a system notification.\n     */\n    private void handleNotificationBroadcast(Context context, Intent intent) {\n        final String action = intent.getAction();\n        if (Constants.ACTION_LIST.equals(action)) {\n            final long[] ids = intent.getLongArrayExtra(\n                    DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS);\n            sendNotificationClickedIntent(context, ids);\n\n        } else if (Constants.ACTION_OPEN.equals(action)) {\n            final long id = ContentUris.parseId(intent.getData());\n            openDownload(context, id);\n            hideNotification(context, id);\n\n        } else if (Constants.ACTION_HIDE.equals(action)) {\n            final long id = ContentUris.parseId(intent.getData());\n            hideNotification(context, id);\n        }\n    }\n\n    /**\n     * Mark the given {@link DownloadManager#COLUMN_ID} as being acknowledged by\n     * user so it's not renewed later.\n     */\n    private void hideNotification(Context context, long id) {\n        final int status;\n        final int visibility;\n\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                status = getInt(cursor, Downloads.Impl.COLUMN_STATUS);\n                visibility = getInt(cursor, Downloads.Impl.COLUMN_VISIBILITY);\n            } else {\n                Log.w(TAG, \"Missing details for download \" + id);\n                return;\n            }\n        } finally {\n            cursor.close();\n        }\n\n        if (Downloads.Impl.isStatusCompleted(status) &&\n                (visibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED\n                || visibility == VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION)) {\n            final ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_VISIBILITY,\n                    Downloads.Impl.VISIBILITY_VISIBLE);\n            context.getContentResolver().update(uri, values, null, null);\n        }\n    }\n\n    /**\n     * Start activity to display the file represented by the given\n     * {@link DownloadManager#COLUMN_ID}.\n     */\n    private void openDownload(Context context, long id) {\n        if (!OpenHelper.startViewIntent(context, id, Intent.FLAG_ACTIVITY_NEW_TASK)) {\n            Toast.makeText(context, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                    .show();\n        }\n    }\n\n    /**\n     * Notify the owner of a running download that its notification was clicked.\n     */\n    private void sendNotificationClickedIntent(Context context, long[] ids) {\n        final String packageName;\n        final String clazz;\n        final boolean isPublicApi;\n\n        final Uri uri = ContentUris.withAppendedId(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, ids[0]);\n        final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                packageName = getString(cursor, Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n                clazz = getString(cursor, Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n                isPublicApi = getInt(cursor, Downloads.Impl.COLUMN_IS_PUBLIC_API) != 0;\n            } else {\n                Log.w(TAG, \"Missing details for download \" + ids[0]);\n                return;\n            }\n        } finally {\n            cursor.close();\n        }\n\n        if (TextUtils.isEmpty(packageName)) {\n            Log.w(TAG, \"Missing package; skipping broadcast\");\n            return;\n        }\n\n        Intent appIntent = null;\n        if (isPublicApi) {\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setPackage(packageName);\n            appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, ids);\n\n        } else { // legacy behavior\n            if (TextUtils.isEmpty(clazz)) {\n                Log.w(TAG, \"Missing class; skipping broadcast\");\n                return;\n            }\n\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setClassName(packageName, clazz);\n            appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, ids);\n\n            if (ids.length == 1) {\n                appIntent.setData(uri);\n            } else {\n                appIntent.setData(Downloads.Impl.CONTENT_URI);\n            }\n        }\n\n        getSystemFacade(context).sendBroadcast(appIntent);\n    }\n}\n","lineNo":151}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Files.FileColumns;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == Document.MIME_TYPE_DIR;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            if (isMediaStoreDownload(docId)) {\n                renameMediaStoreDownload(docId, displayName);\n            } else {\n                final long id = Long.parseLong(docId);\n                if (!mDm.rename(getContext(), id, displayName)) {\n                    throw new IllegalStateException(\n                            \"Failed to rename to \" + displayName + \" in downloadsManager\");\n                }\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        // size could be -1 which indicates that download hasn't started.\n        final long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size > 0) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size == -1 ? null : size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : FileUtils.listFilesOrEmpty(downloadsDir)) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private static List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : FileUtils.listFilesOrEmpty(sandboxDir)) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private void renameMediaStoreDownload(String docId, String displayName) {\n        final File before = getFileForMediaStoreDownload(docId);\n        final File after = new File(before.getParentFile(), displayName);\n\n        if (after.exists()) {\n            throw new IllegalStateException(\"Already exists \" + after);\n        }\n        if (!before.renameTo(after)) {\n            throw new IllegalStateException(\"Failed to rename from \" + before + \" to \" + after);\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final Uri mediaStoreUri = getMediaStoreUri(docId);\n            final ContentValues values = new ContentValues();\n            values.put(FileColumns.DATA, after.getAbsolutePath());\n            values.put(FileColumns.DISPLAY_NAME, displayName);\n            final int count = getContext().getContentResolver().update(mediaStoreUri, values,\n                    null, null);\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to update \" + mediaStoreUri\n                        + \", values=\" + values);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String filePath = null;\n            try (Cursor cursor = getContext().getContentResolver().query(\n                    getMediaStoreUri(docId), null, null, null)) {\n                if (cursor.moveToNext()) {\n                    filePath = cursor.getString(cursor.getColumnIndex(FileColumns.DATA));\n                }\n            }\n            if (filePath == null) {\n                throw new IllegalStateException(\"Filepath could not be found for\"\n                        + \" mediastore docId: \" + docId);\n            }\n            return new File(filePath);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Files.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(FileColumns._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(FileColumns.DISPLAY_NAME));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(FileColumns.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(FileColumns.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(FileColumns.IS_PENDING)) == 1;\n\n        int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n        if (!Document.MIME_TYPE_DIR.equals(mimeType)) {\n            extraFlags |= Document.FLAG_SUPPORTS_RENAME;\n        }\n\n        includeDownload(result, docId, displayName, null /* description */, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(FileColumns.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final int format = mediaCursor.getInt(mediaCursor.getColumnIndex(\n                FileColumns.FORMAT));\n        // TODO: Remove once b/123311895 is fixed.\n        if (format == MtpConstants.FORMAT_ASSOCIATION) {\n            return Document.MIME_TYPE_DIR;\n        }\n        final String mimeType = mediaCursor.getString(\n                mediaCursor.getColumnIndex(FileColumns.MIME_TYPE));\n        if (mimeType == null) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mimeType;\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private static Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        selection.append(FileColumns.IS_DOWNLOAD + \"=?\");\n        selectionArgs.add(\"1\");\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            selection.append(\" AND \");\n            selection.append(FileColumns._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            selection.append(\" AND \");\n            selection.append(FileColumns.PARENT + \"=?\");\n            selectionArgs.add(parentId);\n        } else {\n            selection.append(\" AND \");\n            // SELECT _id FROM files where is_download=1\n            final String subQuery = SQLiteQueryBuilder.buildQueryString(false,\n                    MediaStore.Files.TABLE, new String[] { FileColumns._ID },\n                    FileColumns.IS_DOWNLOAD + \"=1\", null, null, null, null);\n            selection.append(FileColumns.PARENT + \" NOT IN (\"\n                    + subQuery + \")\");\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.MEDIA_TYPE + \"=?\");\n                selectionArgs.add(String.valueOf(FileColumns.MEDIA_TYPE_NONE));\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, getDownloadsDirectories());\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.DownloadColumns;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == null;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            if (isMediaStoreDownload(docId)) {\n                renameMediaStoreDownload(docId, displayName);\n            } else {\n                final long id = Long.parseLong(docId);\n                if (!mDm.rename(getContext(), id, displayName)) {\n                    throw new IllegalStateException(\n                            \"Failed to rename to \" + displayName + \" in downloadsManager\");\n                }\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        // size could be -1 which indicates that download hasn't started.\n        final long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size > 0) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size == -1 ? null : size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : FileUtils.listFilesOrEmpty(downloadsDir)) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private static List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : FileUtils.listFilesOrEmpty(sandboxDir)) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private void renameMediaStoreDownload(String docId, String displayName) {\n        final File before = getFileForMediaStoreDownload(docId);\n        final File after = new File(before.getParentFile(), displayName);\n\n        if (after.exists()) {\n            throw new IllegalStateException(\"Already exists \" + after);\n        }\n        if (!before.renameTo(after)) {\n            throw new IllegalStateException(\"Failed to rename from \" + before + \" to \" + after);\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final Uri mediaStoreUri = getMediaStoreUri(docId);\n            final ContentValues values = new ContentValues();\n            values.put(DownloadColumns.DATA, after.getAbsolutePath());\n            values.put(DownloadColumns.DISPLAY_NAME, displayName);\n            final int count = getContext().getContentResolver().update(mediaStoreUri, values,\n                    null, null);\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to update \" + mediaStoreUri\n                        + \", values=\" + values);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final Uri mediaStoreUri = getMediaStoreUri(docId);\n        final long token = Binder.clearCallingIdentity();\n        try (Cursor cursor = queryForSingleItem(mediaStoreUri,\n                new String[] { DownloadColumns.DATA }, null, null, null)) {\n            final String filePath = cursor.getString(0);\n            if (filePath == null) {\n                throw new IllegalStateException(\"Missing _data for \" + mediaStoreUri);\n            }\n            return new File(filePath);\n        } catch (FileNotFoundException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Pair<String, String> getRelativePathAndDisplayNameForDownload(long id) {\n        final Uri mediaStoreUri = ContentUris.withAppendedId(\n                MediaStore.Downloads.EXTERNAL_CONTENT_URI, id);\n        final long token = Binder.clearCallingIdentity();\n        try (Cursor cursor = queryForSingleItem(mediaStoreUri,\n                new String[] { DownloadColumns.RELATIVE_PATH, DownloadColumns.DISPLAY_NAME },\n                null, null, null)) {\n            final String relativePath = cursor.getString(0);\n            final String displayName = cursor.getString(1);\n            if (relativePath == null || displayName == null) {\n                throw new IllegalStateException(\n                        \"relative_path and _display_name should not be null for \" + mediaStoreUri);\n            }\n            return Pair.create(relativePath, displayName);\n        } catch (FileNotFoundException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Copied from MediaProvider.java\n     *\n     * Query the given {@link Uri}, expecting only a single item to be found.\n     *\n     * @throws FileNotFoundException if no items were found, or multiple items\n     *             were found, or there was trouble reading the data.\n     */\n    private Cursor queryForSingleItem(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, CancellationSignal signal)\n            throws FileNotFoundException {\n        final Cursor c = getContext().getContentResolver().query(uri, projection,\n                ContentResolver.createSqlQueryBundle(selection, selectionArgs, null), signal);\n        if (c == null) {\n            throw new FileNotFoundException(\"Missing cursor for \" + uri);\n        } else if (c.getCount() < 1) {\n            IoUtils.closeQuietly(c);\n            throw new FileNotFoundException(\"No item at \" + uri);\n        } else if (c.getCount() > 1) {\n            IoUtils.closeQuietly(c);\n            throw new FileNotFoundException(\"Multiple items at \" + uri);\n        }\n\n        if (c.moveToFirst()) {\n            return c;\n        } else {\n            IoUtils.closeQuietly(c);\n            throw new FileNotFoundException(\"Failed to read row from \" + uri);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Downloads.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(DownloadColumns._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(DownloadColumns.DISPLAY_NAME));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(DownloadColumns.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(DownloadColumns.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(DownloadColumns.IS_PENDING)) == 1;\n\n        int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n        if (!Document.MIME_TYPE_DIR.equals(mimeType)) {\n            extraFlags |= Document.FLAG_SUPPORTS_RENAME;\n        }\n\n        includeDownload(result, docId, displayName, null /* description */, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(DownloadColumns.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final String mimeType = mediaCursor.getString(\n                mediaCursor.getColumnIndex(DownloadColumns.MIME_TYPE));\n        if (mimeType == null) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mimeType;\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            if (selection.length() > 0) {\n                selection.append(\" AND \");\n            }\n            selection.append(DownloadColumns._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            if (selection.length() > 0) {\n                selection.append(\" AND \");\n            }\n            selection.append(DownloadColumns.RELATIVE_PATH + \"=?\");\n            final Pair<String, String> data = getRelativePathAndDisplayNameForDownload(\n                    Long.parseLong(parentId));\n            selectionArgs.add(data.first + \"/\" + data.second);\n        } else {\n            if (selection.length() > 0) {\n                selection.append(\" AND \");\n            }\n            selection.append(DownloadColumns.RELATIVE_PATH + \"=?\");\n            selectionArgs.add(Environment.DIRECTORY_DOWNLOADS);\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.MIME_TYPE + \" NOT LIKE \\\"image/%\\\"\");\n                selection.append(\" AND \");\n                selection.append(DownloadColumns.MIME_TYPE + \" NOT LIKE \\\"audio/%\\\"\");\n                selection.append(\" AND \");\n                selection.append(DownloadColumns.MIME_TYPE + \" NOT LIKE \\\"video/%\\\"\");\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, getDownloadsDirectories());\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","lineNo":828}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Files.FileColumns;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == Document.MIME_TYPE_DIR;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            if (isMediaStoreDownload(docId)) {\n                renameMediaStoreDownload(docId, displayName);\n            } else {\n                final long id = Long.parseLong(docId);\n                if (!mDm.rename(getContext(), id, displayName)) {\n                    throw new IllegalStateException(\n                            \"Failed to rename to \" + displayName + \" in downloadsManager\");\n                }\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        // size could be -1 which indicates that download hasn't started.\n        final long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size > 0) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size == -1 ? null : size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : FileUtils.listFilesOrEmpty(downloadsDir)) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private static List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : FileUtils.listFilesOrEmpty(sandboxDir)) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private void renameMediaStoreDownload(String docId, String displayName) {\n        final File before = getFileForMediaStoreDownload(docId);\n        final File after = new File(before.getParentFile(), displayName);\n\n        if (after.exists()) {\n            throw new IllegalStateException(\"Already exists \" + after);\n        }\n        if (!before.renameTo(after)) {\n            throw new IllegalStateException(\"Failed to rename from \" + before + \" to \" + after);\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final Uri mediaStoreUri = getMediaStoreUri(docId);\n            final ContentValues values = new ContentValues();\n            values.put(FileColumns.DATA, after.getAbsolutePath());\n            values.put(FileColumns.DISPLAY_NAME, displayName);\n            final int count = getContext().getContentResolver().update(mediaStoreUri, values,\n                    null, null);\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to update \" + mediaStoreUri\n                        + \", values=\" + values);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String filePath = null;\n            try (Cursor cursor = getContext().getContentResolver().query(\n                    getMediaStoreUri(docId), null, null, null)) {\n                if (cursor.moveToNext()) {\n                    filePath = cursor.getString(cursor.getColumnIndex(FileColumns.DATA));\n                }\n            }\n            if (filePath == null) {\n                throw new IllegalStateException(\"Filepath could not be found for\"\n                        + \" mediastore docId: \" + docId);\n            }\n            return new File(filePath);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Files.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(FileColumns._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(FileColumns.DISPLAY_NAME));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(FileColumns.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(FileColumns.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(FileColumns.IS_PENDING)) == 1;\n\n        int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n        if (!Document.MIME_TYPE_DIR.equals(mimeType)) {\n            extraFlags |= Document.FLAG_SUPPORTS_RENAME;\n        }\n\n        includeDownload(result, docId, displayName, null /* description */, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(FileColumns.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final int format = mediaCursor.getInt(mediaCursor.getColumnIndex(\n                FileColumns.FORMAT));\n        // TODO: Remove once b/123311895 is fixed.\n        if (format == MtpConstants.FORMAT_ASSOCIATION) {\n            return Document.MIME_TYPE_DIR;\n        }\n        final String mimeType = mediaCursor.getString(\n                mediaCursor.getColumnIndex(FileColumns.MIME_TYPE));\n        if (mimeType == null) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mimeType;\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private static Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        selection.append(FileColumns.IS_DOWNLOAD + \"=?\");\n        selectionArgs.add(\"1\");\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            selection.append(\" AND \");\n            selection.append(FileColumns._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            selection.append(\" AND \");\n            selection.append(FileColumns.PARENT + \"=?\");\n            selectionArgs.add(parentId);\n        } else {\n            selection.append(\" AND \");\n            // SELECT _id FROM files where is_download=1\n            final String subQuery = SQLiteQueryBuilder.buildQueryString(false,\n                    MediaStore.Files.TABLE, new String[] { FileColumns._ID },\n                    FileColumns.IS_DOWNLOAD + \"=1\", null, null, null, null);\n            selection.append(FileColumns.PARENT + \" NOT IN (\"\n                    + subQuery + \")\");\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.MEDIA_TYPE + \"=?\");\n                selectionArgs.add(String.valueOf(FileColumns.MEDIA_TYPE_NONE));\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                selection.append(\" AND \");\n                selection.append(FileColumns.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, getDownloadsDirectories());\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.DownloadColumns;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == null;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            if (isMediaStoreDownload(docId)) {\n                renameMediaStoreDownload(docId, displayName);\n            } else {\n                final long id = Long.parseLong(docId);\n                if (!mDm.rename(getContext(), id, displayName)) {\n                    throw new IllegalStateException(\n                            \"Failed to rename to \" + displayName + \" in downloadsManager\");\n                }\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        // size could be -1 which indicates that download hasn't started.\n        final long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size > 0) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size == -1 ? null : size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : FileUtils.listFilesOrEmpty(downloadsDir)) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private static List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : FileUtils.listFilesOrEmpty(sandboxDir)) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private void renameMediaStoreDownload(String docId, String displayName) {\n        final File before = getFileForMediaStoreDownload(docId);\n        final File after = new File(before.getParentFile(), displayName);\n\n        if (after.exists()) {\n            throw new IllegalStateException(\"Already exists \" + after);\n        }\n        if (!before.renameTo(after)) {\n            throw new IllegalStateException(\"Failed to rename from \" + before + \" to \" + after);\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final Uri mediaStoreUri = getMediaStoreUri(docId);\n            final ContentValues values = new ContentValues();\n            values.put(DownloadColumns.DATA, after.getAbsolutePath());\n            values.put(DownloadColumns.DISPLAY_NAME, displayName);\n            final int count = getContext().getContentResolver().update(mediaStoreUri, values,\n                    null, null);\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to update \" + mediaStoreUri\n                        + \", values=\" + values);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final Uri mediaStoreUri = getMediaStoreUri(docId);\n        final long token = Binder.clearCallingIdentity();\n        try (Cursor cursor = queryForSingleItem(mediaStoreUri,\n                new String[] { DownloadColumns.DATA }, null, null, null)) {\n            final String filePath = cursor.getString(0);\n            if (filePath == null) {\n                throw new IllegalStateException(\"Missing _data for \" + mediaStoreUri);\n            }\n            return new File(filePath);\n        } catch (FileNotFoundException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private Pair<String, String> getRelativePathAndDisplayNameForDownload(long id) {\n        final Uri mediaStoreUri = ContentUris.withAppendedId(\n                MediaStore.Downloads.EXTERNAL_CONTENT_URI, id);\n        final long token = Binder.clearCallingIdentity();\n        try (Cursor cursor = queryForSingleItem(mediaStoreUri,\n                new String[] { DownloadColumns.RELATIVE_PATH, DownloadColumns.DISPLAY_NAME },\n                null, null, null)) {\n            final String relativePath = cursor.getString(0);\n            final String displayName = cursor.getString(1);\n            if (relativePath == null || displayName == null) {\n                throw new IllegalStateException(\n                        \"relative_path and _display_name should not be null for \" + mediaStoreUri);\n            }\n            return Pair.create(relativePath, displayName);\n        } catch (FileNotFoundException e) {\n            throw new IllegalStateException(e);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Copied from MediaProvider.java\n     *\n     * Query the given {@link Uri}, expecting only a single item to be found.\n     *\n     * @throws FileNotFoundException if no items were found, or multiple items\n     *             were found, or there was trouble reading the data.\n     */\n    private Cursor queryForSingleItem(Uri uri, String[] projection,\n            String selection, String[] selectionArgs, CancellationSignal signal)\n            throws FileNotFoundException {\n        final Cursor c = getContext().getContentResolver().query(uri, projection,\n                ContentResolver.createSqlQueryBundle(selection, selectionArgs, null), signal);\n        if (c == null) {\n            throw new FileNotFoundException(\"Missing cursor for \" + uri);\n        } else if (c.getCount() < 1) {\n            IoUtils.closeQuietly(c);\n            throw new FileNotFoundException(\"No item at \" + uri);\n        } else if (c.getCount() > 1) {\n            IoUtils.closeQuietly(c);\n            throw new FileNotFoundException(\"Multiple items at \" + uri);\n        }\n\n        if (c.moveToFirst()) {\n            return c;\n        } else {\n            IoUtils.closeQuietly(c);\n            throw new FileNotFoundException(\"Failed to read row from \" + uri);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Downloads.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(DownloadColumns._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(DownloadColumns.DISPLAY_NAME));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(DownloadColumns.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(DownloadColumns.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(DownloadColumns.IS_PENDING)) == 1;\n\n        int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n        if (!Document.MIME_TYPE_DIR.equals(mimeType)) {\n            extraFlags |= Document.FLAG_SUPPORTS_RENAME;\n        }\n\n        includeDownload(result, docId, displayName, null /* description */, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(DownloadColumns.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final String mimeType = mediaCursor.getString(\n                mediaCursor.getColumnIndex(DownloadColumns.MIME_TYPE));\n        if (mimeType == null) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mimeType;\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            if (selection.length() > 0) {\n                selection.append(\" AND \");\n            }\n            selection.append(DownloadColumns._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            if (selection.length() > 0) {\n                selection.append(\" AND \");\n            }\n            selection.append(DownloadColumns.RELATIVE_PATH + \"=?\");\n            final Pair<String, String> data = getRelativePathAndDisplayNameForDownload(\n                    Long.parseLong(parentId));\n            selectionArgs.add(data.first + \"/\" + data.second);\n        } else {\n            if (selection.length() > 0) {\n                selection.append(\" AND \");\n            }\n            selection.append(DownloadColumns.RELATIVE_PATH + \"=?\");\n            selectionArgs.add(Environment.DIRECTORY_DOWNLOADS);\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.MIME_TYPE + \" NOT LIKE \\\"image/%\\\"\");\n                selection.append(\" AND \");\n                selection.append(DownloadColumns.MIME_TYPE + \" NOT LIKE \\\"audio/%\\\"\");\n                selection.append(\" AND \");\n                selection.append(DownloadColumns.MIME_TYPE + \" NOT LIKE \\\"video/%\\\"\");\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                if (selection.length() > 0) {\n                    selection.append(\" AND \");\n                }\n                selection.append(DownloadColumns.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, getDownloadsDirectories());\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","lineNo":828}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.os.Binder.getCallingPid;\nimport static android.os.Binder.getCallingUid;\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNABLE;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNED;\nimport static android.provider.Downloads.Impl.MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.TranslatingCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Files;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 111;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final Uri mediaStoreUri = updateMediaProvider(client, null,\n                            convertToMediaProviderValues(info));\n                    if (mediaStoreUri != null) {\n                        updateValues.clear();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        try {\n            while (cursor.moveToNext()) {\n                final long downloadId = cursor.getLong(0);\n                final int uid = cursor.getInt(1);\n                final String ownerPackage = getPackageForUid(uid);\n                if (ownerPackage == null) {\n                    idsToDelete.add(downloadId);\n                } else {\n                    grantAllDownloadsPermission(ownerPackage, downloadId);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG,\n                    \"Deleting downloads with ids \" + idsToDelete + \" as owner package is missing\");\n            deleteDownloadsWithIds(idsToDelete);\n        }\n        return true;\n    }\n\n    private void deleteDownloadsWithIds(ArrayList<Long> downloadIds) {\n        final int N = downloadIds.size();\n        if (N == 0) {\n            return;\n        }\n        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + \" in (\");\n        for (int i = 0; i < N; i++) {\n            queryBuilder.append(downloadIds.get(i));\n            queryBuilder.append((i == N - 1) ? \")\" : \",\");\n        }\n        delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, queryBuilder.toString(), null);\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (method == Downloads.MEDIASTORE_DOWNLOADS_DELETED_CALL) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_MEDIA_STORAGE,\n                    \"Not allowed to call \" + Downloads.MEDIASTORE_DOWNLOADS_DELETED_CALL);\n            final long[] deletedDownloadIds = extras.getLongArray(Downloads.EXTRA_IDS);\n            final String[] mimeTypes = extras.getStringArray(Downloads.EXTRA_MIME_TYPES);\n            DownloadStorageProvider.onMediaProviderDownloadsDelete(getContext(),\n                    deletedDownloadIds, mimeTypes);\n            return null;\n        } else {\n            throw new UnsupportedOperationException(\"Unsupported call: \" + method);\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n                final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                        fileUri, getCallingPid(), getCallingUid()));\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            values.put(Downloads.Impl._DATA, translateAppToSystem(\n                    values.getAsString(Downloads.Impl._DATA), getCallingPid(), getCallingUid()));\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        final Integer mediaScanned = values.getAsInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        filteredValues.put(COLUMN_MEDIA_SCANNED,\n                mediaScanned == null ? MEDIA_NOT_SCANNED : mediaScanned);\n\n        final boolean shouldBeVisibleToUser\n                = filteredValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)\n                        || filteredValues.getAsInteger(COLUMN_MEDIA_SCANNED) == MEDIA_NOT_SCANNED;\n        if (shouldBeVisibleToUser && filteredValues.getAsInteger(COLUMN_DESTINATION)\n                == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            final CallingIdentity token = clearCallingIdentity();\n            try (ContentProviderClient client = getContext().getContentResolver()\n                    .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                final Uri mediaStoreUri = updateMediaProvider(client, null,\n                        convertToMediaProviderValues(filteredValues));\n                if (mediaStoreUri != null) {\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = getPackageForUid(Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @Nullable String currentMediaStoreUri,\n            @NonNull ContentValues mediaValues) {\n        Uri mediaStoreUri;\n        final String filePath = mediaValues.getAsString(Files.FileColumns.DATA);\n        final boolean isVisibleInDownloads = mediaValues.getAsInteger(\n                Files.FileColumns.IS_DOWNLOAD) == 1;\n        if (currentMediaStoreUri == null) {\n            if (!isVisibleInDownloads) {\n                return null;\n            }\n            mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n        } else {\n            mediaStoreUri = Uri.parse(currentMediaStoreUri);\n        }\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                removeInvalidColumnsForUpdate(mediaValues);\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return isVisibleInDownloads ? mediaStoreUri : null;\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    /**\n     * Remove column values which are not valid for updating downloads in MediaProvider.\n     */\n    private void removeInvalidColumnsForUpdate(@NonNull ContentValues mediaValues) {\n        mediaValues.remove(MediaStore.Downloads.SIZE);\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = Files.getContentUriForPath(filePath);\n        try (Cursor cursor = mediaProvider.query(filesUri, new String[] { Files.FileColumns._ID },\n                Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA, info.mFileName);\n        mediaValues.put(MediaStore.Downloads.SIZE, info.mTotalBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.DISPLAY_NAME, info.mTitle);\n        mediaValues.put(MediaStore.Downloads.DESCRIPTION, info.mDescription);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING,\n                Downloads.Impl.isStatusSuccess(info.mStatus) ? 0 : 1);\n        mediaValues.put(Files.FileColumns.IS_DOWNLOAD, 1);\n        return mediaValues;\n    }\n\n    private ContentValues convertToMediaProviderValues(ContentValues downloadValues) {\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,\n                downloadValues.getAsString(Downloads.Impl._DATA));\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadValues.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_URI));\n        mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n        mediaValues.put(MediaStore.Downloads.DISPLAY_NAME,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_TITLE));\n        mediaValues.put(MediaStore.Downloads.DESCRIPTION,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_DESCRIPTION));\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_MIME_TYPE));\n        final boolean isPending = downloadValues.getAsInteger(Downloads.Impl.COLUMN_STATUS)\n                != Downloads.Impl.STATUS_SUCCESS;\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, isPending ? 1 : 0);\n        mediaValues.put(Files.FileColumns.IS_DOWNLOAD, downloadValues.getAsBoolean(\n                Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI) ? 1 : 0);\n        return mediaValues;\n    }\n\n    private @Nullable String translateAppToSystem(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File app = new File(path);\n        final File system = mStorageManager.translateAppToSystem(app, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? system.getPath() : Uri.fromFile(system).toString();\n    }\n\n    private @Nullable String translateSystemToApp(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File system = new File(path);\n        final File app = mStorageManager.translateSystemToApp(system, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? app.getPath() : Uri.fromFile(app).toString();\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private String getPackageForUid(int uid) {\n        String[] packages = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packages == null || packages.length == 0) {\n            return null;\n        }\n        // For permission related purposes, any package belonging to the given uid should work.\n        return packages[0];\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            if (!StorageManager.hasIsolatedStorage()) {\n                // Otherwise we require write permission\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write to \" + file);\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write to \" + file);\n                }\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        // map of volumeName -> { mediastore ids that need to be queried }\n        final ArrayMap<String, LongArray> mediaStoreIdsForVolumes = new ArrayMap<>();\n        try (Cursor cursor = qb.query(db, new String[] { Downloads.Impl.COLUMN_MEDIASTORE_URI },\n                selection, selectionArgs, null, null, sort)) {\n            while (cursor.moveToNext()) {\n                final String uriString = cursor.getString(0);\n                if (uriString == null) {\n                    continue;\n                }\n                final Uri mediaStoreUri = Uri.parse(uriString);\n                final String volumeName = MediaStore.getVolumeName(mediaStoreUri);\n                LongArray ids = mediaStoreIdsForVolumes.get(volumeName);\n                if (ids == null) {\n                    ids = new LongArray();\n                    mediaStoreIdsForVolumes.put(volumeName, ids);\n                }\n                ids.add(ContentUris.parseId(mediaStoreUri));\n            }\n        }\n        // map of volumeName -> { map of {mediastore id -> mediastore data} }\n        final ArrayMap<String, LongSparseArray<MediaStoreData>> mediaStoreDataForVolumes\n                = new ArrayMap<>();\n        final CallingIdentity token = clearCallingIdentity();\n        try (ContentProviderClient client = getContext().getContentResolver()\n                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n            final String[] projectionIn = new String[] {\n                    MediaStore.Downloads._ID,\n                    MediaStore.Downloads.DISPLAY_NAME,\n                    MediaStore.Downloads.DATA,\n            };\n            for (int i = 0; i < mediaStoreIdsForVolumes.size(); ++i) {\n                final String volumeName = mediaStoreIdsForVolumes.keyAt(i);\n                final LongArray ids = mediaStoreIdsForVolumes.valueAt(i);\n                final LongSparseArray<MediaStoreData> mediaStoreDataForIds\n                        = new LongSparseArray<>();\n                mediaStoreDataForVolumes.put(volumeName, mediaStoreDataForIds);\n                try (Cursor mediaCursor = getMediaProviderRowsForIds(\n                        client, projectionIn, volumeName, ids)) {\n                    while (mediaCursor.moveToNext()) {\n                        final long id = mediaCursor.getLong(0);\n                        final String displayName = mediaCursor.getString(1);\n                        final String filePath = mediaCursor.getString(2);\n                        mediaStoreDataForIds.put(id, new MediaStoreData(displayName, filePath));\n                    }\n                }\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        } finally {\n            restoreCallingIdentity(token);\n        }\n\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final TranslatingCursor.Config config = getTranslatingCursorConfig(match);\n        final TranslatingCursor.Translator translator\n                = (data, auxiliaryColIndex, matchingColumn, cursor) -> {\n            final String uriString = cursor.getString(auxiliaryColIndex);\n            if (uriString != null) {\n                final Uri mediaStoreUri = Uri.parse(uriString);\n                final String volumeName = MediaStore.getVolumeName(mediaStoreUri);\n                final LongSparseArray<MediaStoreData> mediaStoreDataForIds\n                        = mediaStoreDataForVolumes.get(volumeName);\n                if (mediaStoreDataForIds != null) {\n                    final long id = ContentUris.parseId(mediaStoreUri);\n                    final MediaStoreData mediaStoreData = mediaStoreDataForIds.get(id);\n                    if (mediaStoreData != null) {\n                        switch (matchingColumn) {\n                            case Downloads.Impl.COLUMN_TITLE:\n                                data = mediaStoreData.displayName;\n                                break;\n                            case Downloads.Impl._DATA:\n                            case Downloads.Impl.COLUMN_FILE_NAME_HINT:\n                            case DownloadManager.COLUMN_LOCAL_FILENAME:\n                                data = mediaStoreData.filePath;\n                                break;\n                            default:\n                                return data;\n                        }\n                    }\n                }\n            }\n\n            switch (matchingColumn) {\n                case Downloads.Impl._DATA:\n                case Downloads.Impl.COLUMN_FILE_NAME_HINT:\n                case DownloadManager.COLUMN_LOCAL_FILENAME:\n                    return translateSystemToApp(data, pid, uid);\n                default:\n                    return data;\n            }\n        };\n        final Cursor ret = TranslatingCursor.query(config, translator,\n                qb, db, projection, selection, selectionArgs, null, null, sort, null, null);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private Cursor getMediaProviderRowsForIds(ContentProviderClient mediaProvider,\n            String[] projection, String volumeName, LongArray ids) throws RemoteException {\n        final StringBuilder queryString = new StringBuilder();\n        queryString.append(MediaStore.Downloads._ID + \" in (\");\n        final int size = ids.size();\n        for (int i = 0; i < size; ++i) {\n            queryString.append(ids.get(i));\n            queryString.append((i == size - 1) ? \")\" : \",\");\n        }\n        return mediaProvider.query(MediaStore.Downloads.getContentUri(volumeName),\n                projection, queryString.toString(), null, null);\n    }\n\n    private TranslatingCursor.Config getTranslatingCursorConfig(int match) {\n        final Uri baseUri;\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.CONTENT_URI;\n                break;\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n                break;\n            default:\n                baseUri = null;\n        }\n        return new TranslatingCursor.Config(baseUri, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                Downloads.Impl._DATA,\n                Downloads.Impl.COLUMN_FILE_NAME_HINT,\n                DownloadManager.COLUMN_LOCAL_FILENAME,\n                Downloads.Impl.COLUMN_TITLE);\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid()\n                && callingUid != mSystemUid\n                && callingUid != Process.SHELL_UID\n                && callingUid != Process.ROOT_UID;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                filteredValues.put(Downloads.Impl._DATA,\n                        translateAppToSystem(filename, getCallingPid(), getCallingUid()));\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                    filteredValues.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT),\n                    getCallingPid(), getCallingUid()));\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    final ContentValues updateValues = new ContentValues();\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        final boolean visibleToUser = info.mIsVisibleInDownloadsUi\n                                || (info.mMediaScanned != MEDIA_NOT_SCANNABLE);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                client.delete(Uri.parse(info.mMediaStoreUri), null, null);\n                                updateValues.clear();\n                                updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        } else if ((info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                                && visibleToUser) {\n                            final Uri mediaStoreUri = updateMediaProvider(client,\n                                    info.mMediaStoreUri, convertToMediaProviderValues(info));\n                            if (!TextUtils.equals(info.mMediaStoreUri,\n                                    mediaStoreUri == null ? null : mediaStoreUri.toString())) {\n                                updateValues.clear();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_NOT_SCANNED);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // Should not happen\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true);\n        qb.setTables(table);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaStoreUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } catch (Exception e) {\n                                Log.w(Constants.TAG, \"Failed to delete media entry: \" + e);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != Downloads.Impl.MEDIA_NOT_SCANNABLE;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n\n    private static final class MediaStoreData {\n        public String displayName;\n        public String filePath;\n\n        public MediaStoreData(String displayName, String filePath) {\n            this.displayName = displayName;\n            this.filePath = filePath;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.os.Binder.getCallingPid;\nimport static android.os.Binder.getCallingUid;\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNABLE;\nimport static android.provider.Downloads.Impl.MEDIA_NOT_SCANNED;\nimport static android.provider.Downloads.Impl.MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.TranslatingCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Files;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.ArrayMap;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.LongSparseArray;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 111;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                final ContentValues updateValues = new ContentValues();\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final ContentValues mediaValues;\n                    try {\n                        mediaValues = convertToMediaProviderValues(info);\n                    } catch (IllegalArgumentException e) {\n                        Log.e(Constants.TAG, \"Error getting media content values from \" + info, e);\n                        continue;\n                    }\n                    final Uri mediaStoreUri = updateMediaProvider(client, null, mediaValues);\n                    if (mediaStoreUri != null) {\n                        updateValues.clear();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        try {\n            while (cursor.moveToNext()) {\n                final long downloadId = cursor.getLong(0);\n                final int uid = cursor.getInt(1);\n                final String ownerPackage = getPackageForUid(uid);\n                if (ownerPackage == null) {\n                    idsToDelete.add(downloadId);\n                } else {\n                    grantAllDownloadsPermission(ownerPackage, downloadId);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG,\n                    \"Deleting downloads with ids \" + idsToDelete + \" as owner package is missing\");\n            deleteDownloadsWithIds(idsToDelete);\n        }\n        return true;\n    }\n\n    private void deleteDownloadsWithIds(ArrayList<Long> downloadIds) {\n        final int N = downloadIds.size();\n        if (N == 0) {\n            return;\n        }\n        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + \" in (\");\n        for (int i = 0; i < N; i++) {\n            queryBuilder.append(downloadIds.get(i));\n            queryBuilder.append((i == N - 1) ? \")\" : \",\");\n        }\n        delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, queryBuilder.toString(), null);\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    @Override\n    public Bundle call(String method, String arg, Bundle extras) {\n        if (method == Downloads.MEDIASTORE_DOWNLOADS_DELETED_CALL) {\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_MEDIA_STORAGE,\n                    \"Not allowed to call \" + Downloads.MEDIASTORE_DOWNLOADS_DELETED_CALL);\n            final long[] deletedDownloadIds = extras.getLongArray(Downloads.EXTRA_IDS);\n            final String[] mimeTypes = extras.getStringArray(Downloads.EXTRA_MIME_TYPES);\n            DownloadStorageProvider.onMediaProviderDownloadsDelete(getContext(),\n                    deletedDownloadIds, mimeTypes);\n            return null;\n        } else {\n            throw new UnsupportedOperationException(\"Unsupported call: \" + method);\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n                final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                        fileUri, getCallingPid(), getCallingUid()));\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            values.put(Downloads.Impl._DATA, translateAppToSystem(\n                    values.getAsString(Downloads.Impl._DATA), getCallingPid(), getCallingUid()));\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        final Integer mediaScanned = values.getAsInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        filteredValues.put(COLUMN_MEDIA_SCANNED,\n                mediaScanned == null ? MEDIA_NOT_SCANNED : mediaScanned);\n\n        final boolean shouldBeVisibleToUser\n                = filteredValues.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)\n                        || filteredValues.getAsInteger(COLUMN_MEDIA_SCANNED) == MEDIA_NOT_SCANNED;\n        if (shouldBeVisibleToUser && filteredValues.getAsInteger(COLUMN_DESTINATION)\n                == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            final CallingIdentity token = clearCallingIdentity();\n            try (ContentProviderClient client = getContext().getContentResolver()\n                    .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                final Uri mediaStoreUri = updateMediaProvider(client, null,\n                        convertToMediaProviderValues(filteredValues));\n                if (mediaStoreUri != null) {\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = getPackageForUid(Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @Nullable String currentMediaStoreUri,\n            @NonNull ContentValues mediaValues) {\n        Uri mediaStoreUri;\n        final String filePath = mediaValues.getAsString(Files.FileColumns.DATA);\n        final boolean isVisibleInDownloads = mediaValues.getAsInteger(\n                Files.FileColumns.IS_DOWNLOAD) == 1;\n        if (currentMediaStoreUri == null) {\n            if (!isVisibleInDownloads) {\n                return null;\n            }\n            mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n        } else {\n            mediaStoreUri = Uri.parse(currentMediaStoreUri);\n        }\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                removeInvalidColumnsForUpdate(mediaValues);\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return isVisibleInDownloads ? mediaStoreUri : null;\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    /**\n     * Remove column values which are not valid for updating downloads in MediaProvider.\n     */\n    private void removeInvalidColumnsForUpdate(@NonNull ContentValues mediaValues) {\n        mediaValues.remove(MediaStore.Downloads.SIZE);\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = Files.getContentUriForPath(filePath);\n        try (Cursor cursor = mediaProvider.query(filesUri, new String[] { Files.FileColumns._ID },\n                Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final String filePath;\n        try {\n            filePath = new File(info.mFileName).getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,  filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE, info.mTotalBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.DISPLAY_NAME, info.mTitle);\n        mediaValues.put(MediaStore.Downloads.DESCRIPTION, info.mDescription);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING,\n                Downloads.Impl.isStatusSuccess(info.mStatus) ? 0 : 1);\n        mediaValues.put(Files.FileColumns.IS_DOWNLOAD, 1);\n        return mediaValues;\n    }\n\n    private ContentValues convertToMediaProviderValues(ContentValues downloadValues) {\n        final String filePath;\n        try {\n            filePath = new File(downloadValues.getAsString(Downloads.Impl._DATA))\n                    .getCanonicalPath();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA, filePath);\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadValues.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_URI));\n        mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n        mediaValues.put(MediaStore.Downloads.DISPLAY_NAME,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_TITLE));\n        mediaValues.put(MediaStore.Downloads.DESCRIPTION,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_DESCRIPTION));\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_MIME_TYPE));\n        final boolean isPending = downloadValues.getAsInteger(Downloads.Impl.COLUMN_STATUS)\n                != Downloads.Impl.STATUS_SUCCESS;\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, isPending ? 1 : 0);\n        mediaValues.put(Files.FileColumns.IS_DOWNLOAD, downloadValues.getAsBoolean(\n                Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI) ? 1 : 0);\n        return mediaValues;\n    }\n\n    private @Nullable String translateAppToSystem(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        try {\n            final File app = new File(path).getCanonicalFile();\n            final File system = mStorageManager.translateAppToSystem(app, pid, uid);\n            // If the input was file uri, we need to return a file uri\n            return fileUri == null ? system.getPath() : Uri.fromFile(system).toString();\n        } catch (IOException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n\n    private @Nullable String translateSystemToApp(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File system = new File(path);\n        final File app = mStorageManager.translateSystemToApp(system, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? app.getPath() : Uri.fromFile(app).toString();\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private String getPackageForUid(int uid) {\n        String[] packages = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packages == null || packages.length == 0) {\n            return null;\n        }\n        // For permission related purposes, any package belonging to the given uid should work.\n        return packages[0];\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            if (!StorageManager.hasIsolatedStorage()) {\n                // Otherwise we require write permission\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write to \" + file);\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write to \" + file);\n                }\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        // map of volumeName -> { mediastore ids that need to be queried }\n        final ArrayMap<String, LongArray> mediaStoreIdsForVolumes = new ArrayMap<>();\n        try (Cursor cursor = qb.query(db, new String[] { Downloads.Impl.COLUMN_MEDIASTORE_URI },\n                selection, selectionArgs, null, null, sort)) {\n            while (cursor.moveToNext()) {\n                final String uriString = cursor.getString(0);\n                if (uriString == null) {\n                    continue;\n                }\n                final Uri mediaStoreUri = Uri.parse(uriString);\n                final String volumeName = MediaStore.getVolumeName(mediaStoreUri);\n                LongArray ids = mediaStoreIdsForVolumes.get(volumeName);\n                if (ids == null) {\n                    ids = new LongArray();\n                    mediaStoreIdsForVolumes.put(volumeName, ids);\n                }\n                ids.add(ContentUris.parseId(mediaStoreUri));\n            }\n        }\n        // map of volumeName -> { map of {mediastore id -> mediastore data} }\n        final ArrayMap<String, LongSparseArray<MediaStoreData>> mediaStoreDataForVolumes\n                = new ArrayMap<>();\n        final CallingIdentity token = clearCallingIdentity();\n        try (ContentProviderClient client = getContext().getContentResolver()\n                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n            final String[] projectionIn = new String[] {\n                    MediaStore.Downloads._ID,\n                    MediaStore.Downloads.DISPLAY_NAME,\n                    MediaStore.Downloads.DATA,\n            };\n            for (int i = 0; i < mediaStoreIdsForVolumes.size(); ++i) {\n                final String volumeName = mediaStoreIdsForVolumes.keyAt(i);\n                final LongArray ids = mediaStoreIdsForVolumes.valueAt(i);\n                final LongSparseArray<MediaStoreData> mediaStoreDataForIds\n                        = new LongSparseArray<>();\n                mediaStoreDataForVolumes.put(volumeName, mediaStoreDataForIds);\n                try (Cursor mediaCursor = getMediaProviderRowsForIds(\n                        client, projectionIn, volumeName, ids)) {\n                    while (mediaCursor.moveToNext()) {\n                        final long id = mediaCursor.getLong(0);\n                        final String displayName = mediaCursor.getString(1);\n                        final String filePath = mediaCursor.getString(2);\n                        mediaStoreDataForIds.put(id, new MediaStoreData(displayName, filePath));\n                    }\n                }\n            }\n        } catch (RemoteException e) {\n            // Should not happen\n        } finally {\n            restoreCallingIdentity(token);\n        }\n\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final TranslatingCursor.Config config = getTranslatingCursorConfig(match);\n        final TranslatingCursor.Translator translator\n                = (data, auxiliaryColIndex, matchingColumn, cursor) -> {\n            final String uriString = cursor.getString(auxiliaryColIndex);\n            if (uriString != null) {\n                final Uri mediaStoreUri = Uri.parse(uriString);\n                final String volumeName = MediaStore.getVolumeName(mediaStoreUri);\n                final LongSparseArray<MediaStoreData> mediaStoreDataForIds\n                        = mediaStoreDataForVolumes.get(volumeName);\n                if (mediaStoreDataForIds != null) {\n                    final long id = ContentUris.parseId(mediaStoreUri);\n                    final MediaStoreData mediaStoreData = mediaStoreDataForIds.get(id);\n                    if (mediaStoreData != null) {\n                        switch (matchingColumn) {\n                            case Downloads.Impl.COLUMN_TITLE:\n                                data = mediaStoreData.displayName;\n                                break;\n                            case Downloads.Impl._DATA:\n                            case Downloads.Impl.COLUMN_FILE_NAME_HINT:\n                            case DownloadManager.COLUMN_LOCAL_FILENAME:\n                                data = mediaStoreData.filePath;\n                                break;\n                            default:\n                                return data;\n                        }\n                    }\n                }\n            }\n\n            switch (matchingColumn) {\n                case Downloads.Impl._DATA:\n                case Downloads.Impl.COLUMN_FILE_NAME_HINT:\n                case DownloadManager.COLUMN_LOCAL_FILENAME:\n                    return translateSystemToApp(data, pid, uid);\n                default:\n                    return data;\n            }\n        };\n        final Cursor ret = TranslatingCursor.query(config, translator,\n                qb, db, projection, selection, selectionArgs, null, null, sort, null, null);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private Cursor getMediaProviderRowsForIds(ContentProviderClient mediaProvider,\n            String[] projection, String volumeName, LongArray ids) throws RemoteException {\n        final StringBuilder queryString = new StringBuilder();\n        queryString.append(MediaStore.Downloads._ID + \" in (\");\n        final int size = ids.size();\n        for (int i = 0; i < size; ++i) {\n            queryString.append(ids.get(i));\n            queryString.append((i == size - 1) ? \")\" : \",\");\n        }\n        return mediaProvider.query(MediaStore.Downloads.getContentUri(volumeName),\n                projection, queryString.toString(), null, null);\n    }\n\n    private TranslatingCursor.Config getTranslatingCursorConfig(int match) {\n        final Uri baseUri;\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.CONTENT_URI;\n                break;\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n                break;\n            default:\n                baseUri = null;\n        }\n        return new TranslatingCursor.Config(baseUri, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                Downloads.Impl._DATA,\n                Downloads.Impl.COLUMN_FILE_NAME_HINT,\n                DownloadManager.COLUMN_LOCAL_FILENAME,\n                Downloads.Impl.COLUMN_TITLE);\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid()\n                && callingUid != mSystemUid\n                && callingUid != Process.SHELL_UID\n                && callingUid != Process.ROOT_UID;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                filteredValues.put(Downloads.Impl._DATA,\n                        translateAppToSystem(filename, getCallingPid(), getCallingUid()));\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                    filteredValues.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT),\n                    getCallingPid(), getCallingUid()));\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    final ContentValues updateValues = new ContentValues();\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        final boolean visibleToUser = info.mIsVisibleInDownloadsUi\n                                || (info.mMediaScanned != MEDIA_NOT_SCANNABLE);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                client.delete(Uri.parse(info.mMediaStoreUri), null, null);\n                                updateValues.clear();\n                                updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        } else if ((info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                                && visibleToUser) {\n                            final Uri mediaStoreUri = updateMediaProvider(client,\n                                    info.mMediaStoreUri, convertToMediaProviderValues(info));\n                            if (!TextUtils.equals(info.mMediaStoreUri,\n                                    mediaStoreUri == null ? null : mediaStoreUri.toString())) {\n                                updateValues.clear();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_NOT_SCANNED);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                                            mediaStoreUri.toString());\n                                    updateValues.put(COLUMN_MEDIA_SCANNED, MEDIA_SCANNED);\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[] { Long.toString(info.mId) });\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // Should not happen\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true);\n        qb.setTables(table);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaStoreUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } catch (Exception e) {\n                                Log.w(Constants.TAG, \"Failed to delete media entry: \" + e);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != Downloads.Impl.MEDIA_NOT_SCANNABLE;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n\n    private static final class MediaStoreData {\n        public String displayName;\n        public String filePath;\n\n        public MediaStoreData(String displayName, String filePath) {\n            this.displayName = displayName;\n            this.filePath = filePath;\n        }\n    }\n}\n","lineNo":392}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                Set<String> filePaths = new HashSet<>();\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            assert (DOC_ID_ROOT.equals(parentDocId));\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            if (manage) {\n                cursor = mDm.query(\n                        new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            } else {\n                cursor = mDm\n                        .query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            }\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n            includeFilesFromSharedStorage(result, filePaths, null);\n\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, queryArgs);\n            }\n            Cursor rawFilesCursor = super.querySearchDocuments(getDownloadsDirectory(),\n                    projection, filePaths, queryArgs);\n\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            while (rawFilesCursor.moveToNext()) {\n                final String mimeType = rawFilesCursor.getString(\n                        rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                // When the value of shouldExcludeMedia is true, don't add media files into\n                // the result to avoid duplicated files. MediaScanner will scan the files\n                // into MediaStore. If the behavior is changed, we need to add the files back.\n                if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                    String docId = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                    File rawFile = getFileForDocId(docId);\n                    includeFileFromSharedStorage(result, rawFile);\n                }\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.getType(mDm.getDownloadUri(id));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.openFileDescriptor(mDm.getDownloadUri(id), mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (status != DownloadManager.STATUS_RUNNING) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        }\n        filePaths.add(localFilePath);\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(MatrixCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        File downloadsDir = getDownloadsDirectory();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        for (File file : downloadsDir.listFiles()) {\n            boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n            boolean containsQuery = searchString == null || file.getName().contains(searchString);\n            if (!inResultsAlready && containsQuery) {\n                includeFileFromSharedStorage(result, file);\n            }\n        }\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private static final String DOWNLOADS_PATH = getDownloadsDirectory().getAbsolutePath();\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver) {\n            super(DOWNLOADS_PATH, NOTIFY_EVENTS);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + DOWNLOADS_PATH);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == Document.MIME_TYPE_DIR;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        result.setIncludedDownloadDirs(downloadsDirs);\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        if (size != -1) {\n            row.add(Document.COLUMN_SIZE, size);\n        }\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        result.setIncludedDownloadDirs(downloadsDirs);\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : downloadsDir.listFiles()) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : sandboxDir.listFiles()) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String filePath = null;\n            try (Cursor cursor = getContext().getContentResolver().query(\n                    getMediaStoreUri(docId), null, null, null)) {\n                if (cursor.moveToNext()) {\n                    filePath = cursor.getString(cursor.getColumnIndex(MediaStore.Downloads.DATA));\n                }\n            }\n            if (filePath == null) {\n                throw new IllegalStateException(\"Filepath could not be found for\"\n                        + \" mediastore docId: \" + docId);\n            }\n            return new File(filePath);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Files.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(MediaStore.Downloads._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DISPLAY_NAME));\n        final String description = mediaCursor.getString(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DESCRIPTION));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.IS_PENDING)) == 1;\n        // TODO: Support renaming of downlaods from MediaStore?\n        final int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n\n        includeDownload(result, docId, displayName, description, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(MediaStore.Downloads.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final int format = mediaCursor.getInt(mediaCursor.getColumnIndex(\n                MediaStore.Files.FileColumns.FORMAT));\n        // TODO: MediaProvider should be updated to use correct mimeTypes for directories\n        if (format == MtpConstants.FORMAT_ASSOCIATION) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Downloads.MIME_TYPE));\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private static Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        selection.append(MediaStore.Files.FileColumns.IS_DOWNLOAD + \"=?\");\n        selectionArgs.add(\"1\");\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            selection.append(\" AND \");\n            selection.append(MediaStore.Downloads._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            selection.append(\" AND \");\n            selection.append(MediaStore.Files.FileColumns.PARENT + \"=?\");\n            selectionArgs.add(parentId);\n        } else {\n            selection.append(\" AND \");\n            // SELECT _id FROM files where is_download=1\n            final String subQuery = SQLiteQueryBuilder.buildQueryString(false,\n                    MediaStore.Files.TABLE, new String[] { MediaStore.Files.FileColumns._ID },\n                    MediaStore.Files.FileColumns.IS_DOWNLOAD + \"=1\", null, null, null, null);\n            selection.append(MediaStore.Files.FileColumns.PARENT + \" NOT IN (\"\n                    + subQuery + \")\");\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\");\n                selectionArgs.add(String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_NONE));\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n        @GuardedBy(\"mLock\")\n        private List<File> mIncludedDownloadDirs;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void setIncludedDownloadDirs(List<File> downloadDirs) {\n            synchronized (mLock) {\n                mIncludedDownloadDirs = downloadDirs;\n            }\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0 && mIncludedDownloadDirs != null) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, mIncludedDownloadDirs);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0 && mFileWatcher != null) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","lineNo":222}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                Set<String> filePaths = new HashSet<>();\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            assert (DOC_ID_ROOT.equals(parentDocId));\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            if (manage) {\n                cursor = mDm.query(\n                        new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            } else {\n                cursor = mDm\n                        .query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            }\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n            includeFilesFromSharedStorage(result, filePaths, null);\n\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, queryArgs);\n            }\n            Cursor rawFilesCursor = super.querySearchDocuments(getDownloadsDirectory(),\n                    projection, filePaths, queryArgs);\n\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            while (rawFilesCursor.moveToNext()) {\n                final String mimeType = rawFilesCursor.getString(\n                        rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                // When the value of shouldExcludeMedia is true, don't add media files into\n                // the result to avoid duplicated files. MediaScanner will scan the files\n                // into MediaStore. If the behavior is changed, we need to add the files back.\n                if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                    String docId = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                    File rawFile = getFileForDocId(docId);\n                    includeFileFromSharedStorage(result, rawFile);\n                }\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.getType(mDm.getDownloadUri(id));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.openFileDescriptor(mDm.getDownloadUri(id), mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (status != DownloadManager.STATUS_RUNNING) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        }\n        filePaths.add(localFilePath);\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(MatrixCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        File downloadsDir = getDownloadsDirectory();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        for (File file : downloadsDir.listFiles()) {\n            boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n            boolean containsQuery = searchString == null || file.getName().contains(searchString);\n            if (!inResultsAlready && containsQuery) {\n                includeFileFromSharedStorage(result, file);\n            }\n        }\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private static final String DOWNLOADS_PATH = getDownloadsDirectory().getAbsolutePath();\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver) {\n            super(DOWNLOADS_PATH, NOTIFY_EVENTS);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + DOWNLOADS_PATH);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == Document.MIME_TYPE_DIR;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        result.setIncludedDownloadDirs(downloadsDirs);\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        if (size != -1) {\n            row.add(Document.COLUMN_SIZE, size);\n        }\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        result.setIncludedDownloadDirs(downloadsDirs);\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : downloadsDir.listFiles()) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : sandboxDir.listFiles()) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String filePath = null;\n            try (Cursor cursor = getContext().getContentResolver().query(\n                    getMediaStoreUri(docId), null, null, null)) {\n                if (cursor.moveToNext()) {\n                    filePath = cursor.getString(cursor.getColumnIndex(MediaStore.Downloads.DATA));\n                }\n            }\n            if (filePath == null) {\n                throw new IllegalStateException(\"Filepath could not be found for\"\n                        + \" mediastore docId: \" + docId);\n            }\n            return new File(filePath);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Files.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(MediaStore.Downloads._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DISPLAY_NAME));\n        final String description = mediaCursor.getString(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DESCRIPTION));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.IS_PENDING)) == 1;\n        // TODO: Support renaming of downlaods from MediaStore?\n        final int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n\n        includeDownload(result, docId, displayName, description, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(MediaStore.Downloads.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final int format = mediaCursor.getInt(mediaCursor.getColumnIndex(\n                MediaStore.Files.FileColumns.FORMAT));\n        // TODO: MediaProvider should be updated to use correct mimeTypes for directories\n        if (format == MtpConstants.FORMAT_ASSOCIATION) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Downloads.MIME_TYPE));\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private static Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        selection.append(MediaStore.Files.FileColumns.IS_DOWNLOAD + \"=?\");\n        selectionArgs.add(\"1\");\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            selection.append(\" AND \");\n            selection.append(MediaStore.Downloads._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            selection.append(\" AND \");\n            selection.append(MediaStore.Files.FileColumns.PARENT + \"=?\");\n            selectionArgs.add(parentId);\n        } else {\n            selection.append(\" AND \");\n            // SELECT _id FROM files where is_download=1\n            final String subQuery = SQLiteQueryBuilder.buildQueryString(false,\n                    MediaStore.Files.TABLE, new String[] { MediaStore.Files.FileColumns._ID },\n                    MediaStore.Files.FileColumns.IS_DOWNLOAD + \"=1\", null, null, null, null);\n            selection.append(MediaStore.Files.FileColumns.PARENT + \" NOT IN (\"\n                    + subQuery + \")\");\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\");\n                selectionArgs.add(String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_NONE));\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n        @GuardedBy(\"mLock\")\n        private List<File> mIncludedDownloadDirs;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void setIncludedDownloadDirs(List<File> downloadDirs) {\n            synchronized (mLock) {\n                mIncludedDownloadDirs = downloadDirs;\n            }\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0 && mIncludedDownloadDirs != null) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, mIncludedDownloadDirs);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0 && mFileWatcher != null) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","lineNo":511}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                Set<String> filePaths = new HashSet<>();\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            assert (DOC_ID_ROOT.equals(parentDocId));\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            if (manage) {\n                cursor = mDm.query(\n                        new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            } else {\n                cursor = mDm\n                        .query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            }\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n            includeFilesFromSharedStorage(result, filePaths, null);\n\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, queryArgs);\n            }\n            Cursor rawFilesCursor = super.querySearchDocuments(getDownloadsDirectory(),\n                    projection, filePaths, queryArgs);\n\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            while (rawFilesCursor.moveToNext()) {\n                final String mimeType = rawFilesCursor.getString(\n                        rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                // When the value of shouldExcludeMedia is true, don't add media files into\n                // the result to avoid duplicated files. MediaScanner will scan the files\n                // into MediaStore. If the behavior is changed, we need to add the files back.\n                if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                    String docId = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                    File rawFile = getFileForDocId(docId);\n                    includeFileFromSharedStorage(result, rawFile);\n                }\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.getType(mDm.getDownloadUri(id));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.openFileDescriptor(mDm.getDownloadUri(id), mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (status != DownloadManager.STATUS_RUNNING) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        }\n        filePaths.add(localFilePath);\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(MatrixCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        File downloadsDir = getDownloadsDirectory();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        for (File file : downloadsDir.listFiles()) {\n            boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n            boolean containsQuery = searchString == null || file.getName().contains(searchString);\n            if (!inResultsAlready && containsQuery) {\n                includeFileFromSharedStorage(result, file);\n            }\n        }\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private static final String DOWNLOADS_PATH = getDownloadsDirectory().getAbsolutePath();\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver) {\n            super(DOWNLOADS_PATH, NOTIFY_EVENTS);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + DOWNLOADS_PATH);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreIdString;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.getMediaStoreUri;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownload;\nimport static com.android.providers.downloads.MediaStoreDownloadsHelper.isMediaStoreDownloadDir;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.media.MediaFile;\nimport android.mtp.MtpConstants;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.LongArray;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID, Root.COLUMN_QUERY_ARGS\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    private static final String[] DOWNLOADS_PROJECTION\n            = new String[DownloadManager.UNDERLYING_COLUMNS.length + 1];\n    static {\n        System.arraycopy(DownloadManager.UNDERLYING_COLUMNS, 0,\n                DOWNLOADS_PROJECTION, 0, DownloadManager.UNDERLYING_COLUMNS.length);\n        DOWNLOADS_PROJECTION[DOWNLOADS_PROJECTION.length - 1]\n                = Downloads.Impl.COLUMN_MEDIASTORE_URI;\n    }\n\n    private static final int NO_LIMIT = -1;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    static void onMediaProviderDownloadsDelete(Context context, long[] ids, String[] mimeTypes) {\n        for (int i = 0; i < ids.length; ++i) {\n            final boolean isDir = mimeTypes[i] == Document.MIME_TYPE_DIR;\n            final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY,\n                    MediaStoreDownloadsHelper.getDocIdForMediaStoreDownload(ids[i], isDir));\n            context.revokeUriPermission(uri, ~0);\n        }\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getTopLevelDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_QUERY_ARGS, SUPPORTED_QUERY_ARGS);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n\n            int count;\n            if (isMediaStoreDownload(docId)) {\n                count = getContext().getContentResolver().delete(\n                        getMediaStoreUri(docId), null, null);\n            } else {\n                count = mDm.remove(Long.parseLong(docId));\n            }\n\n            if (count != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else if (isMediaStoreDownload(docId)) {\n                cursor = getContext().getContentResolver().query(getMediaStoreUri(docId),\n                        null, null, null);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromMediaStore(result, cursor, null /* filePaths */);\n                }\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                        DOWNLOADS_PROJECTION);\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                            null /* mediaStoreIds */, null /* queryArgs */);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            final ArrayList<Uri> notificationUris = new ArrayList<>();\n            if (isMediaStoreDownloadDir(parentDocId)) {\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        null /* idsToExclude */, null /* filePaths */, notificationUris,\n                        getMediaStoreIdString(parentDocId), NO_LIMIT, manage);\n            } else {\n                assert (DOC_ID_ROOT.equals(parentDocId));\n                if (manage) {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true),\n                            DOWNLOADS_PROJECTION);\n                } else {\n                    cursor = mDm.query(\n                            new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                            DOWNLOADS_PROJECTION);\n                }\n                final Set<String> filePaths = new HashSet<>();\n                final LongArray mediaStoreIds = new LongArray();\n                while (cursor.moveToNext()) {\n                    includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds,\n                            null /* queryArgs */);\n                }\n                notificationUris.add(cursor.getNotificationUri());\n                includeDownloadsFromMediaStore(result, null /* queryArgs */,\n                        mediaStoreIds, filePaths, notificationUris,\n                        null /* parentId */, NO_LIMIT, manage);\n                includeFilesFromSharedStorage(result, filePaths, null);\n            }\n            result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, null /* filePaths */,\n                        mediaStoreIds, null /* queryArgs */);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, null /* queryArgs */, mediaStoreIds,\n                    null /* filePaths */, notificationUris, null /* parentId */,\n                    (limit - result.getCount()), false /* includePending */);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n        final ArrayList<Uri> notificationUris = new ArrayList<>();\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)),\n                    DOWNLOADS_PROJECTION);\n            final LongArray mediaStoreIds = new LongArray();\n            final Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, mediaStoreIds, queryArgs);\n            }\n            notificationUris.add(cursor.getNotificationUri());\n            includeDownloadsFromMediaStore(result, queryArgs, mediaStoreIds, filePaths,\n                    notificationUris, null /* parentId */, NO_LIMIT, true /* includePending */);\n\n            includeSearchFilesFromSharedStorage(result, projection, filePaths, queryArgs);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.setNotificationUris(getContext().getContentResolver(), notificationUris);\n        result.start();\n        return result;\n    }\n\n    private void includeSearchFilesFromSharedStorage(DownloadsCursor result,\n            String[] projection, Set<String> filePaths,\n            Bundle queryArgs) throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        result.setIncludedDownloadDirs(downloadsDirs);\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadDir = downloadsDirs.get(i);\n            try (Cursor rawFilesCursor = super.querySearchDocuments(downloadDir,\n                    projection, filePaths, queryArgs)) {\n\n                final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                        DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n                while (rawFilesCursor.moveToNext()) {\n                    final String mimeType = rawFilesCursor.getString(\n                            rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_MIME_TYPE));\n                    // When the value of shouldExcludeMedia is true, don't add media files into\n                    // the result to avoid duplicated files. MediaScanner will scan the files\n                    // into MediaStore. If the behavior is changed, we need to add the files back.\n                    if (!shouldExcludeMedia || !isMediaMimeType(mimeType)) {\n                        String docId = rawFilesCursor.getString(\n                                rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                        File rawFile = getFileForDocId(docId);\n                        includeFileFromSharedStorage(result, rawFile);\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.getType(contentUri);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final ContentResolver resolver = getContext().getContentResolver();\n            final Uri contentUri;\n            if (isMediaStoreDownload(docId)) {\n                contentUri = getMediaStoreUri(docId);\n            } else {\n                final long id = Long.parseLong(docId);\n                contentUri = mDm.getDownloadUri(id);\n            }\n            return resolver.openFileDescriptor(contentUri, mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (isMediaStoreDownload(docId)) {\n            return getFileForMediaStoreDownload(docId);\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getTopLevelDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)),\n                    DOWNLOADS_PROJECTION);\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private static boolean isMediaMimeType(String mimeType) {\n        return MediaFile.isImageMimeType(mimeType) || MediaFile.isVideoMimeType(mimeType)\n                || MediaFile.isAudioMimeType(mimeType);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, LongArray mediaStoreIds, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip media files that have been inserted into the MediaStore so we\n                // don't duplicate them in the search list.\n                if (isMediaMimeType(mimeType) && !TextUtils.isEmpty(uri)) {\n                    return;\n                }\n            }\n        }\n\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        includeDownload(result, docId, displayName, summary, size, mimeType,\n                lastModified, extraFlags, status == DownloadManager.STATUS_RUNNING);\n        if (mediaStoreIds != null) {\n            final String mediaStoreUri = cursor.getString(\n                    cursor.getColumnIndex(Downloads.Impl.COLUMN_MEDIASTORE_URI));\n            if (mediaStoreUri != null) {\n                mediaStoreIds.add(ContentUris.parseId(Uri.parse(mediaStoreUri)));\n            }\n        }\n        if (filePaths != null) {\n            filePaths.add(localFilePath);\n        }\n    }\n\n    private void includeDownload(MatrixCursor result,\n            String docId, String displayName, String summary, long size,\n            String mimeType, long lastModifiedMs, int extraFlags, boolean isPending) {\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        if (size != -1) {\n            row.add(Document.COLUMN_SIZE, size);\n        }\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (!isPending) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModifiedMs);\n        }\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(DownloadsCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        final List<File> downloadsDirs = getDownloadsDirectories();\n        result.setIncludedDownloadDirs(downloadsDirs);\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        final int size = downloadsDirs.size();\n        for (int i = 0; i < size; ++i) {\n            final File downloadsDir = downloadsDirs.get(i);\n            for (File file : downloadsDir.listFiles()) {\n                boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n                boolean containsQuery = searchString == null || file.getName().contains(\n                        searchString);\n                if (!inResultsAlready && containsQuery) {\n                    includeFileFromSharedStorage(result, file);\n                }\n            }\n        }\n    }\n\n    private List<File> getDownloadsDirectories() {\n        final List<File> downloadsDirectories = new ArrayList<>();\n        downloadsDirectories.add(getTopLevelDownloadsDirectory());\n        final File sandboxDir = Environment.buildExternalStorageAndroidSandboxDirs()[0];\n        for (File file : sandboxDir.listFiles()) {\n            final File downloadDir = new File(file, Environment.DIRECTORY_DOWNLOADS);\n            if (downloadDir.exists()) {\n                downloadsDirectories.add(downloadDir);\n            }\n        }\n        return downloadsDirectories;\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getTopLevelDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    private File getFileForMediaStoreDownload(String docId) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String filePath = null;\n            try (Cursor cursor = getContext().getContentResolver().query(\n                    getMediaStoreUri(docId), null, null, null)) {\n                if (cursor.moveToNext()) {\n                    filePath = cursor.getString(cursor.getColumnIndex(MediaStore.Downloads.DATA));\n                }\n            }\n            if (filePath == null) {\n                throw new IllegalStateException(\"Filepath could not be found for\"\n                        + \" mediastore docId: \" + docId);\n            }\n            return new File(filePath);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadsFromMediaStore(@NonNull MatrixCursor result,\n            @Nullable Bundle queryArgs, @Nullable LongArray idsToExclude,\n            @Nullable Set<String> filePaths, @NonNull ArrayList<Uri> notificationUris,\n            @Nullable String parentId, int limit, boolean includePending) {\n        if (limit == 0) {\n            return;\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        final Pair<String, String[]> selectionPair\n                = buildSearchSelection(queryArgs, idsToExclude, parentId);\n        final Uri.Builder queryUriBuilder = MediaStore.Files.EXTERNAL_CONTENT_URI.buildUpon();\n        if (limit != NO_LIMIT) {\n            queryUriBuilder.appendQueryParameter(MediaStore.PARAM_LIMIT, String.valueOf(limit));\n        }\n        if (includePending) {\n            MediaStore.setIncludePending(queryUriBuilder);\n        }\n        try (Cursor cursor = getContext().getContentResolver().query(\n                queryUriBuilder.build(), null,\n                selectionPair.first, selectionPair.second, null)) {\n            while (cursor.moveToNext()) {\n                includeDownloadFromMediaStore(result, cursor, filePaths);\n            }\n            notificationUris.add(MediaStore.Files.EXTERNAL_CONTENT_URI);\n            notificationUris.add(MediaStore.Downloads.EXTERNAL_CONTENT_URI);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    private void includeDownloadFromMediaStore(@NonNull MatrixCursor result,\n            @NonNull Cursor mediaCursor, @Nullable Set<String> filePaths) {\n        final String mimeType = getMimeType(mediaCursor);\n        final boolean isDir = Document.MIME_TYPE_DIR.equals(mimeType);\n        final String docId = getDocIdForMediaStoreDownload(\n                mediaCursor.getLong(mediaCursor.getColumnIndex(MediaStore.Downloads._ID)), isDir);\n        final String displayName = mediaCursor.getString(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DISPLAY_NAME));\n        final String description = mediaCursor.getString(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DESCRIPTION));\n        final long size = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.SIZE));\n        final long lastModifiedMs = mediaCursor.getLong(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.DATE_MODIFIED)) * 1000;\n        final boolean isPending = mediaCursor.getInt(\n                mediaCursor.getColumnIndex(MediaStore.Downloads.IS_PENDING)) == 1;\n        // TODO: Support renaming of downlaods from MediaStore?\n        final int extraFlags = isPending ? Document.FLAG_PARTIAL : 0;\n\n        includeDownload(result, docId, displayName, description, size, mimeType,\n                lastModifiedMs, extraFlags, isPending);\n        if (filePaths != null) {\n            filePaths.add(mediaCursor.getString(\n                    mediaCursor.getColumnIndex(MediaStore.Downloads.DATA)));\n        }\n    }\n\n    private String getMimeType(@NonNull Cursor mediaCursor) {\n        final int format = mediaCursor.getInt(mediaCursor.getColumnIndex(\n                MediaStore.Files.FileColumns.FORMAT));\n        // TODO: MediaProvider should be updated to use correct mimeTypes for directories\n        if (format == MtpConstants.FORMAT_ASSOCIATION) {\n            return Document.MIME_TYPE_DIR;\n        }\n        return mediaCursor.getString(mediaCursor.getColumnIndex(MediaStore.Downloads.MIME_TYPE));\n    }\n\n    // Copied from MediaDocumentsProvider with some tweaks\n    private static Pair<String, String[]> buildSearchSelection(@Nullable Bundle queryArgs,\n            @Nullable LongArray idsToExclude, @Nullable String parentId) {\n        final StringBuilder selection = new StringBuilder();\n        final ArrayList<String> selectionArgs = new ArrayList<>();\n\n        selection.append(MediaStore.Files.FileColumns.IS_DOWNLOAD + \"=?\");\n        selectionArgs.add(\"1\");\n\n        if (parentId == null && idsToExclude != null && idsToExclude.size() > 0) {\n            selection.append(\" AND \");\n            selection.append(MediaStore.Downloads._ID + \" NOT IN (\");\n            final int size = idsToExclude.size();\n            for (int i = 0; i < size; ++i) {\n                selection.append(idsToExclude.get(i) + ((i == size - 1) ? \")\" : \",\"));\n            }\n        }\n\n        if (parentId != null) {\n            selection.append(\" AND \");\n            selection.append(MediaStore.Files.FileColumns.PARENT + \"=?\");\n            selectionArgs.add(parentId);\n        } else {\n            selection.append(\" AND \");\n            // SELECT _id FROM files where is_download=1\n            final String subQuery = SQLiteQueryBuilder.buildQueryString(false,\n                    MediaStore.Files.TABLE, new String[] { MediaStore.Files.FileColumns._ID },\n                    MediaStore.Files.FileColumns.IS_DOWNLOAD + \"=1\", null, null, null, null);\n            selection.append(MediaStore.Files.FileColumns.PARENT + \" NOT IN (\"\n                    + subQuery + \")\");\n        }\n\n        if (queryArgs != null) {\n            final boolean shouldExcludeMedia = queryArgs.getBoolean(\n                    DocumentsContract.QUERY_ARG_EXCLUDE_MEDIA, false /* defaultValue */);\n            if (shouldExcludeMedia) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Files.FileColumns.MEDIA_TYPE + \"=?\");\n                selectionArgs.add(String.valueOf(MediaStore.Files.FileColumns.MEDIA_TYPE_NONE));\n            }\n\n            final String displayName = queryArgs.getString(\n                    DocumentsContract.QUERY_ARG_DISPLAY_NAME);\n            if (!TextUtils.isEmpty(displayName)) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.DISPLAY_NAME + \" LIKE ?\");\n                selectionArgs.add(\"%\" + displayName + \"%\");\n            }\n\n            final long lastModifiedAfter = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_LAST_MODIFIED_AFTER, -1 /* defaultValue */);\n            if (lastModifiedAfter != -1) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.DATE_MODIFIED\n                        + \" > \" + lastModifiedAfter / 1000);\n            }\n\n            final long fileSizeOver = queryArgs.getLong(\n                    DocumentsContract.QUERY_ARG_FILE_SIZE_OVER, -1 /* defaultValue */);\n            if (fileSizeOver != -1) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.SIZE + \" > \" + fileSizeOver);\n            }\n\n            final String[] mimeTypes = queryArgs.getStringArray(\n                    DocumentsContract.QUERY_ARG_MIME_TYPES);\n            if (mimeTypes != null && mimeTypes.length > 0) {\n                selection.append(\" AND \");\n                selection.append(MediaStore.Downloads.MIME_TYPE + \" IN (\");\n                for (int i = 0; i < mimeTypes.length; ++i) {\n                    selection.append(\"?\").append((i == mimeTypes.length - 1) ? \")\" : \",\");\n                    selectionArgs.add(mimeTypes[i]);\n                }\n            }\n        }\n\n        return new Pair<>(selection.toString(), selectionArgs.toArray(new String[0]));\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n        @GuardedBy(\"mLock\")\n        private List<File> mIncludedDownloadDirs;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void setIncludedDownloadDirs(List<File> downloadDirs) {\n            synchronized (mLock) {\n                mIncludedDownloadDirs = downloadDirs;\n            }\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0 && mIncludedDownloadDirs != null) {\n                    mFileWatcher = new ContentChangedRelay(mResolver, mIncludedDownloadDirs);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0 && mFileWatcher != null) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private File[] mDownloadDirs;\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver, List<File> downloadDirs) {\n            super(downloadDirs, NOTIFY_EVENTS);\n            mDownloadDirs = downloadDirs.toArray(new File[0]);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \"\n                    + Arrays.toString(mDownloadDirs));\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + path);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","lineNo":535}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.os.Binder.defaultBlocking;\nimport static android.os.Binder.getCallingPid;\nimport static android.os.Binder.getCallingUid;\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.TranslatingCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.SystemProperties;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        try {\n            while (cursor.moveToNext()) {\n                final long downloadId = cursor.getLong(0);\n                final int uid = cursor.getInt(1);\n                final String ownerPackage = getPackageForUid(uid);\n                if (ownerPackage == null) {\n                    idsToDelete.add(downloadId);\n                } else {\n                    grantAllDownloadsPermission(ownerPackage, downloadId);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG,\n                    \"Deleting downloads with ids \" + idsToDelete + \" as owner package is missing\");\n            deleteDownloadsWithIds(idsToDelete);\n        }\n        return true;\n    }\n\n    private void deleteDownloadsWithIds(ArrayList<Long> downloadIds) {\n        final int N = downloadIds.size();\n        if (N == 0) {\n            return;\n        }\n        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + \" in (\");\n        for (int i = 0; i < N; i++) {\n            queryBuilder.append(downloadIds.get(i));\n            queryBuilder.append((i == N - 1) ? \")\" : \",\");\n        }\n        delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, queryBuilder.toString(), null);\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n                final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                        fileUri, getCallingPid(), getCallingUid()));\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            values.put(Downloads.Impl._DATA, translateAppToSystem(\n                    values.getAsString(Downloads.Impl._DATA), getCallingPid(), getCallingUid()));\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = getPackageForUid(Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    private @Nullable String translateAppToSystem(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File app = new File(path);\n        final File system = mStorageManager.translateAppToSystem(app, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? system.getPath() : Uri.fromFile(system).toString();\n    }\n\n    private @Nullable String translateSystemToApp(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File system = new File(path);\n        final File app = mStorageManager.translateSystemToApp(system, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? app.getPath() : Uri.fromFile(app).toString();\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private String getPackageForUid(int uid) {\n        String[] packages = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packages == null || packages.length == 0) {\n            return null;\n        }\n        // For permission related purposes, any package belonging to the given uid should work.\n        return packages[0];\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            if (!SystemProperties.getBoolean(StorageManager.PROP_ISOLATED_STORAGE, false)) {\n                // Otherwise we require write permission\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write to \" + file);\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write to \" + file);\n                }\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final TranslatingCursor.Config config = getTranslatingCursorConfig(match);\n        final TranslatingCursor.Translator translator\n                = (data, id) -> translateSystemToApp(data, pid, uid);\n        final Cursor ret = TranslatingCursor.query(config, translator, qb, db,\n                projection, selection, selectionArgs, null, null, sort, null, null);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private TranslatingCursor.Config getTranslatingCursorConfig(int match) {\n        final Uri baseUri;\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.CONTENT_URI;\n                break;\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n                break;\n            default:\n                baseUri = null;\n        }\n        return new TranslatingCursor.Config(baseUri,\n                Downloads.Impl._ID, Downloads.Impl._DATA, Downloads.Impl.COLUMN_FILE_NAME_HINT,\n                DownloadManager.COLUMN_LOCAL_FILENAME);\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                filteredValues.put(Downloads.Impl._DATA,\n                        translateAppToSystem(filename, getCallingPid(), getCallingUid()));\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                    filteredValues.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT),\n                    getCallingPid(), getCallingUid()));\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                if (updateSchedule || isCompleting) {\n                    final long token = Binder.clearCallingIdentity();\n                    try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                        final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                                cursor);\n                        final DownloadInfo info = new DownloadInfo(context);\n                        while (cursor.moveToNext()) {\n                            reader.updateFromDatabase(info);\n                            if (updateSchedule) {\n                                Helpers.scheduleJob(context, info);\n                            }\n                            if (isCompleting) {\n                                info.sendIntentIfRequested();\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true);\n        qb.setTables(table);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } catch (Exception e) {\n                                Log.w(Constants.TAG, \"Failed to delete media entry: \" + e);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.os.Binder.getCallingPid;\nimport static android.os.Binder.getCallingUid;\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI;\nimport static android.provider.Downloads.Impl.COLUMN_OTHER_UID;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl.PERMISSION_ACCESS_ALL;\n\nimport android.annotation.NonNull;\nimport android.annotation.Nullable;\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentProviderClient;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.PackageManager;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.TranslatingCursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.RemoteException;\nimport android.os.SystemProperties;\nimport android.os.storage.StorageManager;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.MediaStore;\nimport android.provider.MediaStore.Files;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 111;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n    /** Memory optimization - close idle connections after 30s of inactivity */\n    private static final int IDLE_CONNECTION_TIMEOUT_MS = 30000;\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int MY_DOWNLOADS_ID_HEADERS = 3;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 4;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 5;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int ALL_DOWNLOADS_ID_HEADERS = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                ALL_DOWNLOADS_ID_HEADERS);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                MY_DOWNLOADS_ID_HEADERS);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n\n    private StorageManager mStorageManager;\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n            setIdleConnectionTimeout(IDLE_CONNECTION_TIMEOUT_MS);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 111:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            \"TEXT DEFAULT NULL\");\n                    addMediaStoreUris(db);\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add {@link Downloads.Impl#COLUMN_MEDIASTORE_URI} for all successful downloads and\n         * add/update corresponding entries in MediaProvider.\n         */\n        private void addMediaStoreUris(@NonNull SQLiteDatabase db) {\n            final String[] selectionArgs = new String[] {\n                    Integer.toString(Downloads.Impl.DESTINATION_EXTERNAL),\n                    Integer.toString(Downloads.Impl.DESTINATION_FILE_URI),\n                    Integer.toString(Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD),\n            };\n            final CallingIdentity token = clearCallingIdentity();\n            try (Cursor cursor = db.query(DB_TABLE, null,\n                    \"_data IS NOT NULL AND is_visible_in_downloads_ui != '0'\"\n                            + \" AND (destination=? OR destination=? OR destination=?)\",\n                    selectionArgs, null, null, null);\n                    ContentProviderClient client = getContext().getContentResolver()\n                            .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                if (cursor.getCount() == 0) {\n                    return;\n                }\n                final DownloadInfo.Reader reader\n                        = new DownloadInfo.Reader(getContext().getContentResolver(), cursor);\n                final DownloadInfo info = new DownloadInfo(getContext());\n                while (cursor.moveToNext()) {\n                    reader.updateFromDatabase(info);\n                    final Uri mediaStoreUri = updateMediaProvider(client, null,\n                            convertToMediaProviderValues(info));\n                    if (mediaStoreUri != null) {\n                        final ContentValues updateValues = new ContentValues();\n                        updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                mediaStoreUri.toString());\n                        db.update(DB_TABLE, updateValues, Downloads.Impl._ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n\n        mStorageManager = getContext().getSystemService(StorageManager.class);\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        final ArrayList<Long> idsToDelete = new ArrayList<>();\n        try {\n            while (cursor.moveToNext()) {\n                final long downloadId = cursor.getLong(0);\n                final int uid = cursor.getInt(1);\n                final String ownerPackage = getPackageForUid(uid);\n                if (ownerPackage == null) {\n                    idsToDelete.add(downloadId);\n                } else {\n                    grantAllDownloadsPermission(ownerPackage, downloadId);\n                }\n            }\n        } finally {\n            cursor.close();\n        }\n        if (idsToDelete.size() > 0) {\n            Log.i(Constants.TAG,\n                    \"Deleting downloads with ids \" + idsToDelete + \" as owner package is missing\");\n            deleteDownloadsWithIds(idsToDelete);\n        }\n        return true;\n    }\n\n    private void deleteDownloadsWithIds(ArrayList<Long> downloadIds) {\n        final int N = downloadIds.size();\n        if (N == 0) {\n            return;\n        }\n        final StringBuilder queryBuilder = new StringBuilder(Downloads.Impl._ID + \" in (\");\n        for (int i = 0; i < N; i++) {\n            queryBuilder.append(downloadIds.get(i));\n            queryBuilder.append((i == N - 1) ? \")\" : \",\");\n        }\n        delete(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, queryBuilder.toString(), null);\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        ContentValues filteredValues = new ContentValues();\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n                final String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n                values.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                        fileUri, getCallingPid(), getCallingUid()));\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // copy some of the input values as is\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            values.put(Downloads.Impl._DATA, translateAppToSystem(\n                    values.getAsString(Downloads.Impl._DATA), getCallingPid(), getCallingUid()));\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsBoolean(COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            final CallingIdentity token = clearCallingIdentity();\n            try (ContentProviderClient client = getContext().getContentResolver()\n                    .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                final Uri mediaStoreUri = updateMediaProvider(client, null,\n                        convertToMediaProviderValues(filteredValues));\n                if (mediaStoreUri != null) {\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n                            mediaStoreUri.toString());\n                    filteredValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                            mediaStoreUri.toString());\n                }\n            } finally {\n                restoreCallingIdentity(token);\n            }\n        }\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n\n        final String callingPackage = getPackageForUid(Binder.getCallingUid());\n        if (callingPackage == null) {\n            Log.e(Constants.TAG, \"Package does not exist for calling uid\");\n            return null;\n        }\n        grantAllDownloadsPermission(callingPackage, rowID);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * If an entry corresponding to given mediaValues doesn't already exist in MediaProvider,\n     * add it, otherwise update that entry with the given values.\n     */\n    private Uri updateMediaProvider(@NonNull ContentProviderClient mediaProvider,\n            @Nullable String currentMediaStoreUri,\n            @NonNull ContentValues mediaValues) {\n        Uri mediaStoreUri;\n        final String filePath = mediaValues.getAsString(Files.FileColumns.DATA);\n        final boolean isVisibleInDownloads = mediaValues.getAsInteger(\n                Files.FileColumns.IS_DOWNLOAD) == 1;\n        if (currentMediaStoreUri == null) {\n            if (!isVisibleInDownloads) {\n                return null;\n            }\n            mediaStoreUri = getMediaStoreUri(mediaProvider, filePath);\n        } else {\n            mediaStoreUri = Uri.parse(currentMediaStoreUri);\n        }\n\n        try {\n            if (mediaStoreUri == null) {\n                mediaStoreUri = mediaProvider.insert(Files.getContentUriForPath(filePath),\n                        mediaValues);\n                if (mediaStoreUri == null) {\n                    Log.e(Constants.TAG, \"Error inserting into mediaProvider: \" + mediaValues);\n                }\n                return mediaStoreUri;\n            } else {\n                removeInvalidColumnsForUpdate(mediaValues);\n                if (mediaProvider.update(mediaStoreUri, mediaValues, null, null) != 1) {\n                    Log.e(Constants.TAG, \"Error updating MediaProvider, uri: \" + mediaStoreUri\n                            + \", values: \" + mediaValues);\n                }\n                return isVisibleInDownloads ? mediaStoreUri : null;\n            }\n        } catch (RemoteException e) {\n        }\n        return null;\n    }\n\n    /**\n     * Remove column values which are not valid for updating downloads in MediaProvider.\n     */\n    private void removeInvalidColumnsForUpdate(@NonNull ContentValues mediaValues) {\n        mediaValues.remove(MediaStore.Downloads.SIZE);\n    }\n\n    private Uri getMediaStoreUri(@NonNull ContentProviderClient mediaProvider,\n            @NonNull String filePath) {\n        final Uri filesUri = Files.getContentUriForPath(filePath);\n        try (Cursor cursor = mediaProvider.query(filesUri, new String[] { Files.FileColumns._ID },\n                Files.FileColumns.DATA + \"=?\", new String[] { filePath }, null, null)) {\n            if (cursor.moveToNext()) {\n                return ContentUris.withAppendedId(filesUri, cursor.getLong(0));\n            }\n        } catch (RemoteException e) {\n        }\n        return null;\n    }\n\n    private ContentValues convertToMediaProviderValues(DownloadInfo info) {\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA, info.mFileName);\n        mediaValues.put(MediaStore.Downloads.SIZE, info.mTotalBytes);\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI, info.mUri);\n        mediaValues.put(MediaStore.Downloads.REFERER_URI, info.mReferer);\n        mediaValues.put(MediaStore.Downloads.DISPLAY_NAME, info.mTitle);\n        mediaValues.put(MediaStore.Downloads.DESCRIPTION, info.mDescription);\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE, info.mMimeType);\n        mediaValues.put(MediaStore.Downloads.IS_PENDING,\n                Downloads.Impl.isStatusSuccess(info.mStatus) ? 0 : 1);\n        mediaValues.put(Files.FileColumns.IS_DOWNLOAD, info.mIsVisibleInDownloadsUi ? 1 : 0);\n        return mediaValues;\n    }\n\n    private ContentValues convertToMediaProviderValues(ContentValues downloadValues) {\n        final ContentValues mediaValues = new ContentValues();\n        mediaValues.put(MediaStore.Downloads.DATA,\n                downloadValues.getAsString(Downloads.Impl._DATA));\n        mediaValues.put(MediaStore.Downloads.SIZE,\n                downloadValues.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n        mediaValues.put(MediaStore.Downloads.DOWNLOAD_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_URI));\n        mediaValues.put(MediaStore.Downloads.REFERER_URI,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_REFERER));\n        mediaValues.put(MediaStore.Downloads.DISPLAY_NAME,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_TITLE));\n        mediaValues.put(MediaStore.Downloads.DESCRIPTION,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_DESCRIPTION));\n        mediaValues.put(MediaStore.Downloads.MIME_TYPE,\n                downloadValues.getAsString(Downloads.Impl.COLUMN_MIME_TYPE));\n        final boolean isPending = downloadValues.getAsInteger(Downloads.Impl.COLUMN_STATUS)\n                != Downloads.Impl.STATUS_SUCCESS;\n        mediaValues.put(MediaStore.Downloads.IS_PENDING, isPending ? 1 : 0);\n        mediaValues.put(Files.FileColumns.IS_DOWNLOAD, downloadValues.getAsBoolean(\n                Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI) ? 1 : 0);\n        return mediaValues;\n    }\n\n    private @Nullable String translateAppToSystem(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File app = new File(path);\n        final File system = mStorageManager.translateAppToSystem(app, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? system.getPath() : Uri.fromFile(system).toString();\n    }\n\n    private @Nullable String translateSystemToApp(@Nullable String path, int pid, int uid) {\n        if (path == null) return path;\n\n        final Uri fileUri = getFileUri(path);\n        if (fileUri != null) {\n            path = fileUri.getPath();\n        }\n        final File system = new File(path);\n        final File app = mStorageManager.translateSystemToApp(system, pid, uid);\n        // If the input was file uri, we need to return a file uri\n        return fileUri == null ? app.getPath() : Uri.fromFile(app).toString();\n    }\n\n    private static Uri getFileUri(String uriString) {\n        final Uri uri = Uri.parse(uriString);\n        return TextUtils.equals(uri.getScheme(), ContentResolver.SCHEME_FILE) ? uri : null;\n    }\n\n    private String getPackageForUid(int uid) {\n        String[] packages = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packages == null || packages.length == 0) {\n            return null;\n        }\n        // For permission related purposes, any package belonging to the given uid should work.\n        return packages[0];\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        final Uri uri = getFileUri(fileUri);\n        if (uri == null) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            if (!SystemProperties.getBoolean(StorageManager.PROP_ISOLATED_STORAGE, false)) {\n                // Otherwise we require write permission\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write to \" + file);\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write to \" + file);\n                }\n            }\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == MY_DOWNLOADS_ID_HEADERS || match == ALL_DOWNLOADS_ID_HEADERS) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n\n            // Headers are only available to callers with full access.\n            getContext().enforceCallingOrSelfPermission(\n                    Downloads.Impl.PERMISSION_ACCESS_ALL, Constants.TAG);\n\n            final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n            projection = new String[] {\n                    Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                    Downloads.Impl.RequestHeaders.COLUMN_VALUE\n            };\n            return qb.query(db, projection, null, null, null, null, null);\n        }\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n\n        final int pid = Binder.getCallingPid();\n        final int uid = Binder.getCallingUid();\n        final TranslatingCursor.Config config = getTranslatingCursorConfig(match);\n        final TranslatingCursor.Translator translator\n                = (data, id) -> translateSystemToApp(data, pid, uid);\n        final Cursor ret = TranslatingCursor.query(config, translator, qb, db,\n                projection, selection, selectionArgs, null, null, sort, null, null);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private TranslatingCursor.Config getTranslatingCursorConfig(int match) {\n        final Uri baseUri;\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.CONTENT_URI;\n                break;\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                baseUri = Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n                break;\n            default:\n                baseUri = null;\n        }\n        return new TranslatingCursor.Config(baseUri,\n                Downloads.Impl._ID, Downloads.Impl._DATA, Downloads.Impl.COLUMN_FILE_NAME_HINT,\n                DownloadManager.COLUMN_LOCAL_FILENAME);\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid()\n                && callingUid != mSystemUid\n                && callingUid != Process.SHELL_UID\n                && callingUid != Process.ROOT_UID;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                filteredValues.put(Downloads.Impl._DATA,\n                        translateAppToSystem(filename, getCallingPid(), getCallingUid()));\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_FILE_NAME_HINT, translateAppToSystem(\n                    filteredValues.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT),\n                    getCallingPid(), getCallingUid()));\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                count = qb.update(db, filteredValues, where, whereArgs);\n                final CallingIdentity token = clearCallingIdentity();\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null);\n                        ContentProviderClient client = getContext().getContentResolver()\n                                .acquireContentProviderClient(MediaStore.AUTHORITY)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                            cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        if (info.mFileName == null) {\n                            if (info.mMediaStoreUri != null) {\n                                client.delete(Uri.parse(info.mMediaStoreUri), null, null);\n                            }\n                            final ContentValues updateValues = new ContentValues();\n                            updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                            qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                    new String[] { Long.toString(info.mId) });\n                        } else if (info.mDestination == Downloads.Impl.DESTINATION_EXTERNAL\n                                || info.mDestination == Downloads.Impl.DESTINATION_FILE_URI\n                                || info.mDestination == Downloads.Impl\n                                        .DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n                            final Uri mediaStoreUri = updateMediaProvider(client,\n                                    info.mMediaStoreUri, convertToMediaProviderValues(info));\n                            if (!TextUtils.equals(\n                                    info.mMediaStoreUri, mediaStoreUri.toString())) {\n                                final ContentValues updateValues = new ContentValues();\n                                if (mediaStoreUri == null) {\n                                    updateValues.putNull(Downloads.Impl.COLUMN_MEDIASTORE_URI);\n                                } else {\n                                    updateValues.put(Downloads.Impl.COLUMN_MEDIASTORE_URI,\n                                            mediaStoreUri.toString());\n                                }\n                                qb.update(db, updateValues, Downloads.Impl._ID + \"=?\",\n                                        new String[]{Long.toString(info.mId)});\n                            }\n                        }\n                        if (updateSchedule) {\n                            Helpers.scheduleJob(context, info);\n                        }\n                        if (isCompleting) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                } catch (RemoteException e) {\n                    // Should not happen\n                } finally {\n                    restoreCallingIdentity(token);\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    /**\n     * Create a query builder that filters access to the underlying database\n     * based on both the requested {@link Uri} and permissions of the caller.\n     */\n    private SQLiteQueryBuilder getQueryBuilder(final Uri uri, int match) {\n        final String table;\n        final StringBuilder where = new StringBuilder();\n        switch (match) {\n            // The \"my_downloads\" view normally limits the caller to operating\n            // on downloads that they either directly own, or have been given\n            // indirect ownership of via OTHER_UID.\n            case MY_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case MY_DOWNLOADS:\n                table = DB_TABLE;\n                if (getContext().checkCallingOrSelfPermission(\n                        PERMISSION_ACCESS_ALL) != PackageManager.PERMISSION_GRANTED) {\n                    appendWhereExpression(where, Constants.UID + \"=\" + Binder.getCallingUid()\n                            + \" OR \" + COLUMN_OTHER_UID + \"=\" + Binder.getCallingUid());\n                }\n                break;\n\n            // The \"all_downloads\" view is already limited via <path-permission>\n            // to only callers holding the ACCESS_ALL_DOWNLOADS permission, but\n            // access may also be delegated via Uri permission grants.\n            case ALL_DOWNLOADS_ID:\n                appendWhereExpression(where, _ID + \"=\" + getDownloadIdFromUri(uri));\n                // fall-through\n            case ALL_DOWNLOADS:\n                table = DB_TABLE;\n                break;\n\n            // Headers are limited to callers holding the ACCESS_ALL_DOWNLOADS\n            // permission, since they're only needed for executing downloads.\n            case MY_DOWNLOADS_ID_HEADERS:\n            case ALL_DOWNLOADS_ID_HEADERS:\n                table = Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE;\n                appendWhereExpression(where, Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                        + getDownloadIdFromUri(uri));\n                break;\n\n            default:\n                throw new UnsupportedOperationException(\"Unknown URI: \" + uri);\n        }\n\n        final SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n        qb.setStrict(true);\n        qb.setTables(table);\n        qb.appendWhere(where);\n        return qb;\n    }\n\n    private static void appendWhereExpression(StringBuilder sb, String expression) {\n        if (sb.length() > 0) {\n            sb.append(\" AND \");\n        }\n        sb.append('(').append(expression).append(')');\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SQLiteQueryBuilder qb = getQueryBuilder(uri, match);\n                try (Cursor cursor = qb.query(db, null, where, whereArgs, null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaStoreUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } catch (Exception e) {\n                                Log.w(Constants.TAG, \"Failed to delete media entry: \" + e);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n\n                        // Delete any headers for this download\n                        db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE,\n                                Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=?\",\n                                new String[] { Long.toString(info.mId) });\n                    }\n                }\n\n                count = qb.delete(db, where, whereArgs);\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(String toPackage, long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(toPackage, uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","lineNo":1341}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.graphics.Point;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID,\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                Set<String> filePaths = new HashSet<>();\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, filePaths, null);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            assert (DOC_ID_ROOT.equals(parentDocId));\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            if (manage) {\n                cursor = mDm.query(\n                        new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            } else {\n                cursor = mDm\n                        .query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            }\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, null);\n            }\n            includeFilesFromSharedStorage(result, filePaths, null);\n\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext() && result.getCount() < 12) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images that have been inserted into the MediaStore so we\n                // don't duplicate them in the recents list.\n                if (mimeType == null\n                        || (mimeType.startsWith(\"image/\") && !TextUtils.isEmpty(uri))) {\n                    continue;\n                }\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, queryArgs);\n            }\n            Cursor rawFilesCursor = super.querySearchDocuments(getDownloadsDirectory(),\n                    projection, filePaths, queryArgs);\n\n            while (rawFilesCursor.moveToNext()) {\n                String docId = rawFilesCursor.getString(\n                        rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                File rawFile = getFileForDocId(docId);\n                includeFileFromSharedStorage(result, rawFile);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.getType(mDm.getDownloadUri(id));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.openFileDescriptor(mDm.getDownloadUri(id), mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (status != DownloadManager.STATUS_RUNNING) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        }\n        filePaths.add(localFilePath);\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(MatrixCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        File downloadsDir = getDownloadsDirectory();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        for (File file : downloadsDir.listFiles()) {\n            boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n            boolean containsQuery = searchString == null || file.getName().contains(searchString);\n            if (!inResultsAlready && containsQuery) {\n                includeFileFromSharedStorage(result, file);\n            }\n        }\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private static final String DOWNLOADS_PATH = getDownloadsDirectory().getAbsolutePath();\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver) {\n            super(DOWNLOADS_PATH, NOTIFY_EVENTS);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + DOWNLOADS_PATH);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.graphics.Point;\nimport android.media.MediaFile;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Bundle;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.FileObserver;\nimport android.os.FileUtils;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Path;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\n\nimport com.android.internal.content.FileSystemProvider;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.text.NumberFormat;\nimport java.util.HashSet;\nimport java.util.Set;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Presents files located in {@link Environment#DIRECTORY_DOWNLOADS} and contents from\n * {@link DownloadManager}. {@link DownloadManager} contents include active downloads and completed\n * downloads added by other applications using\n * {@link DownloadManager#addCompletedDownload(String, String, boolean, String, String, long, boolean, boolean, Uri, Uri)}\n * .\n */\npublic class DownloadStorageProvider extends FileSystemProvider {\n    private static final String TAG = \"DownloadStorageProvider\";\n    private static final boolean DEBUG = false;\n\n    private static final String AUTHORITY = Constants.STORAGE_AUTHORITY;\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_DOCUMENT_ID,\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        super.onCreate(DEFAULT_DOCUMENT_PROJECTION);\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        mDm.setAccessFilename(true);\n\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    /**\n     * Called by {@link DownloadProvider} when deleting a row in the {@link DownloadManager}\n     * database.\n     */\n    static void onDownloadProviderDelete(Context context, long id) {\n        final Uri uri = DocumentsContract.buildDocumentUri(AUTHORITY, Long.toString(id));\n        context.revokeUriPermission(uri, ~0);\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        // It's possible that the folder does not exist on disk, so we will create the folder if\n        // that is the case. If user decides to delete the folder later, then it's OK to fail on\n        // subsequent queries.\n        getDownloadsDirectory().mkdirs();\n\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS\n                | Root.FLAG_SUPPORTS_CREATE | Root.FLAG_SUPPORTS_SEARCH\n                | Root.FLAG_SUPPORTS_IS_CHILD);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        return result;\n    }\n\n    @Override\n    public Path findDocumentPath(@Nullable String parentDocId, String docId) throws FileNotFoundException {\n\n        // parentDocId is null if the client is asking for the path to the root of a doc tree.\n        // Don't share root information with those who shouldn't know it.\n        final String rootId = (parentDocId == null) ? DOC_ID_ROOT : null;\n\n        if (parentDocId == null) {\n            parentDocId = DOC_ID_ROOT;\n        }\n\n        final File parent = getFileForDocId(parentDocId);\n\n        final File doc = getFileForDocId(docId);\n\n        return new Path(rootId, findDocumentPath(parent, doc));\n    }\n\n    /**\n     * Calls on {@link FileSystemProvider#createDocument(String, String, String)}, and then creates\n     * a new database entry in {@link DownloadManager} if it is not a raw file and not a folder.\n     */\n    @Override\n    public String createDocument(String parentDocId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            String newDocumentId = super.createDocument(parentDocId, mimeType, displayName);\n            if (!Document.MIME_TYPE_DIR.equals(mimeType)\n                    && !RawDocumentsHelper.isRawDocId(parentDocId)) {\n                File newFile = getFileForDocId(newDocumentId);\n                newDocumentId = Long.toString(mDm.addCompletedDownload(\n                        newFile.getName(), newFile.getName(), true, mimeType,\n                        newFile.getAbsolutePath(), 0L,\n                        false, true));\n            }\n            return newDocumentId;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                super.deleteDocument(docId);\n                return;\n            }\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public String renameDocument(String docId, String displayName)\n            throws FileNotFoundException {\n        final long token = Binder.clearCallingIdentity();\n\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.renameDocument(docId, displayName);\n            }\n\n            displayName = FileUtils.buildValidFatFilename(displayName);\n            final long id = Long.parseLong(docId);\n            if (!mDm.rename(getContext(), id, displayName)) {\n                throw new IllegalStateException(\n                        \"Failed to rename to \" + displayName + \" in downloadsManager\");\n            }\n            return null;\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.queryDocument(docId, projection);\n            }\n\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n\n            if (DOC_ID_ROOT.equals(docId)) {\n                includeDefaultDocument(result);\n            } else {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                Set<String> filePaths = new HashSet<>();\n                if (cursor.moveToFirst()) {\n                    // We don't know if this queryDocument() call is from Downloads (manage)\n                    // or Files. Safely assume it's Files.\n                    includeDownloadFromCursor(result, cursor, filePaths, null);\n                }\n            }\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, false);\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        return queryChildDocuments(parentDocId, projection, sortOrder, true);\n    }\n\n    private Cursor queryChildDocuments(String parentDocId, String[] projection,\n            String sortOrder, boolean manage) throws FileNotFoundException {\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            if (RawDocumentsHelper.isRawDocId(parentDocId)) {\n                return super.queryChildDocuments(parentDocId, projection, sortOrder);\n            }\n\n            assert (DOC_ID_ROOT.equals(parentDocId));\n            final DownloadsCursor result = new DownloadsCursor(projection,\n                    getContext().getContentResolver());\n            if (manage) {\n                cursor = mDm.query(\n                        new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            } else {\n                cursor = mDm\n                        .query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                                .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            }\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, null);\n            }\n            includeFilesFromSharedStorage(result, filePaths, null);\n\n            result.start();\n            return result;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection,\n            @Nullable Bundle queryArgs, @Nullable CancellationSignal signal)\n            throws FileNotFoundException {\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n\n        int limit = 12;\n        if (queryArgs != null) {\n            limit = queryArgs.getInt(ContentResolver.QUERY_ARG_LIMIT, -1);\n\n            if (limit < 0) {\n                // Use default value, and no QUERY_ARG* is honored.\n                limit = 12;\n            } else {\n                // We are honoring the QUERY_ARG_LIMIT.\n                Bundle extras = new Bundle();\n                result.setExtras(extras);\n                extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, new String[]{\n                        ContentResolver.QUERY_ARG_LIMIT\n                });\n            }\n        }\n\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext() && result.getCount() < limit) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images and videos that have been inserted into the MediaStore so we\n                // don't duplicate them in the recent list. The audio root of\n                // MediaDocumentsProvider doesn't support recent, we add it into recent list.\n                if (mimeType == null || (MediaFile.isImageMimeType(mimeType)\n                        || MediaFile.isVideoMimeType(mimeType)) && !TextUtils.isEmpty(uri)) {\n                    continue;\n                }\n                includeDownloadFromCursor(result, cursor, filePaths, null /* queryArgs */);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public Cursor querySearchDocuments(String rootId, String[] projection, Bundle queryArgs)\n            throws FileNotFoundException {\n\n        final DownloadsCursor result =\n                new DownloadsCursor(projection, getContext().getContentResolver());\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByString(DocumentsContract.getSearchDocumentsQuery(queryArgs)));\n            copyNotificationUri(result, cursor);\n            Set<String> filePaths = new HashSet<>();\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor, filePaths, queryArgs);\n            }\n            Cursor rawFilesCursor = super.querySearchDocuments(getDownloadsDirectory(),\n                    projection, filePaths, queryArgs);\n\n            while (rawFilesCursor.moveToNext()) {\n                String docId = rawFilesCursor.getString(\n                        rawFilesCursor.getColumnIndexOrThrow(Document.COLUMN_DOCUMENT_ID));\n                File rawFile = getFileForDocId(docId);\n                includeFileFromSharedStorage(result, rawFile);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        final String[] handledQueryArgs = DocumentsContract.getHandledQueryArguments(queryArgs);\n        if (handledQueryArgs.length > 0) {\n            final Bundle extras = new Bundle();\n            extras.putStringArray(ContentResolver.EXTRA_HONORED_ARGS, handledQueryArgs);\n            result.setExtras(extras);\n        }\n\n        result.start();\n        return result;\n    }\n\n    @Override\n    public String getDocumentType(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.getDocumentType(docId);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.getType(mDm.getDownloadUri(id));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (RawDocumentsHelper.isRawDocId(docId)) {\n                return super.openDocument(docId, mode, signal);\n            }\n\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.openFileDescriptor(mDm.getDownloadUri(id), mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    protected File getFileForDocId(String docId, boolean visible) throws FileNotFoundException {\n        if (RawDocumentsHelper.isRawDocId(docId)) {\n            return new File(RawDocumentsHelper.getAbsoluteFilePath(docId));\n        }\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            return getDownloadsDirectory();\n        }\n\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        String localFilePath = null;\n        try {\n            cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n            if (cursor.moveToFirst()) {\n                localFilePath = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (localFilePath == null) {\n            throw new IllegalStateException(\"File has no filepath. Could not be found.\");\n        }\n        return new File(localFilePath);\n    }\n\n    @Override\n    protected String getDocIdForFile(File file) throws FileNotFoundException {\n        return RawDocumentsHelper.getDocIdForFile(file);\n    }\n\n    @Override\n    protected Uri buildNotificationUri(String docId) {\n        return DocumentsContract.buildChildDocumentsUri(AUTHORITY, docId);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        // We have the same display name as our root :)\n        row.add(Document.COLUMN_DISPLAY_NAME,\n                getContext().getString(R.string.root_downloads));\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    /**\n     * Adds the entry from the cursor to the result only if the entry is valid. That is,\n     * if the file exists in the file system.\n     */\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor,\n            Set<String> filePaths, Bundle queryArgs) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            // Provide fake MIME type so it's openable\n            mimeType = \"vnd.android.document/file\";\n        }\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n        String localFilePath = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LOCAL_FILENAME));\n\n        int extraFlags = Document.FLAG_PARTIAL;\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                // Verify that the document still exists in external storage. This is necessary\n                // because files can be deleted from the file system without their entry being\n                // removed from DownloadsManager.\n                if (localFilePath == null || !new File(localFilePath).exists()) {\n                    return;\n                }\n                extraFlags = Document.FLAG_SUPPORTS_RENAME;  // only successful is non-partial\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    String percent =\n                            NumberFormat.getPercentInstance().format((double) progress / size);\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE | Document.FLAG_SUPPORTS_WRITE | extraFlags;\n        if (mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        if (typeSupportsMetadata(mimeType)) {\n            flags |= Document.FLAG_SUPPORTS_METADATA;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        if (!DocumentsContract.matchSearchQueryArguments(queryArgs, displayName, mimeType,\n                lastModified, size)) {\n            return;\n        }\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_FLAGS, flags);\n        // Incomplete downloads get a null timestamp.  This prevents thrashy UI when a bunch of\n        // active downloads get sorted by mod time.\n        if (status != DownloadManager.STATUS_RUNNING) {\n            row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        }\n        filePaths.add(localFilePath);\n    }\n\n    /**\n     * Takes all the top-level files from the Downloads directory and adds them to the result.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param downloadedFilePaths The absolute file paths of all the files in the result Cursor.\n     * @param searchString query used to filter out unwanted results.\n     */\n    private void includeFilesFromSharedStorage(MatrixCursor result,\n            Set<String> downloadedFilePaths, @Nullable String searchString)\n            throws FileNotFoundException {\n        File downloadsDir = getDownloadsDirectory();\n        // Add every file from the Downloads directory to the result cursor. Ignore files that\n        // were in the supplied downloaded file paths.\n        for (File file : downloadsDir.listFiles()) {\n            boolean inResultsAlready = downloadedFilePaths.contains(file.getAbsolutePath());\n            boolean containsQuery = searchString == null || file.getName().contains(searchString);\n            if (!inResultsAlready && containsQuery) {\n                includeFileFromSharedStorage(result, file);\n            }\n        }\n    }\n\n    /**\n     * Adds a file to the result cursor. It uses a combination of {@code #RAW_PREFIX} and its\n     * absolute file path for its id. Directories are not to be included.\n     *\n     * @param result cursor containing all documents to be returned by queryChildDocuments or\n     *            queryChildDocumentsForManage.\n     * @param file file to be included in the result cursor.\n     */\n    private void includeFileFromSharedStorage(MatrixCursor result, File file)\n            throws FileNotFoundException {\n        includeFile(result, null, file);\n    }\n\n    private static File getDownloadsDirectory() {\n        return Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DOWNLOADS);\n    }\n\n    /**\n     * A MatrixCursor that spins up a file observer when the first instance is\n     * started ({@link #start()}, and stops the file observer when the last instance\n     * closed ({@link #close()}. When file changes are observed, a content change\n     * notification is sent on the Downloads content URI.\n     *\n     * <p>This is necessary as other processes, like ExternalStorageProvider,\n     * can access and modify files directly (without sending operations\n     * through DownloadStorageProvider).\n     *\n     * <p>Without this, contents accessible by one a Downloads cursor instance\n     * (like the Downloads root in Files app) can become state.\n     */\n    private static final class DownloadsCursor extends MatrixCursor {\n\n        private static final Object mLock = new Object();\n        @GuardedBy(\"mLock\")\n        private static int mOpenCursorCount = 0;\n        @GuardedBy(\"mLock\")\n        private static @Nullable ContentChangedRelay mFileWatcher;\n\n        private final ContentResolver mResolver;\n\n        DownloadsCursor(String[] projection, ContentResolver resolver) {\n            super(resolveDocumentProjection(projection));\n            mResolver = resolver;\n        }\n\n        void start() {\n            synchronized (mLock) {\n                if (mOpenCursorCount++ == 0) {\n                    mFileWatcher = new ContentChangedRelay(mResolver);\n                    mFileWatcher.startWatching();\n                }\n            }\n        }\n\n        @Override\n        public void close() {\n            super.close();\n            synchronized (mLock) {\n                if (--mOpenCursorCount == 0) {\n                    mFileWatcher.stopWatching();\n                    mFileWatcher = null;\n                }\n            }\n        }\n    }\n\n    /**\n     * A file observer that notifies on the Downloads content URI(s) when\n     * files change on disk.\n     */\n    private static class ContentChangedRelay extends FileObserver {\n        private static final int NOTIFY_EVENTS = ATTRIB | CLOSE_WRITE | MOVED_FROM | MOVED_TO\n                | CREATE | DELETE | DELETE_SELF | MOVE_SELF;\n\n        private static final String DOWNLOADS_PATH = getDownloadsDirectory().getAbsolutePath();\n        private final ContentResolver mResolver;\n\n        public ContentChangedRelay(ContentResolver resolver) {\n            super(DOWNLOADS_PATH, NOTIFY_EVENTS);\n            mResolver = resolver;\n        }\n\n        @Override\n        public void startWatching() {\n            super.startWatching();\n            if (DEBUG) Log.d(TAG, \"Started watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void stopWatching() {\n            super.stopWatching();\n            if (DEBUG) Log.d(TAG, \"Stopped watching for file changes in: \" + DOWNLOADS_PATH);\n        }\n\n        @Override\n        public void onEvent(int event, String path) {\n            if ((event & NOTIFY_EVENTS) != 0) {\n                if (DEBUG) Log.v(TAG, \"Change detected at path: \" + DOWNLOADS_PATH);\n                mResolver.notifyChange(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, null, false);\n                mResolver.notifyChange(Downloads.Impl.CONTENT_URI, null, false);\n            }\n        }\n    }\n}\n","lineNo":310}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_CONTROL;\nimport static android.provider.Downloads.Impl.COLUMN_DELETED;\nimport static android.provider.Downloads.Impl.COLUMN_STATUS;\nimport static android.provider.Downloads.Impl.CONTROL_PAUSED;\nimport static android.provider.Downloads.Impl.STATUS_BAD_REQUEST;\nimport static android.provider.Downloads.Impl.STATUS_CANCELED;\nimport static android.provider.Downloads.Impl.STATUS_CANNOT_RESUME;\nimport static android.provider.Downloads.Impl.STATUS_FILE_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_HTTP_DATA_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_PAUSED_BY_APP;\nimport static android.provider.Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\nimport static android.provider.Downloads.Impl.STATUS_RUNNING;\nimport static android.provider.Downloads.Impl.STATUS_SUCCESS;\nimport static android.provider.Downloads.Impl.STATUS_TOO_MANY_REDIRECTS;\nimport static android.provider.Downloads.Impl.STATUS_UNHANDLED_HTTP_CODE;\nimport static android.provider.Downloads.Impl.STATUS_UNKNOWN_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_TO_RETRY;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_PRECON_FAILED;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\nimport static java.net.HttpURLConnection.HTTP_UNAVAILABLE;\n\nimport android.app.job.JobParameters;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.drm.DrmManagerClient;\nimport android.drm.DrmOutputStream;\nimport android.net.ConnectivityManager;\nimport android.net.INetworkPolicyListener;\nimport android.net.Network;\nimport android.net.NetworkInfo;\nimport android.net.NetworkPolicyManager;\nimport android.net.TrafficStats;\nimport android.net.Uri;\nimport android.os.ParcelFileDescriptor;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.os.storage.StorageManager;\nimport android.provider.Downloads;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.system.OsConstants;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Pair;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.GeneralSecurityException;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\n\n/**\n * Task which executes a given {@link DownloadInfo}: making network requests,\n * persisting data to disk, and updating {@link DownloadProvider}.\n * <p>\n * To know if a download is successful, we need to know either the final content\n * length to expect, or the transfer to be chunked. To resume an interrupted\n * download, we need an ETag.\n * <p>\n * Failed network requests are retried several times before giving up. Local\n * disk errors fail immediately and are not retried.\n */\npublic class DownloadThread extends Thread {\n\n    // TODO: bind each download to a specific network interface to avoid state\n    // checking races once we have ConnectivityManager API\n\n    // TODO: add support for saving to content://\n\n    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    private static final int HTTP_TEMP_REDIRECT = 307;\n\n    private static final int DEFAULT_TIMEOUT = (int) (20 * SECOND_IN_MILLIS);\n\n    private final Context mContext;\n    private final SystemFacade mSystemFacade;\n    private final DownloadNotifier mNotifier;\n    private final NetworkPolicyManager mNetworkPolicy;\n    private final StorageManager mStorage;\n\n    private final DownloadJobService mJobService;\n    private final JobParameters mParams;\n\n    private final long mId;\n\n    /**\n     * Info object that should be treated as read-only. Any potentially mutated\n     * fields are tracked in {@link #mInfoDelta}. If a field exists in\n     * {@link #mInfoDelta}, it must not be read from {@link #mInfo}.\n     */\n    private final DownloadInfo mInfo;\n    private final DownloadInfoDelta mInfoDelta;\n\n    private volatile boolean mPolicyDirty;\n\n    /**\n     * Local changes to {@link DownloadInfo}. These are kept local to avoid\n     * racing with the thread that updates based on change notifications.\n     */\n    private class DownloadInfoDelta {\n        public String mUri;\n        public String mFileName;\n        public String mMimeType;\n        public int mStatus;\n        public int mNumFailed;\n        public int mRetryAfter;\n        public long mTotalBytes;\n        public long mCurrentBytes;\n        public String mETag;\n\n        public String mErrorMsg;\n\n        private static final String NOT_CANCELED = COLUMN_STATUS + \" != '\" + STATUS_CANCELED + \"'\";\n        private static final String NOT_DELETED = COLUMN_DELETED + \" == '0'\";\n        private static final String NOT_PAUSED = \"(\" + COLUMN_CONTROL + \" IS NULL OR \"\n                + COLUMN_CONTROL + \" != '\" + CONTROL_PAUSED + \"')\";\n\n        private static final String SELECTION_VALID = NOT_CANCELED + \" AND \" + NOT_DELETED + \" AND \"\n                + NOT_PAUSED;\n\n        public DownloadInfoDelta(DownloadInfo info) {\n            mUri = info.mUri;\n            mFileName = info.mFileName;\n            mMimeType = info.mMimeType;\n            mStatus = info.mStatus;\n            mNumFailed = info.mNumFailed;\n            mRetryAfter = info.mRetryAfter;\n            mTotalBytes = info.mTotalBytes;\n            mCurrentBytes = info.mCurrentBytes;\n            mETag = info.mETag;\n        }\n\n        private ContentValues buildContentValues() {\n            final ContentValues values = new ContentValues();\n\n            values.put(Downloads.Impl.COLUMN_URI, mUri);\n            values.put(Downloads.Impl._DATA, mFileName);\n            values.put(Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);\n            values.put(Downloads.Impl.COLUMN_STATUS, mStatus);\n            values.put(Downloads.Impl.COLUMN_FAILED_CONNECTIONS, mNumFailed);\n            values.put(Constants.RETRY_AFTER_X_REDIRECT_COUNT, mRetryAfter);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, mTotalBytes);\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, mCurrentBytes);\n            values.put(Constants.ETAG, mETag);\n\n            values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, mSystemFacade.currentTimeMillis());\n            values.put(Downloads.Impl.COLUMN_ERROR_MSG, mErrorMsg);\n\n            return values;\n        }\n\n        /**\n         * Blindly push update of current delta values to provider.\n         */\n        public void writeToDatabase() {\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), buildContentValues(),\n                    null, null);\n        }\n\n        /**\n         * Push update of current delta values to provider, asserting strongly\n         * that we haven't been paused or deleted.\n         */\n        public void writeToDatabaseOrThrow() throws StopRequestException {\n            if (mContext.getContentResolver().update(mInfo.getAllDownloadsUri(),\n                    buildContentValues(), SELECTION_VALID, null) == 0) {\n                if (mInfo.queryDownloadControl() == CONTROL_PAUSED) {\n                    throw new StopRequestException(STATUS_PAUSED_BY_APP, \"Download paused!\");\n                } else {\n                    throw new StopRequestException(STATUS_CANCELED, \"Download deleted or missing!\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Flag indicating if we've made forward progress transferring file data\n     * from a remote server.\n     */\n    private boolean mMadeProgress = false;\n\n    /**\n     * Details from the last time we pushed a database update.\n     */\n    private long mLastUpdateBytes = 0;\n    private long mLastUpdateTime = 0;\n\n    private boolean mIgnoreBlocked;\n    private Network mNetwork;\n\n    private int mNetworkType = ConnectivityManager.TYPE_NONE;\n\n    /** Historical bytes/second speed of this download. */\n    private long mSpeed;\n    /** Time when current sample started. */\n    private long mSpeedSampleStart;\n    /** Bytes transferred since current sample started. */\n    private long mSpeedSampleBytes;\n\n    /** Flag indicating that thread must be halted */\n    private volatile boolean mShutdownRequested;\n\n    public DownloadThread(DownloadJobService service, JobParameters params, DownloadInfo info) {\n        mContext = service;\n        mSystemFacade = Helpers.getSystemFacade(mContext);\n        mNotifier = Helpers.getDownloadNotifier(mContext);\n        mNetworkPolicy = mContext.getSystemService(NetworkPolicyManager.class);\n        mStorage = mContext.getSystemService(StorageManager.class);\n\n        mJobService = service;\n        mParams = params;\n\n        mId = info.mId;\n        mInfo = info;\n        mInfoDelta = new DownloadInfoDelta(info);\n    }\n\n    @Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        // Skip when download already marked as finished; this download was\n        // probably started again while racing with UpdateThread.\n        if (mInfo.queryDownloadStatus() == Downloads.Impl.STATUS_SUCCESS) {\n            logDebug(\"Already finished; skipping\");\n            return;\n        }\n\n        try {\n            // while performing download, register for rules updates\n            mNetworkPolicy.registerListener(mPolicyListener);\n\n            logDebug(\"Starting\");\n\n            mInfoDelta.mStatus = STATUS_RUNNING;\n            mInfoDelta.writeToDatabase();\n\n            // If we're showing a foreground notification for the requesting\n            // app, the download isn't affected by the blocked status of the\n            // requesting app\n            mIgnoreBlocked = mInfo.isVisible();\n\n            // Use the caller's default network to make this connection, since\n            // they might be subject to restrictions that we shouldn't let them\n            // circumvent\n            mNetwork = mSystemFacade.getActiveNetwork(mInfo.mUid, mIgnoreBlocked);\n            if (mNetwork == null) {\n                throw new StopRequestException(STATUS_WAITING_FOR_NETWORK,\n                        \"No network associated with requesting UID\");\n            }\n\n            // Remember which network this download started on; used to\n            // determine if errors were due to network changes.\n            final NetworkInfo info = mSystemFacade.getNetworkInfo(mNetwork, mInfo.mUid,\n                    mIgnoreBlocked);\n            if (info != null) {\n                mNetworkType = info.getType();\n            }\n\n            // Network traffic on this thread should be counted against the\n            // requesting UID, and is tagged with well-known value.\n            TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_DOWNLOAD);\n            TrafficStats.setThreadStatsUid(mInfo.mUid);\n\n            executeDownload();\n\n            mInfoDelta.mStatus = STATUS_SUCCESS;\n            TrafficStats.incrementOperationCount(1);\n\n            // If we just finished a chunked file, record total size\n            if (mInfoDelta.mTotalBytes == -1) {\n                mInfoDelta.mTotalBytes = mInfoDelta.mCurrentBytes;\n            }\n\n        } catch (StopRequestException e) {\n            mInfoDelta.mStatus = e.getFinalStatus();\n            mInfoDelta.mErrorMsg = e.getMessage();\n\n            logWarning(\"Stop requested with status \"\n                    + Downloads.Impl.statusToString(mInfoDelta.mStatus) + \": \"\n                    + mInfoDelta.mErrorMsg);\n\n            // Nobody below our level should request retries, since we handle\n            // failure counts at this level.\n            if (mInfoDelta.mStatus == STATUS_WAITING_TO_RETRY) {\n                throw new IllegalStateException(\"Execution should always throw final error codes\");\n            }\n\n            // Some errors should be retryable, unless we fail too many times.\n            if (isStatusRetryable(mInfoDelta.mStatus)) {\n                if (mMadeProgress) {\n                    mInfoDelta.mNumFailed = 1;\n                } else {\n                    mInfoDelta.mNumFailed += 1;\n                }\n\n                if (mInfoDelta.mNumFailed < Constants.MAX_RETRIES) {\n                    final NetworkInfo info = mSystemFacade.getNetworkInfo(mNetwork, mInfo.mUid,\n                            mIgnoreBlocked);\n                    if (info != null && info.getType() == mNetworkType && info.isConnected()) {\n                        // Underlying network is still intact, use normal backoff\n                        mInfoDelta.mStatus = STATUS_WAITING_TO_RETRY;\n                    } else {\n                        // Network changed, retry on any next available\n                        mInfoDelta.mStatus = STATUS_WAITING_FOR_NETWORK;\n                    }\n\n                    if ((mInfoDelta.mETag == null && mMadeProgress)\n                            || DownloadDrmHelper.isDrmConvertNeeded(mInfoDelta.mMimeType)) {\n                        // However, if we wrote data and have no ETag to verify\n                        // contents against later, we can't actually resume.\n                        mInfoDelta.mStatus = STATUS_CANNOT_RESUME;\n                    }\n                }\n            }\n\n            // If we're waiting for a network that must be unmetered, our status\n            // is actually queued so we show relevant notifications\n            if (mInfoDelta.mStatus == STATUS_WAITING_FOR_NETWORK\n                    && !mInfo.isMeteredAllowed(mInfoDelta.mTotalBytes)) {\n                mInfoDelta.mStatus = STATUS_QUEUED_FOR_WIFI;\n            }\n\n        } catch (Throwable t) {\n            mInfoDelta.mStatus = STATUS_UNKNOWN_ERROR;\n            mInfoDelta.mErrorMsg = t.toString();\n\n            logError(\"Failed: \" + mInfoDelta.mErrorMsg, t);\n\n        } finally {\n            logDebug(\"Finished with status \" + Downloads.Impl.statusToString(mInfoDelta.mStatus));\n\n            mNotifier.notifyDownloadSpeed(mId, 0);\n\n            finalizeDestination();\n\n            mInfoDelta.writeToDatabase();\n\n            TrafficStats.clearThreadStatsTag();\n            TrafficStats.clearThreadStatsUid();\n\n            mNetworkPolicy.unregisterListener(mPolicyListener);\n        }\n\n        if (Downloads.Impl.isStatusCompleted(mInfoDelta.mStatus)) {\n            if (mInfo.shouldScanFile(mInfoDelta.mStatus)) {\n                DownloadScanner.requestScanBlocking(mContext, mInfo.mId, mInfoDelta.mFileName,\n                        mInfoDelta.mMimeType);\n            }\n        } else if (mInfoDelta.mStatus == STATUS_WAITING_TO_RETRY\n                || mInfoDelta.mStatus == STATUS_WAITING_FOR_NETWORK\n                || mInfoDelta.mStatus == STATUS_QUEUED_FOR_WIFI) {\n            Helpers.scheduleJob(mContext, DownloadInfo.queryDownloadInfo(mContext, mId));\n        }\n\n        mJobService.jobFinishedInternal(mParams, false);\n    }\n\n    public void requestShutdown() {\n        mShutdownRequested = true;\n    }\n\n    /**\n     * Fully execute a single download request. Setup and send the request,\n     * handle the response, and transfer the data to the destination file.\n     */\n    private void executeDownload() throws StopRequestException {\n        final boolean resuming = mInfoDelta.mCurrentBytes != 0;\n\n        URL url;\n        try {\n            // TODO: migrate URL sanity checking into client side of API\n            url = new URL(mInfoDelta.mUri);\n        } catch (MalformedURLException e) {\n            throw new StopRequestException(STATUS_BAD_REQUEST, e);\n        }\n\n        boolean cleartextTrafficPermitted = mSystemFacade.isCleartextTrafficPermitted(mInfo.mUid);\n        SSLContext appContext;\n        try {\n            appContext = mSystemFacade.getSSLContextForPackage(mContext, mInfo.mPackage);\n        } catch (GeneralSecurityException e) {\n            // This should never happen.\n            throw new StopRequestException(STATUS_UNKNOWN_ERROR, \"Unable to create SSLContext.\");\n        }\n        int redirectionCount = 0;\n        while (redirectionCount++ < Constants.MAX_REDIRECTS) {\n            // Enforce the cleartext traffic opt-out for the UID. This cannot be enforced earlier\n            // because of HTTP redirects which can change the protocol between HTTP and HTTPS.\n            if ((!cleartextTrafficPermitted) && (\"http\".equalsIgnoreCase(url.getProtocol()))) {\n                throw new StopRequestException(STATUS_BAD_REQUEST,\n                        \"Cleartext traffic not permitted for UID \" + mInfo.mUid + \": \"\n                        + Uri.parse(url.toString()).toSafeString());\n            }\n\n            // Open connection and follow any redirects until we have a useful\n            // response with body.\n            HttpURLConnection conn = null;\n            try {\n                // Check that the caller is allowed to make network connections. If so, make one on\n                // their behalf to open the url.\n                checkConnectivity();\n                conn = (HttpURLConnection) mNetwork.openConnection(url);\n                conn.setInstanceFollowRedirects(false);\n                conn.setConnectTimeout(DEFAULT_TIMEOUT);\n                conn.setReadTimeout(DEFAULT_TIMEOUT);\n                // If this is going over HTTPS configure the trust to be the same as the calling\n                // package.\n                if (conn instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection)conn).setSSLSocketFactory(appContext.getSocketFactory());\n                }\n\n                addRequestHeaders(conn, resuming);\n\n                final int responseCode = conn.getResponseCode();\n                switch (responseCode) {\n                    case HTTP_OK:\n                        if (resuming) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected partial, but received OK\");\n                        }\n                        parseOkHeaders(conn);\n                        transferData(conn);\n                        return;\n\n                    case HTTP_PARTIAL:\n                        if (!resuming) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected OK, but received partial\");\n                        }\n                        transferData(conn);\n                        return;\n\n                    case HTTP_MOVED_PERM:\n                    case HTTP_MOVED_TEMP:\n                    case HTTP_SEE_OTHER:\n                    case HTTP_TEMP_REDIRECT:\n                        final String location = conn.getHeaderField(\"Location\");\n                        url = new URL(url, location);\n                        if (responseCode == HTTP_MOVED_PERM) {\n                            // Push updated URL back to database\n                            mInfoDelta.mUri = url.toString();\n                        }\n                        continue;\n\n                    case HTTP_PRECON_FAILED:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Precondition failed\");\n\n                    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Requested range not satisfiable\");\n\n                    case HTTP_UNAVAILABLE:\n                        parseUnavailableHeaders(conn);\n                        throw new StopRequestException(\n                                HTTP_UNAVAILABLE, conn.getResponseMessage());\n\n                    case HTTP_INTERNAL_ERROR:\n                        throw new StopRequestException(\n                                HTTP_INTERNAL_ERROR, conn.getResponseMessage());\n\n                    default:\n                        StopRequestException.throwUnhandledHttpError(\n                                responseCode, conn.getResponseMessage());\n                }\n\n            } catch (IOException e) {\n                if (e instanceof ProtocolException\n                        && e.getMessage().startsWith(\"Unexpected status line\")) {\n                    throw new StopRequestException(STATUS_UNHANDLED_HTTP_CODE, e);\n                } else {\n                    // Trouble with low-level sockets\n                    throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n                }\n\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        }\n\n        throw new StopRequestException(STATUS_TOO_MANY_REDIRECTS, \"Too many redirects\");\n    }\n\n    /**\n     * Transfer data from the given connection to the destination file.\n     */\n    private void transferData(HttpURLConnection conn) throws StopRequestException {\n\n        // To detect when we're really finished, we either need a length, closed\n        // connection, or chunked encoding.\n        final boolean hasLength = mInfoDelta.mTotalBytes != -1;\n        final boolean isConnectionClose = \"close\".equalsIgnoreCase(\n                conn.getHeaderField(\"Connection\"));\n        final boolean isEncodingChunked = \"chunked\".equalsIgnoreCase(\n                conn.getHeaderField(\"Transfer-Encoding\"));\n\n        final boolean finishKnown = hasLength || isConnectionClose || isEncodingChunked;\n        if (!finishKnown) {\n            throw new StopRequestException(\n                    STATUS_CANNOT_RESUME, \"can't know size of download, giving up\");\n        }\n\n        DrmManagerClient drmClient = null;\n        ParcelFileDescriptor outPfd = null;\n        FileDescriptor outFd = null;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            try {\n                in = conn.getInputStream();\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n            }\n\n            try {\n                outPfd = mContext.getContentResolver()\n                        .openFileDescriptor(mInfo.getAllDownloadsUri(), \"rw\");\n                outFd = outPfd.getFileDescriptor();\n\n                if (DownloadDrmHelper.isDrmConvertNeeded(mInfoDelta.mMimeType)) {\n                    drmClient = new DrmManagerClient(mContext);\n                    out = new DrmOutputStream(drmClient, outPfd, mInfoDelta.mMimeType);\n                } else {\n                    out = new ParcelFileDescriptor.AutoCloseOutputStream(outPfd);\n                }\n\n                // Move into place to begin writing\n                Os.lseek(outFd, mInfoDelta.mCurrentBytes, OsConstants.SEEK_SET);\n            } catch (ErrnoException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n            try {\n                // Pre-flight disk space requirements, when known\n                if (mInfoDelta.mTotalBytes > 0 && mStorage.isAllocationSupported(outFd)) {\n                    mStorage.allocateBytes(outFd, mInfoDelta.mTotalBytes);\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_INSUFFICIENT_SPACE_ERROR, e);\n            }\n\n            // Start streaming data, periodically watch for pause/cancel\n            // commands and checking disk space as needed.\n            transferData(in, out, outFd);\n\n            try {\n                if (out instanceof DrmOutputStream) {\n                    ((DrmOutputStream) out).finish();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n        } finally {\n            if (drmClient != null) {\n                drmClient.close();\n            }\n\n            IoUtils.closeQuietly(in);\n\n            try {\n                if (out != null) out.flush();\n                if (outFd != null) outFd.sync();\n            } catch (IOException e) {\n            } finally {\n                IoUtils.closeQuietly(out);\n            }\n        }\n    }\n\n    /**\n     * Transfer as much data as possible from the HTTP response to the\n     * destination file.\n     */\n    private void transferData(InputStream in, OutputStream out, FileDescriptor outFd)\n            throws StopRequestException {\n        final byte buffer[] = new byte[Constants.BUFFER_SIZE];\n        while (true) {\n            if (mPolicyDirty) checkConnectivity();\n\n            if (mShutdownRequested) {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR,\n                        \"Local halt requested; job probably timed out\");\n            }\n\n            int len = -1;\n            try {\n                len = in.read(buffer);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        STATUS_HTTP_DATA_ERROR, \"Failed reading response: \" + e, e);\n            }\n\n            if (len == -1) {\n                break;\n            }\n\n            try {\n                out.write(buffer, 0, len);\n\n                mMadeProgress = true;\n                mInfoDelta.mCurrentBytes += len;\n\n                updateProgress(outFd);\n\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n        }\n\n        // Finished without error; verify length if known\n        if (mInfoDelta.mTotalBytes != -1 && mInfoDelta.mCurrentBytes != mInfoDelta.mTotalBytes) {\n            throw new StopRequestException(STATUS_HTTP_DATA_ERROR, \"Content length mismatch; found \"\n                    + mInfoDelta.mCurrentBytes + \" instead of \" + mInfoDelta.mTotalBytes);\n        }\n    }\n\n    /**\n     * Called just before the thread finishes, regardless of status, to take any\n     * necessary action on the downloaded file.\n     */\n    private void finalizeDestination() {\n        if (Downloads.Impl.isStatusError(mInfoDelta.mStatus)) {\n            // When error, free up any disk space\n            try {\n                final ParcelFileDescriptor target = mContext.getContentResolver()\n                        .openFileDescriptor(mInfo.getAllDownloadsUri(), \"rw\");\n                try {\n                    Os.ftruncate(target.getFileDescriptor(), 0);\n                } catch (ErrnoException ignored) {\n                } finally {\n                    IoUtils.closeQuietly(target);\n                }\n            } catch (FileNotFoundException ignored) {\n            }\n\n            // Delete if local file\n            if (mInfoDelta.mFileName != null) {\n                new File(mInfoDelta.mFileName).delete();\n                mInfoDelta.mFileName = null;\n            }\n\n        } else if (Downloads.Impl.isStatusSuccess(mInfoDelta.mStatus)) {\n            // When success, open access if local file\n            if (mInfoDelta.mFileName != null) {\n                if (mInfo.mDestination != Downloads.Impl.DESTINATION_FILE_URI) {\n                    try {\n                        // Move into final resting place, if needed\n                        final File before = new File(mInfoDelta.mFileName);\n                        final File beforeDir = Helpers.getRunningDestinationDirectory(\n                                mContext, mInfo.mDestination);\n                        final File afterDir = Helpers.getSuccessDestinationDirectory(\n                                mContext, mInfo.mDestination);\n                        if (!beforeDir.equals(afterDir)\n                                && before.getParentFile().equals(beforeDir)) {\n                            final File after = new File(afterDir, before.getName());\n                            if (before.renameTo(after)) {\n                                mInfoDelta.mFileName = after.getAbsolutePath();\n                            }\n                        }\n                    } catch (IOException ignored) {\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if current connectivity is valid for this request.\n     */\n    private void checkConnectivity() throws StopRequestException {\n        // checking connectivity will apply current policy\n        mPolicyDirty = false;\n\n        final NetworkInfo info = mSystemFacade.getNetworkInfo(mNetwork, mInfo.mUid,\n                mIgnoreBlocked);\n        if (info == null || !info.isConnected()) {\n            throw new StopRequestException(STATUS_WAITING_FOR_NETWORK, \"Network is disconnected\");\n        }\n        if (info.isRoaming() && !mInfo.isRoamingAllowed()) {\n            throw new StopRequestException(STATUS_WAITING_FOR_NETWORK, \"Network is roaming\");\n        }\n        if (mSystemFacade.isNetworkMetered(mNetwork)\n                && !mInfo.isMeteredAllowed(mInfoDelta.mTotalBytes)) {\n            throw new StopRequestException(STATUS_WAITING_FOR_NETWORK, \"Network is metered\");\n        }\n    }\n\n    /**\n     * Report download progress through the database if necessary.\n     */\n    private void updateProgress(FileDescriptor outFd) throws IOException, StopRequestException {\n        final long now = SystemClock.elapsedRealtime();\n        final long currentBytes = mInfoDelta.mCurrentBytes;\n\n        final long sampleDelta = now - mSpeedSampleStart;\n        if (sampleDelta > 500) {\n            final long sampleSpeed = ((currentBytes - mSpeedSampleBytes) * 1000)\n                    / sampleDelta;\n\n            if (mSpeed == 0) {\n                mSpeed = sampleSpeed;\n            } else {\n                mSpeed = ((mSpeed * 3) + sampleSpeed) / 4;\n            }\n\n            // Only notify once we have a full sample window\n            if (mSpeedSampleStart != 0) {\n                mNotifier.notifyDownloadSpeed(mId, mSpeed);\n            }\n\n            mSpeedSampleStart = now;\n            mSpeedSampleBytes = currentBytes;\n        }\n\n        final long bytesDelta = currentBytes - mLastUpdateBytes;\n        final long timeDelta = now - mLastUpdateTime;\n        if (bytesDelta > Constants.MIN_PROGRESS_STEP && timeDelta > Constants.MIN_PROGRESS_TIME) {\n            // fsync() to ensure that current progress has been flushed to disk,\n            // so we can always resume based on latest database information.\n            outFd.sync();\n\n            mInfoDelta.writeToDatabaseOrThrow();\n\n            mLastUpdateBytes = currentBytes;\n            mLastUpdateTime = now;\n        }\n    }\n\n    /**\n     * Process response headers from first server response. This derives its\n     * filename, size, and ETag.\n     */\n    private void parseOkHeaders(HttpURLConnection conn) throws StopRequestException {\n        if (mInfoDelta.mFileName == null) {\n            final String contentDisposition = conn.getHeaderField(\"Content-Disposition\");\n            final String contentLocation = conn.getHeaderField(\"Content-Location\");\n\n            try {\n                mInfoDelta.mFileName = Helpers.generateSaveFile(mContext, mInfoDelta.mUri,\n                        mInfo.mHint, contentDisposition, contentLocation, mInfoDelta.mMimeType,\n                        mInfo.mDestination);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_FILE_ERROR, \"Failed to generate filename: \" + e);\n            }\n        }\n\n        if (mInfoDelta.mMimeType == null) {\n            mInfoDelta.mMimeType = Intent.normalizeMimeType(conn.getContentType());\n        }\n\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        if (transferEncoding == null) {\n            mInfoDelta.mTotalBytes = getHeaderFieldLong(conn, \"Content-Length\", -1);\n        } else {\n            mInfoDelta.mTotalBytes = -1;\n        }\n\n        mInfoDelta.mETag = conn.getHeaderField(\"ETag\");\n\n        mInfoDelta.writeToDatabaseOrThrow();\n\n        // Check connectivity again now that we know the total size\n        checkConnectivity();\n    }\n\n    private void parseUnavailableHeaders(HttpURLConnection conn) {\n        long retryAfter = conn.getHeaderFieldInt(\"Retry-After\", -1);\n        retryAfter = MathUtils.constrain(retryAfter, Constants.MIN_RETRY_AFTER,\n                Constants.MAX_RETRY_AFTER);\n        mInfoDelta.mRetryAfter = (int) (retryAfter * SECOND_IN_MILLIS);\n    }\n\n    /**\n     * Add custom headers for this download to the HTTP request.\n     */\n    private void addRequestHeaders(HttpURLConnection conn, boolean resuming) {\n        for (Pair<String, String> header : mInfo.getHeaders()) {\n            conn.addRequestProperty(header.first, header.second);\n        }\n\n        // Only splice in user agent when not already defined\n        if (conn.getRequestProperty(\"User-Agent\") == null) {\n            conn.addRequestProperty(\"User-Agent\", mInfo.getUserAgent());\n        }\n\n        // Defeat transparent gzip compression, since it doesn't allow us to\n        // easily resume partial downloads.\n        conn.setRequestProperty(\"Accept-Encoding\", \"identity\");\n\n        // Defeat connection reuse, since otherwise servers may continue\n        // streaming large downloads after cancelled.\n        conn.setRequestProperty(\"Connection\", \"close\");\n\n        if (resuming) {\n            if (mInfoDelta.mETag != null) {\n                conn.addRequestProperty(\"If-Match\", mInfoDelta.mETag);\n            }\n            conn.addRequestProperty(\"Range\", \"bytes=\" + mInfoDelta.mCurrentBytes + \"-\");\n        }\n    }\n\n    private void logDebug(String msg) {\n        Log.d(TAG, \"[\" + mId + \"] \" + msg);\n    }\n\n    private void logWarning(String msg) {\n        Log.w(TAG, \"[\" + mId + \"] \" + msg);\n    }\n\n    private void logError(String msg, Throwable t) {\n        Log.e(TAG, \"[\" + mId + \"] \" + msg, t);\n    }\n\n    private INetworkPolicyListener mPolicyListener = new INetworkPolicyListener.Stub() {\n        @Override\n        public void onUidRulesChanged(int uid, int uidRules) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n\n        @Override\n        public void onMeteredIfacesChanged(String[] meteredIfaces) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onRestrictBackgroundChanged(boolean restrictBackground) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onUidPoliciesChanged(int uid, int uidPolicies) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n    };\n\n    private static long getHeaderFieldLong(URLConnection conn, String field, long defaultValue) {\n        try {\n            return Long.parseLong(conn.getHeaderField(field));\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Return if given status is eligible to be treated as\n     * {@link android.provider.Downloads.Impl#STATUS_WAITING_TO_RETRY}.\n     */\n    public static boolean isStatusRetryable(int status) {\n        switch (status) {\n            case STATUS_HTTP_DATA_ERROR:\n            case HTTP_UNAVAILABLE:\n            case HTTP_INTERNAL_ERROR:\n            case STATUS_FILE_ERROR:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.COLUMN_CONTROL;\nimport static android.provider.Downloads.Impl.COLUMN_DELETED;\nimport static android.provider.Downloads.Impl.COLUMN_STATUS;\nimport static android.provider.Downloads.Impl.CONTROL_PAUSED;\nimport static android.provider.Downloads.Impl.STATUS_BAD_REQUEST;\nimport static android.provider.Downloads.Impl.STATUS_CANCELED;\nimport static android.provider.Downloads.Impl.STATUS_CANNOT_RESUME;\nimport static android.provider.Downloads.Impl.STATUS_FILE_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_HTTP_DATA_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_PAUSED_BY_APP;\nimport static android.provider.Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\nimport static android.provider.Downloads.Impl.STATUS_RUNNING;\nimport static android.provider.Downloads.Impl.STATUS_SUCCESS;\nimport static android.provider.Downloads.Impl.STATUS_TOO_MANY_REDIRECTS;\nimport static android.provider.Downloads.Impl.STATUS_UNHANDLED_HTTP_CODE;\nimport static android.provider.Downloads.Impl.STATUS_UNKNOWN_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_TO_RETRY;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_PRECON_FAILED;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\nimport static java.net.HttpURLConnection.HTTP_UNAVAILABLE;\n\nimport android.app.job.JobParameters;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.drm.DrmManagerClient;\nimport android.drm.DrmOutputStream;\nimport android.net.ConnectivityManager;\nimport android.net.INetworkPolicyListener;\nimport android.net.Network;\nimport android.net.NetworkInfo;\nimport android.net.NetworkPolicyManager;\nimport android.net.TrafficStats;\nimport android.net.Uri;\nimport android.os.ParcelFileDescriptor;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.os.storage.StorageManager;\nimport android.provider.Downloads;\nimport android.system.ErrnoException;\nimport android.system.Os;\nimport android.system.OsConstants;\nimport android.util.Log;\nimport android.util.MathUtils;\nimport android.util.Pair;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.security.GeneralSecurityException;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\n\n/**\n * Task which executes a given {@link DownloadInfo}: making network requests,\n * persisting data to disk, and updating {@link DownloadProvider}.\n * <p>\n * To know if a download is successful, we need to know either the final content\n * length to expect, or the transfer to be chunked. To resume an interrupted\n * download, we need an ETag.\n * <p>\n * Failed network requests are retried several times before giving up. Local\n * disk errors fail immediately and are not retried.\n */\npublic class DownloadThread extends Thread {\n\n    // TODO: bind each download to a specific network interface to avoid state\n    // checking races once we have ConnectivityManager API\n\n    // TODO: add support for saving to content://\n\n    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    private static final int HTTP_TEMP_REDIRECT = 307;\n\n    private static final int DEFAULT_TIMEOUT = (int) (20 * SECOND_IN_MILLIS);\n\n    private final Context mContext;\n    private final SystemFacade mSystemFacade;\n    private final DownloadNotifier mNotifier;\n    private final NetworkPolicyManager mNetworkPolicy;\n    private final StorageManager mStorage;\n\n    private final DownloadJobService mJobService;\n    private final JobParameters mParams;\n\n    private final long mId;\n\n    /**\n     * Info object that should be treated as read-only. Any potentially mutated\n     * fields are tracked in {@link #mInfoDelta}. If a field exists in\n     * {@link #mInfoDelta}, it must not be read from {@link #mInfo}.\n     */\n    private final DownloadInfo mInfo;\n    private final DownloadInfoDelta mInfoDelta;\n\n    private volatile boolean mPolicyDirty;\n\n    /**\n     * Local changes to {@link DownloadInfo}. These are kept local to avoid\n     * racing with the thread that updates based on change notifications.\n     */\n    private class DownloadInfoDelta {\n        public String mUri;\n        public String mFileName;\n        public String mMimeType;\n        public int mStatus;\n        public int mNumFailed;\n        public int mRetryAfter;\n        public long mTotalBytes;\n        public long mCurrentBytes;\n        public String mETag;\n\n        public String mErrorMsg;\n\n        private static final String NOT_CANCELED = COLUMN_STATUS + \" != '\" + STATUS_CANCELED + \"'\";\n        private static final String NOT_DELETED = COLUMN_DELETED + \" == '0'\";\n        private static final String NOT_PAUSED = \"(\" + COLUMN_CONTROL + \" IS NULL OR \"\n                + COLUMN_CONTROL + \" != '\" + CONTROL_PAUSED + \"')\";\n\n        private static final String SELECTION_VALID = NOT_CANCELED + \" AND \" + NOT_DELETED + \" AND \"\n                + NOT_PAUSED;\n\n        public DownloadInfoDelta(DownloadInfo info) {\n            mUri = info.mUri;\n            mFileName = info.mFileName;\n            mMimeType = info.mMimeType;\n            mStatus = info.mStatus;\n            mNumFailed = info.mNumFailed;\n            mRetryAfter = info.mRetryAfter;\n            mTotalBytes = info.mTotalBytes;\n            mCurrentBytes = info.mCurrentBytes;\n            mETag = info.mETag;\n        }\n\n        private ContentValues buildContentValues() {\n            final ContentValues values = new ContentValues();\n\n            values.put(Downloads.Impl.COLUMN_URI, mUri);\n            values.put(Downloads.Impl._DATA, mFileName);\n            values.put(Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);\n            values.put(Downloads.Impl.COLUMN_STATUS, mStatus);\n            values.put(Downloads.Impl.COLUMN_FAILED_CONNECTIONS, mNumFailed);\n            values.put(Constants.RETRY_AFTER_X_REDIRECT_COUNT, mRetryAfter);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, mTotalBytes);\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, mCurrentBytes);\n            values.put(Constants.ETAG, mETag);\n\n            values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, mSystemFacade.currentTimeMillis());\n            values.put(Downloads.Impl.COLUMN_ERROR_MSG, mErrorMsg);\n\n            return values;\n        }\n\n        /**\n         * Blindly push update of current delta values to provider.\n         */\n        public void writeToDatabase() {\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), buildContentValues(),\n                    null, null);\n        }\n\n        /**\n         * Push update of current delta values to provider, asserting strongly\n         * that we haven't been paused or deleted.\n         */\n        public void writeToDatabaseOrThrow() throws StopRequestException {\n            if (mContext.getContentResolver().update(mInfo.getAllDownloadsUri(),\n                    buildContentValues(), SELECTION_VALID, null) == 0) {\n                if (mInfo.queryDownloadControl() == CONTROL_PAUSED) {\n                    throw new StopRequestException(STATUS_PAUSED_BY_APP, \"Download paused!\");\n                } else {\n                    throw new StopRequestException(STATUS_CANCELED, \"Download deleted or missing!\");\n                }\n            }\n        }\n    }\n\n    /**\n     * Flag indicating if we've made forward progress transferring file data\n     * from a remote server.\n     */\n    private boolean mMadeProgress = false;\n\n    /**\n     * Details from the last time we pushed a database update.\n     */\n    private long mLastUpdateBytes = 0;\n    private long mLastUpdateTime = 0;\n\n    private boolean mIgnoreBlocked;\n    private Network mNetwork;\n\n    private int mNetworkType = ConnectivityManager.TYPE_NONE;\n\n    /** Historical bytes/second speed of this download. */\n    private long mSpeed;\n    /** Time when current sample started. */\n    private long mSpeedSampleStart;\n    /** Bytes transferred since current sample started. */\n    private long mSpeedSampleBytes;\n\n    /** Flag indicating that thread must be halted */\n    private volatile boolean mShutdownRequested;\n\n    public DownloadThread(DownloadJobService service, JobParameters params, DownloadInfo info) {\n        mContext = service;\n        mSystemFacade = Helpers.getSystemFacade(mContext);\n        mNotifier = Helpers.getDownloadNotifier(mContext);\n        mNetworkPolicy = mContext.getSystemService(NetworkPolicyManager.class);\n        mStorage = mContext.getSystemService(StorageManager.class);\n\n        mJobService = service;\n        mParams = params;\n\n        mId = info.mId;\n        mInfo = info;\n        mInfoDelta = new DownloadInfoDelta(info);\n    }\n\n    @Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        // Skip when download already marked as finished; this download was\n        // probably started again while racing with UpdateThread.\n        if (mInfo.queryDownloadStatus() == Downloads.Impl.STATUS_SUCCESS) {\n            logDebug(\"Already finished; skipping\");\n            return;\n        }\n\n        try {\n            // while performing download, register for rules updates\n            mNetworkPolicy.registerListener(mPolicyListener);\n\n            logDebug(\"Starting\");\n\n            mInfoDelta.mStatus = STATUS_RUNNING;\n            mInfoDelta.writeToDatabase();\n\n            // If we're showing a foreground notification for the requesting\n            // app, the download isn't affected by the blocked status of the\n            // requesting app\n            mIgnoreBlocked = mInfo.isVisible();\n\n            // Use the caller's default network to make this connection, since\n            // they might be subject to restrictions that we shouldn't let them\n            // circumvent\n            mNetwork = mSystemFacade.getActiveNetwork(mInfo.mUid, mIgnoreBlocked);\n            if (mNetwork == null) {\n                throw new StopRequestException(STATUS_WAITING_FOR_NETWORK,\n                        \"No network associated with requesting UID\");\n            }\n\n            // Remember which network this download started on; used to\n            // determine if errors were due to network changes.\n            final NetworkInfo info = mSystemFacade.getNetworkInfo(mNetwork, mInfo.mUid,\n                    mIgnoreBlocked);\n            if (info != null) {\n                mNetworkType = info.getType();\n            }\n\n            // Network traffic on this thread should be counted against the\n            // requesting UID, and is tagged with well-known value.\n            TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_DOWNLOAD);\n            TrafficStats.setThreadStatsUid(mInfo.mUid);\n\n            executeDownload();\n\n            mInfoDelta.mStatus = STATUS_SUCCESS;\n            TrafficStats.incrementOperationCount(1);\n\n            // If we just finished a chunked file, record total size\n            if (mInfoDelta.mTotalBytes == -1) {\n                mInfoDelta.mTotalBytes = mInfoDelta.mCurrentBytes;\n            }\n\n        } catch (StopRequestException e) {\n            mInfoDelta.mStatus = e.getFinalStatus();\n            mInfoDelta.mErrorMsg = e.getMessage();\n\n            logWarning(\"Stop requested with status \"\n                    + Downloads.Impl.statusToString(mInfoDelta.mStatus) + \": \"\n                    + mInfoDelta.mErrorMsg);\n\n            // Nobody below our level should request retries, since we handle\n            // failure counts at this level.\n            if (mInfoDelta.mStatus == STATUS_WAITING_TO_RETRY) {\n                throw new IllegalStateException(\"Execution should always throw final error codes\");\n            }\n\n            // Some errors should be retryable, unless we fail too many times.\n            if (isStatusRetryable(mInfoDelta.mStatus)) {\n                if (mMadeProgress) {\n                    mInfoDelta.mNumFailed = 1;\n                } else {\n                    mInfoDelta.mNumFailed += 1;\n                }\n\n                if (mInfoDelta.mNumFailed < Constants.MAX_RETRIES) {\n                    final NetworkInfo info = mSystemFacade.getNetworkInfo(mNetwork, mInfo.mUid,\n                            mIgnoreBlocked);\n                    if (info != null && info.getType() == mNetworkType && info.isConnected()) {\n                        // Underlying network is still intact, use normal backoff\n                        mInfoDelta.mStatus = STATUS_WAITING_TO_RETRY;\n                    } else {\n                        // Network changed, retry on any next available\n                        mInfoDelta.mStatus = STATUS_WAITING_FOR_NETWORK;\n                    }\n\n                    if ((mInfoDelta.mETag == null && mMadeProgress)\n                            || DownloadDrmHelper.isDrmConvertNeeded(mInfoDelta.mMimeType)) {\n                        // However, if we wrote data and have no ETag to verify\n                        // contents against later, we can't actually resume.\n                        mInfoDelta.mStatus = STATUS_CANNOT_RESUME;\n                    }\n                }\n            }\n\n            // If we're waiting for a network that must be unmetered, our status\n            // is actually queued so we show relevant notifications\n            if (mInfoDelta.mStatus == STATUS_WAITING_FOR_NETWORK\n                    && !mInfo.isMeteredAllowed(mInfoDelta.mTotalBytes)) {\n                mInfoDelta.mStatus = STATUS_QUEUED_FOR_WIFI;\n            }\n\n        } catch (Throwable t) {\n            mInfoDelta.mStatus = STATUS_UNKNOWN_ERROR;\n            mInfoDelta.mErrorMsg = t.toString();\n\n            logError(\"Failed: \" + mInfoDelta.mErrorMsg, t);\n\n        } finally {\n            logDebug(\"Finished with status \" + Downloads.Impl.statusToString(mInfoDelta.mStatus));\n\n            mNotifier.notifyDownloadSpeed(mId, 0);\n\n            finalizeDestination();\n\n            mInfoDelta.writeToDatabase();\n\n            TrafficStats.clearThreadStatsTag();\n            TrafficStats.clearThreadStatsUid();\n\n            mNetworkPolicy.unregisterListener(mPolicyListener);\n        }\n\n        boolean needsReschedule = false;\n        if (Downloads.Impl.isStatusCompleted(mInfoDelta.mStatus)) {\n            if (mInfo.shouldScanFile(mInfoDelta.mStatus)) {\n                DownloadScanner.requestScanBlocking(mContext, mInfo.mId, mInfoDelta.mFileName,\n                        mInfoDelta.mMimeType);\n            }\n        } else if (mInfoDelta.mStatus == STATUS_WAITING_TO_RETRY\n                || mInfoDelta.mStatus == STATUS_WAITING_FOR_NETWORK\n                || mInfoDelta.mStatus == STATUS_QUEUED_FOR_WIFI) {\n            needsReschedule = true;\n        }\n\n        mJobService.jobFinishedInternal(mParams, needsReschedule);\n    }\n\n    public void requestShutdown() {\n        mShutdownRequested = true;\n    }\n\n    /**\n     * Fully execute a single download request. Setup and send the request,\n     * handle the response, and transfer the data to the destination file.\n     */\n    private void executeDownload() throws StopRequestException {\n        final boolean resuming = mInfoDelta.mCurrentBytes != 0;\n\n        URL url;\n        try {\n            // TODO: migrate URL sanity checking into client side of API\n            url = new URL(mInfoDelta.mUri);\n        } catch (MalformedURLException e) {\n            throw new StopRequestException(STATUS_BAD_REQUEST, e);\n        }\n\n        boolean cleartextTrafficPermitted = mSystemFacade.isCleartextTrafficPermitted(mInfo.mUid);\n        SSLContext appContext;\n        try {\n            appContext = mSystemFacade.getSSLContextForPackage(mContext, mInfo.mPackage);\n        } catch (GeneralSecurityException e) {\n            // This should never happen.\n            throw new StopRequestException(STATUS_UNKNOWN_ERROR, \"Unable to create SSLContext.\");\n        }\n        int redirectionCount = 0;\n        while (redirectionCount++ < Constants.MAX_REDIRECTS) {\n            // Enforce the cleartext traffic opt-out for the UID. This cannot be enforced earlier\n            // because of HTTP redirects which can change the protocol between HTTP and HTTPS.\n            if ((!cleartextTrafficPermitted) && (\"http\".equalsIgnoreCase(url.getProtocol()))) {\n                throw new StopRequestException(STATUS_BAD_REQUEST,\n                        \"Cleartext traffic not permitted for UID \" + mInfo.mUid + \": \"\n                        + Uri.parse(url.toString()).toSafeString());\n            }\n\n            // Open connection and follow any redirects until we have a useful\n            // response with body.\n            HttpURLConnection conn = null;\n            try {\n                // Check that the caller is allowed to make network connections. If so, make one on\n                // their behalf to open the url.\n                checkConnectivity();\n                conn = (HttpURLConnection) mNetwork.openConnection(url);\n                conn.setInstanceFollowRedirects(false);\n                conn.setConnectTimeout(DEFAULT_TIMEOUT);\n                conn.setReadTimeout(DEFAULT_TIMEOUT);\n                // If this is going over HTTPS configure the trust to be the same as the calling\n                // package.\n                if (conn instanceof HttpsURLConnection) {\n                    ((HttpsURLConnection)conn).setSSLSocketFactory(appContext.getSocketFactory());\n                }\n\n                addRequestHeaders(conn, resuming);\n\n                final int responseCode = conn.getResponseCode();\n                switch (responseCode) {\n                    case HTTP_OK:\n                        if (resuming) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected partial, but received OK\");\n                        }\n                        parseOkHeaders(conn);\n                        transferData(conn);\n                        return;\n\n                    case HTTP_PARTIAL:\n                        if (!resuming) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected OK, but received partial\");\n                        }\n                        transferData(conn);\n                        return;\n\n                    case HTTP_MOVED_PERM:\n                    case HTTP_MOVED_TEMP:\n                    case HTTP_SEE_OTHER:\n                    case HTTP_TEMP_REDIRECT:\n                        final String location = conn.getHeaderField(\"Location\");\n                        url = new URL(url, location);\n                        if (responseCode == HTTP_MOVED_PERM) {\n                            // Push updated URL back to database\n                            mInfoDelta.mUri = url.toString();\n                        }\n                        continue;\n\n                    case HTTP_PRECON_FAILED:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Precondition failed\");\n\n                    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Requested range not satisfiable\");\n\n                    case HTTP_UNAVAILABLE:\n                        parseUnavailableHeaders(conn);\n                        throw new StopRequestException(\n                                HTTP_UNAVAILABLE, conn.getResponseMessage());\n\n                    case HTTP_INTERNAL_ERROR:\n                        throw new StopRequestException(\n                                HTTP_INTERNAL_ERROR, conn.getResponseMessage());\n\n                    default:\n                        StopRequestException.throwUnhandledHttpError(\n                                responseCode, conn.getResponseMessage());\n                }\n\n            } catch (IOException e) {\n                if (e instanceof ProtocolException\n                        && e.getMessage().startsWith(\"Unexpected status line\")) {\n                    throw new StopRequestException(STATUS_UNHANDLED_HTTP_CODE, e);\n                } else {\n                    // Trouble with low-level sockets\n                    throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n                }\n\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        }\n\n        throw new StopRequestException(STATUS_TOO_MANY_REDIRECTS, \"Too many redirects\");\n    }\n\n    /**\n     * Transfer data from the given connection to the destination file.\n     */\n    private void transferData(HttpURLConnection conn) throws StopRequestException {\n\n        // To detect when we're really finished, we either need a length, closed\n        // connection, or chunked encoding.\n        final boolean hasLength = mInfoDelta.mTotalBytes != -1;\n        final boolean isConnectionClose = \"close\".equalsIgnoreCase(\n                conn.getHeaderField(\"Connection\"));\n        final boolean isEncodingChunked = \"chunked\".equalsIgnoreCase(\n                conn.getHeaderField(\"Transfer-Encoding\"));\n\n        final boolean finishKnown = hasLength || isConnectionClose || isEncodingChunked;\n        if (!finishKnown) {\n            throw new StopRequestException(\n                    STATUS_CANNOT_RESUME, \"can't know size of download, giving up\");\n        }\n\n        DrmManagerClient drmClient = null;\n        ParcelFileDescriptor outPfd = null;\n        FileDescriptor outFd = null;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            try {\n                in = conn.getInputStream();\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n            }\n\n            try {\n                outPfd = mContext.getContentResolver()\n                        .openFileDescriptor(mInfo.getAllDownloadsUri(), \"rw\");\n                outFd = outPfd.getFileDescriptor();\n\n                if (DownloadDrmHelper.isDrmConvertNeeded(mInfoDelta.mMimeType)) {\n                    drmClient = new DrmManagerClient(mContext);\n                    out = new DrmOutputStream(drmClient, outPfd, mInfoDelta.mMimeType);\n                } else {\n                    out = new ParcelFileDescriptor.AutoCloseOutputStream(outPfd);\n                }\n\n                // Move into place to begin writing\n                Os.lseek(outFd, mInfoDelta.mCurrentBytes, OsConstants.SEEK_SET);\n            } catch (ErrnoException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n            try {\n                // Pre-flight disk space requirements, when known\n                if (mInfoDelta.mTotalBytes > 0 && mStorage.isAllocationSupported(outFd)) {\n                    mStorage.allocateBytes(outFd, mInfoDelta.mTotalBytes);\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_INSUFFICIENT_SPACE_ERROR, e);\n            }\n\n            // Start streaming data, periodically watch for pause/cancel\n            // commands and checking disk space as needed.\n            transferData(in, out, outFd);\n\n            try {\n                if (out instanceof DrmOutputStream) {\n                    ((DrmOutputStream) out).finish();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n        } finally {\n            if (drmClient != null) {\n                drmClient.close();\n            }\n\n            IoUtils.closeQuietly(in);\n\n            try {\n                if (out != null) out.flush();\n                if (outFd != null) outFd.sync();\n            } catch (IOException e) {\n            } finally {\n                IoUtils.closeQuietly(out);\n            }\n        }\n    }\n\n    /**\n     * Transfer as much data as possible from the HTTP response to the\n     * destination file.\n     */\n    private void transferData(InputStream in, OutputStream out, FileDescriptor outFd)\n            throws StopRequestException {\n        final byte buffer[] = new byte[Constants.BUFFER_SIZE];\n        while (true) {\n            if (mPolicyDirty) checkConnectivity();\n\n            if (mShutdownRequested) {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR,\n                        \"Local halt requested; job probably timed out\");\n            }\n\n            int len = -1;\n            try {\n                len = in.read(buffer);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        STATUS_HTTP_DATA_ERROR, \"Failed reading response: \" + e, e);\n            }\n\n            if (len == -1) {\n                break;\n            }\n\n            try {\n                out.write(buffer, 0, len);\n\n                mMadeProgress = true;\n                mInfoDelta.mCurrentBytes += len;\n\n                updateProgress(outFd);\n\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n        }\n\n        // Finished without error; verify length if known\n        if (mInfoDelta.mTotalBytes != -1 && mInfoDelta.mCurrentBytes != mInfoDelta.mTotalBytes) {\n            throw new StopRequestException(STATUS_HTTP_DATA_ERROR, \"Content length mismatch; found \"\n                    + mInfoDelta.mCurrentBytes + \" instead of \" + mInfoDelta.mTotalBytes);\n        }\n    }\n\n    /**\n     * Called just before the thread finishes, regardless of status, to take any\n     * necessary action on the downloaded file.\n     */\n    private void finalizeDestination() {\n        if (Downloads.Impl.isStatusError(mInfoDelta.mStatus)) {\n            // When error, free up any disk space\n            try {\n                final ParcelFileDescriptor target = mContext.getContentResolver()\n                        .openFileDescriptor(mInfo.getAllDownloadsUri(), \"rw\");\n                try {\n                    Os.ftruncate(target.getFileDescriptor(), 0);\n                } catch (ErrnoException ignored) {\n                } finally {\n                    IoUtils.closeQuietly(target);\n                }\n            } catch (FileNotFoundException ignored) {\n            }\n\n            // Delete if local file\n            if (mInfoDelta.mFileName != null) {\n                new File(mInfoDelta.mFileName).delete();\n                mInfoDelta.mFileName = null;\n            }\n\n        } else if (Downloads.Impl.isStatusSuccess(mInfoDelta.mStatus)) {\n            // When success, open access if local file\n            if (mInfoDelta.mFileName != null) {\n                if (mInfo.mDestination != Downloads.Impl.DESTINATION_FILE_URI) {\n                    try {\n                        // Move into final resting place, if needed\n                        final File before = new File(mInfoDelta.mFileName);\n                        final File beforeDir = Helpers.getRunningDestinationDirectory(\n                                mContext, mInfo.mDestination);\n                        final File afterDir = Helpers.getSuccessDestinationDirectory(\n                                mContext, mInfo.mDestination);\n                        if (!beforeDir.equals(afterDir)\n                                && before.getParentFile().equals(beforeDir)) {\n                            final File after = new File(afterDir, before.getName());\n                            if (before.renameTo(after)) {\n                                mInfoDelta.mFileName = after.getAbsolutePath();\n                            }\n                        }\n                    } catch (IOException ignored) {\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if current connectivity is valid for this request.\n     */\n    private void checkConnectivity() throws StopRequestException {\n        // checking connectivity will apply current policy\n        mPolicyDirty = false;\n\n        final NetworkInfo info = mSystemFacade.getNetworkInfo(mNetwork, mInfo.mUid,\n                mIgnoreBlocked);\n        if (info == null || !info.isConnected()) {\n            throw new StopRequestException(STATUS_WAITING_FOR_NETWORK, \"Network is disconnected\");\n        }\n        if (info.isRoaming() && !mInfo.isRoamingAllowed()) {\n            throw new StopRequestException(STATUS_WAITING_FOR_NETWORK, \"Network is roaming\");\n        }\n        if (mSystemFacade.isNetworkMetered(mNetwork)\n                && !mInfo.isMeteredAllowed(mInfoDelta.mTotalBytes)) {\n            throw new StopRequestException(STATUS_WAITING_FOR_NETWORK, \"Network is metered\");\n        }\n    }\n\n    /**\n     * Report download progress through the database if necessary.\n     */\n    private void updateProgress(FileDescriptor outFd) throws IOException, StopRequestException {\n        final long now = SystemClock.elapsedRealtime();\n        final long currentBytes = mInfoDelta.mCurrentBytes;\n\n        final long sampleDelta = now - mSpeedSampleStart;\n        if (sampleDelta > 500) {\n            final long sampleSpeed = ((currentBytes - mSpeedSampleBytes) * 1000)\n                    / sampleDelta;\n\n            if (mSpeed == 0) {\n                mSpeed = sampleSpeed;\n            } else {\n                mSpeed = ((mSpeed * 3) + sampleSpeed) / 4;\n            }\n\n            // Only notify once we have a full sample window\n            if (mSpeedSampleStart != 0) {\n                mNotifier.notifyDownloadSpeed(mId, mSpeed);\n            }\n\n            mSpeedSampleStart = now;\n            mSpeedSampleBytes = currentBytes;\n        }\n\n        final long bytesDelta = currentBytes - mLastUpdateBytes;\n        final long timeDelta = now - mLastUpdateTime;\n        if (bytesDelta > Constants.MIN_PROGRESS_STEP && timeDelta > Constants.MIN_PROGRESS_TIME) {\n            // fsync() to ensure that current progress has been flushed to disk,\n            // so we can always resume based on latest database information.\n            outFd.sync();\n\n            mInfoDelta.writeToDatabaseOrThrow();\n\n            mLastUpdateBytes = currentBytes;\n            mLastUpdateTime = now;\n        }\n    }\n\n    /**\n     * Process response headers from first server response. This derives its\n     * filename, size, and ETag.\n     */\n    private void parseOkHeaders(HttpURLConnection conn) throws StopRequestException {\n        if (mInfoDelta.mFileName == null) {\n            final String contentDisposition = conn.getHeaderField(\"Content-Disposition\");\n            final String contentLocation = conn.getHeaderField(\"Content-Location\");\n\n            try {\n                mInfoDelta.mFileName = Helpers.generateSaveFile(mContext, mInfoDelta.mUri,\n                        mInfo.mHint, contentDisposition, contentLocation, mInfoDelta.mMimeType,\n                        mInfo.mDestination);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_FILE_ERROR, \"Failed to generate filename: \" + e);\n            }\n        }\n\n        if (mInfoDelta.mMimeType == null) {\n            mInfoDelta.mMimeType = Intent.normalizeMimeType(conn.getContentType());\n        }\n\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        if (transferEncoding == null) {\n            mInfoDelta.mTotalBytes = getHeaderFieldLong(conn, \"Content-Length\", -1);\n        } else {\n            mInfoDelta.mTotalBytes = -1;\n        }\n\n        mInfoDelta.mETag = conn.getHeaderField(\"ETag\");\n\n        mInfoDelta.writeToDatabaseOrThrow();\n\n        // Check connectivity again now that we know the total size\n        checkConnectivity();\n    }\n\n    private void parseUnavailableHeaders(HttpURLConnection conn) {\n        long retryAfter = conn.getHeaderFieldInt(\"Retry-After\", -1);\n        retryAfter = MathUtils.constrain(retryAfter, Constants.MIN_RETRY_AFTER,\n                Constants.MAX_RETRY_AFTER);\n        mInfoDelta.mRetryAfter = (int) (retryAfter * SECOND_IN_MILLIS);\n    }\n\n    /**\n     * Add custom headers for this download to the HTTP request.\n     */\n    private void addRequestHeaders(HttpURLConnection conn, boolean resuming) {\n        for (Pair<String, String> header : mInfo.getHeaders()) {\n            conn.addRequestProperty(header.first, header.second);\n        }\n\n        // Only splice in user agent when not already defined\n        if (conn.getRequestProperty(\"User-Agent\") == null) {\n            conn.addRequestProperty(\"User-Agent\", mInfo.getUserAgent());\n        }\n\n        // Defeat transparent gzip compression, since it doesn't allow us to\n        // easily resume partial downloads.\n        conn.setRequestProperty(\"Accept-Encoding\", \"identity\");\n\n        // Defeat connection reuse, since otherwise servers may continue\n        // streaming large downloads after cancelled.\n        conn.setRequestProperty(\"Connection\", \"close\");\n\n        if (resuming) {\n            if (mInfoDelta.mETag != null) {\n                conn.addRequestProperty(\"If-Match\", mInfoDelta.mETag);\n            }\n            conn.addRequestProperty(\"Range\", \"bytes=\" + mInfoDelta.mCurrentBytes + \"-\");\n        }\n    }\n\n    private void logDebug(String msg) {\n        Log.d(TAG, \"[\" + mId + \"] \" + msg);\n    }\n\n    private void logWarning(String msg) {\n        Log.w(TAG, \"[\" + mId + \"] \" + msg);\n    }\n\n    private void logError(String msg, Throwable t) {\n        Log.e(TAG, \"[\" + mId + \"] \" + msg, t);\n    }\n\n    private INetworkPolicyListener mPolicyListener = new INetworkPolicyListener.Stub() {\n        @Override\n        public void onUidRulesChanged(int uid, int uidRules) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n\n        @Override\n        public void onMeteredIfacesChanged(String[] meteredIfaces) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onRestrictBackgroundChanged(boolean restrictBackground) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onUidPoliciesChanged(int uid, int uidPolicies) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n    };\n\n    private static long getHeaderFieldLong(URLConnection conn, String field, long defaultValue) {\n        try {\n            return Long.parseLong(conn.getHeaderField(field));\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Return if given status is eligible to be treated as\n     * {@link android.provider.Downloads.Impl#STATUS_WAITING_TO_RETRY}.\n     */\n    public static boolean isStatusRetryable(int status) {\n        switch (status) {\n            case STATUS_HTTP_DATA_ERROR:\n            case HTTP_UNAVAILABLE:\n            case HTTP_INTERNAL_ERROR:\n            case STATUS_FILE_ERROR:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","lineNo":387}
{"Smelly Sample":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.COLUMN_LOCAL_FILENAME;\nimport static android.app.DownloadManager.COLUMN_MEDIA_TYPE;\nimport static android.app.DownloadManager.COLUMN_URI;\nimport static android.provider.Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.app.DownloadManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads.Impl.RequestHeaders;\nimport android.util.Log;\n\nimport java.io.File;\n\npublic class OpenHelper {\n    /**\n     * Build and start an {@link Intent} to view the download with given ID,\n     * handling subtleties around installing packages.\n     */\n    public static boolean startViewIntent(Context context, long id, int intentFlags) {\n        final Intent intent = OpenHelper.buildViewIntent(context, id);\n        if (intent == null) {\n            Log.w(TAG, \"No intent built for \" + id);\n            return false;\n        }\n\n        intent.addFlags(intentFlags);\n        try {\n            context.startActivity(intent);\n            return true;\n        } catch (ActivityNotFoundException e) {\n            Log.w(TAG, \"Failed to start \" + intent + \": \" + e);\n            return false;\n        }\n    }\n\n    /**\n     * Build an {@link Intent} to view the download with given ID, handling\n     * subtleties around installing packages.\n     */\n    private static Intent buildViewIntent(Context context, long id) {\n        final DownloadManager downManager = (DownloadManager) context.getSystemService(\n                Context.DOWNLOAD_SERVICE);\n        downManager.setAccessAllDownloads(true);\n        downManager.setAccessFilename(true);\n\n        final Cursor cursor = downManager.query(new DownloadManager.Query().setFilterById(id));\n        try {\n            if (!cursor.moveToFirst()) {\n                return null;\n            }\n\n            final File file = getCursorFile(cursor, COLUMN_LOCAL_FILENAME);\n            String mimeType = getCursorString(cursor, COLUMN_MEDIA_TYPE);\n            mimeType = DownloadDrmHelper.getOriginalMimeType(context, file, mimeType);\n\n            final Uri documentUri = DocumentsContract.buildDocumentUri(\n                    Constants.STORAGE_AUTHORITY, String.valueOf(id));\n\n            final Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setDataAndType(documentUri, mimeType);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n\n            if (\"application/vnd.android.package-archive\".equals(mimeType)) {\n                // Also splice in details about where it came from\n                final Uri remoteUri = getCursorUri(cursor, COLUMN_URI);\n                intent.putExtra(Intent.EXTRA_ORIGINATING_URI, remoteUri);\n                intent.putExtra(Intent.EXTRA_REFERRER, getRefererUri(context, id));\n                intent.putExtra(Intent.EXTRA_ORIGINATING_UID, getOriginatingUid(context, id));\n            }\n\n            return intent;\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private static Uri getRefererUri(Context context, long id) {\n        final Uri headersUri = Uri.withAppendedPath(\n                ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id),\n                RequestHeaders.URI_SEGMENT);\n        final Cursor headers = context.getContentResolver()\n                .query(headersUri, null, null, null, null);\n        try {\n            while (headers.moveToNext()) {\n                final String header = getCursorString(headers, RequestHeaders.COLUMN_HEADER);\n                if (\"Referer\".equalsIgnoreCase(header)) {\n                    return getCursorUri(headers, RequestHeaders.COLUMN_VALUE);\n                }\n            }\n        } finally {\n            headers.close();\n        }\n        return null;\n    }\n\n    private static int getOriginatingUid(Context context, long id) {\n        final Uri uri = ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, new String[]{Constants.UID},\n                null, null, null);\n        if (cursor != null) {\n            try {\n                if (cursor.moveToFirst()) {\n                    return cursor.getInt(cursor.getColumnIndexOrThrow(Constants.UID));\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        return PackageInstaller.SessionParams.UID_UNKNOWN;\n    }\n\n    private static String getCursorString(Cursor cursor, String column) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(column));\n    }\n\n    private static Uri getCursorUri(Cursor cursor, String column) {\n        return Uri.parse(getCursorString(cursor, column));\n    }\n\n    private static File getCursorFile(Cursor cursor, String column) {\n        return new File(cursor.getString(cursor.getColumnIndexOrThrow(column)));\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.COLUMN_LOCAL_FILENAME;\nimport static android.app.DownloadManager.COLUMN_MEDIA_TYPE;\nimport static android.app.DownloadManager.COLUMN_URI;\nimport static android.provider.Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.app.DownloadManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Process;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads.Impl.RequestHeaders;\nimport android.util.Log;\n\nimport java.io.File;\n\npublic class OpenHelper {\n    /**\n     * Build and start an {@link Intent} to view the download with given ID,\n     * handling subtleties around installing packages.\n     */\n    public static boolean startViewIntent(Context context, long id, int intentFlags) {\n        final Intent intent = OpenHelper.buildViewIntent(context, id);\n        if (intent == null) {\n            Log.w(TAG, \"No intent built for \" + id);\n            return false;\n        }\n\n        intent.addFlags(intentFlags);\n        try {\n            context.startActivity(intent);\n            return true;\n        } catch (ActivityNotFoundException e) {\n            Log.w(TAG, \"Failed to start \" + intent + \": \" + e);\n            return false;\n        }\n    }\n\n    /**\n     * Build an {@link Intent} to view the download with given ID, handling\n     * subtleties around installing packages.\n     */\n    private static Intent buildViewIntent(Context context, long id) {\n        final DownloadManager downManager = (DownloadManager) context.getSystemService(\n                Context.DOWNLOAD_SERVICE);\n        downManager.setAccessAllDownloads(true);\n        downManager.setAccessFilename(true);\n\n        final Cursor cursor = downManager.query(new DownloadManager.Query().setFilterById(id));\n        try {\n            if (!cursor.moveToFirst()) {\n                return null;\n            }\n\n            final File file = getCursorFile(cursor, COLUMN_LOCAL_FILENAME);\n            String mimeType = getCursorString(cursor, COLUMN_MEDIA_TYPE);\n            mimeType = DownloadDrmHelper.getOriginalMimeType(context, file, mimeType);\n\n            final Uri documentUri = DocumentsContract.buildDocumentUri(\n                    Constants.STORAGE_AUTHORITY, String.valueOf(id));\n\n            final Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setDataAndType(documentUri, mimeType);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n\n            if (\"application/vnd.android.package-archive\".equals(mimeType)) {\n                // Also splice in details about where it came from\n                final Uri remoteUri = getCursorUri(cursor, COLUMN_URI);\n                intent.putExtra(Intent.EXTRA_ORIGINATING_URI, remoteUri);\n                intent.putExtra(Intent.EXTRA_REFERRER, getRefererUri(context, id));\n                intent.putExtra(Intent.EXTRA_ORIGINATING_UID, getOriginatingUid(context, id));\n            }\n\n            return intent;\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private static Uri getRefererUri(Context context, long id) {\n        final Uri headersUri = Uri.withAppendedPath(\n                ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id),\n                RequestHeaders.URI_SEGMENT);\n        final Cursor headers = context.getContentResolver()\n                .query(headersUri, null, null, null, null);\n        try {\n            while (headers.moveToNext()) {\n                final String header = getCursorString(headers, RequestHeaders.COLUMN_HEADER);\n                if (\"Referer\".equalsIgnoreCase(header)) {\n                    return getCursorUri(headers, RequestHeaders.COLUMN_VALUE);\n                }\n            }\n        } finally {\n            headers.close();\n        }\n        return null;\n    }\n\n    private static int getOriginatingUid(Context context, long id) {\n        final Uri uri = ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, new String[]{Constants.UID},\n                null, null, null);\n        if (cursor != null) {\n            try {\n                if (cursor.moveToFirst()) {\n                    final int uid = cursor.getInt(cursor.getColumnIndexOrThrow(Constants.UID));\n                    if (uid != Process.myUid()) {\n                        return uid;\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        return PackageInstaller.SessionParams.UID_UNKNOWN;\n    }\n\n    private static String getCursorString(Cursor cursor, String column) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(column));\n    }\n\n    private static Uri getCursorUri(Cursor cursor, String column) {\n        return Uri.parse(getCursorString(cursor, column));\n    }\n\n    private static File getCursorFile(Cursor cursor, String column) {\n        return new File(cursor.getString(cursor.getColumnIndexOrThrow(column)));\n    }\n}\n","lineNo":131}
{"Smelly Sample":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.COLUMN_LOCAL_FILENAME;\nimport static android.app.DownloadManager.COLUMN_MEDIA_TYPE;\nimport static android.app.DownloadManager.COLUMN_URI;\nimport static android.provider.Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.app.DownloadManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads.Impl.RequestHeaders;\nimport android.util.Log;\n\nimport java.io.File;\n\npublic class OpenHelper {\n    /**\n     * Build and start an {@link Intent} to view the download with given ID,\n     * handling subtleties around installing packages.\n     */\n    public static boolean startViewIntent(Context context, long id, int intentFlags) {\n        final Intent intent = OpenHelper.buildViewIntent(context, id);\n        if (intent == null) {\n            Log.w(TAG, \"No intent built for \" + id);\n            return false;\n        }\n\n        intent.addFlags(intentFlags);\n        try {\n            context.startActivity(intent);\n            return true;\n        } catch (ActivityNotFoundException e) {\n            Log.w(TAG, \"Failed to start \" + intent + \": \" + e);\n            return false;\n        }\n    }\n\n    /**\n     * Build an {@link Intent} to view the download with given ID, handling\n     * subtleties around installing packages.\n     */\n    private static Intent buildViewIntent(Context context, long id) {\n        final DownloadManager downManager = (DownloadManager) context.getSystemService(\n                Context.DOWNLOAD_SERVICE);\n        downManager.setAccessAllDownloads(true);\n        downManager.setAccessFilename(true);\n\n        final Cursor cursor = downManager.query(new DownloadManager.Query().setFilterById(id));\n        try {\n            if (!cursor.moveToFirst()) {\n                return null;\n            }\n\n            final File file = getCursorFile(cursor, COLUMN_LOCAL_FILENAME);\n            String mimeType = getCursorString(cursor, COLUMN_MEDIA_TYPE);\n            mimeType = DownloadDrmHelper.getOriginalMimeType(context, file, mimeType);\n\n            final Uri documentUri = DocumentsContract.buildDocumentUri(\n                    Constants.STORAGE_AUTHORITY, String.valueOf(id));\n\n            final Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setDataAndType(documentUri, mimeType);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n\n            if (\"application/vnd.android.package-archive\".equals(mimeType)) {\n                // Also splice in details about where it came from\n                final Uri remoteUri = getCursorUri(cursor, COLUMN_URI);\n                intent.putExtra(Intent.EXTRA_ORIGINATING_URI, remoteUri);\n                intent.putExtra(Intent.EXTRA_REFERRER, getRefererUri(context, id));\n                intent.putExtra(Intent.EXTRA_ORIGINATING_UID, getOriginatingUid(context, id));\n            }\n\n            return intent;\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private static Uri getRefererUri(Context context, long id) {\n        final Uri headersUri = Uri.withAppendedPath(\n                ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id),\n                RequestHeaders.URI_SEGMENT);\n        final Cursor headers = context.getContentResolver()\n                .query(headersUri, null, null, null, null);\n        try {\n            while (headers.moveToNext()) {\n                final String header = getCursorString(headers, RequestHeaders.COLUMN_HEADER);\n                if (\"Referer\".equalsIgnoreCase(header)) {\n                    return getCursorUri(headers, RequestHeaders.COLUMN_VALUE);\n                }\n            }\n        } finally {\n            headers.close();\n        }\n        return null;\n    }\n\n    private static int getOriginatingUid(Context context, long id) {\n        final Uri uri = ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, new String[]{Constants.UID},\n                null, null, null);\n        if (cursor != null) {\n            try {\n                if (cursor.moveToFirst()) {\n                    return cursor.getInt(cursor.getColumnIndexOrThrow(Constants.UID));\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        return PackageInstaller.SessionParams.UID_UNKNOWN;\n    }\n\n    private static String getCursorString(Cursor cursor, String column) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(column));\n    }\n\n    private static Uri getCursorUri(Cursor cursor, String column) {\n        return Uri.parse(getCursorString(cursor, column));\n    }\n\n    private static File getCursorFile(Cursor cursor, String column) {\n        return new File(cursor.getString(cursor.getColumnIndexOrThrow(column)));\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.COLUMN_LOCAL_FILENAME;\nimport static android.app.DownloadManager.COLUMN_MEDIA_TYPE;\nimport static android.app.DownloadManager.COLUMN_URI;\nimport static android.provider.Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.app.DownloadManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.pm.PackageInstaller;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Process;\nimport android.provider.DocumentsContract;\nimport android.provider.Downloads.Impl.RequestHeaders;\nimport android.util.Log;\n\nimport java.io.File;\n\npublic class OpenHelper {\n    /**\n     * Build and start an {@link Intent} to view the download with given ID,\n     * handling subtleties around installing packages.\n     */\n    public static boolean startViewIntent(Context context, long id, int intentFlags) {\n        final Intent intent = OpenHelper.buildViewIntent(context, id);\n        if (intent == null) {\n            Log.w(TAG, \"No intent built for \" + id);\n            return false;\n        }\n\n        intent.addFlags(intentFlags);\n        try {\n            context.startActivity(intent);\n            return true;\n        } catch (ActivityNotFoundException e) {\n            Log.w(TAG, \"Failed to start \" + intent + \": \" + e);\n            return false;\n        }\n    }\n\n    /**\n     * Build an {@link Intent} to view the download with given ID, handling\n     * subtleties around installing packages.\n     */\n    private static Intent buildViewIntent(Context context, long id) {\n        final DownloadManager downManager = (DownloadManager) context.getSystemService(\n                Context.DOWNLOAD_SERVICE);\n        downManager.setAccessAllDownloads(true);\n        downManager.setAccessFilename(true);\n\n        final Cursor cursor = downManager.query(new DownloadManager.Query().setFilterById(id));\n        try {\n            if (!cursor.moveToFirst()) {\n                return null;\n            }\n\n            final File file = getCursorFile(cursor, COLUMN_LOCAL_FILENAME);\n            String mimeType = getCursorString(cursor, COLUMN_MEDIA_TYPE);\n            mimeType = DownloadDrmHelper.getOriginalMimeType(context, file, mimeType);\n\n            final Uri documentUri = DocumentsContract.buildDocumentUri(\n                    Constants.STORAGE_AUTHORITY, String.valueOf(id));\n\n            final Intent intent = new Intent(Intent.ACTION_VIEW);\n            intent.setDataAndType(documentUri, mimeType);\n            intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION\n                    | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n\n            if (\"application/vnd.android.package-archive\".equals(mimeType)) {\n                // Also splice in details about where it came from\n                final Uri remoteUri = getCursorUri(cursor, COLUMN_URI);\n                intent.putExtra(Intent.EXTRA_ORIGINATING_URI, remoteUri);\n                intent.putExtra(Intent.EXTRA_REFERRER, getRefererUri(context, id));\n                intent.putExtra(Intent.EXTRA_ORIGINATING_UID, getOriginatingUid(context, id));\n            }\n\n            return intent;\n        } finally {\n            cursor.close();\n        }\n    }\n\n    private static Uri getRefererUri(Context context, long id) {\n        final Uri headersUri = Uri.withAppendedPath(\n                ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id),\n                RequestHeaders.URI_SEGMENT);\n        final Cursor headers = context.getContentResolver()\n                .query(headersUri, null, null, null, null);\n        try {\n            while (headers.moveToNext()) {\n                final String header = getCursorString(headers, RequestHeaders.COLUMN_HEADER);\n                if (\"Referer\".equalsIgnoreCase(header)) {\n                    return getCursorUri(headers, RequestHeaders.COLUMN_VALUE);\n                }\n            }\n        } finally {\n            headers.close();\n        }\n        return null;\n    }\n\n    private static int getOriginatingUid(Context context, long id) {\n        final Uri uri = ContentUris.withAppendedId(ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, new String[]{Constants.UID},\n                null, null, null);\n        if (cursor != null) {\n            try {\n                if (cursor.moveToFirst()) {\n                    final int uid = cursor.getInt(cursor.getColumnIndexOrThrow(Constants.UID));\n                    if (uid != Process.myUid()) {\n                        return uid;\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        return PackageInstaller.SessionParams.UID_UNKNOWN;\n    }\n\n    private static String getCursorString(Cursor cursor, String column) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(column));\n    }\n\n    private static Uri getCursorUri(Cursor cursor, String column) {\n        return Uri.parse(getCursorString(cursor, column));\n    }\n\n    private static File getCursorFile(Cursor cursor, String column) {\n        return new File(cursor.getString(cursor.getColumnIndexOrThrow(column)));\n    }\n}\n","lineNo":131}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads.ui;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.app.FragmentManager;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.android.providers.downloads.Constants;\nimport com.android.providers.downloads.OpenHelper;\n\nimport libcore.io.IoUtils;\n\n/**\n * Intercept all download clicks to provide special behavior. For example,\n * PackageInstaller really wants raw file paths.\n */\npublic class TrampolineActivity extends Activity {\n    private static final String TAG_PAUSED = \"paused\";\n    private static final String TAG_FAILED = \"failed\";\n\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_REASON = \"reason\";\n    private static final String KEY_SIZE = \"size\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final long id = ContentUris.parseId(getIntent().getData());\n\n        final DownloadManager dm = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n        dm.setAccessAllDownloads(true);\n\n        final int status;\n        final int reason;\n        final long size;\n\n        final Cursor cursor = dm.query(new Query().setFilterById(id));\n        try {\n            if (cursor.moveToFirst()) {\n                status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n                reason = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));\n                size = cursor.getLong(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n            } else {\n                Toast.makeText(this, R.string.dialog_file_missing_body, Toast.LENGTH_SHORT).show();\n                finish();\n                return;\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        Log.d(Constants.TAG, \"Found \" + id + \" with status \" + status + \", reason \" + reason);\n        switch (status) {\n            case DownloadManager.STATUS_PENDING:\n            case DownloadManager.STATUS_RUNNING:\n                sendRunningDownloadClickedBroadcast(id);\n                finish();\n                break;\n\n            case DownloadManager.STATUS_PAUSED:\n                if (reason == DownloadManager.PAUSED_QUEUED_FOR_WIFI) {\n                    PausedDialogFragment.show(getFragmentManager(), id, size);\n                } else {\n                    sendRunningDownloadClickedBroadcast(id);\n                    finish();\n                }\n                break;\n\n            case DownloadManager.STATUS_SUCCESSFUL:\n                if (!OpenHelper.startViewIntent(this, id, 0)) {\n                    Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                            .show();\n                }\n                finish();\n                break;\n\n            case DownloadManager.STATUS_FAILED:\n                FailedDialogFragment.show(getFragmentManager(), id, reason);\n                break;\n        }\n    }\n\n    private void sendRunningDownloadClickedBroadcast(long id) {\n        final Intent intent = new Intent(Constants.ACTION_LIST);\n        intent.setPackage(Constants.PROVIDER_PACKAGE_NAME);\n        intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, new long[] { id });\n        sendBroadcast(intent);\n    }\n\n    public static class PausedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, long size) {\n            final PausedDialogFragment dialog = new PausedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putLong(KEY_SIZE, size);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_PAUSED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final long size = getArguments().getLong(KEY_SIZE);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, android.R.style.Theme_DeviceDefault_Light_Dialog_Alert);\n            builder.setTitle(R.string.dialog_title_queued_body);\n            builder.setMessage(R.string.dialog_queued_body);\n\n            final Long maxSize = DownloadManager.getMaxBytesOverMobile(context);\n            if (maxSize != null && size > maxSize) {\n                // When we have a max size, we have no choice\n                builder.setPositiveButton(R.string.keep_queued_download, null);\n            } else {\n                // Give user the choice of starting now\n                builder.setPositiveButton(R.string.start_now_download,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                dm.forceDownload(id);\n                            }\n                        });\n            }\n\n            builder.setNegativeButton(\n                    R.string.remove_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n\n    public static class FailedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, int reason) {\n            final FailedDialogFragment dialog = new FailedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putInt(KEY_REASON, reason);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_FAILED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final int reason = getArguments().getInt(KEY_REASON);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, android.R.style.Theme_DeviceDefault_Light_Dialog_Alert);\n            builder.setTitle(R.string.dialog_title_not_available);\n\n            switch (reason) {\n                case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                    builder.setMessage(R.string.dialog_file_already_exists);\n                    break;\n                case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                    builder.setMessage(R.string.dialog_insufficient_space_on_external);\n                    break;\n                case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                    builder.setMessage(R.string.dialog_media_not_found);\n                    break;\n                case DownloadManager.ERROR_CANNOT_RESUME:\n                    builder.setMessage(R.string.dialog_cannot_resume);\n                    break;\n                default:\n                    builder.setMessage(R.string.dialog_failed_body);\n            }\n\n            builder.setNegativeButton(\n                    R.string.delete_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            builder.setPositiveButton(\n                    R.string.retry_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.restartDownload(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads.ui;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.app.FragmentManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.provider.DocumentsContract;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.android.providers.downloads.Constants;\nimport com.android.providers.downloads.OpenHelper;\nimport com.android.providers.downloads.RawDocumentsHelper;\n\nimport libcore.io.IoUtils;\n\n/**\n * Intercept all download clicks to provide special behavior. For example,\n * PackageInstaller really wants raw file paths.\n */\npublic class TrampolineActivity extends Activity {\n    private static final String TAG_PAUSED = \"paused\";\n    private static final String TAG_FAILED = \"failed\";\n\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_REASON = \"reason\";\n    private static final String KEY_SIZE = \"size\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Uri documentUri = getIntent().getData();\n        if (RawDocumentsHelper.isRawDocId(DocumentsContract.getDocumentId(documentUri))) {\n            if (!RawDocumentsHelper.startViewIntent(this, documentUri)) {\n                Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                        .show();\n            }\n            finish();\n            return;\n        }\n\n        final long id = ContentUris.parseId(documentUri);\n        final DownloadManager dm = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n        dm.setAccessAllDownloads(true);\n\n        final int status;\n        final int reason;\n        final long size;\n\n        final Cursor cursor = dm.query(new Query().setFilterById(id));\n        try {\n            if (cursor.moveToFirst()) {\n                status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n                reason = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));\n                size = cursor.getLong(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n            } else {\n                Toast.makeText(this, R.string.dialog_file_missing_body, Toast.LENGTH_SHORT).show();\n                finish();\n                return;\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        Log.d(Constants.TAG, \"Found \" + id + \" with status \" + status + \", reason \" + reason);\n        switch (status) {\n            case DownloadManager.STATUS_PENDING:\n            case DownloadManager.STATUS_RUNNING:\n                sendRunningDownloadClickedBroadcast(id);\n                finish();\n                break;\n\n            case DownloadManager.STATUS_PAUSED:\n                if (reason == DownloadManager.PAUSED_QUEUED_FOR_WIFI) {\n                    PausedDialogFragment.show(getFragmentManager(), id, size);\n                } else {\n                    sendRunningDownloadClickedBroadcast(id);\n                    finish();\n                }\n                break;\n\n            case DownloadManager.STATUS_SUCCESSFUL:\n                if (!OpenHelper.startViewIntent(this, id, 0)) {\n                    Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                            .show();\n                }\n                finish();\n                break;\n\n            case DownloadManager.STATUS_FAILED:\n                FailedDialogFragment.show(getFragmentManager(), id, reason);\n                break;\n        }\n    }\n\n    private void sendRunningDownloadClickedBroadcast(long id) {\n        final Intent intent = new Intent(Constants.ACTION_LIST);\n        intent.setPackage(Constants.PROVIDER_PACKAGE_NAME);\n        intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, new long[] { id });\n        sendBroadcast(intent);\n    }\n\n    public static class PausedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, long size) {\n            final PausedDialogFragment dialog = new PausedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putLong(KEY_SIZE, size);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_PAUSED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final long size = getArguments().getLong(KEY_SIZE);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, android.R.style.Theme_DeviceDefault_Light_Dialog_Alert);\n            builder.setTitle(R.string.dialog_title_queued_body);\n            builder.setMessage(R.string.dialog_queued_body);\n\n            final Long maxSize = DownloadManager.getMaxBytesOverMobile(context);\n            if (maxSize != null && size > maxSize) {\n                // When we have a max size, we have no choice\n                builder.setPositiveButton(R.string.keep_queued_download, null);\n            } else {\n                // Give user the choice of starting now\n                builder.setPositiveButton(R.string.start_now_download,\n                        new DialogInterface.OnClickListener() {\n                            @Override\n                            public void onClick(DialogInterface dialog, int which) {\n                                dm.forceDownload(id);\n                            }\n                        });\n            }\n\n            builder.setNegativeButton(\n                    R.string.remove_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n\n    public static class FailedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, int reason) {\n            final FailedDialogFragment dialog = new FailedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putInt(KEY_REASON, reason);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_FAILED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final int reason = getArguments().getInt(KEY_REASON);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, android.R.style.Theme_DeviceDefault_Light_Dialog_Alert);\n            builder.setTitle(R.string.dialog_title_not_available);\n\n            switch (reason) {\n                case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                    builder.setMessage(R.string.dialog_file_already_exists);\n                    break;\n                case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                    builder.setMessage(R.string.dialog_insufficient_space_on_external);\n                    break;\n                case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                    builder.setMessage(R.string.dialog_media_not_found);\n                    break;\n                case DownloadManager.ERROR_CANNOT_RESUME:\n                    builder.setMessage(R.string.dialog_cannot_resume);\n                    break;\n                default:\n                    builder.setMessage(R.string.dialog_failed_body);\n            }\n\n            builder.setNegativeButton(\n                    R.string.delete_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            builder.setPositiveButton(\n                    R.string.retry_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.restartDownload(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n}\n","lineNo":60}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        try {\n            while (cursor.moveToNext()) {\n                grantAllDownloadsPermission(cursor.getLong(0), cursor.getInt(1));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        grantAllDownloadsPermission(rowID, Binder.getCallingUid());\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule) {\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        try (Cursor cursor = db.query(DB_TABLE, new String[] { _ID },\n                                selection.getSelection(), selection.getParameters(),\n                                null, null, null)) {\n                            while (cursor.moveToNext()) {\n                                Helpers.scheduleJob(getContext(), cursor.getInt(0));\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                        selection.getParameters(), null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // Tell requester that download is finished\n                        info.sendIntentIfRequested();\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(long id, int uid) {\n        final String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packageNames == null || packageNames.length == 0) return;\n\n        // We only need to grant to the first package, since the\n        // platform internally tracks based on UIDs\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(packageNames[0], uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        try {\n            while (cursor.moveToNext()) {\n                grantAllDownloadsPermission(cursor.getLong(0), cursor.getInt(1));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        grantAllDownloadsPermission(rowID, Binder.getCallingUid());\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule || isCompleting) {\n                    final long token = Binder.clearCallingIdentity();\n                    try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                            selection.getParameters(), null, null, null)) {\n                        final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                                cursor);\n                        final DownloadInfo info = new DownloadInfo(context);\n                        while (cursor.moveToNext()) {\n                            reader.updateFromDatabase(info);\n                            if (updateSchedule) {\n                                Helpers.scheduleJob(context, info);\n                            }\n                            if (isCompleting) {\n                                info.sendIntentIfRequested();\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                        selection.getParameters(), null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(long id, int uid) {\n        final String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packageNames == null || packageNames.length == 0) return;\n\n        // We only need to grant to the first package, since the\n        // platform internally tracks based on UIDs\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(packageNames[0], uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","lineNo":1080}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        try {\n            while (cursor.moveToNext()) {\n                grantAllDownloadsPermission(cursor.getLong(0), cursor.getInt(1));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        grantAllDownloadsPermission(rowID, Binder.getCallingUid());\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n        builder.setTables(DB_TABLE);\n        builder.setStrict(true);\n        Cursor ret = builder.query(db, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule) {\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        try (Cursor cursor = db.query(DB_TABLE, new String[] { _ID },\n                                selection.getSelection(), selection.getParameters(),\n                                null, null, null)) {\n                            while (cursor.moveToNext()) {\n                                Helpers.scheduleJob(getContext(), cursor.getInt(0));\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                        selection.getParameters(), null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // Tell requester that download is finished\n                        info.sendIntentIfRequested();\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(long id, int uid) {\n        final String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packageNames == null || packageNames.length == 0) return;\n\n        // We only need to grant to the first package, since the\n        // platform internally tracks based on UIDs\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(packageNames[0], uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n\n        // Grant access permissions for all known downloads to the owning apps\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final Cursor cursor = db.query(DB_TABLE, new String[] {\n                Downloads.Impl._ID, Constants.UID }, null, null, null, null, null);\n        try {\n            while (cursor.moveToNext()) {\n                grantAllDownloadsPermission(cursor.getLong(0), cursor.getInt(1));\n            }\n        } finally {\n            cursor.close();\n        }\n\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        grantAllDownloadsPermission(rowID, Binder.getCallingUid());\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n        builder.setTables(DB_TABLE);\n        builder.setStrict(true);\n        Cursor ret = builder.query(db, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n        boolean isCompleting = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n            isCompleting = status != null && Downloads.Impl.isStatusCompleted(status);\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule || isCompleting) {\n                    final long token = Binder.clearCallingIdentity();\n                    try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                            selection.getParameters(), null, null, null)) {\n                        final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver,\n                                cursor);\n                        final DownloadInfo info = new DownloadInfo(context);\n                        while (cursor.moveToNext()) {\n                            reader.updateFromDatabase(info);\n                            if (updateSchedule) {\n                                Helpers.scheduleJob(context, info);\n                            }\n                            if (isCompleting) {\n                                info.sendIntentIfRequested();\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                        selection.getParameters(), null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        revokeAllDownloadsPermission(info.mId);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // If the download wasn't completed yet, we're\n                        // effectively completing it now, and we need to send\n                        // any requested broadcasts\n                        if (!Downloads.Impl.isStatusCompleted(info.mStatus)) {\n                            info.sendIntentIfRequested();\n                        }\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.getDownloadNotifier(getContext()).update();\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n\n    private void grantAllDownloadsPermission(long id, int uid) {\n        final String[] packageNames = getContext().getPackageManager().getPackagesForUid(uid);\n        if (packageNames == null || packageNames.length == 0) return;\n\n        // We only need to grant to the first package, since the\n        // platform internally tracks based on UIDs\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().grantUriPermission(packageNames[0], uri,\n                Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);\n    }\n\n    private void revokeAllDownloadsPermission(long id) {\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        getContext().revokeUriPermission(uri, ~0);\n    }\n}\n","lineNo":1082}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIAPROVIDER_URI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule) {\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        try (Cursor cursor = db.query(DB_TABLE, new String[] { _ID },\n                                selection.getSelection(), selection.getParameters(),\n                                null, null, null)) {\n                            while (cursor.moveToNext()) {\n                                Helpers.scheduleJob(getContext(), cursor.getInt(0));\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final JobScheduler scheduler = getContext().getSystemService(JobScheduler.class);\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, new String[] {\n                        _ID, _DATA, COLUMN_MEDIAPROVIDER_URI\n                }, selection.getSelection(), selection.getParameters(), null, null, null)) {\n                    while (cursor.moveToNext()) {\n                        final long id = cursor.getLong(0);\n                        scheduler.cancel((int) id);\n\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), id);\n\n                        final String path = cursor.getString(1);\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = cursor.getString(2);\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule) {\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        try (Cursor cursor = db.query(DB_TABLE, new String[] { _ID },\n                                selection.getSelection(), selection.getParameters(),\n                                null, null, null)) {\n                            while (cursor.moveToNext()) {\n                                Helpers.scheduleJob(getContext(), cursor.getInt(0));\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                        selection.getParameters(), null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // Tell requester that download is finished\n                        info.sendIntentIfRequested();\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","lineNo":1196}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIAPROVIDER_URI;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n        builder.setTables(DB_TABLE);\n        builder.setStrict(true);\n        Cursor ret = builder.query(db, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule) {\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        try (Cursor cursor = db.query(DB_TABLE, new String[] { _ID },\n                                selection.getSelection(), selection.getParameters(),\n                                null, null, null)) {\n                            while (cursor.moveToNext()) {\n                                Helpers.scheduleJob(getContext(), cursor.getInt(0));\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final JobScheduler scheduler = getContext().getSystemService(JobScheduler.class);\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, new String[] {\n                        _ID, _DATA, COLUMN_MEDIAPROVIDER_URI\n                }, selection.getSelection(), selection.getParameters(), null, null, null)) {\n                    while (cursor.moveToNext()) {\n                        final long id = cursor.getLong(0);\n                        scheduler.cancel((int) id);\n\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), id);\n\n                        final String path = cursor.getString(1);\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = cursor.getString(2);\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.BaseColumns._ID;\nimport static android.provider.Downloads.Impl.COLUMN_DESTINATION;\nimport static android.provider.Downloads.Impl.COLUMN_MEDIA_SCANNED;\nimport static android.provider.Downloads.Impl.COLUMN_MIME_TYPE;\nimport static android.provider.Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD;\nimport static android.provider.Downloads.Impl._DATA;\n\nimport android.app.AppOpsManager;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.app.job.JobScheduler;\nimport android.content.ContentProvider;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.database.sqlite.SQLiteQueryBuilder;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport libcore.io.IoUtils;\n\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 110;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 110:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_FLAGS,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                checkFileUriDestination(values);\n\n            } else if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                getContext().enforceCallingOrSelfPermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        \"No permission to write\");\n\n                final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n                if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                        getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                    throw new SecurityException(\"No permission to write\");\n                }\n\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_FLAGS, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        notifyContentChanged(uri, match);\n\n        final long token = Binder.clearCallingIdentity();\n        try {\n            Helpers.scheduleJob(getContext(), rowID);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n\n        if (values.getAsInteger(COLUMN_DESTINATION) == DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD\n                && values.getAsInteger(COLUMN_MEDIA_SCANNED) == 0) {\n            DownloadScanner.requestScanBlocking(getContext(), rowID, values.getAsString(_DATA),\n                    values.getAsString(COLUMN_MIME_TYPE));\n        }\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new SecurityException(e);\n        }\n\n        if (Helpers.isFilenameValidInExternalPackage(getContext(), file, getCallingPackage())) {\n            // No permissions required for paths belonging to calling package\n            return;\n        } else if (Helpers.isFilenameValidInExternal(getContext(), file)) {\n            // Otherwise we require write permission\n            getContext().enforceCallingOrSelfPermission(\n                    android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                    \"No permission to write to \" + file);\n\n            final AppOpsManager appOps = getContext().getSystemService(AppOpsManager.class);\n            if (appOps.noteProxyOp(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE,\n                    getCallingPackage()) != AppOpsManager.MODE_ALLOWED) {\n                throw new SecurityException(\"No permission to write to \" + file);\n            }\n\n        } else {\n            throw new SecurityException(\"Unsupported path \" + file);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_FLAGS);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    private Cursor queryCleared(Uri uri, String[] projection, String selection,\n            String[] selectionArgs, String sort) {\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return query(uri, projection, selection, selectionArgs, sort);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        SQLiteQueryBuilder builder = new SQLiteQueryBuilder();\n        builder.setTables(DB_TABLE);\n        builder.setStrict(true);\n        Cursor ret = builder.query(db, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean updateSchedule = false;\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                updateSchedule = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                updateSchedule = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                if (filteredValues.size() == 0) {\n                    count = 0;\n                    break;\n                }\n\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                        selection.getParameters());\n                if (updateSchedule) {\n                    final long token = Binder.clearCallingIdentity();\n                    try {\n                        try (Cursor cursor = db.query(DB_TABLE, new String[] { _ID },\n                                selection.getSelection(), selection.getParameters(),\n                                null, null, null)) {\n                            while (cursor.moveToNext()) {\n                                Helpers.scheduleJob(getContext(), cursor.getInt(0));\n                            }\n                        }\n                    } finally {\n                        Binder.restoreCallingIdentity(token);\n                    }\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where, final String[] whereArgs) {\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        final Context context = getContext();\n        final ContentResolver resolver = context.getContentResolver();\n        final JobScheduler scheduler = context.getSystemService(JobScheduler.class);\n\n        final SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                final SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                try (Cursor cursor = db.query(DB_TABLE, null, selection.getSelection(),\n                        selection.getParameters(), null, null, null)) {\n                    final DownloadInfo.Reader reader = new DownloadInfo.Reader(resolver, cursor);\n                    final DownloadInfo info = new DownloadInfo(context);\n                    while (cursor.moveToNext()) {\n                        reader.updateFromDatabase(info);\n                        scheduler.cancel((int) info.mId);\n\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), info.mId);\n\n                        final String path = info.mFileName;\n                        if (!TextUtils.isEmpty(path)) {\n                            try {\n                                final File file = new File(path).getCanonicalFile();\n                                if (Helpers.isFilenameValid(getContext(), file)) {\n                                    Log.v(Constants.TAG,\n                                            \"Deleting \" + file + \" via provider delete\");\n                                    file.delete();\n                                }\n                            } catch (IOException ignored) {\n                            }\n                        }\n\n                        final String mediaUri = info.mMediaProviderUri;\n                        if (!TextUtils.isEmpty(mediaUri)) {\n                            final long token = Binder.clearCallingIdentity();\n                            try {\n                                getContext().getContentResolver().delete(Uri.parse(mediaUri), null,\n                                        null);\n                            } finally {\n                                Binder.restoreCallingIdentity(token);\n                            }\n                        }\n\n                        // Tell requester that download is finished\n                        info.sendIntentIfRequested();\n                    }\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        // Perform normal query to enforce caller identity access before\n        // clearing it to reach internal-only columns\n        final Cursor probeCursor = query(uri, new String[] {\n                Downloads.Impl._DATA }, null, null, null);\n        try {\n            if ((probeCursor == null) || (probeCursor.getCount() == 0)) {\n                throw new FileNotFoundException(\n                        \"No file found for \" + uri + \" as UID \" + Binder.getCallingUid());\n            }\n        } finally {\n            IoUtils.closeQuietly(probeCursor);\n        }\n\n        final Cursor cursor = queryCleared(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file;\n        try {\n            file = new File(path).getCanonicalFile();\n        } catch (IOException e) {\n            throw new FileNotFoundException(e.getMessage());\n        }\n\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, Helpers.getAsyncHandler(),\n                        new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","lineNo":1198}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads.ui;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.app.FragmentManager;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.android.providers.downloads.Constants;\nimport com.android.providers.downloads.OpenHelper;\n\nimport libcore.io.IoUtils;\n\n/**\n * Intercept all download clicks to provide special behavior. For example,\n * PackageInstaller really wants raw file paths.\n */\npublic class TrampolineActivity extends Activity {\n    private static final String TAG_PAUSED = \"paused\";\n    private static final String TAG_FAILED = \"failed\";\n\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_REASON = \"reason\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final long id = ContentUris.parseId(getIntent().getData());\n\n        final DownloadManager dm = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n        dm.setAccessAllDownloads(true);\n\n        final int status;\n        final int reason;\n\n        final Cursor cursor = dm.query(new Query().setFilterById(id));\n        try {\n            if (cursor.moveToFirst()) {\n                status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n                reason = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));\n            } else {\n                Toast.makeText(this, R.string.dialog_file_missing_body, Toast.LENGTH_SHORT).show();\n                finish();\n                return;\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        Log.d(Constants.TAG, \"Found \" + id + \" with status \" + status + \", reason \" + reason);\n        switch (status) {\n            case DownloadManager.STATUS_PENDING:\n            case DownloadManager.STATUS_RUNNING:\n                sendRunningDownloadClickedBroadcast(id);\n                finish();\n                break;\n\n            case DownloadManager.STATUS_PAUSED:\n                if (reason == DownloadManager.PAUSED_QUEUED_FOR_WIFI) {\n                    PausedDialogFragment.show(getFragmentManager(), id);\n                } else {\n                    sendRunningDownloadClickedBroadcast(id);\n                    finish();\n                }\n                break;\n\n            case DownloadManager.STATUS_SUCCESSFUL:\n                if (!OpenHelper.startViewIntent(this, id, 0)) {\n                    Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                            .show();\n                }\n                finish();\n                break;\n\n            case DownloadManager.STATUS_FAILED:\n                FailedDialogFragment.show(getFragmentManager(), id, reason);\n                break;\n        }\n    }\n\n    private void sendRunningDownloadClickedBroadcast(long id) {\n        final Intent intent = new Intent(Constants.ACTION_LIST);\n        intent.setPackage(Constants.PROVIDER_PACKAGE_NAME);\n        intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, new long[] { id });\n        sendBroadcast(intent);\n    }\n\n    public static class PausedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id) {\n            final PausedDialogFragment dialog = new PausedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_PAUSED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_queued_body);\n            builder.setMessage(R.string.dialog_queued_body);\n\n            builder.setPositiveButton(R.string.keep_queued_download, null);\n\n            builder.setNegativeButton(\n                    R.string.remove_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            getActivity().finish();\n        }\n    }\n\n    public static class FailedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, int reason) {\n            final FailedDialogFragment dialog = new FailedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putInt(KEY_REASON, reason);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_FAILED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final int reason = getArguments().getInt(KEY_REASON);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_not_available);\n\n            final String message;\n            switch (reason) {\n                case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                    builder.setMessage(R.string.dialog_file_already_exists);\n                    break;\n                case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                    builder.setMessage(R.string.dialog_insufficient_space_on_external);\n                    break;\n                case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                    builder.setMessage(R.string.dialog_media_not_found);\n                    break;\n                case DownloadManager.ERROR_CANNOT_RESUME:\n                    builder.setMessage(R.string.dialog_cannot_resume);\n                    break;\n                default:\n                    builder.setMessage(R.string.dialog_failed_body);\n            }\n\n            builder.setNegativeButton(\n                    R.string.delete_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            builder.setPositiveButton(\n                    R.string.retry_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.restartDownload(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            getActivity().finish();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads.ui;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.app.FragmentManager;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.android.providers.downloads.Constants;\nimport com.android.providers.downloads.OpenHelper;\n\nimport libcore.io.IoUtils;\n\n/**\n * Intercept all download clicks to provide special behavior. For example,\n * PackageInstaller really wants raw file paths.\n */\npublic class TrampolineActivity extends Activity {\n    private static final String TAG_PAUSED = \"paused\";\n    private static final String TAG_FAILED = \"failed\";\n\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_REASON = \"reason\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final long id = ContentUris.parseId(getIntent().getData());\n\n        final DownloadManager dm = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n        dm.setAccessAllDownloads(true);\n\n        final int status;\n        final int reason;\n\n        final Cursor cursor = dm.query(new Query().setFilterById(id));\n        try {\n            if (cursor.moveToFirst()) {\n                status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n                reason = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));\n            } else {\n                Toast.makeText(this, R.string.dialog_file_missing_body, Toast.LENGTH_SHORT).show();\n                finish();\n                return;\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        Log.d(Constants.TAG, \"Found \" + id + \" with status \" + status + \", reason \" + reason);\n        switch (status) {\n            case DownloadManager.STATUS_PENDING:\n            case DownloadManager.STATUS_RUNNING:\n                sendRunningDownloadClickedBroadcast(id);\n                finish();\n                break;\n\n            case DownloadManager.STATUS_PAUSED:\n                if (reason == DownloadManager.PAUSED_QUEUED_FOR_WIFI) {\n                    PausedDialogFragment.show(getFragmentManager(), id);\n                } else {\n                    sendRunningDownloadClickedBroadcast(id);\n                    finish();\n                }\n                break;\n\n            case DownloadManager.STATUS_SUCCESSFUL:\n                if (!OpenHelper.startViewIntent(this, id, 0)) {\n                    Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                            .show();\n                }\n                finish();\n                break;\n\n            case DownloadManager.STATUS_FAILED:\n                FailedDialogFragment.show(getFragmentManager(), id, reason);\n                break;\n        }\n    }\n\n    private void sendRunningDownloadClickedBroadcast(long id) {\n        final Intent intent = new Intent(Constants.ACTION_LIST);\n        intent.setPackage(Constants.PROVIDER_PACKAGE_NAME);\n        intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, new long[] { id });\n        sendBroadcast(intent);\n    }\n\n    public static class PausedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id) {\n            final PausedDialogFragment dialog = new PausedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_PAUSED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_queued_body);\n            builder.setMessage(R.string.dialog_queued_body);\n\n            builder.setPositiveButton(R.string.keep_queued_download, null);\n\n            builder.setNegativeButton(\n                    R.string.remove_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n\n    public static class FailedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, int reason) {\n            final FailedDialogFragment dialog = new FailedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putInt(KEY_REASON, reason);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_FAILED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final int reason = getArguments().getInt(KEY_REASON);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_not_available);\n\n            final String message;\n            switch (reason) {\n                case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                    builder.setMessage(R.string.dialog_file_already_exists);\n                    break;\n                case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                    builder.setMessage(R.string.dialog_insufficient_space_on_external);\n                    break;\n                case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                    builder.setMessage(R.string.dialog_media_not_found);\n                    break;\n                case DownloadManager.ERROR_CANNOT_RESUME:\n                    builder.setMessage(R.string.dialog_cannot_resume);\n                    break;\n                default:\n                    builder.setMessage(R.string.dialog_failed_body);\n            }\n\n            builder.setNegativeButton(\n                    R.string.delete_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            builder.setPositiveButton(\n                    R.string.retry_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.restartDownload(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n}\n","lineNo":155}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads.ui;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.app.FragmentManager;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.android.providers.downloads.Constants;\nimport com.android.providers.downloads.OpenHelper;\n\nimport libcore.io.IoUtils;\n\n/**\n * Intercept all download clicks to provide special behavior. For example,\n * PackageInstaller really wants raw file paths.\n */\npublic class TrampolineActivity extends Activity {\n    private static final String TAG_PAUSED = \"paused\";\n    private static final String TAG_FAILED = \"failed\";\n\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_REASON = \"reason\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final long id = ContentUris.parseId(getIntent().getData());\n\n        final DownloadManager dm = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n        dm.setAccessAllDownloads(true);\n\n        final int status;\n        final int reason;\n\n        final Cursor cursor = dm.query(new Query().setFilterById(id));\n        try {\n            if (cursor.moveToFirst()) {\n                status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n                reason = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));\n            } else {\n                Toast.makeText(this, R.string.dialog_file_missing_body, Toast.LENGTH_SHORT).show();\n                finish();\n                return;\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        Log.d(Constants.TAG, \"Found \" + id + \" with status \" + status + \", reason \" + reason);\n        switch (status) {\n            case DownloadManager.STATUS_PENDING:\n            case DownloadManager.STATUS_RUNNING:\n                sendRunningDownloadClickedBroadcast(id);\n                finish();\n                break;\n\n            case DownloadManager.STATUS_PAUSED:\n                if (reason == DownloadManager.PAUSED_QUEUED_FOR_WIFI) {\n                    PausedDialogFragment.show(getFragmentManager(), id);\n                } else {\n                    sendRunningDownloadClickedBroadcast(id);\n                    finish();\n                }\n                break;\n\n            case DownloadManager.STATUS_SUCCESSFUL:\n                if (!OpenHelper.startViewIntent(this, id, 0)) {\n                    Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                            .show();\n                }\n                finish();\n                break;\n\n            case DownloadManager.STATUS_FAILED:\n                FailedDialogFragment.show(getFragmentManager(), id, reason);\n                break;\n        }\n    }\n\n    private void sendRunningDownloadClickedBroadcast(long id) {\n        final Intent intent = new Intent(Constants.ACTION_LIST);\n        intent.setPackage(Constants.PROVIDER_PACKAGE_NAME);\n        intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, new long[] { id });\n        sendBroadcast(intent);\n    }\n\n    public static class PausedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id) {\n            final PausedDialogFragment dialog = new PausedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_PAUSED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_queued_body);\n            builder.setMessage(R.string.dialog_queued_body);\n\n            builder.setPositiveButton(R.string.keep_queued_download, null);\n\n            builder.setNegativeButton(\n                    R.string.remove_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            getActivity().finish();\n        }\n    }\n\n    public static class FailedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, int reason) {\n            final FailedDialogFragment dialog = new FailedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putInt(KEY_REASON, reason);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_FAILED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final int reason = getArguments().getInt(KEY_REASON);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_not_available);\n\n            final String message;\n            switch (reason) {\n                case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                    builder.setMessage(R.string.dialog_file_already_exists);\n                    break;\n                case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                    builder.setMessage(R.string.dialog_insufficient_space_on_external);\n                    break;\n                case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                    builder.setMessage(R.string.dialog_media_not_found);\n                    break;\n                case DownloadManager.ERROR_CANNOT_RESUME:\n                    builder.setMessage(R.string.dialog_cannot_resume);\n                    break;\n                default:\n                    builder.setMessage(R.string.dialog_failed_body);\n            }\n\n            builder.setNegativeButton(\n                    R.string.delete_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            builder.setPositiveButton(\n                    R.string.retry_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.restartDownload(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            getActivity().finish();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads.ui;\n\nimport android.app.Activity;\nimport android.app.AlertDialog;\nimport android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.app.FragmentManager;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.android.providers.downloads.Constants;\nimport com.android.providers.downloads.OpenHelper;\n\nimport libcore.io.IoUtils;\n\n/**\n * Intercept all download clicks to provide special behavior. For example,\n * PackageInstaller really wants raw file paths.\n */\npublic class TrampolineActivity extends Activity {\n    private static final String TAG_PAUSED = \"paused\";\n    private static final String TAG_FAILED = \"failed\";\n\n    private static final String KEY_ID = \"id\";\n    private static final String KEY_REASON = \"reason\";\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        final long id = ContentUris.parseId(getIntent().getData());\n\n        final DownloadManager dm = (DownloadManager) getSystemService(Context.DOWNLOAD_SERVICE);\n        dm.setAccessAllDownloads(true);\n\n        final int status;\n        final int reason;\n\n        final Cursor cursor = dm.query(new Query().setFilterById(id));\n        try {\n            if (cursor.moveToFirst()) {\n                status = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n                reason = cursor.getInt(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_REASON));\n            } else {\n                Toast.makeText(this, R.string.dialog_file_missing_body, Toast.LENGTH_SHORT).show();\n                finish();\n                return;\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        Log.d(Constants.TAG, \"Found \" + id + \" with status \" + status + \", reason \" + reason);\n        switch (status) {\n            case DownloadManager.STATUS_PENDING:\n            case DownloadManager.STATUS_RUNNING:\n                sendRunningDownloadClickedBroadcast(id);\n                finish();\n                break;\n\n            case DownloadManager.STATUS_PAUSED:\n                if (reason == DownloadManager.PAUSED_QUEUED_FOR_WIFI) {\n                    PausedDialogFragment.show(getFragmentManager(), id);\n                } else {\n                    sendRunningDownloadClickedBroadcast(id);\n                    finish();\n                }\n                break;\n\n            case DownloadManager.STATUS_SUCCESSFUL:\n                if (!OpenHelper.startViewIntent(this, id, 0)) {\n                    Toast.makeText(this, R.string.download_no_application_title, Toast.LENGTH_SHORT)\n                            .show();\n                }\n                finish();\n                break;\n\n            case DownloadManager.STATUS_FAILED:\n                FailedDialogFragment.show(getFragmentManager(), id, reason);\n                break;\n        }\n    }\n\n    private void sendRunningDownloadClickedBroadcast(long id) {\n        final Intent intent = new Intent(Constants.ACTION_LIST);\n        intent.setPackage(Constants.PROVIDER_PACKAGE_NAME);\n        intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, new long[] { id });\n        sendBroadcast(intent);\n    }\n\n    public static class PausedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id) {\n            final PausedDialogFragment dialog = new PausedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_PAUSED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_queued_body);\n            builder.setMessage(R.string.dialog_queued_body);\n\n            builder.setPositiveButton(R.string.keep_queued_download, null);\n\n            builder.setNegativeButton(\n                    R.string.remove_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n\n    public static class FailedDialogFragment extends DialogFragment {\n        public static void show(FragmentManager fm, long id, int reason) {\n            final FailedDialogFragment dialog = new FailedDialogFragment();\n            final Bundle args = new Bundle();\n            args.putLong(KEY_ID, id);\n            args.putInt(KEY_REASON, reason);\n            dialog.setArguments(args);\n            dialog.show(fm, TAG_FAILED);\n        }\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final Context context = getActivity();\n\n            final DownloadManager dm = (DownloadManager) context.getSystemService(\n                    Context.DOWNLOAD_SERVICE);\n            dm.setAccessAllDownloads(true);\n\n            final long id = getArguments().getLong(KEY_ID);\n            final int reason = getArguments().getInt(KEY_REASON);\n\n            final AlertDialog.Builder builder = new AlertDialog.Builder(\n                    context, AlertDialog.THEME_HOLO_LIGHT);\n            builder.setTitle(R.string.dialog_title_not_available);\n\n            final String message;\n            switch (reason) {\n                case DownloadManager.ERROR_FILE_ALREADY_EXISTS:\n                    builder.setMessage(R.string.dialog_file_already_exists);\n                    break;\n                case DownloadManager.ERROR_INSUFFICIENT_SPACE:\n                    builder.setMessage(R.string.dialog_insufficient_space_on_external);\n                    break;\n                case DownloadManager.ERROR_DEVICE_NOT_FOUND:\n                    builder.setMessage(R.string.dialog_media_not_found);\n                    break;\n                case DownloadManager.ERROR_CANNOT_RESUME:\n                    builder.setMessage(R.string.dialog_cannot_resume);\n                    break;\n                default:\n                    builder.setMessage(R.string.dialog_failed_body);\n            }\n\n            builder.setNegativeButton(\n                    R.string.delete_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.remove(id);\n                        }\n                    });\n\n            builder.setPositiveButton(\n                    R.string.retry_download, new DialogInterface.OnClickListener() {\n                        @Override\n                        public void onClick(DialogInterface dialog, int which) {\n                            dm.restartDownload(id);\n                        }\n                    });\n\n            return builder.create();\n        }\n\n        @Override\n        public void onDismiss(DialogInterface dialog) {\n            super.onDismiss(dialog);\n            final Activity activity = getActivity();\n            if (activity != null) {\n                activity.finish();\n            }\n        }\n    }\n}\n","lineNo":227}
{"Smelly Sample":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION;\nimport static android.provider.Downloads.Impl.STATUS_RUNNING;\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.app.DownloadManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.net.Uri;\nimport android.os.SystemClock;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\nimport android.util.LongSparseLongArray;\n\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\n\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Update {@link NotificationManager} to reflect current {@link DownloadInfo}\n * states. Collapses similar downloads into a single notification, and builds\n * {@link PendingIntent} that launch towards {@link DownloadReceiver}.\n */\npublic class DownloadNotifier {\n\n    private static final int TYPE_ACTIVE = 1;\n    private static final int TYPE_WAITING = 2;\n    private static final int TYPE_COMPLETE = 3;\n\n    private final Context mContext;\n    private final NotificationManager mNotifManager;\n\n    /**\n     * Currently active notifications, mapped from clustering tag to timestamp\n     * when first shown.\n     *\n     * @see #buildNotificationTag(DownloadInfo)\n     */\n    @GuardedBy(\"mActiveNotifs\")\n    private final HashMap<String, Long> mActiveNotifs = Maps.newHashMap();\n\n    /**\n     * Current speed of active downloads, mapped from {@link DownloadInfo#mId}\n     * to speed in bytes per second.\n     */\n    @GuardedBy(\"mDownloadSpeed\")\n    private final LongSparseLongArray mDownloadSpeed = new LongSparseLongArray();\n\n    /**\n     * Last time speed was reproted, mapped from {@link DownloadInfo#mId} to\n     * {@link SystemClock#elapsedRealtime()}.\n     */\n    @GuardedBy(\"mDownloadSpeed\")\n    private final LongSparseLongArray mDownloadTouch = new LongSparseLongArray();\n\n    public DownloadNotifier(Context context) {\n        mContext = context;\n        mNotifManager = (NotificationManager) context.getSystemService(\n                Context.NOTIFICATION_SERVICE);\n    }\n\n    public void cancelAll() {\n        mNotifManager.cancelAll();\n    }\n\n    /**\n     * Notify the current speed of an active download, used for calculating\n     * estimated remaining time.\n     */\n    public void notifyDownloadSpeed(long id, long bytesPerSecond) {\n        synchronized (mDownloadSpeed) {\n            if (bytesPerSecond != 0) {\n                mDownloadSpeed.put(id, bytesPerSecond);\n                mDownloadTouch.put(id, SystemClock.elapsedRealtime());\n            } else {\n                mDownloadSpeed.delete(id);\n                mDownloadTouch.delete(id);\n            }\n        }\n    }\n\n    /**\n     * Update {@link NotificationManager} to reflect the given set of\n     * {@link DownloadInfo}, adding, collapsing, and removing as needed.\n     */\n    public void updateWith(Collection<DownloadInfo> downloads) {\n        synchronized (mActiveNotifs) {\n            updateWithLocked(downloads);\n        }\n    }\n\n    private void updateWithLocked(Collection<DownloadInfo> downloads) {\n        final Resources res = mContext.getResources();\n\n        // Cluster downloads together\n        final Multimap<String, DownloadInfo> clustered = ArrayListMultimap.create();\n        for (DownloadInfo info : downloads) {\n            final String tag = buildNotificationTag(info);\n            if (tag != null) {\n                clustered.put(tag, info);\n            }\n        }\n\n        // Build notification for each cluster\n        for (String tag : clustered.keySet()) {\n            final int type = getNotificationTagType(tag);\n            final Collection<DownloadInfo> cluster = clustered.get(tag);\n\n            final Notification.Builder builder = new Notification.Builder(mContext);\n            builder.setColor(res.getColor(\n                    com.android.internal.R.color.system_notification_accent_color));\n\n            // Use time when cluster was first shown to avoid shuffling\n            final long firstShown;\n            if (mActiveNotifs.containsKey(tag)) {\n                firstShown = mActiveNotifs.get(tag);\n            } else {\n                firstShown = System.currentTimeMillis();\n                mActiveNotifs.put(tag, firstShown);\n            }\n            builder.setWhen(firstShown);\n\n            // Show relevant icon\n            if (type == TYPE_ACTIVE) {\n                builder.setSmallIcon(android.R.drawable.stat_sys_download);\n            } else if (type == TYPE_WAITING) {\n                builder.setSmallIcon(android.R.drawable.stat_sys_warning);\n            } else if (type == TYPE_COMPLETE) {\n                builder.setSmallIcon(android.R.drawable.stat_sys_download_done);\n            }\n\n            // Build action intents\n            if (type == TYPE_ACTIVE || type == TYPE_WAITING) {\n                // build a synthetic uri for intent identification purposes\n                final Uri uri = new Uri.Builder().scheme(\"active-dl\").appendPath(tag).build();\n                final Intent intent = new Intent(Constants.ACTION_LIST,\n                        uri, mContext, DownloadReceiver.class);\n                intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS,\n                        getDownloadIds(cluster));\n                builder.setContentIntent(PendingIntent.getBroadcast(mContext,\n                        0, intent, PendingIntent.FLAG_UPDATE_CURRENT));\n                builder.setOngoing(true);\n\n            } else if (type == TYPE_COMPLETE) {\n                final DownloadInfo info = cluster.iterator().next();\n                final Uri uri = ContentUris.withAppendedId(\n                        Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);\n                builder.setAutoCancel(true);\n\n                final String action;\n                if (Downloads.Impl.isStatusError(info.mStatus)) {\n                    action = Constants.ACTION_LIST;\n                } else {\n                    if (info.mDestination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                        action = Constants.ACTION_OPEN;\n                    } else {\n                        action = Constants.ACTION_LIST;\n                    }\n                }\n\n                final Intent intent = new Intent(action, uri, mContext, DownloadReceiver.class);\n                intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS,\n                        getDownloadIds(cluster));\n                builder.setContentIntent(PendingIntent.getBroadcast(mContext,\n                        0, intent, PendingIntent.FLAG_UPDATE_CURRENT));\n\n                final Intent hideIntent = new Intent(Constants.ACTION_HIDE,\n                        uri, mContext, DownloadReceiver.class);\n                builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, hideIntent, 0));\n            }\n\n            // Calculate and show progress\n            String remainingText = null;\n            String percentText = null;\n            if (type == TYPE_ACTIVE) {\n                long current = 0;\n                long total = 0;\n                long speed = 0;\n                synchronized (mDownloadSpeed) {\n                    for (DownloadInfo info : cluster) {\n                        if (info.mTotalBytes != -1) {\n                            current += info.mCurrentBytes;\n                            total += info.mTotalBytes;\n                            speed += mDownloadSpeed.get(info.mId);\n                        }\n                    }\n                }\n\n                if (total > 0) {\n                    percentText =\n                            NumberFormat.getPercentInstance().format((double) current / total);\n\n                    if (speed > 0) {\n                        final long remainingMillis = ((total - current) * 1000) / speed;\n                        remainingText = res.getString(R.string.download_remaining,\n                                DateUtils.formatDuration(remainingMillis));\n                    }\n\n                    final int percent = (int) ((current * 100) / total);\n                    builder.setProgress(100, percent, false);\n                } else {\n                    builder.setProgress(100, 0, true);\n                }\n            }\n\n            // Build titles and description\n            final Notification notif;\n            if (cluster.size() == 1) {\n                final DownloadInfo info = cluster.iterator().next();\n\n                builder.setContentTitle(getDownloadTitle(res, info));\n\n                if (type == TYPE_ACTIVE) {\n                    if (!TextUtils.isEmpty(info.mDescription)) {\n                        builder.setContentText(info.mDescription);\n                    } else {\n                        builder.setContentText(remainingText);\n                    }\n                    builder.setContentInfo(percentText);\n\n                } else if (type == TYPE_WAITING) {\n                    builder.setContentText(\n                            res.getString(R.string.notification_need_wifi_for_size));\n\n                } else if (type == TYPE_COMPLETE) {\n                    if (Downloads.Impl.isStatusError(info.mStatus)) {\n                        builder.setContentText(res.getText(R.string.notification_download_failed));\n                    } else if (Downloads.Impl.isStatusSuccess(info.mStatus)) {\n                        builder.setContentText(\n                                res.getText(R.string.notification_download_complete));\n                    }\n                }\n\n                notif = builder.build();\n\n            } else {\n                final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);\n\n                for (DownloadInfo info : cluster) {\n                    inboxStyle.addLine(getDownloadTitle(res, info));\n                }\n\n                if (type == TYPE_ACTIVE) {\n                    builder.setContentTitle(res.getQuantityString(\n                            R.plurals.notif_summary_active, cluster.size(), cluster.size()));\n                    builder.setContentText(remainingText);\n                    builder.setContentInfo(percentText);\n                    inboxStyle.setSummaryText(remainingText);\n\n                } else if (type == TYPE_WAITING) {\n                    builder.setContentTitle(res.getQuantityString(\n                            R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));\n                    builder.setContentText(\n                            res.getString(R.string.notification_need_wifi_for_size));\n                    inboxStyle.setSummaryText(\n                            res.getString(R.string.notification_need_wifi_for_size));\n                }\n\n                notif = inboxStyle.build();\n            }\n\n            mNotifManager.notify(tag, 0, notif);\n        }\n\n        // Remove stale tags that weren't renewed\n        final Iterator<String> it = mActiveNotifs.keySet().iterator();\n        while (it.hasNext()) {\n            final String tag = it.next();\n            if (!clustered.containsKey(tag)) {\n                mNotifManager.cancel(tag, 0);\n                it.remove();\n            }\n        }\n    }\n\n    private static CharSequence getDownloadTitle(Resources res, DownloadInfo info) {\n        if (!TextUtils.isEmpty(info.mTitle)) {\n            return info.mTitle;\n        } else {\n            return res.getString(R.string.download_unknown_title);\n        }\n    }\n\n    private long[] getDownloadIds(Collection<DownloadInfo> infos) {\n        final long[] ids = new long[infos.size()];\n        int i = 0;\n        for (DownloadInfo info : infos) {\n            ids[i++] = info.mId;\n        }\n        return ids;\n    }\n\n    public void dumpSpeeds() {\n        synchronized (mDownloadSpeed) {\n            for (int i = 0; i < mDownloadSpeed.size(); i++) {\n                final long id = mDownloadSpeed.keyAt(i);\n                final long delta = SystemClock.elapsedRealtime() - mDownloadTouch.get(id);\n                Log.d(TAG, \"Download \" + id + \" speed \" + mDownloadSpeed.valueAt(i) + \"bps, \"\n                        + delta + \"ms ago\");\n            }\n        }\n    }\n\n    /**\n     * Build tag used for collapsing several {@link DownloadInfo} into a single\n     * {@link Notification}.\n     */\n    private static String buildNotificationTag(DownloadInfo info) {\n        if (info.mStatus == Downloads.Impl.STATUS_QUEUED_FOR_WIFI) {\n            return TYPE_WAITING + \":\" + info.mPackage;\n        } else if (isActiveAndVisible(info)) {\n            return TYPE_ACTIVE + \":\" + info.mPackage;\n        } else if (isCompleteAndVisible(info)) {\n            // Complete downloads always have unique notifs\n            return TYPE_COMPLETE + \":\" + info.mId;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return the cluster type of the given tag, as created by\n     * {@link #buildNotificationTag(DownloadInfo)}.\n     */\n    private static int getNotificationTagType(String tag) {\n        return Integer.parseInt(tag.substring(0, tag.indexOf(':')));\n    }\n\n    private static boolean isActiveAndVisible(DownloadInfo download) {\n        return download.mStatus == STATUS_RUNNING &&\n                (download.mVisibility == VISIBILITY_VISIBLE\n                || download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n    }\n\n    private static boolean isCompleteAndVisible(DownloadInfo download) {\n        return Downloads.Impl.isStatusCompleted(download.mStatus) &&\n                (download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED\n                || download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2012 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION;\nimport static android.provider.Downloads.Impl.STATUS_RUNNING;\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.app.DownloadManager;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.res.Resources;\nimport android.net.Uri;\nimport android.os.SystemClock;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\nimport android.util.LongSparseLongArray;\n\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Multimap;\n\nimport java.text.NumberFormat;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\nimport javax.annotation.concurrent.GuardedBy;\n\n/**\n * Update {@link NotificationManager} to reflect current {@link DownloadInfo}\n * states. Collapses similar downloads into a single notification, and builds\n * {@link PendingIntent} that launch towards {@link DownloadReceiver}.\n */\npublic class DownloadNotifier {\n\n    private static final int TYPE_ACTIVE = 1;\n    private static final int TYPE_WAITING = 2;\n    private static final int TYPE_COMPLETE = 3;\n\n    private final Context mContext;\n    private final NotificationManager mNotifManager;\n\n    /**\n     * Currently active notifications, mapped from clustering tag to timestamp\n     * when first shown.\n     *\n     * @see #buildNotificationTag(DownloadInfo)\n     */\n    @GuardedBy(\"mActiveNotifs\")\n    private final HashMap<String, Long> mActiveNotifs = Maps.newHashMap();\n\n    /**\n     * Current speed of active downloads, mapped from {@link DownloadInfo#mId}\n     * to speed in bytes per second.\n     */\n    @GuardedBy(\"mDownloadSpeed\")\n    private final LongSparseLongArray mDownloadSpeed = new LongSparseLongArray();\n\n    /**\n     * Last time speed was reproted, mapped from {@link DownloadInfo#mId} to\n     * {@link SystemClock#elapsedRealtime()}.\n     */\n    @GuardedBy(\"mDownloadSpeed\")\n    private final LongSparseLongArray mDownloadTouch = new LongSparseLongArray();\n\n    public DownloadNotifier(Context context) {\n        mContext = context;\n        mNotifManager = (NotificationManager) context.getSystemService(\n                Context.NOTIFICATION_SERVICE);\n    }\n\n    public void cancelAll() {\n        mNotifManager.cancelAll();\n    }\n\n    /**\n     * Notify the current speed of an active download, used for calculating\n     * estimated remaining time.\n     */\n    public void notifyDownloadSpeed(long id, long bytesPerSecond) {\n        synchronized (mDownloadSpeed) {\n            if (bytesPerSecond != 0) {\n                mDownloadSpeed.put(id, bytesPerSecond);\n                mDownloadTouch.put(id, SystemClock.elapsedRealtime());\n            } else {\n                mDownloadSpeed.delete(id);\n                mDownloadTouch.delete(id);\n            }\n        }\n    }\n\n    /**\n     * Update {@link NotificationManager} to reflect the given set of\n     * {@link DownloadInfo}, adding, collapsing, and removing as needed.\n     */\n    public void updateWith(Collection<DownloadInfo> downloads) {\n        synchronized (mActiveNotifs) {\n            updateWithLocked(downloads);\n        }\n    }\n\n    private static boolean isClusterDeleted(Collection<DownloadInfo> cluster) {\n        boolean wasDeleted = true;\n        for (DownloadInfo info : cluster) {\n            wasDeleted = wasDeleted && info.mDeleted;\n        }\n\n        return wasDeleted;\n    }\n\n    private void updateWithLocked(Collection<DownloadInfo> downloads) {\n        final Resources res = mContext.getResources();\n\n        // Cluster downloads together\n        final Multimap<String, DownloadInfo> clustered = ArrayListMultimap.create();\n        for (DownloadInfo info : downloads) {\n            final String tag = buildNotificationTag(info);\n            if (tag != null) {\n                clustered.put(tag, info);\n            }\n        }\n\n        // Build notification for each cluster\n        for (String tag : clustered.keySet()) {\n            final int type = getNotificationTagType(tag);\n            final Collection<DownloadInfo> cluster = clustered.get(tag);\n\n            // If each of the downloads was canceled, don't show notification for the cluster\n            if (isClusterDeleted(cluster)) {\n                continue;\n            }\n\n            final Notification.Builder builder = new Notification.Builder(mContext);\n            builder.setColor(res.getColor(\n                    com.android.internal.R.color.system_notification_accent_color));\n\n            // Use time when cluster was first shown to avoid shuffling\n            final long firstShown;\n            if (mActiveNotifs.containsKey(tag)) {\n                firstShown = mActiveNotifs.get(tag);\n            } else {\n                firstShown = System.currentTimeMillis();\n                mActiveNotifs.put(tag, firstShown);\n            }\n            builder.setWhen(firstShown);\n\n            // Show relevant icon\n            if (type == TYPE_ACTIVE) {\n                builder.setSmallIcon(android.R.drawable.stat_sys_download);\n            } else if (type == TYPE_WAITING) {\n                builder.setSmallIcon(android.R.drawable.stat_sys_warning);\n            } else if (type == TYPE_COMPLETE) {\n                builder.setSmallIcon(android.R.drawable.stat_sys_download_done);\n            }\n\n            // Build action intents\n            if (type == TYPE_ACTIVE || type == TYPE_WAITING) {\n                long[] downloadIds = getDownloadIds(cluster);\n\n                // build a synthetic uri for intent identification purposes\n                final Uri uri = new Uri.Builder().scheme(\"active-dl\").appendPath(tag).build();\n                final Intent intent = new Intent(Constants.ACTION_LIST,\n                        uri, mContext, DownloadReceiver.class);\n                intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS,\n                        downloadIds);\n                builder.setContentIntent(PendingIntent.getBroadcast(mContext,\n                        0, intent, PendingIntent.FLAG_UPDATE_CURRENT));\n                builder.setOngoing(true);\n\n                // Add a Cancel action\n                final Uri cancelUri = new Uri.Builder().scheme(\"cancel-dl\").appendPath(tag).build();\n                final Intent cancelIntent = new Intent(Constants.ACTION_CANCEL,\n                        cancelUri, mContext, DownloadReceiver.class);\n                cancelIntent.putExtra(DownloadReceiver.EXTRA_CANCELED_DOWNLOAD_IDS, downloadIds);\n                cancelIntent.putExtra(DownloadReceiver.EXTRA_CANCELED_DOWNLOAD_NOTIFICATION_TAG, tag);\n\n                builder.addAction(\n                    android.R.drawable.ic_menu_close_clear_cancel,\n                    res.getString(R.string.button_cancel_download),\n                    PendingIntent.getBroadcast(mContext,\n                            0, cancelIntent, PendingIntent.FLAG_UPDATE_CURRENT));\n\n            } else if (type == TYPE_COMPLETE) {\n                final DownloadInfo info = cluster.iterator().next();\n                final Uri uri = ContentUris.withAppendedId(\n                        Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, info.mId);\n                builder.setAutoCancel(true);\n\n                final String action;\n                if (Downloads.Impl.isStatusError(info.mStatus)) {\n                    action = Constants.ACTION_LIST;\n                } else {\n                    if (info.mDestination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                        action = Constants.ACTION_OPEN;\n                    } else {\n                        action = Constants.ACTION_LIST;\n                    }\n                }\n\n                final Intent intent = new Intent(action, uri, mContext, DownloadReceiver.class);\n                intent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS,\n                        getDownloadIds(cluster));\n                builder.setContentIntent(PendingIntent.getBroadcast(mContext,\n                        0, intent, PendingIntent.FLAG_UPDATE_CURRENT));\n\n                final Intent hideIntent = new Intent(Constants.ACTION_HIDE,\n                        uri, mContext, DownloadReceiver.class);\n                builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, hideIntent, 0));\n            }\n\n            // Calculate and show progress\n            String remainingText = null;\n            String percentText = null;\n            if (type == TYPE_ACTIVE) {\n                long current = 0;\n                long total = 0;\n                long speed = 0;\n                synchronized (mDownloadSpeed) {\n                    for (DownloadInfo info : cluster) {\n                        if (info.mTotalBytes != -1) {\n                            current += info.mCurrentBytes;\n                            total += info.mTotalBytes;\n                            speed += mDownloadSpeed.get(info.mId);\n                        }\n                    }\n                }\n\n                if (total > 0) {\n                    percentText =\n                            NumberFormat.getPercentInstance().format((double) current / total);\n\n                    if (speed > 0) {\n                        final long remainingMillis = ((total - current) * 1000) / speed;\n                        remainingText = res.getString(R.string.download_remaining,\n                                DateUtils.formatDuration(remainingMillis));\n                    }\n\n                    final int percent = (int) ((current * 100) / total);\n                    builder.setProgress(100, percent, false);\n                } else {\n                    builder.setProgress(100, 0, true);\n                }\n            }\n\n            // Build titles and description\n            final Notification notif;\n            if (cluster.size() == 1) {\n                final DownloadInfo info = cluster.iterator().next();\n\n                builder.setContentTitle(getDownloadTitle(res, info));\n\n                if (type == TYPE_ACTIVE) {\n                    if (!TextUtils.isEmpty(info.mDescription)) {\n                        builder.setContentText(info.mDescription);\n                    } else {\n                        builder.setContentText(remainingText);\n                    }\n                    builder.setContentInfo(percentText);\n\n                } else if (type == TYPE_WAITING) {\n                    builder.setContentText(\n                            res.getString(R.string.notification_need_wifi_for_size));\n\n                } else if (type == TYPE_COMPLETE) {\n                    if (Downloads.Impl.isStatusError(info.mStatus)) {\n                        builder.setContentText(res.getText(R.string.notification_download_failed));\n                    } else if (Downloads.Impl.isStatusSuccess(info.mStatus)) {\n                        builder.setContentText(\n                                res.getText(R.string.notification_download_complete));\n                    }\n                }\n\n                notif = builder.build();\n\n            } else {\n                final Notification.InboxStyle inboxStyle = new Notification.InboxStyle(builder);\n\n                for (DownloadInfo info : cluster) {\n                    inboxStyle.addLine(getDownloadTitle(res, info));\n                }\n\n                if (type == TYPE_ACTIVE) {\n                    builder.setContentTitle(res.getQuantityString(\n                            R.plurals.notif_summary_active, cluster.size(), cluster.size()));\n                    builder.setContentText(remainingText);\n                    builder.setContentInfo(percentText);\n                    inboxStyle.setSummaryText(remainingText);\n\n                } else if (type == TYPE_WAITING) {\n                    builder.setContentTitle(res.getQuantityString(\n                            R.plurals.notif_summary_waiting, cluster.size(), cluster.size()));\n                    builder.setContentText(\n                            res.getString(R.string.notification_need_wifi_for_size));\n                    inboxStyle.setSummaryText(\n                            res.getString(R.string.notification_need_wifi_for_size));\n                }\n\n                notif = inboxStyle.build();\n            }\n\n            mNotifManager.notify(tag, 0, notif);\n        }\n\n        // Remove stale tags that weren't renewed\n        final Iterator<String> it = mActiveNotifs.keySet().iterator();\n        while (it.hasNext()) {\n            final String tag = it.next();\n            if (!clustered.containsKey(tag)) {\n                mNotifManager.cancel(tag, 0);\n                it.remove();\n            }\n        }\n    }\n\n    private static CharSequence getDownloadTitle(Resources res, DownloadInfo info) {\n        if (!TextUtils.isEmpty(info.mTitle)) {\n            return info.mTitle;\n        } else {\n            return res.getString(R.string.download_unknown_title);\n        }\n    }\n\n    private long[] getDownloadIds(Collection<DownloadInfo> infos) {\n        final long[] ids = new long[infos.size()];\n        int i = 0;\n        for (DownloadInfo info : infos) {\n            ids[i++] = info.mId;\n        }\n        return ids;\n    }\n\n    public void dumpSpeeds() {\n        synchronized (mDownloadSpeed) {\n            for (int i = 0; i < mDownloadSpeed.size(); i++) {\n                final long id = mDownloadSpeed.keyAt(i);\n                final long delta = SystemClock.elapsedRealtime() - mDownloadTouch.get(id);\n                Log.d(TAG, \"Download \" + id + \" speed \" + mDownloadSpeed.valueAt(i) + \"bps, \"\n                        + delta + \"ms ago\");\n            }\n        }\n    }\n\n    /**\n     * Build tag used for collapsing several {@link DownloadInfo} into a single\n     * {@link Notification}.\n     */\n    private static String buildNotificationTag(DownloadInfo info) {\n        if (info.mStatus == Downloads.Impl.STATUS_QUEUED_FOR_WIFI) {\n            return TYPE_WAITING + \":\" + info.mPackage;\n        } else if (isActiveAndVisible(info)) {\n            return TYPE_ACTIVE + \":\" + info.mPackage;\n        } else if (isCompleteAndVisible(info)) {\n            // Complete downloads always have unique notifs\n            return TYPE_COMPLETE + \":\" + info.mId;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Return the cluster type of the given tag, as created by\n     * {@link #buildNotificationTag(DownloadInfo)}.\n     */\n    private static int getNotificationTagType(String tag) {\n        return Integer.parseInt(tag.substring(0, tag.indexOf(':')));\n    }\n\n    private static boolean isActiveAndVisible(DownloadInfo download) {\n        return download.mStatus == STATUS_RUNNING &&\n                (download.mVisibility == VISIBILITY_VISIBLE\n                || download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n    }\n\n    private static boolean isCompleteAndVisible(DownloadInfo download) {\n        return Downloads.Impl.isStatusCompleted(download.mStatus) &&\n                (download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED\n                || download.mVisibility == VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n    }\n}\n","lineNo":181}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 109;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    private Handler mHandler;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Constants.MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mHandler = new Handler();\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        // start the DownloadService class. don't wait for the 1st download to be issued.\n        // saves us by getting some initialization code in DownloadService out of the way.\n        Context context = getContext();\n        context.startService(new Intent(context, DownloadService.class));\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need WRITE_EXTERNAL_STORAGE permission to use DESTINATION_FILE_URI\");\n                checkFileUriDestination(values);\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        notifyContentChanged(uri, match);\n\n        // Always start service to handle notifications and/or scanning\n        final Context context = getContext();\n        context.startService(new Intent(context, DownloadService.class));\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n        try {\n            final String canonicalPath = new File(path).getCanonicalPath();\n            final String externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();\n            if (!canonicalPath.startsWith(externalPath)) {\n                throw new SecurityException(\"Destination must be on external storage: \" + uri);\n            }\n        } catch (IOException e) {\n            throw new SecurityException(\"Problem resolving path: \" + uri);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean startService = false;\n\n        if (values.containsKey(Downloads.Impl.COLUMN_DELETED)) {\n            if (values.getAsInteger(Downloads.Impl.COLUMN_DELETED) == 1) {\n                // some rows are to be 'deleted'. need to start DownloadService.\n                startService = true;\n            }\n        }\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                startService = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                startService = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                if (filteredValues.size() > 0) {\n                    count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                            selection.getParameters());\n                } else {\n                    count = 0;\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        if (startService) {\n            Context context = getContext();\n            context.startService(new Intent(context, DownloadService.class));\n        }\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where,\n            final String[] whereArgs) {\n\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                final Cursor cursor = db.query(DB_TABLE, new String[] {\n                        Downloads.Impl._ID }, selection.getSelection(), selection.getParameters(),\n                        null, null, null);\n                try {\n                    while (cursor.moveToNext()) {\n                        final long id = cursor.getLong(0);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), id);\n                    }\n                } finally {\n                    IoUtils.closeQuietly(cursor);\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        final Cursor cursor = query(uri, new String[] { Downloads.Impl._DATA }, null, null, null);\n        String path;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            cursor.moveToFirst();\n            path = cursor.getString(0);\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file = new File(path);\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        if (\"r\".equals(mode)) {\n            return ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, ParcelFileDescriptor.parseMode(mode),\n                        mHandler, new OnCloseListener() {\n                            @Override\n                            public void onClose(IOException e) {\n                                final ContentValues values = new ContentValues();\n                                values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                                values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                        System.currentTimeMillis());\n                                update(uri, values, null, null);\n                            }\n                        });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 109;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    private Handler mHandler;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mHandler = new Handler();\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        // start the DownloadService class. don't wait for the 1st download to be issued.\n        // saves us by getting some initialization code in DownloadService out of the way.\n        Context context = getContext();\n        context.startService(new Intent(context, DownloadService.class));\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingOrSelfPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need WRITE_EXTERNAL_STORAGE permission to use DESTINATION_FILE_URI\");\n                checkFileUriDestination(values);\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        notifyContentChanged(uri, match);\n\n        // Always start service to handle notifications and/or scanning\n        final Context context = getContext();\n        context.startService(new Intent(context, DownloadService.class));\n\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n        try {\n            final String canonicalPath = new File(path).getCanonicalPath();\n            final String externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();\n            if (!canonicalPath.startsWith(externalPath)) {\n                throw new SecurityException(\"Destination must be on external storage: \" + uri);\n            }\n        } catch (IOException e) {\n            throw new SecurityException(\"Problem resolving path: \" + uri);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean startService = false;\n\n        if (values.containsKey(Downloads.Impl.COLUMN_DELETED)) {\n            if (values.getAsInteger(Downloads.Impl.COLUMN_DELETED) == 1) {\n                // some rows are to be 'deleted'. need to start DownloadService.\n                startService = true;\n            }\n        }\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                startService = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = null;\n                try {\n                    c = query(uri, new String[]\n                            { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                    if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                        values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                    }\n                } finally {\n                    IoUtils.closeQuietly(c);\n                }\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                startService = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                if (filteredValues.size() > 0) {\n                    count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                            selection.getParameters());\n                } else {\n                    count = 0;\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        if (startService) {\n            Context context = getContext();\n            context.startService(new Intent(context, DownloadService.class));\n        }\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where,\n            final String[] whereArgs) {\n\n        if (shouldRestrictVisibility()) {\n            Helpers.validateSelection(where, sAppReadableColumnsSet);\n        }\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n\n                final Cursor cursor = db.query(DB_TABLE, new String[] {\n                        Downloads.Impl._ID }, selection.getSelection(), selection.getParameters(),\n                        null, null, null);\n                try {\n                    while (cursor.moveToNext()) {\n                        final long id = cursor.getLong(0);\n                        DownloadStorageProvider.onDownloadProviderDelete(getContext(), id);\n                    }\n                } finally {\n                    IoUtils.closeQuietly(cursor);\n                }\n\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        final Cursor cursor = query(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_STATUS,\n                Downloads.Impl.COLUMN_DESTINATION, Downloads.Impl.COLUMN_MEDIA_SCANNED }, null,\n                null, null);\n        final String path;\n        final boolean shouldScan;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            if (cursor.moveToFirst()) {\n                final int status = cursor.getInt(1);\n                final int destination = cursor.getInt(2);\n                final int mediaScanned = cursor.getInt(3);\n\n                path = cursor.getString(0);\n                shouldScan = Downloads.Impl.isStatusSuccess(status) && (\n                        destination == Downloads.Impl.DESTINATION_EXTERNAL\n                        || destination == Downloads.Impl.DESTINATION_FILE_URI\n                        || destination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                        && mediaScanned != 2;\n            } else {\n                throw new FileNotFoundException(\"Failed moveToFirst\");\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n\n        final File file = new File(path);\n        if (!Helpers.isFilenameValid(getContext(), file)) {\n            throw new FileNotFoundException(\"Invalid file: \" + file);\n        }\n\n        final int pfdMode = ParcelFileDescriptor.parseMode(mode);\n        if (pfdMode == ParcelFileDescriptor.MODE_READ_ONLY) {\n            return ParcelFileDescriptor.open(file, pfdMode);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                return ParcelFileDescriptor.open(file, pfdMode, mHandler, new OnCloseListener() {\n                    @Override\n                    public void onClose(IOException e) {\n                        final ContentValues values = new ContentValues();\n                        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                System.currentTimeMillis());\n                        update(uri, values, null, null);\n\n                        if (shouldScan) {\n                            final Intent intent = new Intent(\n                                    Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);\n                            intent.setData(Uri.fromFile(file));\n                            getContext().sendBroadcast(intent);\n                        }\n                    }\n                });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    do {\n                        Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                    } while(cursor.moveToNext());\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            try {\n                if (!cursor.moveToFirst()) {\n                    Log.v(Constants.TAG, \"empty cursor in openFile\");\n                } else {\n                    String filename = cursor.getString(0);\n                    Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                    if (new java.io.File(filename).isFile()) {\n                        Log.v(Constants.TAG, \"file exists in openFile\");\n                    }\n                }\n            } finally {\n                cursor.close();\n            }\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","lineNo":1228}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.STATUS_BAD_REQUEST;\nimport static android.provider.Downloads.Impl.STATUS_CANNOT_RESUME;\nimport static android.provider.Downloads.Impl.STATUS_FILE_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_HTTP_DATA_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_SUCCESS;\nimport static android.provider.Downloads.Impl.STATUS_TOO_MANY_REDIRECTS;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_TO_RETRY;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\nimport static com.android.providers.downloads.Constants.TAG;\nimport static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\nimport static java.net.HttpURLConnection.HTTP_UNAVAILABLE;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.drm.DrmManagerClient;\nimport android.drm.DrmOutputStream;\nimport android.net.ConnectivityManager;\nimport android.net.INetworkPolicyListener;\nimport android.net.NetworkInfo;\nimport android.net.NetworkPolicyManager;\nimport android.net.TrafficStats;\nimport android.os.FileUtils;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.os.WorkSource;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Pair;\n\nimport com.android.providers.downloads.DownloadInfo.NetworkState;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\n/**\n * Task which executes a given {@link DownloadInfo}: making network requests,\n * persisting data to disk, and updating {@link DownloadProvider}.\n */\npublic class DownloadThread implements Runnable {\n\n    // TODO: bind each download to a specific network interface to avoid state\n    // checking races once we have ConnectivityManager API\n\n    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    private static final int HTTP_TEMP_REDIRECT = 307;\n\n    private static final int DEFAULT_TIMEOUT = (int) (20 * SECOND_IN_MILLIS);\n\n    private final Context mContext;\n    private final DownloadInfo mInfo;\n    private final SystemFacade mSystemFacade;\n    private final StorageManager mStorageManager;\n    private final DownloadNotifier mNotifier;\n\n    private volatile boolean mPolicyDirty;\n\n    public DownloadThread(Context context, SystemFacade systemFacade, DownloadInfo info,\n            StorageManager storageManager, DownloadNotifier notifier) {\n        mContext = context;\n        mSystemFacade = systemFacade;\n        mInfo = info;\n        mStorageManager = storageManager;\n        mNotifier = notifier;\n    }\n\n    /**\n     * Returns the user agent provided by the initiating app, or use the default one\n     */\n    private String userAgent() {\n        String userAgent = mInfo.mUserAgent;\n        if (userAgent == null) {\n            userAgent = Constants.DEFAULT_USER_AGENT;\n        }\n        return userAgent;\n    }\n\n    /**\n     * State for the entire run() method.\n     */\n    static class State {\n        public String mFilename;\n        public String mMimeType;\n        public int mRetryAfter = 0;\n        public boolean mGotData = false;\n        public String mRequestUri;\n        public long mTotalBytes = -1;\n        public long mCurrentBytes = 0;\n        public String mHeaderETag;\n        public boolean mContinuingDownload = false;\n        public long mBytesNotified = 0;\n        public long mTimeLastNotification = 0;\n        public int mNetworkType = ConnectivityManager.TYPE_NONE;\n\n        /** Historical bytes/second speed of this download. */\n        public long mSpeed;\n        /** Time when current sample started. */\n        public long mSpeedSampleStart;\n        /** Bytes transferred since current sample started. */\n        public long mSpeedSampleBytes;\n\n        public long mContentLength = -1;\n        public String mContentDisposition;\n        public String mContentLocation;\n\n        public int mRedirectionCount;\n        public URL mUrl;\n\n        public State(DownloadInfo info) {\n            mMimeType = Intent.normalizeMimeType(info.mMimeType);\n            mRequestUri = info.mUri;\n            mFilename = info.mFileName;\n            mTotalBytes = info.mTotalBytes;\n            mCurrentBytes = info.mCurrentBytes;\n        }\n\n        public void resetBeforeExecute() {\n            // Reset any state from previous execution\n            mContentLength = -1;\n            mContentDisposition = null;\n            mContentLocation = null;\n            mRedirectionCount = 0;\n        }\n    }\n\n    @Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        try {\n            runInternal();\n        } finally {\n            mNotifier.notifyDownloadSpeed(mInfo.mId, 0);\n        }\n    }\n\n    private void runInternal() {\n        // Skip when download already marked as finished; this download was\n        // probably started again while racing with UpdateThread.\n        if (DownloadInfo.queryDownloadStatus(mContext.getContentResolver(), mInfo.mId)\n                == Downloads.Impl.STATUS_SUCCESS) {\n            Log.d(TAG, \"Download \" + mInfo.mId + \" already finished; skipping\");\n            return;\n        }\n\n        State state = new State(mInfo);\n        PowerManager.WakeLock wakeLock = null;\n        int finalStatus = Downloads.Impl.STATUS_UNKNOWN_ERROR;\n        int numFailed = mInfo.mNumFailed;\n        String errorMsg = null;\n\n        final NetworkPolicyManager netPolicy = NetworkPolicyManager.from(mContext);\n        final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n\n        try {\n            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, Constants.TAG);\n            wakeLock.setWorkSource(new WorkSource(mInfo.mUid));\n            wakeLock.acquire();\n\n            // while performing download, register for rules updates\n            netPolicy.registerListener(mPolicyListener);\n\n            Log.i(Constants.TAG, \"Download \" + mInfo.mId + \" starting\");\n\n            // Remember which network this download started on; used to\n            // determine if errors were due to network changes.\n            final NetworkInfo info = mSystemFacade.getActiveNetworkInfo(mInfo.mUid);\n            if (info != null) {\n                state.mNetworkType = info.getType();\n            }\n\n            // Network traffic on this thread should be counted against the\n            // requesting UID, and is tagged with well-known value.\n            TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_DOWNLOAD);\n            TrafficStats.setThreadStatsUid(mInfo.mUid);\n\n            try {\n                // TODO: migrate URL sanity checking into client side of API\n                state.mUrl = new URL(state.mRequestUri);\n            } catch (MalformedURLException e) {\n                throw new StopRequestException(STATUS_BAD_REQUEST, e);\n            }\n\n            executeDownload(state);\n\n            finalizeDestinationFile(state);\n            finalStatus = Downloads.Impl.STATUS_SUCCESS;\n        } catch (StopRequestException error) {\n            // remove the cause before printing, in case it contains PII\n            errorMsg = error.getMessage();\n            String msg = \"Aborting request for download \" + mInfo.mId + \": \" + errorMsg;\n            Log.w(Constants.TAG, msg);\n            if (Constants.LOGV) {\n                Log.w(Constants.TAG, msg, error);\n            }\n            finalStatus = error.getFinalStatus();\n\n            // Nobody below our level should request retries, since we handle\n            // failure counts at this level.\n            if (finalStatus == STATUS_WAITING_TO_RETRY) {\n                throw new IllegalStateException(\"Execution should always throw final error codes\");\n            }\n\n            // Some errors should be retryable, unless we fail too many times.\n            if (isStatusRetryable(finalStatus)) {\n                if (state.mGotData) {\n                    numFailed = 1;\n                } else {\n                    numFailed += 1;\n                }\n\n                if (numFailed < Constants.MAX_RETRIES) {\n                    final NetworkInfo info = mSystemFacade.getActiveNetworkInfo(mInfo.mUid);\n                    if (info != null && info.getType() == state.mNetworkType\n                            && info.isConnected()) {\n                        // Underlying network is still intact, use normal backoff\n                        finalStatus = STATUS_WAITING_TO_RETRY;\n                    } else {\n                        // Network changed, retry on any next available\n                        finalStatus = STATUS_WAITING_FOR_NETWORK;\n                    }\n                }\n            }\n\n            // fall through to finally block\n        } catch (Throwable ex) {\n            errorMsg = ex.getMessage();\n            String msg = \"Exception for id \" + mInfo.mId + \": \" + errorMsg;\n            Log.w(Constants.TAG, msg, ex);\n            finalStatus = Downloads.Impl.STATUS_UNKNOWN_ERROR;\n            // falls through to the code that reports an error\n        } finally {\n            if (finalStatus == STATUS_SUCCESS) {\n                TrafficStats.incrementOperationCount(1);\n            }\n\n            TrafficStats.clearThreadStatsTag();\n            TrafficStats.clearThreadStatsUid();\n\n            cleanupDestination(state, finalStatus);\n            notifyDownloadCompleted(state, finalStatus, errorMsg, numFailed);\n\n            Log.i(Constants.TAG, \"Download \" + mInfo.mId + \" finished with status \"\n                    + Downloads.Impl.statusToString(finalStatus));\n\n            netPolicy.unregisterListener(mPolicyListener);\n\n            if (wakeLock != null) {\n                wakeLock.release();\n                wakeLock = null;\n            }\n        }\n        mStorageManager.incrementNumDownloadsSoFar();\n    }\n\n    /**\n     * Fully execute a single download request. Setup and send the request,\n     * handle the response, and transfer the data to the destination file.\n     */\n    private void executeDownload(State state) throws StopRequestException {\n        state.resetBeforeExecute();\n        setupDestinationFile(state);\n\n        // skip when already finished; remove after fixing race in 5217390\n        if (state.mCurrentBytes == state.mTotalBytes) {\n            Log.i(Constants.TAG, \"Skipping initiating request for download \" +\n                  mInfo.mId + \"; already completed\");\n            return;\n        }\n\n        while (state.mRedirectionCount++ < Constants.MAX_REDIRECTS) {\n            // Open connection and follow any redirects until we have a useful\n            // response with body.\n            HttpURLConnection conn = null;\n            try {\n                checkConnectivity();\n                conn = (HttpURLConnection) state.mUrl.openConnection();\n                conn.setInstanceFollowRedirects(false);\n                conn.setConnectTimeout(DEFAULT_TIMEOUT);\n                conn.setReadTimeout(DEFAULT_TIMEOUT);\n\n                addRequestHeaders(state, conn);\n\n                final int responseCode = conn.getResponseCode();\n                switch (responseCode) {\n                    case HTTP_OK:\n                        if (state.mContinuingDownload) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected partial, but received OK\");\n                        }\n                        processResponseHeaders(state, conn);\n                        transferData(state, conn);\n                        return;\n\n                    case HTTP_PARTIAL:\n                        if (!state.mContinuingDownload) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected OK, but received partial\");\n                        }\n                        transferData(state, conn);\n                        return;\n\n                    case HTTP_MOVED_PERM:\n                    case HTTP_MOVED_TEMP:\n                    case HTTP_SEE_OTHER:\n                    case HTTP_TEMP_REDIRECT:\n                        final String location = conn.getHeaderField(\"Location\");\n                        state.mUrl = new URL(state.mUrl, location);\n                        if (responseCode == HTTP_MOVED_PERM) {\n                            // Push updated URL back to database\n                            state.mRequestUri = state.mUrl.toString();\n                        }\n                        continue;\n\n                    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Requested range not satisfiable\");\n\n                    case HTTP_UNAVAILABLE:\n                        parseRetryAfterHeaders(state, conn);\n                        throw new StopRequestException(\n                                HTTP_UNAVAILABLE, conn.getResponseMessage());\n\n                    case HTTP_INTERNAL_ERROR:\n                        throw new StopRequestException(\n                                HTTP_INTERNAL_ERROR, conn.getResponseMessage());\n\n                    default:\n                        StopRequestException.throwUnhandledHttpError(\n                                responseCode, conn.getResponseMessage());\n                }\n            } catch (IOException e) {\n                // Trouble with low-level sockets\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        }\n\n        throw new StopRequestException(STATUS_TOO_MANY_REDIRECTS, \"Too many redirects\");\n    }\n\n    /**\n     * Transfer data from the given connection to the destination file.\n     */\n    private void transferData(State state, HttpURLConnection conn) throws StopRequestException {\n        DrmManagerClient drmClient = null;\n        InputStream in = null;\n        OutputStream out = null;\n        FileDescriptor outFd = null;\n        try {\n            try {\n                in = conn.getInputStream();\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n            }\n\n            try {\n                if (DownloadDrmHelper.isDrmConvertNeeded(state.mMimeType)) {\n                    drmClient = new DrmManagerClient(mContext);\n                    final RandomAccessFile file = new RandomAccessFile(\n                            new File(state.mFilename), \"rw\");\n                    out = new DrmOutputStream(drmClient, file, state.mMimeType);\n                    outFd = file.getFD();\n                } else {\n                    out = new FileOutputStream(state.mFilename, true);\n                    outFd = ((FileOutputStream) out).getFD();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n            // Start streaming data, periodically watch for pause/cancel\n            // commands and checking disk space as needed.\n            transferData(state, in, out);\n\n            try {\n                if (out instanceof DrmOutputStream) {\n                    ((DrmOutputStream) out).finish();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n        } finally {\n            if (drmClient != null) {\n                drmClient.release();\n            }\n\n            IoUtils.closeQuietly(in);\n\n            try {\n                if (out != null) out.flush();\n                if (outFd != null) outFd.sync();\n            } catch (IOException e) {\n            } finally {\n                IoUtils.closeQuietly(out);\n            }\n        }\n    }\n\n    /**\n     * Check if current connectivity is valid for this request.\n     */\n    private void checkConnectivity() throws StopRequestException {\n        // checking connectivity will apply current policy\n        mPolicyDirty = false;\n\n        final NetworkState networkUsable = mInfo.checkCanUseNetwork();\n        if (networkUsable != NetworkState.OK) {\n            int status = Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\n            if (networkUsable == NetworkState.UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(true);\n            } else if (networkUsable == NetworkState.RECOMMENDED_UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(false);\n            }\n            throw new StopRequestException(status, networkUsable.name());\n        }\n    }\n\n    /**\n     * Transfer as much data as possible from the HTTP response to the\n     * destination file.\n     */\n    private void transferData(State state, InputStream in, OutputStream out)\n            throws StopRequestException {\n        final byte data[] = new byte[Constants.BUFFER_SIZE];\n        for (;;) {\n            int bytesRead = readFromResponse(state, data, in);\n            if (bytesRead == -1) { // success, end of stream already reached\n                handleEndOfStream(state);\n                return;\n            }\n\n            state.mGotData = true;\n            writeDataToDestination(state, data, bytesRead, out);\n            state.mCurrentBytes += bytesRead;\n            reportProgress(state);\n\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"downloaded \" + state.mCurrentBytes + \" for \"\n                      + mInfo.mUri);\n            }\n\n            checkPausedOrCanceled(state);\n        }\n    }\n\n    /**\n     * Called after a successful completion to take any necessary action on the downloaded file.\n     */\n    private void finalizeDestinationFile(State state) {\n        if (state.mFilename != null) {\n            // make sure the file is readable\n            FileUtils.setPermissions(state.mFilename, 0644, -1, -1);\n        }\n    }\n\n    /**\n     * Called just before the thread finishes, regardless of status, to take any necessary action on\n     * the downloaded file.\n     */\n    private void cleanupDestination(State state, int finalStatus) {\n        if (state.mFilename != null && Downloads.Impl.isStatusError(finalStatus)) {\n            if (Constants.LOGVV) {\n                Log.d(TAG, \"cleanupDestination() deleting \" + state.mFilename);\n            }\n            new File(state.mFilename).delete();\n            state.mFilename = null;\n        }\n    }\n\n    /**\n     * Check if the download has been paused or canceled, stopping the request appropriately if it\n     * has been.\n     */\n    private void checkPausedOrCanceled(State state) throws StopRequestException {\n        synchronized (mInfo) {\n            if (mInfo.mControl == Downloads.Impl.CONTROL_PAUSED) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_PAUSED_BY_APP, \"download paused by owner\");\n            }\n            if (mInfo.mStatus == Downloads.Impl.STATUS_CANCELED || mInfo.mDeleted) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANCELED, \"download canceled\");\n            }\n        }\n\n        // if policy has been changed, trigger connectivity check\n        if (mPolicyDirty) {\n            checkConnectivity();\n        }\n    }\n\n    /**\n     * Report download progress through the database if necessary.\n     */\n    private void reportProgress(State state) {\n        final long now = SystemClock.elapsedRealtime();\n\n        final long sampleDelta = now - state.mSpeedSampleStart;\n        if (sampleDelta > 500) {\n            final long sampleSpeed = ((state.mCurrentBytes - state.mSpeedSampleBytes) * 1000)\n                    / sampleDelta;\n\n            if (state.mSpeed == 0) {\n                state.mSpeed = sampleSpeed;\n            } else {\n                state.mSpeed = ((state.mSpeed * 3) + sampleSpeed) / 4;\n            }\n\n            // Only notify once we have a full sample window\n            if (state.mSpeedSampleStart != 0) {\n                mNotifier.notifyDownloadSpeed(mInfo.mId, state.mSpeed);\n            }\n\n            state.mSpeedSampleStart = now;\n            state.mSpeedSampleBytes = state.mCurrentBytes;\n        }\n\n        if (state.mCurrentBytes - state.mBytesNotified > Constants.MIN_PROGRESS_STEP &&\n            now - state.mTimeLastNotification > Constants.MIN_PROGRESS_TIME) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n            state.mBytesNotified = state.mCurrentBytes;\n            state.mTimeLastNotification = now;\n        }\n    }\n\n    /**\n     * Write a data buffer to the destination file.\n     * @param data buffer containing the data to write\n     * @param bytesRead how many bytes to write from the buffer\n     */\n    private void writeDataToDestination(State state, byte[] data, int bytesRead, OutputStream out)\n            throws StopRequestException {\n        mStorageManager.verifySpaceBeforeWritingToFile(\n                mInfo.mDestination, state.mFilename, bytesRead);\n\n        boolean forceVerified = false;\n        while (true) {\n            try {\n                out.write(data, 0, bytesRead);\n                return;\n            } catch (IOException ex) {\n                // TODO: better differentiate between DRM and disk failures\n                if (!forceVerified) {\n                    // couldn't write to file. are we out of space? check.\n                    mStorageManager.verifySpace(mInfo.mDestination, state.mFilename, bytesRead);\n                    forceVerified = true;\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"Failed to write data: \" + ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Called when we've reached the end of the HTTP response stream, to update the database and\n     * check for consistency.\n     */\n    private void handleEndOfStream(State state) throws StopRequestException {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n        if (state.mContentLength == -1) {\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, state.mCurrentBytes);\n        }\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n\n        final boolean lengthMismatched = (state.mContentLength != -1)\n                && (state.mCurrentBytes != state.mContentLength);\n        if (lengthMismatched) {\n            if (cannotResume(state)) {\n                throw new StopRequestException(STATUS_CANNOT_RESUME,\n                        \"mismatched content length; unable to resume\");\n            } else {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR,\n                        \"closed socket before end of file\");\n            }\n        }\n    }\n\n    private boolean cannotResume(State state) {\n        return (state.mCurrentBytes > 0 && !mInfo.mNoIntegrity && state.mHeaderETag == null)\n                || DownloadDrmHelper.isDrmConvertNeeded(state.mMimeType);\n    }\n\n    /**\n     * Read some data from the HTTP response stream, handling I/O errors.\n     * @param data buffer to use to read data\n     * @param entityStream stream for reading the HTTP response entity\n     * @return the number of bytes actually read or -1 if the end of the stream has been reached\n     */\n    private int readFromResponse(State state, byte[] data, InputStream entityStream)\n            throws StopRequestException {\n        try {\n            return entityStream.read(data);\n        } catch (IOException ex) {\n            // TODO: handle stream errors the same as other retries\n            if (\"unexpected end of stream\".equals(ex.getMessage())) {\n                return -1;\n            }\n\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n            if (cannotResume(state)) {\n                throw new StopRequestException(STATUS_CANNOT_RESUME,\n                        \"Failed reading response: \" + ex + \"; unable to resume\", ex);\n            } else {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR,\n                        \"Failed reading response: \" + ex, ex);\n            }\n        }\n    }\n\n    /**\n     * Prepare target file based on given network response. Derives filename and\n     * target size as needed.\n     */\n    private void processResponseHeaders(State state, HttpURLConnection conn)\n            throws StopRequestException {\n        // TODO: fallocate the entire file if header gave us specific length\n\n        readResponseHeaders(state, conn);\n\n        state.mFilename = Helpers.generateSaveFile(\n                mContext,\n                mInfo.mUri,\n                mInfo.mHint,\n                state.mContentDisposition,\n                state.mContentLocation,\n                state.mMimeType,\n                mInfo.mDestination,\n                state.mContentLength,\n                mStorageManager);\n\n        updateDatabaseFromHeaders(state);\n        // check connectivity again now that we know the total size\n        checkConnectivity();\n    }\n\n    /**\n     * Update necessary database fields based on values of HTTP response headers that have been\n     * read.\n     */\n    private void updateDatabaseFromHeaders(State state) {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl._DATA, state.mFilename);\n        if (state.mHeaderETag != null) {\n            values.put(Constants.ETAG, state.mHeaderETag);\n        }\n        if (state.mMimeType != null) {\n            values.put(Downloads.Impl.COLUMN_MIME_TYPE, state.mMimeType);\n        }\n        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, mInfo.mTotalBytes);\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n    }\n\n    /**\n     * Read headers from the HTTP response and store them into local state.\n     */\n    private void readResponseHeaders(State state, HttpURLConnection conn)\n            throws StopRequestException {\n        state.mContentDisposition = conn.getHeaderField(\"Content-Disposition\");\n        state.mContentLocation = conn.getHeaderField(\"Content-Location\");\n\n        if (state.mMimeType == null) {\n            state.mMimeType = Intent.normalizeMimeType(conn.getContentType());\n        }\n\n        state.mHeaderETag = conn.getHeaderField(\"ETag\");\n\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        if (transferEncoding == null) {\n            state.mContentLength = getHeaderFieldLong(conn, \"Content-Length\", -1);\n        } else {\n            Log.i(TAG, \"Ignoring Content-Length since Transfer-Encoding is also defined\");\n            state.mContentLength = -1;\n        }\n\n        state.mTotalBytes = state.mContentLength;\n        mInfo.mTotalBytes = state.mContentLength;\n\n        final boolean noSizeInfo = state.mContentLength == -1\n                && (transferEncoding == null || !transferEncoding.equalsIgnoreCase(\"chunked\"));\n        if (!mInfo.mNoIntegrity && noSizeInfo) {\n            throw new StopRequestException(STATUS_CANNOT_RESUME,\n                    \"can't know size of download, giving up\");\n        }\n    }\n\n    private void parseRetryAfterHeaders(State state, HttpURLConnection conn) {\n        state.mRetryAfter = conn.getHeaderFieldInt(\"Retry-After\", -1);\n        if (state.mRetryAfter < 0) {\n            state.mRetryAfter = 0;\n        } else {\n            if (state.mRetryAfter < Constants.MIN_RETRY_AFTER) {\n                state.mRetryAfter = Constants.MIN_RETRY_AFTER;\n            } else if (state.mRetryAfter > Constants.MAX_RETRY_AFTER) {\n                state.mRetryAfter = Constants.MAX_RETRY_AFTER;\n            }\n            state.mRetryAfter += Helpers.sRandom.nextInt(Constants.MIN_RETRY_AFTER + 1);\n            state.mRetryAfter *= 1000;\n        }\n    }\n\n    /**\n     * Prepare the destination file to receive data.  If the file already exists, we'll set up\n     * appropriately for resumption.\n     */\n    private void setupDestinationFile(State state) throws StopRequestException {\n        if (!TextUtils.isEmpty(state.mFilename)) { // only true if we've already run a thread for this download\n            if (Constants.LOGV) {\n                Log.i(Constants.TAG, \"have run thread before for id: \" + mInfo.mId +\n                        \", and state.mFilename: \" + state.mFilename);\n            }\n            if (!Helpers.isFilenameValid(state.mFilename,\n                    mStorageManager.getDownloadDataDirectory())) {\n                // this should never happen\n                throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                        \"found invalid internal destination filename\");\n            }\n            // We're resuming a download that got interrupted\n            File f = new File(state.mFilename);\n            if (f.exists()) {\n                if (Constants.LOGV) {\n                    Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                            \", and state.mFilename: \" + state.mFilename);\n                }\n                long fileLength = f.length();\n                if (fileLength == 0) {\n                    // The download hadn't actually started, we can restart from scratch\n                    if (Constants.LOGVV) {\n                        Log.d(TAG, \"setupDestinationFile() found fileLength=0, deleting \"\n                                + state.mFilename);\n                    }\n                    f.delete();\n                    state.mFilename = null;\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", BUT starting from scratch again: \");\n                    }\n                } else if (mInfo.mETag == null && !mInfo.mNoIntegrity) {\n                    // This should've been caught upon failure\n                    if (Constants.LOGVV) {\n                        Log.d(TAG, \"setupDestinationFile() unable to resume download, deleting \"\n                                + state.mFilename);\n                    }\n                    f.delete();\n                    throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                            \"Trying to resume a download that can't be resumed\");\n                } else {\n                    // All right, we'll be able to resume this download\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", and starting with file of length: \" + fileLength);\n                    }\n                    state.mCurrentBytes = (int) fileLength;\n                    if (mInfo.mTotalBytes != -1) {\n                        state.mContentLength = mInfo.mTotalBytes;\n                    }\n                    state.mHeaderETag = mInfo.mETag;\n                    state.mContinuingDownload = true;\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", state.mCurrentBytes: \" + state.mCurrentBytes +\n                                \", and setting mContinuingDownload to true: \");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add custom headers for this download to the HTTP request.\n     */\n    private void addRequestHeaders(State state, HttpURLConnection conn) {\n        for (Pair<String, String> header : mInfo.getHeaders()) {\n            conn.addRequestProperty(header.first, header.second);\n        }\n\n        // Only splice in user agent when not already defined\n        if (conn.getRequestProperty(\"User-Agent\") == null) {\n            conn.addRequestProperty(\"User-Agent\", userAgent());\n        }\n\n        // Defeat transparent gzip compression, since it doesn't allow us to\n        // easily resume partial downloads.\n        conn.setRequestProperty(\"Accept-Encoding\", \"identity\");\n\n        if (state.mContinuingDownload) {\n            if (state.mHeaderETag != null) {\n                conn.addRequestProperty(\"If-Match\", state.mHeaderETag);\n            }\n            conn.addRequestProperty(\"Range\", \"bytes=\" + state.mCurrentBytes + \"-\");\n        }\n    }\n\n    /**\n     * Stores information about the completed download, and notifies the initiating application.\n     */\n    private void notifyDownloadCompleted(\n            State state, int finalStatus, String errorMsg, int numFailed) {\n        notifyThroughDatabase(state, finalStatus, errorMsg, numFailed);\n        if (Downloads.Impl.isStatusCompleted(finalStatus)) {\n            mInfo.sendIntentIfRequested();\n        }\n    }\n\n    private void notifyThroughDatabase(\n            State state, int finalStatus, String errorMsg, int numFailed) {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl.COLUMN_STATUS, finalStatus);\n        values.put(Downloads.Impl._DATA, state.mFilename);\n        values.put(Downloads.Impl.COLUMN_MIME_TYPE, state.mMimeType);\n        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, mSystemFacade.currentTimeMillis());\n        values.put(Downloads.Impl.COLUMN_FAILED_CONNECTIONS, numFailed);\n        values.put(Constants.RETRY_AFTER_X_REDIRECT_COUNT, state.mRetryAfter);\n\n        if (!TextUtils.equals(mInfo.mUri, state.mRequestUri)) {\n            values.put(Downloads.Impl.COLUMN_URI, state.mRequestUri);\n        }\n\n        // save the error message. could be useful to developers.\n        if (!TextUtils.isEmpty(errorMsg)) {\n            values.put(Downloads.Impl.COLUMN_ERROR_MSG, errorMsg);\n        }\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n    }\n\n    private INetworkPolicyListener mPolicyListener = new INetworkPolicyListener.Stub() {\n        @Override\n        public void onUidRulesChanged(int uid, int uidRules) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n\n        @Override\n        public void onMeteredIfacesChanged(String[] meteredIfaces) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onRestrictBackgroundChanged(boolean restrictBackground) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n    };\n\n    public static long getHeaderFieldLong(URLConnection conn, String field, long defaultValue) {\n        try {\n            return Long.parseLong(conn.getHeaderField(field));\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Return if given status is eligible to be treated as\n     * {@link android.provider.Downloads.Impl#STATUS_WAITING_TO_RETRY}.\n     */\n    public static boolean isStatusRetryable(int status) {\n        switch (status) {\n            case STATUS_HTTP_DATA_ERROR:\n            case HTTP_UNAVAILABLE:\n            case HTTP_INTERNAL_ERROR:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.provider.Downloads.Impl.STATUS_BAD_REQUEST;\nimport static android.provider.Downloads.Impl.STATUS_CANNOT_RESUME;\nimport static android.provider.Downloads.Impl.STATUS_FILE_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_HTTP_DATA_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_SUCCESS;\nimport static android.provider.Downloads.Impl.STATUS_TOO_MANY_REDIRECTS;\nimport static android.provider.Downloads.Impl.STATUS_UNHANDLED_HTTP_CODE;\nimport static android.provider.Downloads.Impl.STATUS_UNKNOWN_ERROR;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\nimport static android.provider.Downloads.Impl.STATUS_WAITING_TO_RETRY;\nimport static android.text.format.DateUtils.SECOND_IN_MILLIS;\nimport static com.android.providers.downloads.Constants.TAG;\nimport static java.net.HttpURLConnection.HTTP_INTERNAL_ERROR;\nimport static java.net.HttpURLConnection.HTTP_MOVED_PERM;\nimport static java.net.HttpURLConnection.HTTP_MOVED_TEMP;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_PRECON_FAILED;\nimport static java.net.HttpURLConnection.HTTP_SEE_OTHER;\nimport static java.net.HttpURLConnection.HTTP_UNAVAILABLE;\nimport static libcore.io.OsConstants.SEEK_SET;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.drm.DrmManagerClient;\nimport android.drm.DrmOutputStream;\nimport android.net.ConnectivityManager;\nimport android.net.INetworkPolicyListener;\nimport android.net.NetworkInfo;\nimport android.net.NetworkPolicyManager;\nimport android.net.TrafficStats;\nimport android.os.ParcelFileDescriptor;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.os.WorkSource;\nimport android.provider.Downloads;\nimport android.util.Log;\nimport android.util.Pair;\n\nimport com.android.providers.downloads.DownloadInfo.NetworkState;\n\nimport libcore.io.ErrnoException;\nimport libcore.io.IoUtils;\nimport libcore.io.Libcore;\nimport libcore.io.OsConstants;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.ProtocolException;\nimport java.net.URL;\nimport java.net.URLConnection;\n\n/**\n * Task which executes a given {@link DownloadInfo}: making network requests,\n * persisting data to disk, and updating {@link DownloadProvider}.\n * <p>\n * To know if a download is successful, we need to know either the final content\n * length to expect, or the transfer to be chunked. To resume an interrupted\n * download, we need an ETag.\n * <p>\n * Failed network requests are retried several times before giving up. Local\n * disk errors fail immediately and are not retried.\n */\npublic class DownloadThread implements Runnable {\n\n    // TODO: bind each download to a specific network interface to avoid state\n    // checking races once we have ConnectivityManager API\n\n    // TODO: add support for saving to content://\n\n    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n    private static final int HTTP_TEMP_REDIRECT = 307;\n\n    private static final int DEFAULT_TIMEOUT = (int) (20 * SECOND_IN_MILLIS);\n\n    private final Context mContext;\n    private final SystemFacade mSystemFacade;\n    private final DownloadNotifier mNotifier;\n\n    private final long mId;\n\n    /**\n     * Info object that should be treated as read-only. Any potentially mutated\n     * fields are tracked in {@link #mInfoDelta}. If a field exists in\n     * {@link #mInfoDelta}, it must not be read from {@link #mInfo}.\n     */\n    private final DownloadInfo mInfo;\n    private final DownloadInfoDelta mInfoDelta;\n\n    private volatile boolean mPolicyDirty;\n\n    /**\n     * Local changes to {@link DownloadInfo}. These are kept local to avoid\n     * racing with the thread that updates based on change notifications.\n     */\n    private class DownloadInfoDelta {\n        public String mUri;\n        public String mFileName;\n        public String mMimeType;\n        public int mStatus;\n        public int mNumFailed;\n        public int mRetryAfter;\n        public long mTotalBytes;\n        public long mCurrentBytes;\n        public String mETag;\n\n        public String mErrorMsg;\n\n        public DownloadInfoDelta(DownloadInfo info) {\n            mUri = info.mUri;\n            mFileName = info.mFileName;\n            mMimeType = info.mMimeType;\n            mStatus = info.mStatus;\n            mNumFailed = info.mNumFailed;\n            mRetryAfter = info.mRetryAfter;\n            mTotalBytes = info.mTotalBytes;\n            mCurrentBytes = info.mCurrentBytes;\n            mETag = info.mETag;\n        }\n\n        /**\n         * Push update of current delta values to provider.\n         */\n        public void writeToDatabase() {\n            final ContentValues values = new ContentValues();\n\n            values.put(Downloads.Impl.COLUMN_URI, mUri);\n            values.put(Downloads.Impl._DATA, mFileName);\n            values.put(Downloads.Impl.COLUMN_MIME_TYPE, mMimeType);\n            values.put(Downloads.Impl.COLUMN_STATUS, mStatus);\n            values.put(Downloads.Impl.COLUMN_FAILED_CONNECTIONS, mNumFailed);\n            values.put(Constants.RETRY_AFTER_X_REDIRECT_COUNT, mRetryAfter);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, mTotalBytes);\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, mCurrentBytes);\n            values.put(Constants.ETAG, mETag);\n\n            values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, mSystemFacade.currentTimeMillis());\n            values.put(Downloads.Impl.COLUMN_ERROR_MSG, mErrorMsg);\n\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n        }\n    }\n\n    /**\n     * Flag indicating if we've made forward progress transferring file data\n     * from a remote server.\n     */\n    private boolean mMadeProgress = false;\n\n    /**\n     * Details from the last time we pushed a database update.\n     */\n    private long mLastUpdateBytes = 0;\n    private long mLastUpdateTime = 0;\n\n    private int mNetworkType = ConnectivityManager.TYPE_NONE;\n\n    /** Historical bytes/second speed of this download. */\n    private long mSpeed;\n    /** Time when current sample started. */\n    private long mSpeedSampleStart;\n    /** Bytes transferred since current sample started. */\n    private long mSpeedSampleBytes;\n\n    public DownloadThread(Context context, SystemFacade systemFacade, DownloadNotifier notifier,\n            DownloadInfo info) {\n        mContext = context;\n        mSystemFacade = systemFacade;\n        mNotifier = notifier;\n\n        mId = info.mId;\n        mInfo = info;\n        mInfoDelta = new DownloadInfoDelta(info);\n    }\n\n    @Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n\n        // Skip when download already marked as finished; this download was\n        // probably started again while racing with UpdateThread.\n        if (DownloadInfo.queryDownloadStatus(mContext.getContentResolver(), mId)\n                == Downloads.Impl.STATUS_SUCCESS) {\n            logDebug(\"Already finished; skipping\");\n            return;\n        }\n\n        final NetworkPolicyManager netPolicy = NetworkPolicyManager.from(mContext);\n        PowerManager.WakeLock wakeLock = null;\n        final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n\n        try {\n            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, Constants.TAG);\n            wakeLock.setWorkSource(new WorkSource(mInfo.mUid));\n            wakeLock.acquire();\n\n            // while performing download, register for rules updates\n            netPolicy.registerListener(mPolicyListener);\n\n            logDebug(\"Starting\");\n\n            // Remember which network this download started on; used to\n            // determine if errors were due to network changes.\n            final NetworkInfo info = mSystemFacade.getActiveNetworkInfo(mInfo.mUid);\n            if (info != null) {\n                mNetworkType = info.getType();\n            }\n\n            // Network traffic on this thread should be counted against the\n            // requesting UID, and is tagged with well-known value.\n            TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_DOWNLOAD);\n            TrafficStats.setThreadStatsUid(mInfo.mUid);\n\n            executeDownload();\n\n            mInfoDelta.mStatus = STATUS_SUCCESS;\n            TrafficStats.incrementOperationCount(1);\n\n            // If we just finished a chunked file, record total size\n            if (mInfoDelta.mTotalBytes == -1) {\n                mInfoDelta.mTotalBytes = mInfoDelta.mCurrentBytes;\n            }\n\n        } catch (StopRequestException e) {\n            mInfoDelta.mStatus = e.getFinalStatus();\n            mInfoDelta.mErrorMsg = e.getMessage();\n\n            logWarning(\"Stop requested with status \"\n                    + Downloads.Impl.statusToString(mInfoDelta.mStatus) + \": \"\n                    + mInfoDelta.mErrorMsg);\n\n            // Nobody below our level should request retries, since we handle\n            // failure counts at this level.\n            if (mInfoDelta.mStatus == STATUS_WAITING_TO_RETRY) {\n                throw new IllegalStateException(\"Execution should always throw final error codes\");\n            }\n\n            // Some errors should be retryable, unless we fail too many times.\n            if (isStatusRetryable(mInfoDelta.mStatus)) {\n                if (mMadeProgress) {\n                    mInfoDelta.mNumFailed = 1;\n                } else {\n                    mInfoDelta.mNumFailed += 1;\n                }\n\n                if (mInfoDelta.mNumFailed < Constants.MAX_RETRIES) {\n                    final NetworkInfo info = mSystemFacade.getActiveNetworkInfo(mInfo.mUid);\n                    if (info != null && info.getType() == mNetworkType && info.isConnected()) {\n                        // Underlying network is still intact, use normal backoff\n                        mInfoDelta.mStatus = STATUS_WAITING_TO_RETRY;\n                    } else {\n                        // Network changed, retry on any next available\n                        mInfoDelta.mStatus = STATUS_WAITING_FOR_NETWORK;\n                    }\n\n                    if ((mInfoDelta.mETag == null && mMadeProgress)\n                            || DownloadDrmHelper.isDrmConvertNeeded(mInfoDelta.mMimeType)) {\n                        // However, if we wrote data and have no ETag to verify\n                        // contents against later, we can't actually resume.\n                        mInfoDelta.mStatus = STATUS_CANNOT_RESUME;\n                    }\n                }\n            }\n\n        } catch (Throwable t) {\n            mInfoDelta.mStatus = STATUS_UNKNOWN_ERROR;\n            mInfoDelta.mErrorMsg = t.toString();\n\n            logError(\"Failed: \" + mInfoDelta.mErrorMsg, t);\n\n        } finally {\n            logDebug(\"Finished with status \" + Downloads.Impl.statusToString(mInfoDelta.mStatus));\n\n            mNotifier.notifyDownloadSpeed(mId, 0);\n\n            finalizeDestination();\n\n            mInfoDelta.writeToDatabase();\n\n            if (Downloads.Impl.isStatusCompleted(mInfoDelta.mStatus)) {\n                mInfo.sendIntentIfRequested();\n            }\n\n            TrafficStats.clearThreadStatsTag();\n            TrafficStats.clearThreadStatsUid();\n\n            netPolicy.unregisterListener(mPolicyListener);\n\n            if (wakeLock != null) {\n                wakeLock.release();\n                wakeLock = null;\n            }\n        }\n    }\n\n    /**\n     * Fully execute a single download request. Setup and send the request,\n     * handle the response, and transfer the data to the destination file.\n     */\n    private void executeDownload() throws StopRequestException {\n        final boolean resuming = mInfoDelta.mCurrentBytes != 0;\n\n        URL url;\n        try {\n            // TODO: migrate URL sanity checking into client side of API\n            url = new URL(mInfoDelta.mUri);\n        } catch (MalformedURLException e) {\n            throw new StopRequestException(STATUS_BAD_REQUEST, e);\n        }\n\n        int redirectionCount = 0;\n        while (redirectionCount++ < Constants.MAX_REDIRECTS) {\n            // Open connection and follow any redirects until we have a useful\n            // response with body.\n            HttpURLConnection conn = null;\n            try {\n                checkConnectivity();\n                conn = (HttpURLConnection) url.openConnection();\n                conn.setInstanceFollowRedirects(false);\n                conn.setConnectTimeout(DEFAULT_TIMEOUT);\n                conn.setReadTimeout(DEFAULT_TIMEOUT);\n\n                addRequestHeaders(conn, resuming);\n\n                final int responseCode = conn.getResponseCode();\n                switch (responseCode) {\n                    case HTTP_OK:\n                        if (resuming) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected partial, but received OK\");\n                        }\n                        parseOkHeaders(conn);\n                        transferData(conn);\n                        return;\n\n                    case HTTP_PARTIAL:\n                        if (!resuming) {\n                            throw new StopRequestException(\n                                    STATUS_CANNOT_RESUME, \"Expected OK, but received partial\");\n                        }\n                        transferData(conn);\n                        return;\n\n                    case HTTP_MOVED_PERM:\n                    case HTTP_MOVED_TEMP:\n                    case HTTP_SEE_OTHER:\n                    case HTTP_TEMP_REDIRECT:\n                        final String location = conn.getHeaderField(\"Location\");\n                        url = new URL(url, location);\n                        if (responseCode == HTTP_MOVED_PERM) {\n                            // Push updated URL back to database\n                            mInfoDelta.mUri = url.toString();\n                        }\n                        continue;\n\n                    case HTTP_PRECON_FAILED:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Precondition failed\");\n\n                    case HTTP_REQUESTED_RANGE_NOT_SATISFIABLE:\n                        throw new StopRequestException(\n                                STATUS_CANNOT_RESUME, \"Requested range not satisfiable\");\n\n                    case HTTP_UNAVAILABLE:\n                        parseUnavailableHeaders(conn);\n                        throw new StopRequestException(\n                                HTTP_UNAVAILABLE, conn.getResponseMessage());\n\n                    case HTTP_INTERNAL_ERROR:\n                        throw new StopRequestException(\n                                HTTP_INTERNAL_ERROR, conn.getResponseMessage());\n\n                    default:\n                        StopRequestException.throwUnhandledHttpError(\n                                responseCode, conn.getResponseMessage());\n                }\n\n            } catch (IOException e) {\n                if (e instanceof ProtocolException\n                        && e.getMessage().startsWith(\"Unexpected status line\")) {\n                    throw new StopRequestException(STATUS_UNHANDLED_HTTP_CODE, e);\n                } else {\n                    // Trouble with low-level sockets\n                    throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n                }\n\n            } finally {\n                if (conn != null) conn.disconnect();\n            }\n        }\n\n        throw new StopRequestException(STATUS_TOO_MANY_REDIRECTS, \"Too many redirects\");\n    }\n\n    /**\n     * Transfer data from the given connection to the destination file.\n     */\n    private void transferData(HttpURLConnection conn) throws StopRequestException {\n\n        // To detect when we're really finished, we either need a length or\n        // chunked encoding.\n        final boolean hasLength = mInfoDelta.mTotalBytes != -1;\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        final boolean isChunked = \"chunked\".equalsIgnoreCase(transferEncoding);\n        if (!hasLength && !isChunked) {\n            throw new StopRequestException(\n                    STATUS_CANNOT_RESUME, \"can't know size of download, giving up\");\n        }\n\n        DrmManagerClient drmClient = null;\n        ParcelFileDescriptor outPfd = null;\n        FileDescriptor outFd = null;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            try {\n                in = conn.getInputStream();\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_HTTP_DATA_ERROR, e);\n            }\n\n            try {\n                outPfd = mContext.getContentResolver()\n                        .openFileDescriptor(mInfo.getAllDownloadsUri(), \"rw\");\n                outFd = outPfd.getFileDescriptor();\n\n                if (DownloadDrmHelper.isDrmConvertNeeded(mInfoDelta.mMimeType)) {\n                    drmClient = new DrmManagerClient(mContext);\n                    out = new DrmOutputStream(drmClient, outPfd, mInfoDelta.mMimeType);\n                } else {\n                    out = new ParcelFileDescriptor.AutoCloseOutputStream(outPfd);\n                }\n\n                // Pre-flight disk space requirements, when known\n                if (mInfoDelta.mTotalBytes > 0) {\n                    final long curSize = Libcore.os.fstat(outFd).st_size;\n                    final long newBytes = mInfoDelta.mTotalBytes - curSize;\n\n                    StorageUtils.ensureAvailableSpace(mContext, outFd, newBytes);\n\n                    try {\n                        // We found enough space, so claim it for ourselves\n                        Libcore.os.posix_fallocate(outFd, 0, mInfoDelta.mTotalBytes);\n                    } catch (ErrnoException e) {\n                        if (e.errno == OsConstants.ENOTSUP) {\n                            Log.w(TAG, \"fallocate() said ENOTSUP; falling back to ftruncate()\");\n                            Libcore.os.ftruncate(outFd, mInfoDelta.mTotalBytes);\n                        } else {\n                            throw e;\n                        }\n                    }\n                }\n\n                // Move into place to begin writing\n                Libcore.os.lseek(outFd, mInfoDelta.mCurrentBytes, SEEK_SET);\n\n            } catch (ErrnoException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n            // Start streaming data, periodically watch for pause/cancel\n            // commands and checking disk space as needed.\n            transferData(in, out, outFd);\n\n            try {\n                if (out instanceof DrmOutputStream) {\n                    ((DrmOutputStream) out).finish();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n\n        } finally {\n            if (drmClient != null) {\n                drmClient.release();\n            }\n\n            IoUtils.closeQuietly(in);\n\n            try {\n                if (out != null) out.flush();\n                if (outFd != null) outFd.sync();\n            } catch (IOException e) {\n            } finally {\n                IoUtils.closeQuietly(out);\n            }\n        }\n    }\n\n    /**\n     * Transfer as much data as possible from the HTTP response to the\n     * destination file.\n     */\n    private void transferData(InputStream in, OutputStream out, FileDescriptor outFd)\n            throws StopRequestException {\n        final byte buffer[] = new byte[Constants.BUFFER_SIZE];\n        while (true) {\n            checkPausedOrCanceled();\n\n            int len = -1;\n            try {\n                len = in.read(buffer);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        STATUS_HTTP_DATA_ERROR, \"Failed reading response: \" + e, e);\n            }\n\n            if (len == -1) {\n                break;\n            }\n\n            try {\n                // When streaming, ensure space before each write\n                if (mInfoDelta.mTotalBytes == -1) {\n                    final long curSize = Libcore.os.fstat(outFd).st_size;\n                    final long newBytes = (mInfoDelta.mCurrentBytes + len) - curSize;\n\n                    StorageUtils.ensureAvailableSpace(mContext, outFd, newBytes);\n                }\n\n                out.write(buffer, 0, len);\n\n                mMadeProgress = true;\n                mInfoDelta.mCurrentBytes += len;\n\n                updateProgress(outFd);\n\n            } catch (ErrnoException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            } catch (IOException e) {\n                throw new StopRequestException(STATUS_FILE_ERROR, e);\n            }\n        }\n\n        // Finished without error; verify length if known\n        if (mInfoDelta.mTotalBytes != -1 && mInfoDelta.mCurrentBytes != mInfoDelta.mTotalBytes) {\n            throw new StopRequestException(STATUS_HTTP_DATA_ERROR, \"Content length mismatch\");\n        }\n    }\n\n    /**\n     * Called just before the thread finishes, regardless of status, to take any\n     * necessary action on the downloaded file.\n     */\n    private void finalizeDestination() {\n        if (Downloads.Impl.isStatusError(mInfoDelta.mStatus)) {\n            // When error, free up any disk space\n            try {\n                final ParcelFileDescriptor target = mContext.getContentResolver()\n                        .openFileDescriptor(mInfo.getAllDownloadsUri(), \"rw\");\n                try {\n                    Libcore.os.ftruncate(target.getFileDescriptor(), 0);\n                } catch (ErrnoException ignored) {\n                } finally {\n                    IoUtils.closeQuietly(target);\n                }\n            } catch (FileNotFoundException ignored) {\n            }\n\n            // Delete if local file\n            if (mInfoDelta.mFileName != null) {\n                new File(mInfoDelta.mFileName).delete();\n            }\n\n        } else if (Downloads.Impl.isStatusSuccess(mInfoDelta.mStatus)) {\n            // When success, open access if local file\n            if (mInfoDelta.mFileName != null) {\n                try {\n                    // TODO: remove this once PackageInstaller works with content://\n                    Libcore.os.chmod(mInfoDelta.mFileName, 0644);\n                } catch (ErrnoException ignored) {\n                }\n\n                if (mInfo.mDestination != Downloads.Impl.DESTINATION_FILE_URI) {\n                    try {\n                        // Move into final resting place, if needed\n                        final File before = new File(mInfoDelta.mFileName);\n                        final File beforeDir = Helpers.getRunningDestinationDirectory(\n                                mContext, mInfo.mDestination);\n                        final File afterDir = Helpers.getSuccessDestinationDirectory(\n                                mContext, mInfo.mDestination);\n                        if (!beforeDir.equals(afterDir)\n                                && before.getParentFile().equals(beforeDir)) {\n                            final File after = new File(afterDir, before.getName());\n                            if (before.renameTo(after)) {\n                                mInfoDelta.mFileName = after.getAbsolutePath();\n                            }\n                        }\n                    } catch (IOException ignored) {\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Check if current connectivity is valid for this request.\n     */\n    private void checkConnectivity() throws StopRequestException {\n        // checking connectivity will apply current policy\n        mPolicyDirty = false;\n\n        final NetworkState networkUsable = mInfo.checkCanUseNetwork(mInfoDelta.mTotalBytes);\n        if (networkUsable != NetworkState.OK) {\n            int status = Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\n            if (networkUsable == NetworkState.UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(true);\n            } else if (networkUsable == NetworkState.RECOMMENDED_UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(false);\n            }\n            throw new StopRequestException(status, networkUsable.name());\n        }\n    }\n\n    /**\n     * Check if the download has been paused or canceled, stopping the request\n     * appropriately if it has been.\n     */\n    private void checkPausedOrCanceled() throws StopRequestException {\n        synchronized (mInfo) {\n            if (mInfo.mControl == Downloads.Impl.CONTROL_PAUSED) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_PAUSED_BY_APP, \"download paused by owner\");\n            }\n            if (mInfo.mStatus == Downloads.Impl.STATUS_CANCELED || mInfo.mDeleted) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANCELED, \"download canceled\");\n            }\n        }\n\n        // if policy has been changed, trigger connectivity check\n        if (mPolicyDirty) {\n            checkConnectivity();\n        }\n    }\n\n    /**\n     * Report download progress through the database if necessary.\n     */\n    private void updateProgress(FileDescriptor outFd) throws IOException {\n        final long now = SystemClock.elapsedRealtime();\n        final long currentBytes = mInfoDelta.mCurrentBytes;\n\n        final long sampleDelta = now - mSpeedSampleStart;\n        if (sampleDelta > 500) {\n            final long sampleSpeed = ((currentBytes - mSpeedSampleBytes) * 1000)\n                    / sampleDelta;\n\n            if (mSpeed == 0) {\n                mSpeed = sampleSpeed;\n            } else {\n                mSpeed = ((mSpeed * 3) + sampleSpeed) / 4;\n            }\n\n            // Only notify once we have a full sample window\n            if (mSpeedSampleStart != 0) {\n                mNotifier.notifyDownloadSpeed(mId, mSpeed);\n            }\n\n            mSpeedSampleStart = now;\n            mSpeedSampleBytes = currentBytes;\n        }\n\n        final long bytesDelta = currentBytes - mLastUpdateBytes;\n        final long timeDelta = now - mLastUpdateTime;\n        if (bytesDelta > Constants.MIN_PROGRESS_STEP && timeDelta > Constants.MIN_PROGRESS_TIME) {\n            // fsync() to ensure that current progress has been flushed to disk,\n            // so we can always resume based on latest database information.\n            outFd.sync();\n\n            mInfoDelta.writeToDatabase();\n\n            mLastUpdateBytes = currentBytes;\n            mLastUpdateTime = now;\n        }\n    }\n\n    /**\n     * Process response headers from first server response. This derives its\n     * filename, size, and ETag.\n     */\n    private void parseOkHeaders(HttpURLConnection conn) throws StopRequestException {\n        if (mInfoDelta.mFileName == null) {\n            final String contentDisposition = conn.getHeaderField(\"Content-Disposition\");\n            final String contentLocation = conn.getHeaderField(\"Content-Location\");\n\n            try {\n                mInfoDelta.mFileName = Helpers.generateSaveFile(mContext, mInfoDelta.mUri,\n                        mInfo.mHint, contentDisposition, contentLocation, mInfoDelta.mMimeType,\n                        mInfo.mDestination);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_FILE_ERROR, \"Failed to generate filename: \" + e);\n            }\n        }\n\n        if (mInfoDelta.mMimeType == null) {\n            mInfoDelta.mMimeType = Intent.normalizeMimeType(conn.getContentType());\n        }\n\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        if (transferEncoding == null) {\n            mInfoDelta.mTotalBytes = getHeaderFieldLong(conn, \"Content-Length\", -1);\n        } else {\n            mInfoDelta.mTotalBytes = -1;\n        }\n\n        mInfoDelta.mETag = conn.getHeaderField(\"ETag\");\n\n        mInfoDelta.writeToDatabase();\n\n        // Check connectivity again now that we know the total size\n        checkConnectivity();\n    }\n\n    private void parseUnavailableHeaders(HttpURLConnection conn) {\n        long retryAfter = conn.getHeaderFieldInt(\"Retry-After\", -1);\n        if (retryAfter < 0) {\n            retryAfter = 0;\n        } else {\n            if (retryAfter < Constants.MIN_RETRY_AFTER) {\n                retryAfter = Constants.MIN_RETRY_AFTER;\n            } else if (retryAfter > Constants.MAX_RETRY_AFTER) {\n                retryAfter = Constants.MAX_RETRY_AFTER;\n            }\n            retryAfter += Helpers.sRandom.nextInt(Constants.MIN_RETRY_AFTER + 1);\n        }\n\n        mInfoDelta.mRetryAfter = (int) (retryAfter * SECOND_IN_MILLIS);\n    }\n\n    /**\n     * Add custom headers for this download to the HTTP request.\n     */\n    private void addRequestHeaders(HttpURLConnection conn, boolean resuming) {\n        for (Pair<String, String> header : mInfo.getHeaders()) {\n            conn.addRequestProperty(header.first, header.second);\n        }\n\n        // Only splice in user agent when not already defined\n        if (conn.getRequestProperty(\"User-Agent\") == null) {\n            conn.addRequestProperty(\"User-Agent\", mInfo.getUserAgent());\n        }\n\n        // Defeat transparent gzip compression, since it doesn't allow us to\n        // easily resume partial downloads.\n        conn.setRequestProperty(\"Accept-Encoding\", \"identity\");\n\n        if (resuming) {\n            if (mInfoDelta.mETag != null) {\n                conn.addRequestProperty(\"If-Match\", mInfoDelta.mETag);\n            }\n            conn.addRequestProperty(\"Range\", \"bytes=\" + mInfoDelta.mCurrentBytes + \"-\");\n        }\n    }\n\n    private void logDebug(String msg) {\n        Log.d(TAG, \"[\" + mId + \"] \" + msg);\n    }\n\n    private void logWarning(String msg) {\n        Log.w(TAG, \"[\" + mId + \"] \" + msg);\n    }\n\n    private void logError(String msg, Throwable t) {\n        Log.e(TAG, \"[\" + mId + \"] \" + msg, t);\n    }\n\n    private INetworkPolicyListener mPolicyListener = new INetworkPolicyListener.Stub() {\n        @Override\n        public void onUidRulesChanged(int uid, int uidRules) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n\n        @Override\n        public void onMeteredIfacesChanged(String[] meteredIfaces) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onRestrictBackgroundChanged(boolean restrictBackground) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n    };\n\n    private static long getHeaderFieldLong(URLConnection conn, String field, long defaultValue) {\n        try {\n            return Long.parseLong(conn.getHeaderField(field));\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n\n    /**\n     * Return if given status is eligible to be treated as\n     * {@link android.provider.Downloads.Impl#STATUS_WAITING_TO_RETRY}.\n     */\n    public static boolean isStatusRetryable(int status) {\n        switch (status) {\n            case STATUS_HTTP_DATA_ERROR:\n            case HTTP_UNAVAILABLE:\n            case HTTP_INTERNAL_ERROR:\n                return true;\n            default:\n                return false;\n        }\n    }\n}\n","lineNo":671}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.SystemClock;\nimport android.provider.Downloads;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Some helper functions for the download manager\n */\npublic class Helpers {\n    public static Random sRandom = new Random(SystemClock.uptimeMillis());\n\n    /** Regex used to parse content-disposition headers */\n    private static final Pattern CONTENT_DISPOSITION_PATTERN =\n            Pattern.compile(\"attachment;\\\\s*filename\\\\s*=\\\\s*\\\"([^\\\"]*)\\\"\");\n\n    private static final Object sUniqueLock = new Object();\n\n    private Helpers() {\n    }\n\n    /*\n     * Parse the Content-Disposition HTTP Header. The format of the header\n     * is defined here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html\n     * This header provides a filename for content that is going to be\n     * downloaded to the file system. We only support the attachment type.\n     */\n    private static String parseContentDisposition(String contentDisposition) {\n        try {\n            Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);\n            if (m.find()) {\n                return m.group(1);\n            }\n        } catch (IllegalStateException ex) {\n             // This function is defined as returning null when it can't parse the header\n        }\n        return null;\n    }\n\n    /**\n     * Creates a filename (where the file should be saved) from info about a download.\n     */\n    static String generateSaveFile(\n            Context context,\n            String url,\n            String hint,\n            String contentDisposition,\n            String contentLocation,\n            String mimeType,\n            int destination,\n            long contentLength,\n            StorageManager storageManager) throws StopRequestException {\n        if (contentLength < 0) {\n            contentLength = 0;\n        }\n        String path;\n        File base = null;\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            path = Uri.parse(hint).getPath();\n        } else {\n            base = storageManager.locateDestinationDirectory(mimeType, destination,\n                    contentLength);\n            path = chooseFilename(url, hint, contentDisposition, contentLocation,\n                                             destination);\n        }\n        storageManager.verifySpace(destination, path, contentLength);\n        if (DownloadDrmHelper.isDrmConvertNeeded(mimeType)) {\n            path = DownloadDrmHelper.modifyDrmFwLockFileExtension(path);\n        }\n        path = getFullPath(path, mimeType, destination, base);\n        return path;\n    }\n\n    static String getFullPath(String filename, String mimeType, int destination, File base)\n            throws StopRequestException {\n        String extension = null;\n        int dotIndex = filename.lastIndexOf('.');\n        boolean missingExtension = dotIndex < 0 || dotIndex < filename.lastIndexOf('/');\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            // Destination is explicitly set - do not change the extension\n            if (missingExtension) {\n                extension = \"\";\n            } else {\n                extension = filename.substring(dotIndex);\n                filename = filename.substring(0, dotIndex);\n            }\n        } else {\n            // Split filename between base and extension\n            // Add an extension if filename does not have one\n            if (missingExtension) {\n                extension = chooseExtensionFromMimeType(mimeType, true);\n            } else {\n                extension = chooseExtensionFromFilename(mimeType, destination, filename, dotIndex);\n                filename = filename.substring(0, dotIndex);\n            }\n        }\n\n        boolean recoveryDir = Constants.RECOVERY_DIRECTORY.equalsIgnoreCase(filename + extension);\n\n        if (base != null) {\n            filename = base.getPath() + File.separator + filename;\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"target file: \" + filename + extension);\n        }\n\n        synchronized (sUniqueLock) {\n            final String path = chooseUniqueFilenameLocked(\n                    destination, filename, extension, recoveryDir);\n\n            // Claim this filename inside lock to prevent other threads from\n            // clobbering us. We're not paranoid enough to use O_EXCL.\n            try {\n                new File(path).createNewFile();\n            } catch (IOException e) {\n                throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                        \"Failed to create target file \" + path, e);\n            }\n            return path;\n        }\n    }\n\n    private static String chooseFilename(String url, String hint, String contentDisposition,\n            String contentLocation, int destination) {\n        String filename = null;\n\n        // First, try to use the hint from the application, if there's one\n        if (filename == null && hint != null && !hint.endsWith(\"/\")) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"getting filename from hint\");\n            }\n            int index = hint.lastIndexOf('/') + 1;\n            if (index > 0) {\n                filename = hint.substring(index);\n            } else {\n                filename = hint;\n            }\n        }\n\n        // If we couldn't do anything with the hint, move toward the content disposition\n        if (filename == null && contentDisposition != null) {\n            filename = parseContentDisposition(contentDisposition);\n            if (filename != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-disposition\");\n                }\n                int index = filename.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = filename.substring(index);\n                }\n            }\n        }\n\n        // If we still have nothing at this point, try the content location\n        if (filename == null && contentLocation != null) {\n            String decodedContentLocation = Uri.decode(contentLocation);\n            if (decodedContentLocation != null\n                    && !decodedContentLocation.endsWith(\"/\")\n                    && decodedContentLocation.indexOf('?') < 0) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-location\");\n                }\n                int index = decodedContentLocation.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = decodedContentLocation.substring(index);\n                } else {\n                    filename = decodedContentLocation;\n                }\n            }\n        }\n\n        // If all the other http-related approaches failed, use the plain uri\n        if (filename == null) {\n            String decodedUrl = Uri.decode(url);\n            if (decodedUrl != null\n                    && !decodedUrl.endsWith(\"/\") && decodedUrl.indexOf('?') < 0) {\n                int index = decodedUrl.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"getting filename from uri\");\n                    }\n                    filename = decodedUrl.substring(index);\n                }\n            }\n        }\n\n        // Finally, if couldn't get filename from URI, get a generic filename\n        if (filename == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"using default filename\");\n            }\n            filename = Constants.DEFAULT_DL_FILENAME;\n        }\n\n        // The VFAT file system is assumed as target for downloads.\n        // Replace invalid characters according to the specifications of VFAT.\n        filename = replaceInvalidVfatCharacters(filename);\n\n        return filename;\n    }\n\n    private static String chooseExtensionFromMimeType(String mimeType, boolean useDefaults) {\n        String extension = null;\n        if (mimeType != null) {\n            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);\n            if (extension != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding extension from type\");\n                }\n                extension = \".\" + extension;\n            } else {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                }\n            }\n        }\n        if (extension == null) {\n            if (mimeType != null && mimeType.toLowerCase().startsWith(\"text/\")) {\n                if (mimeType.equalsIgnoreCase(\"text/html\")) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default html extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_HTML_EXTENSION;\n                } else if (useDefaults) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default text extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_TEXT_EXTENSION;\n                }\n            } else if (useDefaults) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding default binary extension\");\n                }\n                extension = Constants.DEFAULT_DL_BINARY_EXTENSION;\n            }\n        }\n        return extension;\n    }\n\n    private static String chooseExtensionFromFilename(String mimeType, int destination,\n            String filename, int lastDotIndex) {\n        String extension = null;\n        if (mimeType != null) {\n            // Compare the last segment of the extension against the mime type.\n            // If there's a mismatch, discard the entire extension.\n            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                    filename.substring(lastDotIndex + 1));\n            if (typeFromExt == null || !typeFromExt.equalsIgnoreCase(mimeType)) {\n                extension = chooseExtensionFromMimeType(mimeType, false);\n                if (extension != null) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"substituting extension from type\");\n                    }\n                } else {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                    }\n                }\n            }\n        }\n        if (extension == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"keeping extension\");\n            }\n            extension = filename.substring(lastDotIndex);\n        }\n        return extension;\n    }\n\n    private static String chooseUniqueFilenameLocked(int destination, String filename,\n            String extension, boolean recoveryDir) throws StopRequestException {\n        String fullFilename = filename + extension;\n        if (!new File(fullFilename).exists()\n                && (!recoveryDir ||\n                (destination != Downloads.Impl.DESTINATION_CACHE_PARTITION &&\n                        destination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION &&\n                        destination != Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE &&\n                        destination != Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING))) {\n            return fullFilename;\n        }\n        filename = filename + Constants.FILENAME_SEQUENCE_SEPARATOR;\n        /*\n        * This number is used to generate partially randomized filenames to avoid\n        * collisions.\n        * It starts at 1.\n        * The next 9 iterations increment it by 1 at a time (up to 10).\n        * The next 9 iterations increment it by 1 to 10 (random) at a time.\n        * The next 9 iterations increment it by 1 to 100 (random) at a time.\n        * ... Up to the point where it increases by 100000000 at a time.\n        * (the maximum value that can be reached is 1000000000)\n        * As soon as a number is reached that generates a filename that doesn't exist,\n        *     that filename is used.\n        * If the filename coming in is [base].[ext], the generated filenames are\n        *     [base]-[sequence].[ext].\n        */\n        int sequence = 1;\n        for (int magnitude = 1; magnitude < 1000000000; magnitude *= 10) {\n            for (int iteration = 0; iteration < 9; ++iteration) {\n                fullFilename = filename + sequence + extension;\n                if (!new File(fullFilename).exists()) {\n                    return fullFilename;\n                }\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"file with sequence number \" + sequence + \" exists\");\n                }\n                sequence += sRandom.nextInt(magnitude) + 1;\n            }\n        }\n        throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                \"failed to generate an unused filename on internal download storage\");\n    }\n\n    /**\n     * Checks whether the filename looks legitimate\n     */\n    static boolean isFilenameValid(String filename, File downloadsDataDir) {\n        final String[] whitelist;\n        try {\n            filename = new File(filename).getCanonicalPath();\n            whitelist = new String[] {\n                    downloadsDataDir.getCanonicalPath(),\n                    Environment.getDownloadCacheDirectory().getCanonicalPath(),\n                    Environment.getExternalStorageDirectory().getCanonicalPath(),\n            };\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + e);\n            return false;\n        }\n\n        for (String test : whitelist) {\n            if (filename.startsWith(test)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether this looks like a legitimate selection parameter\n     */\n    public static void validateSelection(String selection, Set<String> allowedColumns) {\n        try {\n            if (selection == null || selection.isEmpty()) {\n                return;\n            }\n            Lexer lexer = new Lexer(selection, allowedColumns);\n            parseExpression(lexer);\n            if (lexer.currentToken() != Lexer.TOKEN_END) {\n                throw new IllegalArgumentException(\"syntax error\");\n            }\n        } catch (RuntimeException ex) {\n            if (Constants.LOGV) {\n                Log.d(Constants.TAG, \"invalid selection [\" + selection + \"] triggered \" + ex);\n            } else if (false) {\n                Log.d(Constants.TAG, \"invalid selection triggered \" + ex);\n            }\n            throw ex;\n        }\n\n    }\n\n    // expression <- ( expression ) | statement [AND_OR ( expression ) | statement] *\n    //             | statement [AND_OR expression]*\n    private static void parseExpression(Lexer lexer) {\n        for (;;) {\n            // ( expression )\n            if (lexer.currentToken() == Lexer.TOKEN_OPEN_PAREN) {\n                lexer.advance();\n                parseExpression(lexer);\n                if (lexer.currentToken() != Lexer.TOKEN_CLOSE_PAREN) {\n                    throw new IllegalArgumentException(\"syntax error, unmatched parenthese\");\n                }\n                lexer.advance();\n            } else {\n                // statement\n                parseStatement(lexer);\n            }\n            if (lexer.currentToken() != Lexer.TOKEN_AND_OR) {\n                break;\n            }\n            lexer.advance();\n        }\n    }\n\n    // statement <- COLUMN COMPARE VALUE\n    //            | COLUMN IS NULL\n    private static void parseStatement(Lexer lexer) {\n        // both possibilities start with COLUMN\n        if (lexer.currentToken() != Lexer.TOKEN_COLUMN) {\n            throw new IllegalArgumentException(\"syntax error, expected column name\");\n        }\n        lexer.advance();\n\n        // statement <- COLUMN COMPARE VALUE\n        if (lexer.currentToken() == Lexer.TOKEN_COMPARE) {\n            lexer.advance();\n            if (lexer.currentToken() != Lexer.TOKEN_VALUE) {\n                throw new IllegalArgumentException(\"syntax error, expected quoted string\");\n            }\n            lexer.advance();\n            return;\n        }\n\n        // statement <- COLUMN IS NULL\n        if (lexer.currentToken() == Lexer.TOKEN_IS) {\n            lexer.advance();\n            if (lexer.currentToken() != Lexer.TOKEN_NULL) {\n                throw new IllegalArgumentException(\"syntax error, expected NULL\");\n            }\n            lexer.advance();\n            return;\n        }\n\n        // didn't get anything good after COLUMN\n        throw new IllegalArgumentException(\"syntax error after column name\");\n    }\n\n    /**\n     * A simple lexer that recognizes the words of our restricted subset of SQL where clauses\n     */\n    private static class Lexer {\n        public static final int TOKEN_START = 0;\n        public static final int TOKEN_OPEN_PAREN = 1;\n        public static final int TOKEN_CLOSE_PAREN = 2;\n        public static final int TOKEN_AND_OR = 3;\n        public static final int TOKEN_COLUMN = 4;\n        public static final int TOKEN_COMPARE = 5;\n        public static final int TOKEN_VALUE = 6;\n        public static final int TOKEN_IS = 7;\n        public static final int TOKEN_NULL = 8;\n        public static final int TOKEN_END = 9;\n\n        private final String mSelection;\n        private final Set<String> mAllowedColumns;\n        private int mOffset = 0;\n        private int mCurrentToken = TOKEN_START;\n        private final char[] mChars;\n\n        public Lexer(String selection, Set<String> allowedColumns) {\n            mSelection = selection;\n            mAllowedColumns = allowedColumns;\n            mChars = new char[mSelection.length()];\n            mSelection.getChars(0, mChars.length, mChars, 0);\n            advance();\n        }\n\n        public int currentToken() {\n            return mCurrentToken;\n        }\n\n        public void advance() {\n            char[] chars = mChars;\n\n            // consume whitespace\n            while (mOffset < chars.length && chars[mOffset] == ' ') {\n                ++mOffset;\n            }\n\n            // end of input\n            if (mOffset == chars.length) {\n                mCurrentToken = TOKEN_END;\n                return;\n            }\n\n            // \"(\"\n            if (chars[mOffset] == '(') {\n                ++mOffset;\n                mCurrentToken = TOKEN_OPEN_PAREN;\n                return;\n            }\n\n            // \")\"\n            if (chars[mOffset] == ')') {\n                ++mOffset;\n                mCurrentToken = TOKEN_CLOSE_PAREN;\n                return;\n            }\n\n            // \"?\"\n            if (chars[mOffset] == '?') {\n                ++mOffset;\n                mCurrentToken = TOKEN_VALUE;\n                return;\n            }\n\n            // \"=\" and \"==\"\n            if (chars[mOffset] == '=') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && chars[mOffset] == '=') {\n                    ++mOffset;\n                }\n                return;\n            }\n\n            // \">\" and \">=\"\n            if (chars[mOffset] == '>') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && chars[mOffset] == '=') {\n                    ++mOffset;\n                }\n                return;\n            }\n\n            // \"<\", \"<=\" and \"<>\"\n            if (chars[mOffset] == '<') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && (chars[mOffset] == '=' || chars[mOffset] == '>')) {\n                    ++mOffset;\n                }\n                return;\n            }\n\n            // \"!=\"\n            if (chars[mOffset] == '!') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && chars[mOffset] == '=') {\n                    ++mOffset;\n                    return;\n                }\n                throw new IllegalArgumentException(\"Unexpected character after !\");\n            }\n\n            // columns and keywords\n            // first look for anything that looks like an identifier or a keyword\n            //     and then recognize the individual words.\n            // no attempt is made at discarding sequences of underscores with no alphanumeric\n            //     characters, even though it's not clear that they'd be legal column names.\n            if (isIdentifierStart(chars[mOffset])) {\n                int startOffset = mOffset;\n                ++mOffset;\n                while (mOffset < chars.length && isIdentifierChar(chars[mOffset])) {\n                    ++mOffset;\n                }\n                String word = mSelection.substring(startOffset, mOffset);\n                if (mOffset - startOffset <= 4) {\n                    if (word.equals(\"IS\")) {\n                        mCurrentToken = TOKEN_IS;\n                        return;\n                    }\n                    if (word.equals(\"OR\") || word.equals(\"AND\")) {\n                        mCurrentToken = TOKEN_AND_OR;\n                        return;\n                    }\n                    if (word.equals(\"NULL\")) {\n                        mCurrentToken = TOKEN_NULL;\n                        return;\n                    }\n                }\n                if (mAllowedColumns.contains(word)) {\n                    mCurrentToken = TOKEN_COLUMN;\n                    return;\n                }\n                throw new IllegalArgumentException(\"unrecognized column or keyword\");\n            }\n\n            // quoted strings\n            if (chars[mOffset] == '\\'') {\n                ++mOffset;\n                while (mOffset < chars.length) {\n                    if (chars[mOffset] == '\\'') {\n                        if (mOffset + 1 < chars.length && chars[mOffset + 1] == '\\'') {\n                            ++mOffset;\n                        } else {\n                            break;\n                        }\n                    }\n                    ++mOffset;\n                }\n                if (mOffset == chars.length) {\n                    throw new IllegalArgumentException(\"unterminated string\");\n                }\n                ++mOffset;\n                mCurrentToken = TOKEN_VALUE;\n                return;\n            }\n\n            // anything we don't recognize\n            throw new IllegalArgumentException(\"illegal character: \" + chars[mOffset]);\n        }\n\n        private static final boolean isIdentifierStart(char c) {\n            return c == '_' ||\n                    (c >= 'A' && c <= 'Z') ||\n                    (c >= 'a' && c <= 'z');\n        }\n\n        private static final boolean isIdentifierChar(char c) {\n            return c == '_' ||\n                    (c >= 'A' && c <= 'Z') ||\n                    (c >= 'a' && c <= 'z') ||\n                    (c >= '0' && c <= '9');\n        }\n    }\n\n    /**\n     * Replace invalid filename characters according to\n     * specifications of the VFAT.\n     * @note Package-private due to testing.\n     */\n    private static String replaceInvalidVfatCharacters(String filename) {\n        final char START_CTRLCODE = 0x00;\n        final char END_CTRLCODE = 0x1f;\n        final char QUOTEDBL = 0x22;\n        final char ASTERISK = 0x2A;\n        final char SLASH = 0x2F;\n        final char COLON = 0x3A;\n        final char LESS = 0x3C;\n        final char GREATER = 0x3E;\n        final char QUESTION = 0x3F;\n        final char BACKSLASH = 0x5C;\n        final char BAR = 0x7C;\n        final char DEL = 0x7F;\n        final char UNDERSCORE = 0x5F;\n\n        StringBuffer sb = new StringBuffer();\n        char ch;\n        boolean isRepetition = false;\n        for (int i = 0; i < filename.length(); i++) {\n            ch = filename.charAt(i);\n            if ((START_CTRLCODE <= ch &&\n                ch <= END_CTRLCODE) ||\n                ch == QUOTEDBL ||\n                ch == ASTERISK ||\n                ch == SLASH ||\n                ch == COLON ||\n                ch == LESS ||\n                ch == GREATER ||\n                ch == QUESTION ||\n                ch == BACKSLASH ||\n                ch == BAR ||\n                ch == DEL){\n                if (!isRepetition) {\n                    sb.append(UNDERSCORE);\n                    isRepetition = true;\n                }\n            } else {\n                sb.append(ch);\n                isRepetition = false;\n            }\n        }\n        return sb.toString();\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.content.Context;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.SystemClock;\nimport android.provider.Downloads;\nimport android.util.Log;\nimport android.webkit.MimeTypeMap;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Some helper functions for the download manager\n */\npublic class Helpers {\n    public static Random sRandom = new Random(SystemClock.uptimeMillis());\n\n    /** Regex used to parse content-disposition headers */\n    private static final Pattern CONTENT_DISPOSITION_PATTERN =\n            Pattern.compile(\"attachment;\\\\s*filename\\\\s*=\\\\s*\\\"([^\\\"]*)\\\"\");\n\n    private static final Object sUniqueLock = new Object();\n\n    private Helpers() {\n    }\n\n    /*\n     * Parse the Content-Disposition HTTP Header. The format of the header\n     * is defined here: http://www.w3.org/Protocols/rfc2616/rfc2616-sec19.html\n     * This header provides a filename for content that is going to be\n     * downloaded to the file system. We only support the attachment type.\n     */\n    private static String parseContentDisposition(String contentDisposition) {\n        try {\n            Matcher m = CONTENT_DISPOSITION_PATTERN.matcher(contentDisposition);\n            if (m.find()) {\n                return m.group(1);\n            }\n        } catch (IllegalStateException ex) {\n             // This function is defined as returning null when it can't parse the header\n        }\n        return null;\n    }\n\n    /**\n     * Creates a filename (where the file should be saved) from info about a download.\n     */\n    static String generateSaveFile(\n            Context context,\n            String url,\n            String hint,\n            String contentDisposition,\n            String contentLocation,\n            String mimeType,\n            int destination,\n            long contentLength,\n            StorageManager storageManager) throws StopRequestException {\n        if (contentLength < 0) {\n            contentLength = 0;\n        }\n        String path;\n        File base = null;\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            path = Uri.parse(hint).getPath();\n        } else {\n            base = storageManager.locateDestinationDirectory(mimeType, destination,\n                    contentLength);\n            path = chooseFilename(url, hint, contentDisposition, contentLocation,\n                                             destination);\n        }\n        storageManager.verifySpace(destination, path, contentLength);\n        if (DownloadDrmHelper.isDrmConvertNeeded(mimeType)) {\n            path = DownloadDrmHelper.modifyDrmFwLockFileExtension(path);\n        }\n        path = getFullPath(path, mimeType, destination, base);\n        return path;\n    }\n\n    static String getFullPath(String filename, String mimeType, int destination, File base)\n            throws StopRequestException {\n        String extension = null;\n        int dotIndex = filename.lastIndexOf('.');\n        boolean missingExtension = dotIndex < 0 || dotIndex < filename.lastIndexOf('/');\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI) {\n            // Destination is explicitly set - do not change the extension\n            if (missingExtension) {\n                extension = \"\";\n            } else {\n                extension = filename.substring(dotIndex);\n                filename = filename.substring(0, dotIndex);\n            }\n        } else {\n            // Split filename between base and extension\n            // Add an extension if filename does not have one\n            if (missingExtension) {\n                extension = chooseExtensionFromMimeType(mimeType, true);\n            } else {\n                extension = chooseExtensionFromFilename(mimeType, destination, filename, dotIndex);\n                filename = filename.substring(0, dotIndex);\n            }\n        }\n\n        boolean recoveryDir = Constants.RECOVERY_DIRECTORY.equalsIgnoreCase(filename + extension);\n\n        if (base != null) {\n            filename = base.getPath() + File.separator + filename;\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"target file: \" + filename + extension);\n        }\n\n        synchronized (sUniqueLock) {\n            final String path = chooseUniqueFilenameLocked(\n                    destination, filename, extension, recoveryDir);\n\n            // Claim this filename inside lock to prevent other threads from\n            // clobbering us. We're not paranoid enough to use O_EXCL.\n            try {\n                File file = new File(path);\n                File parent = file.getParentFile();\n\n                // Make sure the parent directories exists before generates new file\n                if (parent != null && !parent.exists()) {\n                    parent.mkdirs();\n                }\n\n                file.createNewFile();\n            } catch (IOException e) {\n                throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                        \"Failed to create target file \" + path, e);\n            }\n            return path;\n        }\n    }\n\n    private static String chooseFilename(String url, String hint, String contentDisposition,\n            String contentLocation, int destination) {\n        String filename = null;\n\n        // First, try to use the hint from the application, if there's one\n        if (filename == null && hint != null && !hint.endsWith(\"/\")) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"getting filename from hint\");\n            }\n            int index = hint.lastIndexOf('/') + 1;\n            if (index > 0) {\n                filename = hint.substring(index);\n            } else {\n                filename = hint;\n            }\n        }\n\n        // If we couldn't do anything with the hint, move toward the content disposition\n        if (filename == null && contentDisposition != null) {\n            filename = parseContentDisposition(contentDisposition);\n            if (filename != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-disposition\");\n                }\n                int index = filename.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = filename.substring(index);\n                }\n            }\n        }\n\n        // If we still have nothing at this point, try the content location\n        if (filename == null && contentLocation != null) {\n            String decodedContentLocation = Uri.decode(contentLocation);\n            if (decodedContentLocation != null\n                    && !decodedContentLocation.endsWith(\"/\")\n                    && decodedContentLocation.indexOf('?') < 0) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"getting filename from content-location\");\n                }\n                int index = decodedContentLocation.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    filename = decodedContentLocation.substring(index);\n                } else {\n                    filename = decodedContentLocation;\n                }\n            }\n        }\n\n        // If all the other http-related approaches failed, use the plain uri\n        if (filename == null) {\n            String decodedUrl = Uri.decode(url);\n            if (decodedUrl != null\n                    && !decodedUrl.endsWith(\"/\") && decodedUrl.indexOf('?') < 0) {\n                int index = decodedUrl.lastIndexOf('/') + 1;\n                if (index > 0) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"getting filename from uri\");\n                    }\n                    filename = decodedUrl.substring(index);\n                }\n            }\n        }\n\n        // Finally, if couldn't get filename from URI, get a generic filename\n        if (filename == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"using default filename\");\n            }\n            filename = Constants.DEFAULT_DL_FILENAME;\n        }\n\n        // The VFAT file system is assumed as target for downloads.\n        // Replace invalid characters according to the specifications of VFAT.\n        filename = replaceInvalidVfatCharacters(filename);\n\n        return filename;\n    }\n\n    private static String chooseExtensionFromMimeType(String mimeType, boolean useDefaults) {\n        String extension = null;\n        if (mimeType != null) {\n            extension = MimeTypeMap.getSingleton().getExtensionFromMimeType(mimeType);\n            if (extension != null) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding extension from type\");\n                }\n                extension = \".\" + extension;\n            } else {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                }\n            }\n        }\n        if (extension == null) {\n            if (mimeType != null && mimeType.toLowerCase().startsWith(\"text/\")) {\n                if (mimeType.equalsIgnoreCase(\"text/html\")) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default html extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_HTML_EXTENSION;\n                } else if (useDefaults) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"adding default text extension\");\n                    }\n                    extension = Constants.DEFAULT_DL_TEXT_EXTENSION;\n                }\n            } else if (useDefaults) {\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"adding default binary extension\");\n                }\n                extension = Constants.DEFAULT_DL_BINARY_EXTENSION;\n            }\n        }\n        return extension;\n    }\n\n    private static String chooseExtensionFromFilename(String mimeType, int destination,\n            String filename, int lastDotIndex) {\n        String extension = null;\n        if (mimeType != null) {\n            // Compare the last segment of the extension against the mime type.\n            // If there's a mismatch, discard the entire extension.\n            String typeFromExt = MimeTypeMap.getSingleton().getMimeTypeFromExtension(\n                    filename.substring(lastDotIndex + 1));\n            if (typeFromExt == null || !typeFromExt.equalsIgnoreCase(mimeType)) {\n                extension = chooseExtensionFromMimeType(mimeType, false);\n                if (extension != null) {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"substituting extension from type\");\n                    }\n                } else {\n                    if (Constants.LOGVV) {\n                        Log.v(Constants.TAG, \"couldn't find extension for \" + mimeType);\n                    }\n                }\n            }\n        }\n        if (extension == null) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"keeping extension\");\n            }\n            extension = filename.substring(lastDotIndex);\n        }\n        return extension;\n    }\n\n    private static String chooseUniqueFilenameLocked(int destination, String filename,\n            String extension, boolean recoveryDir) throws StopRequestException {\n        String fullFilename = filename + extension;\n        if (!new File(fullFilename).exists()\n                && (!recoveryDir ||\n                (destination != Downloads.Impl.DESTINATION_CACHE_PARTITION &&\n                        destination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION &&\n                        destination != Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE &&\n                        destination != Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING))) {\n            return fullFilename;\n        }\n        filename = filename + Constants.FILENAME_SEQUENCE_SEPARATOR;\n        /*\n        * This number is used to generate partially randomized filenames to avoid\n        * collisions.\n        * It starts at 1.\n        * The next 9 iterations increment it by 1 at a time (up to 10).\n        * The next 9 iterations increment it by 1 to 10 (random) at a time.\n        * The next 9 iterations increment it by 1 to 100 (random) at a time.\n        * ... Up to the point where it increases by 100000000 at a time.\n        * (the maximum value that can be reached is 1000000000)\n        * As soon as a number is reached that generates a filename that doesn't exist,\n        *     that filename is used.\n        * If the filename coming in is [base].[ext], the generated filenames are\n        *     [base]-[sequence].[ext].\n        */\n        int sequence = 1;\n        for (int magnitude = 1; magnitude < 1000000000; magnitude *= 10) {\n            for (int iteration = 0; iteration < 9; ++iteration) {\n                fullFilename = filename + sequence + extension;\n                if (!new File(fullFilename).exists()) {\n                    return fullFilename;\n                }\n                if (Constants.LOGVV) {\n                    Log.v(Constants.TAG, \"file with sequence number \" + sequence + \" exists\");\n                }\n                sequence += sRandom.nextInt(magnitude) + 1;\n            }\n        }\n        throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                \"failed to generate an unused filename on internal download storage\");\n    }\n\n    /**\n     * Checks whether the filename looks legitimate\n     */\n    static boolean isFilenameValid(String filename, File downloadsDataDir) {\n        final String[] whitelist;\n        try {\n            filename = new File(filename).getCanonicalPath();\n            whitelist = new String[] {\n                    downloadsDataDir.getCanonicalPath(),\n                    Environment.getDownloadCacheDirectory().getCanonicalPath(),\n                    Environment.getExternalStorageDirectory().getCanonicalPath(),\n            };\n        } catch (IOException e) {\n            Log.w(TAG, \"Failed to resolve canonical path: \" + e);\n            return false;\n        }\n\n        for (String test : whitelist) {\n            if (filename.startsWith(test)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether this looks like a legitimate selection parameter\n     */\n    public static void validateSelection(String selection, Set<String> allowedColumns) {\n        try {\n            if (selection == null || selection.isEmpty()) {\n                return;\n            }\n            Lexer lexer = new Lexer(selection, allowedColumns);\n            parseExpression(lexer);\n            if (lexer.currentToken() != Lexer.TOKEN_END) {\n                throw new IllegalArgumentException(\"syntax error\");\n            }\n        } catch (RuntimeException ex) {\n            if (Constants.LOGV) {\n                Log.d(Constants.TAG, \"invalid selection [\" + selection + \"] triggered \" + ex);\n            } else if (false) {\n                Log.d(Constants.TAG, \"invalid selection triggered \" + ex);\n            }\n            throw ex;\n        }\n\n    }\n\n    // expression <- ( expression ) | statement [AND_OR ( expression ) | statement] *\n    //             | statement [AND_OR expression]*\n    private static void parseExpression(Lexer lexer) {\n        for (;;) {\n            // ( expression )\n            if (lexer.currentToken() == Lexer.TOKEN_OPEN_PAREN) {\n                lexer.advance();\n                parseExpression(lexer);\n                if (lexer.currentToken() != Lexer.TOKEN_CLOSE_PAREN) {\n                    throw new IllegalArgumentException(\"syntax error, unmatched parenthese\");\n                }\n                lexer.advance();\n            } else {\n                // statement\n                parseStatement(lexer);\n            }\n            if (lexer.currentToken() != Lexer.TOKEN_AND_OR) {\n                break;\n            }\n            lexer.advance();\n        }\n    }\n\n    // statement <- COLUMN COMPARE VALUE\n    //            | COLUMN IS NULL\n    private static void parseStatement(Lexer lexer) {\n        // both possibilities start with COLUMN\n        if (lexer.currentToken() != Lexer.TOKEN_COLUMN) {\n            throw new IllegalArgumentException(\"syntax error, expected column name\");\n        }\n        lexer.advance();\n\n        // statement <- COLUMN COMPARE VALUE\n        if (lexer.currentToken() == Lexer.TOKEN_COMPARE) {\n            lexer.advance();\n            if (lexer.currentToken() != Lexer.TOKEN_VALUE) {\n                throw new IllegalArgumentException(\"syntax error, expected quoted string\");\n            }\n            lexer.advance();\n            return;\n        }\n\n        // statement <- COLUMN IS NULL\n        if (lexer.currentToken() == Lexer.TOKEN_IS) {\n            lexer.advance();\n            if (lexer.currentToken() != Lexer.TOKEN_NULL) {\n                throw new IllegalArgumentException(\"syntax error, expected NULL\");\n            }\n            lexer.advance();\n            return;\n        }\n\n        // didn't get anything good after COLUMN\n        throw new IllegalArgumentException(\"syntax error after column name\");\n    }\n\n    /**\n     * A simple lexer that recognizes the words of our restricted subset of SQL where clauses\n     */\n    private static class Lexer {\n        public static final int TOKEN_START = 0;\n        public static final int TOKEN_OPEN_PAREN = 1;\n        public static final int TOKEN_CLOSE_PAREN = 2;\n        public static final int TOKEN_AND_OR = 3;\n        public static final int TOKEN_COLUMN = 4;\n        public static final int TOKEN_COMPARE = 5;\n        public static final int TOKEN_VALUE = 6;\n        public static final int TOKEN_IS = 7;\n        public static final int TOKEN_NULL = 8;\n        public static final int TOKEN_END = 9;\n\n        private final String mSelection;\n        private final Set<String> mAllowedColumns;\n        private int mOffset = 0;\n        private int mCurrentToken = TOKEN_START;\n        private final char[] mChars;\n\n        public Lexer(String selection, Set<String> allowedColumns) {\n            mSelection = selection;\n            mAllowedColumns = allowedColumns;\n            mChars = new char[mSelection.length()];\n            mSelection.getChars(0, mChars.length, mChars, 0);\n            advance();\n        }\n\n        public int currentToken() {\n            return mCurrentToken;\n        }\n\n        public void advance() {\n            char[] chars = mChars;\n\n            // consume whitespace\n            while (mOffset < chars.length && chars[mOffset] == ' ') {\n                ++mOffset;\n            }\n\n            // end of input\n            if (mOffset == chars.length) {\n                mCurrentToken = TOKEN_END;\n                return;\n            }\n\n            // \"(\"\n            if (chars[mOffset] == '(') {\n                ++mOffset;\n                mCurrentToken = TOKEN_OPEN_PAREN;\n                return;\n            }\n\n            // \")\"\n            if (chars[mOffset] == ')') {\n                ++mOffset;\n                mCurrentToken = TOKEN_CLOSE_PAREN;\n                return;\n            }\n\n            // \"?\"\n            if (chars[mOffset] == '?') {\n                ++mOffset;\n                mCurrentToken = TOKEN_VALUE;\n                return;\n            }\n\n            // \"=\" and \"==\"\n            if (chars[mOffset] == '=') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && chars[mOffset] == '=') {\n                    ++mOffset;\n                }\n                return;\n            }\n\n            // \">\" and \">=\"\n            if (chars[mOffset] == '>') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && chars[mOffset] == '=') {\n                    ++mOffset;\n                }\n                return;\n            }\n\n            // \"<\", \"<=\" and \"<>\"\n            if (chars[mOffset] == '<') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && (chars[mOffset] == '=' || chars[mOffset] == '>')) {\n                    ++mOffset;\n                }\n                return;\n            }\n\n            // \"!=\"\n            if (chars[mOffset] == '!') {\n                ++mOffset;\n                mCurrentToken = TOKEN_COMPARE;\n                if (mOffset < chars.length && chars[mOffset] == '=') {\n                    ++mOffset;\n                    return;\n                }\n                throw new IllegalArgumentException(\"Unexpected character after !\");\n            }\n\n            // columns and keywords\n            // first look for anything that looks like an identifier or a keyword\n            //     and then recognize the individual words.\n            // no attempt is made at discarding sequences of underscores with no alphanumeric\n            //     characters, even though it's not clear that they'd be legal column names.\n            if (isIdentifierStart(chars[mOffset])) {\n                int startOffset = mOffset;\n                ++mOffset;\n                while (mOffset < chars.length && isIdentifierChar(chars[mOffset])) {\n                    ++mOffset;\n                }\n                String word = mSelection.substring(startOffset, mOffset);\n                if (mOffset - startOffset <= 4) {\n                    if (word.equals(\"IS\")) {\n                        mCurrentToken = TOKEN_IS;\n                        return;\n                    }\n                    if (word.equals(\"OR\") || word.equals(\"AND\")) {\n                        mCurrentToken = TOKEN_AND_OR;\n                        return;\n                    }\n                    if (word.equals(\"NULL\")) {\n                        mCurrentToken = TOKEN_NULL;\n                        return;\n                    }\n                }\n                if (mAllowedColumns.contains(word)) {\n                    mCurrentToken = TOKEN_COLUMN;\n                    return;\n                }\n                throw new IllegalArgumentException(\"unrecognized column or keyword\");\n            }\n\n            // quoted strings\n            if (chars[mOffset] == '\\'') {\n                ++mOffset;\n                while (mOffset < chars.length) {\n                    if (chars[mOffset] == '\\'') {\n                        if (mOffset + 1 < chars.length && chars[mOffset + 1] == '\\'') {\n                            ++mOffset;\n                        } else {\n                            break;\n                        }\n                    }\n                    ++mOffset;\n                }\n                if (mOffset == chars.length) {\n                    throw new IllegalArgumentException(\"unterminated string\");\n                }\n                ++mOffset;\n                mCurrentToken = TOKEN_VALUE;\n                return;\n            }\n\n            // anything we don't recognize\n            throw new IllegalArgumentException(\"illegal character: \" + chars[mOffset]);\n        }\n\n        private static final boolean isIdentifierStart(char c) {\n            return c == '_' ||\n                    (c >= 'A' && c <= 'Z') ||\n                    (c >= 'a' && c <= 'z');\n        }\n\n        private static final boolean isIdentifierChar(char c) {\n            return c == '_' ||\n                    (c >= 'A' && c <= 'Z') ||\n                    (c >= 'a' && c <= 'z') ||\n                    (c >= '0' && c <= '9');\n        }\n    }\n\n    /**\n     * Replace invalid filename characters according to\n     * specifications of the VFAT.\n     * @note Package-private due to testing.\n     */\n    private static String replaceInvalidVfatCharacters(String filename) {\n        final char START_CTRLCODE = 0x00;\n        final char END_CTRLCODE = 0x1f;\n        final char QUOTEDBL = 0x22;\n        final char ASTERISK = 0x2A;\n        final char SLASH = 0x2F;\n        final char COLON = 0x3A;\n        final char LESS = 0x3C;\n        final char GREATER = 0x3E;\n        final char QUESTION = 0x3F;\n        final char BACKSLASH = 0x5C;\n        final char BAR = 0x7C;\n        final char DEL = 0x7F;\n        final char UNDERSCORE = 0x5F;\n\n        StringBuffer sb = new StringBuffer();\n        char ch;\n        boolean isRepetition = false;\n        for (int i = 0; i < filename.length(); i++) {\n            ch = filename.charAt(i);\n            if ((START_CTRLCODE <= ch &&\n                ch <= END_CTRLCODE) ||\n                ch == QUOTEDBL ||\n                ch == ASTERISK ||\n                ch == SLASH ||\n                ch == COLON ||\n                ch == LESS ||\n                ch == GREATER ||\n                ch == QUESTION ||\n                ch == BACKSLASH ||\n                ch == BAR ||\n                ch == DEL){\n                if (!isRepetition) {\n                    sb.append(UNDERSCORE);\n                    isRepetition = true;\n                }\n            } else {\n                sb.append(ch);\n                isRepetition = false;\n            }\n        }\n        return sb.toString();\n    }\n}\n","lineNo":144}
{"Smelly Sample":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.os.Process;\nimport android.os.SELinux;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 108;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n    private File mDownloadsDataDir;\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Constants.MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        // start the DownloadService class. don't wait for the 1st download to be issued.\n        // saves us by getting some initialization code in DownloadService out of the way.\n        Context context = getContext();\n        context.startService(new Intent(context, DownloadService.class));\n        mDownloadsDataDir = StorageManager.getDownloadDataDirectory(getContext());\n        try {\n            SELinux.restorecon(mDownloadsDataDir.getCanonicalPath());\n        } catch (IOException e) {\n            Log.wtf(Constants.TAG, \"Could not get canonical path for download directory\", e);\n        }\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need WRITE_EXTERNAL_STORAGE permission to use DESTINATION_FILE_URI\");\n                checkFileUriDestination(values);\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        Context context = getContext();\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // When notification is requested, kick off service to process all\n            // relevant downloads.\n            if (Downloads.Impl.isNotificationToBeDisplayed(vis)) {\n                context.startService(new Intent(context, DownloadService.class));\n            }\n        } else {\n            context.startService(new Intent(context, DownloadService.class));\n        }\n        notifyContentChanged(uri, match);\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n        try {\n            final String canonicalPath = new File(path).getCanonicalPath();\n            final String externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();\n            if (!canonicalPath.startsWith(externalPath)) {\n                throw new SecurityException(\"Destination must be on external storage: \" + uri);\n            }\n        } catch (IOException e) {\n            throw new SecurityException(\"Problem resolving path: \" + uri);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean startService = false;\n\n        if (values.containsKey(Downloads.Impl.COLUMN_DELETED)) {\n            if (values.getAsInteger(Downloads.Impl.COLUMN_DELETED) == 1) {\n                // some rows are to be 'deleted'. need to start DownloadService.\n                startService = true;\n            }\n        }\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                startService = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = query(uri, new String[]\n                        { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                    values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                }\n                c.close();\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                startService = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                if (filteredValues.size() > 0) {\n                    count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                            selection.getParameters());\n                } else {\n                    count = 0;\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        if (startService) {\n            Context context = getContext();\n            context.startService(new Intent(context, DownloadService.class));\n        }\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where,\n            final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        Cursor cursor = query(uri, new String[] {\"_data\"}, null, null, null);\n        String path;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            cursor.moveToFirst();\n            path = cursor.getString(0);\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n        if (!Helpers.isFilenameValid(path, mDownloadsDataDir)) {\n            throw new FileNotFoundException(\"Invalid filename: \" + path);\n        }\n        if (!\"r\".equals(mode)) {\n            throw new FileNotFoundException(\"Bad mode for \" + uri + \": \" + mode);\n        }\n\n        ParcelFileDescriptor ret = ParcelFileDescriptor.open(new File(path),\n                ParcelFileDescriptor.MODE_READ_ONLY);\n\n        if (ret == null) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"couldn't open file\");\n            }\n            throw new FileNotFoundException(\"couldn't open file\");\n        }\n        return ret;\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            if (!cursor.moveToFirst()) {\n                Log.v(Constants.TAG, \"empty cursor in openFile\");\n            } else {\n                do {\n                    Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                } while(cursor.moveToNext());\n            }\n            cursor.close();\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            if (!cursor.moveToFirst()) {\n                Log.v(Constants.TAG, \"empty cursor in openFile\");\n            } else {\n                String filename = cursor.getString(0);\n                Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                if (new java.io.File(filename).isFile()) {\n                    Log.v(Constants.TAG, \"file exists in openFile\");\n                }\n            }\n            cursor.close();\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2007 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Request;\nimport android.content.ContentProvider;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.UriMatcher;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.database.Cursor;\nimport android.database.DatabaseUtils;\nimport android.database.SQLException;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\nimport android.net.Uri;\nimport android.os.Binder;\nimport android.os.Environment;\nimport android.os.Handler;\nimport android.os.ParcelFileDescriptor;\nimport android.os.ParcelFileDescriptor.OnCloseListener;\nimport android.os.Process;\nimport android.os.SELinux;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.provider.OpenableColumns;\nimport android.text.TextUtils;\nimport android.text.format.DateUtils;\nimport android.util.Log;\n\nimport com.android.internal.util.IndentingPrintWriter;\nimport com.google.android.collect.Maps;\nimport com.google.common.annotations.VisibleForTesting;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * Allows application to interact with the download manager.\n */\npublic final class DownloadProvider extends ContentProvider {\n    /** Database filename */\n    private static final String DB_NAME = \"downloads.db\";\n    /** Current database version */\n    private static final int DB_VERSION = 109;\n    /** Name of table in the database */\n    private static final String DB_TABLE = \"downloads\";\n\n    /** MIME type for the entire download list */\n    private static final String DOWNLOAD_LIST_TYPE = \"vnd.android.cursor.dir/download\";\n    /** MIME type for an individual download */\n    private static final String DOWNLOAD_TYPE = \"vnd.android.cursor.item/download\";\n\n    /** URI matcher used to recognize URIs sent by applications */\n    private static final UriMatcher sURIMatcher = new UriMatcher(UriMatcher.NO_MATCH);\n    /** URI matcher constant for the URI of all downloads belonging to the calling UID */\n    private static final int MY_DOWNLOADS = 1;\n    /** URI matcher constant for the URI of an individual download belonging to the calling UID */\n    private static final int MY_DOWNLOADS_ID = 2;\n    /** URI matcher constant for the URI of all downloads in the system */\n    private static final int ALL_DOWNLOADS = 3;\n    /** URI matcher constant for the URI of an individual download */\n    private static final int ALL_DOWNLOADS_ID = 4;\n    /** URI matcher constant for the URI of a download's request headers */\n    private static final int REQUEST_HEADERS_URI = 5;\n    /** URI matcher constant for the public URI returned by\n     * {@link DownloadManager#getUriForDownloadedFile(long)} if the given downloaded file\n     * is publicly accessible.\n     */\n    private static final int PUBLIC_DOWNLOAD_ID = 6;\n    static {\n        sURIMatcher.addURI(\"downloads\", \"my_downloads\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"my_downloads/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads\", ALL_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"all_downloads/#\", ALL_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"my_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                \"all_downloads/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        // temporary, for backwards compatibility\n        sURIMatcher.addURI(\"downloads\", \"download\", MY_DOWNLOADS);\n        sURIMatcher.addURI(\"downloads\", \"download/#\", MY_DOWNLOADS_ID);\n        sURIMatcher.addURI(\"downloads\",\n                \"download/#/\" + Downloads.Impl.RequestHeaders.URI_SEGMENT,\n                REQUEST_HEADERS_URI);\n        sURIMatcher.addURI(\"downloads\",\n                Downloads.Impl.PUBLICLY_ACCESSIBLE_DOWNLOADS_URI_SEGMENT + \"/#\",\n                PUBLIC_DOWNLOAD_ID);\n    }\n\n    /** Different base URIs that could be used to access an individual download */\n    private static final Uri[] BASE_URIS = new Uri[] {\n            Downloads.Impl.CONTENT_URI,\n            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n    };\n\n    private static final String[] sAppReadableColumnsArray = new String[] {\n        Downloads.Impl._ID,\n        Downloads.Impl.COLUMN_APP_DATA,\n        Downloads.Impl._DATA,\n        Downloads.Impl.COLUMN_MIME_TYPE,\n        Downloads.Impl.COLUMN_VISIBILITY,\n        Downloads.Impl.COLUMN_DESTINATION,\n        Downloads.Impl.COLUMN_CONTROL,\n        Downloads.Impl.COLUMN_STATUS,\n        Downloads.Impl.COLUMN_LAST_MODIFICATION,\n        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE,\n        Downloads.Impl.COLUMN_NOTIFICATION_CLASS,\n        Downloads.Impl.COLUMN_TOTAL_BYTES,\n        Downloads.Impl.COLUMN_CURRENT_BYTES,\n        Downloads.Impl.COLUMN_TITLE,\n        Downloads.Impl.COLUMN_DESCRIPTION,\n        Downloads.Impl.COLUMN_URI,\n        Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n        Downloads.Impl.COLUMN_FILE_NAME_HINT,\n        Downloads.Impl.COLUMN_MEDIAPROVIDER_URI,\n        Downloads.Impl.COLUMN_DELETED,\n        OpenableColumns.DISPLAY_NAME,\n        OpenableColumns.SIZE,\n    };\n\n    private static final HashSet<String> sAppReadableColumnsSet;\n    private static final HashMap<String, String> sColumnsMap;\n\n    static {\n        sAppReadableColumnsSet = new HashSet<String>();\n        for (int i = 0; i < sAppReadableColumnsArray.length; ++i) {\n            sAppReadableColumnsSet.add(sAppReadableColumnsArray[i]);\n        }\n\n        sColumnsMap = Maps.newHashMap();\n        sColumnsMap.put(OpenableColumns.DISPLAY_NAME,\n                Downloads.Impl.COLUMN_TITLE + \" AS \" + OpenableColumns.DISPLAY_NAME);\n        sColumnsMap.put(OpenableColumns.SIZE,\n                Downloads.Impl.COLUMN_TOTAL_BYTES + \" AS \" + OpenableColumns.SIZE);\n    }\n    private static final List<String> downloadManagerColumnsList =\n            Arrays.asList(DownloadManager.UNDERLYING_COLUMNS);\n\n    private Handler mHandler;\n\n    /** The database that lies underneath this content provider */\n    private SQLiteOpenHelper mOpenHelper = null;\n\n    /** List of uids that can access the downloads */\n    private int mSystemUid = -1;\n    private int mDefContainerUid = -1;\n    private File mDownloadsDataDir;\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade;\n\n    /**\n     * This class encapsulates a SQL where clause and its parameters.  It makes it possible for\n     * shared methods (like {@link DownloadProvider#getWhereClause(Uri, String, String[], int)})\n     * to return both pieces of information, and provides some utility logic to ease piece-by-piece\n     * construction of selections.\n     */\n    private static class SqlSelection {\n        public StringBuilder mWhereClause = new StringBuilder();\n        public List<String> mParameters = new ArrayList<String>();\n\n        public <T> void appendClause(String newClause, final T... parameters) {\n            if (newClause == null || newClause.isEmpty()) {\n                return;\n            }\n            if (mWhereClause.length() != 0) {\n                mWhereClause.append(\" AND \");\n            }\n            mWhereClause.append(\"(\");\n            mWhereClause.append(newClause);\n            mWhereClause.append(\")\");\n            if (parameters != null) {\n                for (Object parameter : parameters) {\n                    mParameters.add(parameter.toString());\n                }\n            }\n        }\n\n        public String getSelection() {\n            return mWhereClause.toString();\n        }\n\n        public String[] getParameters() {\n            String[] array = new String[mParameters.size()];\n            return mParameters.toArray(array);\n        }\n    }\n\n    /**\n     * Creates and updated database on demand when opening it.\n     * Helper class to create database the first time the provider is\n     * initialized and upgrade it when a new version of the provider needs\n     * an updated version of the database.\n     */\n    private final class DatabaseHelper extends SQLiteOpenHelper {\n        public DatabaseHelper(final Context context) {\n            super(context, DB_NAME, null, DB_VERSION);\n        }\n\n        /**\n         * Creates database the first time we try to open it.\n         */\n        @Override\n        public void onCreate(final SQLiteDatabase db) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"populating new database\");\n            }\n            onUpgrade(db, 0, DB_VERSION);\n        }\n\n        /**\n         * Updates the database format when a content provider is used\n         * with a database that was created with a different format.\n         *\n         * Note: to support downgrades, creating a table should always drop it first if it already\n         * exists.\n         */\n        @Override\n        public void onUpgrade(final SQLiteDatabase db, int oldV, final int newV) {\n            if (oldV == 31) {\n                // 31 and 100 are identical, just in different codelines. Upgrading from 31 is the\n                // same as upgrading from 100.\n                oldV = 100;\n            } else if (oldV < 100) {\n                // no logic to upgrade from these older version, just recreate the DB\n                Log.i(Constants.TAG, \"Upgrading downloads database from version \" + oldV\n                      + \" to version \" + newV + \", which will destroy all old data\");\n                oldV = 99;\n            } else if (oldV > newV) {\n                // user must have downgraded software; we have no way to know how to downgrade the\n                // DB, so just recreate it\n                Log.i(Constants.TAG, \"Downgrading downloads database from version \" + oldV\n                      + \" (current version is \" + newV + \"), destroying all old data\");\n                oldV = 99;\n            }\n\n            for (int version = oldV + 1; version <= newV; version++) {\n                upgradeTo(db, version);\n            }\n        }\n\n        /**\n         * Upgrade database from (version - 1) to version.\n         */\n        private void upgradeTo(SQLiteDatabase db, int version) {\n            switch (version) {\n                case 100:\n                    createDownloadsTable(db);\n                    break;\n\n                case 101:\n                    createHeadersTable(db);\n                    break;\n\n                case 102:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_PUBLIC_API,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_ROAMING,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES,\n                              \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 103:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI,\n                              \"INTEGER NOT NULL DEFAULT 1\");\n                    makeCacheDownloadsInvisible(db);\n                    break;\n\n                case 104:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT,\n                            \"INTEGER NOT NULL DEFAULT 0\");\n                    break;\n\n                case 105:\n                    fillNullValues(db);\n                    break;\n\n                case 106:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, \"TEXT\");\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_DELETED,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                case 107:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ERROR_MSG, \"TEXT\");\n                    break;\n\n                case 108:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_METERED,\n                            \"INTEGER NOT NULL DEFAULT 1\");\n                    break;\n\n                case 109:\n                    addColumn(db, DB_TABLE, Downloads.Impl.COLUMN_ALLOW_WRITE,\n                            \"BOOLEAN NOT NULL DEFAULT 0\");\n                    break;\n\n                default:\n                    throw new IllegalStateException(\"Don't know how to upgrade to \" + version);\n            }\n        }\n\n        /**\n         * insert() now ensures these four columns are never null for new downloads, so this method\n         * makes that true for existing columns, so that code can rely on this assumption.\n         */\n        private void fillNullValues(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_TITLE, \"\");\n            fillNullValuesForColumn(db, values);\n            values.put(Downloads.Impl.COLUMN_DESCRIPTION, \"\");\n            fillNullValuesForColumn(db, values);\n        }\n\n        private void fillNullValuesForColumn(SQLiteDatabase db, ContentValues values) {\n            String column = values.valueSet().iterator().next().getKey();\n            db.update(DB_TABLE, values, column + \" is null\", null);\n            values.clear();\n        }\n\n        /**\n         * Set all existing downloads to the cache partition to be invisible in the downloads UI.\n         */\n        private void makeCacheDownloadsInvisible(SQLiteDatabase db) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, false);\n            String cacheSelection = Downloads.Impl.COLUMN_DESTINATION\n                    + \" != \" + Downloads.Impl.DESTINATION_EXTERNAL;\n            db.update(DB_TABLE, values, cacheSelection, null);\n        }\n\n        /**\n         * Add a column to a table using ALTER TABLE.\n         * @param dbTable name of the table\n         * @param columnName name of the column to add\n         * @param columnDefinition SQL for the column definition\n         */\n        private void addColumn(SQLiteDatabase db, String dbTable, String columnName,\n                               String columnDefinition) {\n            db.execSQL(\"ALTER TABLE \" + dbTable + \" ADD COLUMN \" + columnName + \" \"\n                       + columnDefinition);\n        }\n\n        /**\n         * Creates the table that'll hold the download information.\n         */\n        private void createDownloadsTable(SQLiteDatabase db) {\n            try {\n                db.execSQL(\"DROP TABLE IF EXISTS \" + DB_TABLE);\n                db.execSQL(\"CREATE TABLE \" + DB_TABLE + \"(\" +\n                        Downloads.Impl._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                        Downloads.Impl.COLUMN_URI + \" TEXT, \" +\n                        Constants.RETRY_AFTER_X_REDIRECT_COUNT + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_APP_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NO_INTEGRITY + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_FILE_NAME_HINT + \" TEXT, \" +\n                        Constants.OTA_UPDATE + \" BOOLEAN, \" +\n                        Downloads.Impl._DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_MIME_TYPE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESTINATION + \" INTEGER, \" +\n                        Constants.NO_SYSTEM_FILES + \" BOOLEAN, \" +\n                        Downloads.Impl.COLUMN_VISIBILITY + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CONTROL + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_STATUS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_FAILED_CONNECTIONS + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_LAST_MODIFICATION + \" BIGINT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_CLASS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_COOKIE_DATA + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_USER_AGENT + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_REFERER + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_TOTAL_BYTES + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_CURRENT_BYTES + \" INTEGER, \" +\n                        Constants.ETAG + \" TEXT, \" +\n                        Constants.UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_OTHER_UID + \" INTEGER, \" +\n                        Downloads.Impl.COLUMN_TITLE + \" TEXT, \" +\n                        Downloads.Impl.COLUMN_DESCRIPTION + \" TEXT, \" +\n                        Constants.MEDIA_SCANNED + \" BOOLEAN);\");\n            } catch (SQLException ex) {\n                Log.e(Constants.TAG, \"couldn't create table in downloads database\");\n                throw ex;\n            }\n        }\n\n        private void createHeadersTable(SQLiteDatabase db) {\n            db.execSQL(\"DROP TABLE IF EXISTS \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE);\n            db.execSQL(\"CREATE TABLE \" + Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE + \"(\" +\n                       \"id INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \" INTEGER NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_HEADER + \" TEXT NOT NULL,\" +\n                       Downloads.Impl.RequestHeaders.COLUMN_VALUE + \" TEXT NOT NULL\" +\n                       \");\");\n        }\n    }\n\n    /**\n     * Initializes the content provider when it is created.\n     */\n    @Override\n    public boolean onCreate() {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(getContext());\n        }\n\n        mHandler = new Handler();\n\n        mOpenHelper = new DatabaseHelper(getContext());\n        // Initialize the system uid\n        mSystemUid = Process.SYSTEM_UID;\n        // Initialize the default container uid. Package name hardcoded\n        // for now.\n        ApplicationInfo appInfo = null;\n        try {\n            appInfo = getContext().getPackageManager().\n                    getApplicationInfo(\"com.android.defcontainer\", 0);\n        } catch (NameNotFoundException e) {\n            Log.wtf(Constants.TAG, \"Could not get ApplicationInfo for com.android.defconatiner\", e);\n        }\n        if (appInfo != null) {\n            mDefContainerUid = appInfo.uid;\n        }\n        // start the DownloadService class. don't wait for the 1st download to be issued.\n        // saves us by getting some initialization code in DownloadService out of the way.\n        Context context = getContext();\n        context.startService(new Intent(context, DownloadService.class));\n        mDownloadsDataDir = StorageManager.getDownloadDataDirectory(getContext());\n        try {\n            SELinux.restorecon(mDownloadsDataDir.getCanonicalPath());\n        } catch (IOException e) {\n            Log.wtf(Constants.TAG, \"Could not get canonical path for download directory\", e);\n        }\n        return true;\n    }\n\n    /**\n     * Returns the content-provider-style MIME types of the various\n     * types accessible through this content provider.\n     */\n    @Override\n    public String getType(final Uri uri) {\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case ALL_DOWNLOADS: {\n                return DOWNLOAD_LIST_TYPE;\n            }\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS_ID:\n            case PUBLIC_DOWNLOAD_ID: {\n                // return the mimetype of this id from the database\n                final String id = getDownloadIdFromUri(uri);\n                final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n                final String mimeType = DatabaseUtils.stringForQuery(db,\n                        \"SELECT \" + Downloads.Impl.COLUMN_MIME_TYPE + \" FROM \" + DB_TABLE +\n                        \" WHERE \" + Downloads.Impl._ID + \" = ?\",\n                        new String[]{id});\n                if (TextUtils.isEmpty(mimeType)) {\n                    return DOWNLOAD_TYPE;\n                } else {\n                    return mimeType;\n                }\n            }\n            default: {\n                if (Constants.LOGV) {\n                    Log.v(Constants.TAG, \"calling getType on an unknown URI: \" + uri);\n                }\n                throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n            }\n        }\n    }\n\n    /**\n     * Inserts a row in the database\n     */\n    @Override\n    public Uri insert(final Uri uri, final ContentValues values) {\n        checkInsertPermissions(values);\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        // note we disallow inserting into ALL_DOWNLOADS\n        int match = sURIMatcher.match(uri);\n        if (match != MY_DOWNLOADS) {\n            Log.d(Constants.TAG, \"calling insert on an unknown/invalid URI: \" + uri);\n            throw new IllegalArgumentException(\"Unknown/Invalid URI \" + uri);\n        }\n\n        // copy some of the input values as it\n        ContentValues filteredValues = new ContentValues();\n        copyString(Downloads.Impl.COLUMN_URI, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_NO_INTEGRITY, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_FILE_NAME_HINT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_MIME_TYPE, values, filteredValues);\n        copyBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API, values, filteredValues);\n\n        boolean isPublicApi =\n                values.getAsBoolean(Downloads.Impl.COLUMN_IS_PUBLIC_API) == Boolean.TRUE;\n\n        // validate the destination column\n        Integer dest = values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION);\n        if (dest != null) {\n            if (getContext().checkCallingPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                    != PackageManager.PERMISSION_GRANTED\n                    && (dest == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                            || dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                            || dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION)) {\n                throw new SecurityException(\"setting destination to : \" + dest +\n                        \" not allowed, unless PERMISSION_ACCESS_ADVANCED is granted\");\n            }\n            // for public API behavior, if an app has CACHE_NON_PURGEABLE permission, automatically\n            // switch to non-purgeable download\n            boolean hasNonPurgeablePermission =\n                    getContext().checkCallingPermission(\n                            Downloads.Impl.PERMISSION_CACHE_NON_PURGEABLE)\n                            == PackageManager.PERMISSION_GRANTED;\n            if (isPublicApi && dest == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE\n                    && hasNonPurgeablePermission) {\n                dest = Downloads.Impl.DESTINATION_CACHE_PARTITION;\n            }\n            if (dest == Downloads.Impl.DESTINATION_FILE_URI) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.WRITE_EXTERNAL_STORAGE,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need WRITE_EXTERNAL_STORAGE permission to use DESTINATION_FILE_URI\");\n                checkFileUriDestination(values);\n            } else if (dest == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                getContext().enforcePermission(\n                        android.Manifest.permission.ACCESS_CACHE_FILESYSTEM,\n                        Binder.getCallingPid(), Binder.getCallingUid(),\n                        \"need ACCESS_CACHE_FILESYSTEM permission to use system cache\");\n            }\n            filteredValues.put(Downloads.Impl.COLUMN_DESTINATION, dest);\n        }\n\n        // validate the visibility column\n        Integer vis = values.getAsInteger(Downloads.Impl.COLUMN_VISIBILITY);\n        if (vis == null) {\n            if (dest == Downloads.Impl.DESTINATION_EXTERNAL) {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED);\n            } else {\n                filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY,\n                        Downloads.Impl.VISIBILITY_HIDDEN);\n            }\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_VISIBILITY, vis);\n        }\n        // copy the control column as is\n        copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // these requests always are marked as 'completed'\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_SUCCESS);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES,\n                    values.getAsLong(Downloads.Impl.COLUMN_TOTAL_BYTES));\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n            copyInteger(Downloads.Impl.COLUMN_MEDIA_SCANNED, values, filteredValues);\n            copyString(Downloads.Impl._DATA, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_WRITE, values, filteredValues);\n        } else {\n            filteredValues.put(Downloads.Impl.COLUMN_STATUS, Downloads.Impl.STATUS_PENDING);\n            filteredValues.put(Downloads.Impl.COLUMN_TOTAL_BYTES, -1);\n            filteredValues.put(Downloads.Impl.COLUMN_CURRENT_BYTES, 0);\n        }\n\n        // set lastupdate to current time\n        long lastMod = mSystemFacade.currentTimeMillis();\n        filteredValues.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, lastMod);\n\n        // use packagename of the caller to set the notification columns\n        String pckg = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n        String clazz = values.getAsString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n        if (pckg != null && (clazz != null || isPublicApi)) {\n            int uid = Binder.getCallingUid();\n            try {\n                if (uid == 0 || mSystemFacade.userOwnsPackage(uid, pckg)) {\n                    filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE, pckg);\n                    if (clazz != null) {\n                        filteredValues.put(Downloads.Impl.COLUMN_NOTIFICATION_CLASS, clazz);\n                    }\n                }\n            } catch (PackageManager.NameNotFoundException ex) {\n                /* ignored for now */\n            }\n        }\n\n        // copy some more columns as is\n        copyString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_COOKIE_DATA, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_USER_AGENT, values, filteredValues);\n        copyString(Downloads.Impl.COLUMN_REFERER, values, filteredValues);\n\n        // UID, PID columns\n        if (getContext().checkCallingPermission(Downloads.Impl.PERMISSION_ACCESS_ADVANCED)\n                == PackageManager.PERMISSION_GRANTED) {\n            copyInteger(Downloads.Impl.COLUMN_OTHER_UID, values, filteredValues);\n        }\n        filteredValues.put(Constants.UID, Binder.getCallingUid());\n        if (Binder.getCallingUid() == 0) {\n            copyInteger(Constants.UID, values, filteredValues);\n        }\n\n        // copy some more columns as is\n        copyStringWithDefault(Downloads.Impl.COLUMN_TITLE, values, filteredValues, \"\");\n        copyStringWithDefault(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues, \"\");\n\n        // is_visible_in_downloads_ui column\n        if (values.containsKey(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI)) {\n            copyBoolean(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, values, filteredValues);\n        } else {\n            // by default, make external downloads visible in the UI\n            boolean isExternal = (dest == null || dest == Downloads.Impl.DESTINATION_EXTERNAL);\n            filteredValues.put(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI, isExternal);\n        }\n\n        // public api requests and networktypes/roaming columns\n        if (isPublicApi) {\n            copyInteger(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_ROAMING, values, filteredValues);\n            copyBoolean(Downloads.Impl.COLUMN_ALLOW_METERED, values, filteredValues);\n        }\n\n        if (Constants.LOGVV) {\n            Log.v(Constants.TAG, \"initiating download with UID \"\n                    + filteredValues.getAsInteger(Constants.UID));\n            if (filteredValues.containsKey(Downloads.Impl.COLUMN_OTHER_UID)) {\n                Log.v(Constants.TAG, \"other UID \" +\n                        filteredValues.getAsInteger(Downloads.Impl.COLUMN_OTHER_UID));\n            }\n        }\n\n        long rowID = db.insert(DB_TABLE, null, filteredValues);\n        if (rowID == -1) {\n            Log.d(Constants.TAG, \"couldn't insert into downloads database\");\n            return null;\n        }\n\n        insertRequestHeaders(db, rowID, values);\n        /*\n         * requests coming from\n         * DownloadManager.addCompletedDownload(String, String, String,\n         * boolean, String, String, long) need special treatment\n         */\n        Context context = getContext();\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            // When notification is requested, kick off service to process all\n            // relevant downloads.\n            if (Downloads.Impl.isNotificationToBeDisplayed(vis)) {\n                context.startService(new Intent(context, DownloadService.class));\n            }\n        } else {\n            context.startService(new Intent(context, DownloadService.class));\n        }\n        notifyContentChanged(uri, match);\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, rowID);\n    }\n\n    /**\n     * Check that the file URI provided for DESTINATION_FILE_URI is valid.\n     */\n    private void checkFileUriDestination(ContentValues values) {\n        String fileUri = values.getAsString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n        if (fileUri == null) {\n            throw new IllegalArgumentException(\n                    \"DESTINATION_FILE_URI must include a file URI under COLUMN_FILE_NAME_HINT\");\n        }\n        Uri uri = Uri.parse(fileUri);\n        String scheme = uri.getScheme();\n        if (scheme == null || !scheme.equals(\"file\")) {\n            throw new IllegalArgumentException(\"Not a file URI: \" + uri);\n        }\n        final String path = uri.getPath();\n        if (path == null) {\n            throw new IllegalArgumentException(\"Invalid file URI: \" + uri);\n        }\n        try {\n            final String canonicalPath = new File(path).getCanonicalPath();\n            final String externalPath = Environment.getExternalStorageDirectory().getAbsolutePath();\n            if (!canonicalPath.startsWith(externalPath)) {\n                throw new SecurityException(\"Destination must be on external storage: \" + uri);\n            }\n        } catch (IOException e) {\n            throw new SecurityException(\"Problem resolving path: \" + uri);\n        }\n    }\n\n    /**\n     * Apps with the ACCESS_DOWNLOAD_MANAGER permission can access this provider freely, subject to\n     * constraints in the rest of the code. Apps without that may still access this provider through\n     * the public API, but additional restrictions are imposed. We check those restrictions here.\n     *\n     * @param values ContentValues provided to insert()\n     * @throws SecurityException if the caller has insufficient permissions\n     */\n    private void checkInsertPermissions(ContentValues values) {\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_ACCESS)\n                == PackageManager.PERMISSION_GRANTED) {\n            return;\n        }\n\n        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.INTERNET,\n                \"INTERNET permission is required to use the download manager\");\n\n        // ensure the request fits within the bounds of a public API request\n        // first copy so we can remove values\n        values = new ContentValues(values);\n\n        // check columns whose values are restricted\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_IS_PUBLIC_API, Boolean.TRUE);\n\n        // validate the destination column\n        if (values.getAsInteger(Downloads.Impl.COLUMN_DESTINATION) ==\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD) {\n            /* this row is inserted by\n             * DownloadManager.addCompletedDownload(String, String, String,\n             * boolean, String, String, long)\n             */\n            values.remove(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            values.remove(Downloads.Impl._DATA);\n            values.remove(Downloads.Impl.COLUMN_STATUS);\n        }\n        enforceAllowedValues(values, Downloads.Impl.COLUMN_DESTINATION,\n                Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE,\n                Downloads.Impl.DESTINATION_FILE_URI,\n                Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD);\n\n        if (getContext().checkCallingOrSelfPermission(Downloads.Impl.PERMISSION_NO_NOTIFICATION)\n                == PackageManager.PERMISSION_GRANTED) {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_HIDDEN,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        } else {\n            enforceAllowedValues(values, Downloads.Impl.COLUMN_VISIBILITY,\n                    Request.VISIBILITY_VISIBLE,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED,\n                    Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION);\n        }\n\n        // remove the rest of the columns that are allowed (with any value)\n        values.remove(Downloads.Impl.COLUMN_URI);\n        values.remove(Downloads.Impl.COLUMN_TITLE);\n        values.remove(Downloads.Impl.COLUMN_DESCRIPTION);\n        values.remove(Downloads.Impl.COLUMN_MIME_TYPE);\n        values.remove(Downloads.Impl.COLUMN_FILE_NAME_HINT); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE); // checked later in insert()\n        values.remove(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_ROAMING);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_METERED);\n        values.remove(Downloads.Impl.COLUMN_IS_VISIBLE_IN_DOWNLOADS_UI);\n        values.remove(Downloads.Impl.COLUMN_MEDIA_SCANNED);\n        values.remove(Downloads.Impl.COLUMN_ALLOW_WRITE);\n        Iterator<Map.Entry<String, Object>> iterator = values.valueSet().iterator();\n        while (iterator.hasNext()) {\n            String key = iterator.next().getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                iterator.remove();\n            }\n        }\n\n        // any extra columns are extraneous and disallowed\n        if (values.size() > 0) {\n            StringBuilder error = new StringBuilder(\"Invalid columns in request: \");\n            boolean first = true;\n            for (Map.Entry<String, Object> entry : values.valueSet()) {\n                if (!first) {\n                    error.append(\", \");\n                }\n                error.append(entry.getKey());\n            }\n            throw new SecurityException(error.toString());\n        }\n    }\n\n    /**\n     * Remove column from values, and throw a SecurityException if the value isn't within the\n     * specified allowedValues.\n     */\n    private void enforceAllowedValues(ContentValues values, String column,\n            Object... allowedValues) {\n        Object value = values.get(column);\n        values.remove(column);\n        for (Object allowedValue : allowedValues) {\n            if (value == null && allowedValue == null) {\n                return;\n            }\n            if (value != null && value.equals(allowedValue)) {\n                return;\n            }\n        }\n        throw new SecurityException(\"Invalid value for \" + column + \": \" + value);\n    }\n\n    /**\n     * Starts a database query\n     */\n    @Override\n    public Cursor query(final Uri uri, String[] projection,\n             final String selection, final String[] selectionArgs,\n             final String sort) {\n\n        Helpers.validateSelection(selection, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n\n        int match = sURIMatcher.match(uri);\n        if (match == -1) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"querying unknown URI: \" + uri);\n            }\n            throw new IllegalArgumentException(\"Unknown URI: \" + uri);\n        }\n\n        if (match == REQUEST_HEADERS_URI) {\n            if (projection != null || selection != null || sort != null) {\n                throw new UnsupportedOperationException(\"Request header queries do not support \"\n                                                        + \"projections, selections or sorting\");\n            }\n            return queryRequestHeaders(db, uri);\n        }\n\n        SqlSelection fullSelection = getWhereClause(uri, selection, selectionArgs, match);\n\n        if (shouldRestrictVisibility()) {\n            if (projection == null) {\n                projection = sAppReadableColumnsArray.clone();\n            } else {\n                // check the validity of the columns in projection \n                for (int i = 0; i < projection.length; ++i) {\n                    if (!sAppReadableColumnsSet.contains(projection[i]) &&\n                            !downloadManagerColumnsList.contains(projection[i])) {\n                        throw new IllegalArgumentException(\n                                \"column \" + projection[i] + \" is not allowed in queries\");\n                    }\n                }\n            }\n\n            for (int i = 0; i < projection.length; i++) {\n                final String newColumn = sColumnsMap.get(projection[i]);\n                if (newColumn != null) {\n                    projection[i] = newColumn;\n                }\n            }\n        }\n\n        if (Constants.LOGVV) {\n            logVerboseQueryInfo(projection, selection, selectionArgs, sort, db);\n        }\n\n        Cursor ret = db.query(DB_TABLE, projection, fullSelection.getSelection(),\n                fullSelection.getParameters(), null, null, sort);\n\n        if (ret != null) {\n            ret.setNotificationUri(getContext().getContentResolver(), uri);\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG,\n                        \"created cursor \" + ret + \" on behalf of \" + Binder.getCallingPid());\n            }\n        } else {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"query failed in downloads database\");\n            }\n        }\n\n        return ret;\n    }\n\n    private void logVerboseQueryInfo(String[] projection, final String selection,\n            final String[] selectionArgs, final String sort, SQLiteDatabase db) {\n        java.lang.StringBuilder sb = new java.lang.StringBuilder();\n        sb.append(\"starting query, database is \");\n        if (db != null) {\n            sb.append(\"not \");\n        }\n        sb.append(\"null; \");\n        if (projection == null) {\n            sb.append(\"projection is null; \");\n        } else if (projection.length == 0) {\n            sb.append(\"projection is empty; \");\n        } else {\n            for (int i = 0; i < projection.length; ++i) {\n                sb.append(\"projection[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(projection[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"selection is \");\n        sb.append(selection);\n        sb.append(\"; \");\n        if (selectionArgs == null) {\n            sb.append(\"selectionArgs is null; \");\n        } else if (selectionArgs.length == 0) {\n            sb.append(\"selectionArgs is empty; \");\n        } else {\n            for (int i = 0; i < selectionArgs.length; ++i) {\n                sb.append(\"selectionArgs[\");\n                sb.append(i);\n                sb.append(\"] is \");\n                sb.append(selectionArgs[i]);\n                sb.append(\"; \");\n            }\n        }\n        sb.append(\"sort is \");\n        sb.append(sort);\n        sb.append(\".\");\n        Log.v(Constants.TAG, sb.toString());\n    }\n\n    private String getDownloadIdFromUri(final Uri uri) {\n        return uri.getPathSegments().get(1);\n    }\n\n    /**\n     * Insert request headers for a download into the DB.\n     */\n    private void insertRequestHeaders(SQLiteDatabase db, long downloadId, ContentValues values) {\n        ContentValues rowValues = new ContentValues();\n        rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID, downloadId);\n        for (Map.Entry<String, Object> entry : values.valueSet()) {\n            String key = entry.getKey();\n            if (key.startsWith(Downloads.Impl.RequestHeaders.INSERT_KEY_PREFIX)) {\n                String headerLine = entry.getValue().toString();\n                if (!headerLine.contains(\":\")) {\n                    throw new IllegalArgumentException(\"Invalid HTTP header line: \" + headerLine);\n                }\n                String[] parts = headerLine.split(\":\", 2);\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_HEADER, parts[0].trim());\n                rowValues.put(Downloads.Impl.RequestHeaders.COLUMN_VALUE, parts[1].trim());\n                db.insert(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, null, rowValues);\n            }\n        }\n    }\n\n    /**\n     * Handle a query for the custom request headers registered for a download.\n     */\n    private Cursor queryRequestHeaders(SQLiteDatabase db, Uri uri) {\n        String where = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\"\n                       + getDownloadIdFromUri(uri);\n        String[] projection = new String[] {Downloads.Impl.RequestHeaders.COLUMN_HEADER,\n                                            Downloads.Impl.RequestHeaders.COLUMN_VALUE};\n        return db.query(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, projection, where,\n                        null, null, null, null);\n    }\n\n    /**\n     * Delete request headers for downloads matching the given query.\n     */\n    private void deleteRequestHeaders(SQLiteDatabase db, String where, String[] whereArgs) {\n        String[] projection = new String[] {Downloads.Impl._ID};\n        Cursor cursor = db.query(DB_TABLE, projection, where, whereArgs, null, null, null, null);\n        try {\n            for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                long id = cursor.getLong(0);\n                String idWhere = Downloads.Impl.RequestHeaders.COLUMN_DOWNLOAD_ID + \"=\" + id;\n                db.delete(Downloads.Impl.RequestHeaders.HEADERS_DB_TABLE, idWhere, null);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * @return true if we should restrict the columns readable by this caller\n     */\n    private boolean shouldRestrictVisibility() {\n        int callingUid = Binder.getCallingUid();\n        return Binder.getCallingPid() != Process.myPid() &&\n                callingUid != mSystemUid &&\n                callingUid != mDefContainerUid;\n    }\n\n    /**\n     * Updates a row in the database\n     */\n    @Override\n    public int update(final Uri uri, final ContentValues values,\n            final String where, final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n\n        int count;\n        boolean startService = false;\n\n        if (values.containsKey(Downloads.Impl.COLUMN_DELETED)) {\n            if (values.getAsInteger(Downloads.Impl.COLUMN_DELETED) == 1) {\n                // some rows are to be 'deleted'. need to start DownloadService.\n                startService = true;\n            }\n        }\n\n        ContentValues filteredValues;\n        if (Binder.getCallingPid() != Process.myPid()) {\n            filteredValues = new ContentValues();\n            copyString(Downloads.Impl.COLUMN_APP_DATA, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_VISIBILITY, values, filteredValues);\n            Integer i = values.getAsInteger(Downloads.Impl.COLUMN_CONTROL);\n            if (i != null) {\n                filteredValues.put(Downloads.Impl.COLUMN_CONTROL, i);\n                startService = true;\n            }\n\n            copyInteger(Downloads.Impl.COLUMN_CONTROL, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_TITLE, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI, values, filteredValues);\n            copyString(Downloads.Impl.COLUMN_DESCRIPTION, values, filteredValues);\n            copyInteger(Downloads.Impl.COLUMN_DELETED, values, filteredValues);\n        } else {\n            filteredValues = values;\n            String filename = values.getAsString(Downloads.Impl._DATA);\n            if (filename != null) {\n                Cursor c = query(uri, new String[]\n                        { Downloads.Impl.COLUMN_TITLE }, null, null, null);\n                if (!c.moveToFirst() || c.getString(0).isEmpty()) {\n                    values.put(Downloads.Impl.COLUMN_TITLE, new File(filename).getName());\n                }\n                c.close();\n            }\n\n            Integer status = values.getAsInteger(Downloads.Impl.COLUMN_STATUS);\n            boolean isRestart = status != null && status == Downloads.Impl.STATUS_PENDING;\n            boolean isUserBypassingSizeLimit =\n                values.containsKey(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n            if (isRestart || isUserBypassingSizeLimit) {\n                startService = true;\n            }\n        }\n\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                if (filteredValues.size() > 0) {\n                    count = db.update(DB_TABLE, filteredValues, selection.getSelection(),\n                            selection.getParameters());\n                } else {\n                    count = 0;\n                }\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"updating unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot update URI: \" + uri);\n        }\n\n        notifyContentChanged(uri, match);\n        if (startService) {\n            Context context = getContext();\n            context.startService(new Intent(context, DownloadService.class));\n        }\n        return count;\n    }\n\n    /**\n     * Notify of a change through both URIs (/my_downloads and /all_downloads)\n     * @param uri either URI for the changed download(s)\n     * @param uriMatch the match ID from {@link #sURIMatcher}\n     */\n    private void notifyContentChanged(final Uri uri, int uriMatch) {\n        Long downloadId = null;\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID) {\n            downloadId = Long.parseLong(getDownloadIdFromUri(uri));\n        }\n        for (Uri uriToNotify : BASE_URIS) {\n            if (downloadId != null) {\n                uriToNotify = ContentUris.withAppendedId(uriToNotify, downloadId);\n            }\n            getContext().getContentResolver().notifyChange(uriToNotify, null);\n        }\n    }\n\n    private SqlSelection getWhereClause(final Uri uri, final String where, final String[] whereArgs,\n            int uriMatch) {\n        SqlSelection selection = new SqlSelection();\n        selection.appendClause(where, whereArgs);\n        if (uriMatch == MY_DOWNLOADS_ID || uriMatch == ALL_DOWNLOADS_ID ||\n                uriMatch == PUBLIC_DOWNLOAD_ID) {\n            selection.appendClause(Downloads.Impl._ID + \" = ?\", getDownloadIdFromUri(uri));\n        }\n        if ((uriMatch == MY_DOWNLOADS || uriMatch == MY_DOWNLOADS_ID)\n                && getContext().checkCallingPermission(Downloads.Impl.PERMISSION_ACCESS_ALL)\n                != PackageManager.PERMISSION_GRANTED) {\n            selection.appendClause(\n                    Constants.UID + \"= ? OR \" + Downloads.Impl.COLUMN_OTHER_UID + \"= ?\",\n                    Binder.getCallingUid(), Binder.getCallingUid());\n        }\n        return selection;\n    }\n\n    /**\n     * Deletes a row in the database\n     */\n    @Override\n    public int delete(final Uri uri, final String where,\n            final String[] whereArgs) {\n\n        Helpers.validateSelection(where, sAppReadableColumnsSet);\n\n        SQLiteDatabase db = mOpenHelper.getWritableDatabase();\n        int count;\n        int match = sURIMatcher.match(uri);\n        switch (match) {\n            case MY_DOWNLOADS:\n            case MY_DOWNLOADS_ID:\n            case ALL_DOWNLOADS:\n            case ALL_DOWNLOADS_ID:\n                SqlSelection selection = getWhereClause(uri, where, whereArgs, match);\n                deleteRequestHeaders(db, selection.getSelection(), selection.getParameters());\n                count = db.delete(DB_TABLE, selection.getSelection(), selection.getParameters());\n                break;\n\n            default:\n                Log.d(Constants.TAG, \"deleting unknown/invalid URI: \" + uri);\n                throw new UnsupportedOperationException(\"Cannot delete URI: \" + uri);\n        }\n        notifyContentChanged(uri, match);\n        return count;\n    }\n\n    /**\n     * Remotely opens a file\n     */\n    @Override\n    public ParcelFileDescriptor openFile(final Uri uri, String mode) throws FileNotFoundException {\n        if (Constants.LOGVV) {\n            logVerboseOpenFileInfo(uri, mode);\n        }\n\n        final Cursor cursor = query(uri, new String[] {\n                Downloads.Impl._DATA, Downloads.Impl.COLUMN_ALLOW_WRITE }, null, null, null);\n        String path;\n        boolean allowWrite;\n        try {\n            int count = (cursor != null) ? cursor.getCount() : 0;\n            if (count != 1) {\n                // If there is not exactly one result, throw an appropriate exception.\n                if (count == 0) {\n                    throw new FileNotFoundException(\"No entry for \" + uri);\n                }\n                throw new FileNotFoundException(\"Multiple items at \" + uri);\n            }\n\n            cursor.moveToFirst();\n            path = cursor.getString(0);\n            allowWrite = cursor.getInt(1) != 0;\n        } finally {\n            IoUtils.closeQuietly(cursor);\n        }\n\n        if (path == null) {\n            throw new FileNotFoundException(\"No filename found.\");\n        }\n        if (!Helpers.isFilenameValid(path, mDownloadsDataDir)) {\n            throw new FileNotFoundException(\"Invalid filename: \" + path);\n        }\n        if (!allowWrite && !\"r\".equals(mode)) {\n            throw new FileNotFoundException(\"Bad mode for \" + uri + \": \" + mode);\n        }\n\n        final File file = new File(path);\n\n        ParcelFileDescriptor ret;\n        if (\"r\".equals(mode)) {\n            ret = ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY);\n        } else {\n            try {\n                // When finished writing, update size and timestamp\n                ret = ParcelFileDescriptor.open(file, ParcelFileDescriptor.parseMode(mode),\n                        mHandler, new OnCloseListener() {\n                            @Override\n                            public void onClose(IOException e) {\n                                final ContentValues values = new ContentValues();\n                                values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, file.length());\n                                values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION,\n                                        System.currentTimeMillis());\n                                update(uri, values, null, null);\n                            }\n                        });\n            } catch (IOException e) {\n                throw new FileNotFoundException(\"Failed to open for writing: \" + e);\n            }\n        }\n\n        if (ret == null) {\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"couldn't open file\");\n            }\n            throw new FileNotFoundException(\"couldn't open file\");\n        }\n        return ret;\n    }\n\n    @Override\n    public void dump(FileDescriptor fd, PrintWriter writer, String[] args) {\n        final IndentingPrintWriter pw = new IndentingPrintWriter(writer, \"  \", 120);\n\n        pw.println(\"Downloads updated in last hour:\");\n        pw.increaseIndent();\n\n        final SQLiteDatabase db = mOpenHelper.getReadableDatabase();\n        final long modifiedAfter = mSystemFacade.currentTimeMillis() - DateUtils.HOUR_IN_MILLIS;\n        final Cursor cursor = db.query(DB_TABLE, null,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION + \">\" + modifiedAfter, null, null, null,\n                Downloads.Impl._ID + \" ASC\");\n        try {\n            final String[] cols = cursor.getColumnNames();\n            final int idCol = cursor.getColumnIndex(BaseColumns._ID);\n            while (cursor.moveToNext()) {\n                pw.println(\"Download #\" + cursor.getInt(idCol) + \":\");\n                pw.increaseIndent();\n                for (int i = 0; i < cols.length; i++) {\n                    // Omit sensitive data when dumping\n                    if (Downloads.Impl.COLUMN_COOKIE_DATA.equals(cols[i])) {\n                        continue;\n                    }\n                    pw.printPair(cols[i], cursor.getString(i));\n                }\n                pw.println();\n                pw.decreaseIndent();\n            }\n        } finally {\n            cursor.close();\n        }\n\n        pw.decreaseIndent();\n    }\n\n    private void logVerboseOpenFileInfo(Uri uri, String mode) {\n        Log.v(Constants.TAG, \"openFile uri: \" + uri + \", mode: \" + mode\n                + \", uid: \" + Binder.getCallingUid());\n        Cursor cursor = query(Downloads.Impl.CONTENT_URI,\n                new String[] { \"_id\" }, null, null, \"_id\");\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            if (!cursor.moveToFirst()) {\n                Log.v(Constants.TAG, \"empty cursor in openFile\");\n            } else {\n                do {\n                    Log.v(Constants.TAG, \"row \" + cursor.getInt(0) + \" available\");\n                } while(cursor.moveToNext());\n            }\n            cursor.close();\n        }\n        cursor = query(uri, new String[] { \"_data\" }, null, null, null);\n        if (cursor == null) {\n            Log.v(Constants.TAG, \"null cursor in openFile\");\n        } else {\n            if (!cursor.moveToFirst()) {\n                Log.v(Constants.TAG, \"empty cursor in openFile\");\n            } else {\n                String filename = cursor.getString(0);\n                Log.v(Constants.TAG, \"filename in openFile: \" + filename);\n                if (new java.io.File(filename).isFile()) {\n                    Log.v(Constants.TAG, \"file exists in openFile\");\n                }\n            }\n            cursor.close();\n        }\n    }\n\n    private static final void copyInteger(String key, ContentValues from, ContentValues to) {\n        Integer i = from.getAsInteger(key);\n        if (i != null) {\n            to.put(key, i);\n        }\n    }\n\n    private static final void copyBoolean(String key, ContentValues from, ContentValues to) {\n        Boolean b = from.getAsBoolean(key);\n        if (b != null) {\n            to.put(key, b);\n        }\n    }\n\n    private static final void copyString(String key, ContentValues from, ContentValues to) {\n        String s = from.getAsString(key);\n        if (s != null) {\n            to.put(key, s);\n        }\n    }\n\n    private static final void copyStringWithDefault(String key, ContentValues from,\n            ContentValues to, String defaultValue) {\n        copyString(key, from, to);\n        if (!to.containsKey(key)) {\n            to.put(key, defaultValue);\n        }\n    }\n}\n","lineNo":1216}
{"Smelly Sample":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.graphics.Point;\nimport android.os.Binder;\nimport android.os.CancellationSignal;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.DocumentsProvider;\nimport android.text.TextUtils;\n\nimport libcore.io.IoUtils;\n\nimport java.io.FileNotFoundException;\n\n/**\n * Presents a {@link DocumentsContract} view of {@link DownloadManager}\n * contents.\n */\npublic class DownloadStorageProvider extends DocumentsProvider {\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_ROOT_TYPE, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_SUMMARY, Root.COLUMN_DOCUMENT_ID,\n            Root.COLUMN_AVAILABLE_BYTES,\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_ROOT_TYPE, Root.ROOT_TYPE_SHORTCUT);\n        row.add(Root.COLUMN_FLAGS, Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        return result;\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            includeDefaultDocument(result);\n        } else {\n            // Delegate to real provider\n            final long token = Binder.clearCallingIdentity();\n            Cursor cursor = null;\n            try {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromCursor(result, cursor);\n                }\n            } finally {\n                IoUtils.closeQuietly(cursor);\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String docId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n        return result;\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocumentId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(\n                    new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n        return result;\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext() && result.getCount() < 12) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images that have been inserted into the MediaStore so we\n                // don't duplicate them in the recents list.\n                if (mimeType == null\n                        || (mimeType.startsWith(\"image/\") && !TextUtils.isEmpty(uri))) {\n                    continue;\n                }\n\n                includeDownloadFromCursor(result, cursor);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n        return result;\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        if (!\"r\".equals(mode)) {\n            throw new IllegalArgumentException(\"Downloads are read-only\");\n        }\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            return mDm.openDownloadedFile(Long.parseLong(docId));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public AssetFileDescriptor openDocumentThumbnail(\n            String docId, Point sizeHint, CancellationSignal signal) throws FileNotFoundException {\n        // TODO: extend ExifInterface to support fds\n        final ParcelFileDescriptor pfd = openDocument(docId, \"r\", signal);\n        return new AssetFileDescriptor(pfd, 0, AssetFileDescriptor.UNKNOWN_LENGTH);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS, Document.FLAG_DIR_PREFERS_LAST_MODIFIED);\n    }\n\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            mimeType = \"application/octet-stream\";\n        }\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    final long percent = progress * 100 / size;\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE;\n        if (mimeType != null && mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        row.add(Document.COLUMN_FLAGS, flags);\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2013 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.DownloadManager.Query;\nimport android.content.ContentResolver;\nimport android.content.Context;\nimport android.content.res.AssetFileDescriptor;\nimport android.database.Cursor;\nimport android.database.MatrixCursor;\nimport android.database.MatrixCursor.RowBuilder;\nimport android.graphics.Point;\nimport android.os.Binder;\nimport android.os.CancellationSignal;\nimport android.os.Environment;\nimport android.os.ParcelFileDescriptor;\nimport android.provider.DocumentsContract;\nimport android.provider.DocumentsContract.Document;\nimport android.provider.DocumentsContract.Root;\nimport android.provider.DocumentsProvider;\nimport android.text.TextUtils;\nimport android.webkit.MimeTypeMap;\n\nimport libcore.io.IoUtils;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\n/**\n * Presents a {@link DocumentsContract} view of {@link DownloadManager}\n * contents.\n */\npublic class DownloadStorageProvider extends DocumentsProvider {\n    private static final String DOC_ID_ROOT = Constants.STORAGE_ROOT_ID;\n\n    private static final String[] DEFAULT_ROOT_PROJECTION = new String[] {\n            Root.COLUMN_ROOT_ID, Root.COLUMN_ROOT_TYPE, Root.COLUMN_FLAGS, Root.COLUMN_ICON,\n            Root.COLUMN_TITLE, Root.COLUMN_SUMMARY, Root.COLUMN_DOCUMENT_ID,\n            Root.COLUMN_AVAILABLE_BYTES,\n    };\n\n    private static final String[] DEFAULT_DOCUMENT_PROJECTION = new String[] {\n            Document.COLUMN_DOCUMENT_ID, Document.COLUMN_MIME_TYPE, Document.COLUMN_DISPLAY_NAME,\n            Document.COLUMN_SUMMARY, Document.COLUMN_LAST_MODIFIED, Document.COLUMN_FLAGS,\n            Document.COLUMN_SIZE,\n    };\n\n    private DownloadManager mDm;\n\n    @Override\n    public boolean onCreate() {\n        mDm = (DownloadManager) getContext().getSystemService(Context.DOWNLOAD_SERVICE);\n        mDm.setAccessAllDownloads(true);\n        return true;\n    }\n\n    private static String[] resolveRootProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_ROOT_PROJECTION;\n    }\n\n    private static String[] resolveDocumentProjection(String[] projection) {\n        return projection != null ? projection : DEFAULT_DOCUMENT_PROJECTION;\n    }\n\n    private void copyNotificationUri(MatrixCursor result, Cursor cursor) {\n        result.setNotificationUri(getContext().getContentResolver(), cursor.getNotificationUri());\n    }\n\n    @Override\n    public Cursor queryRoots(String[] projection) throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveRootProjection(projection));\n        final RowBuilder row = result.newRow();\n        row.add(Root.COLUMN_ROOT_ID, DOC_ID_ROOT);\n        row.add(Root.COLUMN_ROOT_TYPE, Root.ROOT_TYPE_SHORTCUT);\n        row.add(Root.COLUMN_FLAGS,\n                Root.FLAG_LOCAL_ONLY | Root.FLAG_SUPPORTS_RECENTS | Root.FLAG_SUPPORTS_CREATE);\n        row.add(Root.COLUMN_ICON, R.mipmap.ic_launcher_download);\n        row.add(Root.COLUMN_TITLE, getContext().getString(R.string.root_downloads));\n        row.add(Root.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        return result;\n    }\n\n    @Override\n    public String createDocument(String docId, String mimeType, String displayName)\n            throws FileNotFoundException {\n        final File parent = Environment.getExternalStoragePublicDirectory(\n                Environment.DIRECTORY_DOWNLOADS);\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            displayName = removeExtension(mimeType, displayName);\n            File file = new File(parent, addExtension(mimeType, displayName));\n\n            // If conflicting file, try adding counter suffix\n            int n = 0;\n            while (file.exists() && n++ < 32) {\n                file = new File(parent, addExtension(mimeType, displayName + \" (\" + n + \")\"));\n            }\n\n            try {\n                if (!file.createNewFile()) {\n                    throw new IllegalStateException(\"Failed to touch \" + file);\n                }\n            } catch (IOException e) {\n                throw new IllegalStateException(\"Failed to touch \" + file + \": \" + e);\n            }\n\n            return Long.toString(mDm.addCompletedDownload(\n                    file.getName(), file.getName(), false, mimeType, file.getAbsolutePath(), 0L,\n                    false, true));\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public void deleteDocument(String docId) throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            if (mDm.remove(Long.parseLong(docId)) != 1) {\n                throw new IllegalStateException(\"Failed to delete \" + docId);\n            }\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public Cursor queryDocument(String docId, String[] projection) throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        if (DOC_ID_ROOT.equals(docId)) {\n            includeDefaultDocument(result);\n        } else {\n            // Delegate to real provider\n            final long token = Binder.clearCallingIdentity();\n            Cursor cursor = null;\n            try {\n                cursor = mDm.query(new Query().setFilterById(Long.parseLong(docId)));\n                copyNotificationUri(result, cursor);\n                if (cursor.moveToFirst()) {\n                    includeDownloadFromCursor(result, cursor);\n                }\n            } finally {\n                IoUtils.closeQuietly(cursor);\n                Binder.restoreCallingIdentity(token);\n            }\n        }\n        return result;\n    }\n\n    @Override\n    public Cursor queryChildDocuments(String docId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n        return result;\n    }\n\n    @Override\n    public Cursor queryChildDocumentsForManage(\n            String parentDocumentId, String[] projection, String sortOrder)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(\n                    new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext()) {\n                includeDownloadFromCursor(result, cursor);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n        return result;\n    }\n\n    @Override\n    public Cursor queryRecentDocuments(String rootId, String[] projection)\n            throws FileNotFoundException {\n        final MatrixCursor result = new MatrixCursor(resolveDocumentProjection(projection));\n\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        Cursor cursor = null;\n        try {\n            cursor = mDm.query(new DownloadManager.Query().setOnlyIncludeVisibleInDownloadsUi(true)\n                    .setFilterByStatus(DownloadManager.STATUS_SUCCESSFUL));\n            copyNotificationUri(result, cursor);\n            while (cursor.moveToNext() && result.getCount() < 12) {\n                final String mimeType = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n                final String uri = cursor.getString(\n                        cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIAPROVIDER_URI));\n\n                // Skip images that have been inserted into the MediaStore so we\n                // don't duplicate them in the recents list.\n                if (mimeType == null\n                        || (mimeType.startsWith(\"image/\") && !TextUtils.isEmpty(uri))) {\n                    continue;\n                }\n\n                includeDownloadFromCursor(result, cursor);\n            }\n        } finally {\n            IoUtils.closeQuietly(cursor);\n            Binder.restoreCallingIdentity(token);\n        }\n        return result;\n    }\n\n    @Override\n    public ParcelFileDescriptor openDocument(String docId, String mode, CancellationSignal signal)\n            throws FileNotFoundException {\n        // Delegate to real provider\n        final long token = Binder.clearCallingIdentity();\n        try {\n            final long id = Long.parseLong(docId);\n            final ContentResolver resolver = getContext().getContentResolver();\n            return resolver.openFileDescriptor(mDm.getDownloadUri(id), mode, signal);\n        } finally {\n            Binder.restoreCallingIdentity(token);\n        }\n    }\n\n    @Override\n    public AssetFileDescriptor openDocumentThumbnail(\n            String docId, Point sizeHint, CancellationSignal signal) throws FileNotFoundException {\n        // TODO: extend ExifInterface to support fds\n        final ParcelFileDescriptor pfd = openDocument(docId, \"r\", signal);\n        return new AssetFileDescriptor(pfd, 0, AssetFileDescriptor.UNKNOWN_LENGTH);\n    }\n\n    private void includeDefaultDocument(MatrixCursor result) {\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, DOC_ID_ROOT);\n        row.add(Document.COLUMN_MIME_TYPE, Document.MIME_TYPE_DIR);\n        row.add(Document.COLUMN_FLAGS,\n                Document.FLAG_DIR_PREFERS_LAST_MODIFIED | Document.FLAG_DIR_SUPPORTS_CREATE);\n    }\n\n    private void includeDownloadFromCursor(MatrixCursor result, Cursor cursor) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ID));\n        final String docId = String.valueOf(id);\n\n        final String displayName = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TITLE));\n        String summary = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_DESCRIPTION));\n        String mimeType = cursor.getString(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_MEDIA_TYPE));\n        if (mimeType == null) {\n            mimeType = \"application/octet-stream\";\n        }\n        Long size = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_TOTAL_SIZE_BYTES));\n        if (size == -1) {\n            size = null;\n        }\n\n        final int status = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_STATUS));\n        switch (status) {\n            case DownloadManager.STATUS_SUCCESSFUL:\n                break;\n            case DownloadManager.STATUS_PAUSED:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_PENDING:\n                summary = getContext().getString(R.string.download_queued);\n                break;\n            case DownloadManager.STATUS_RUNNING:\n                final long progress = cursor.getLong(cursor.getColumnIndexOrThrow(\n                        DownloadManager.COLUMN_BYTES_DOWNLOADED_SO_FAR));\n                if (size != null) {\n                    final long percent = progress * 100 / size;\n                    summary = getContext().getString(R.string.download_running_percent, percent);\n                } else {\n                    summary = getContext().getString(R.string.download_running);\n                }\n                break;\n            case DownloadManager.STATUS_FAILED:\n            default:\n                summary = getContext().getString(R.string.download_error);\n                break;\n        }\n\n        int flags = Document.FLAG_SUPPORTS_DELETE;\n        if (mimeType != null && mimeType.startsWith(\"image/\")) {\n            flags |= Document.FLAG_SUPPORTS_THUMBNAIL;\n        }\n\n        final int allowWrite = cursor.getInt(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_ALLOW_WRITE));\n        if (allowWrite != 0) {\n            flags |= Document.FLAG_SUPPORTS_WRITE;\n        }\n\n        final long lastModified = cursor.getLong(\n                cursor.getColumnIndexOrThrow(DownloadManager.COLUMN_LAST_MODIFIED_TIMESTAMP));\n\n        final RowBuilder row = result.newRow();\n        row.add(Document.COLUMN_DOCUMENT_ID, docId);\n        row.add(Document.COLUMN_DISPLAY_NAME, displayName);\n        row.add(Document.COLUMN_SUMMARY, summary);\n        row.add(Document.COLUMN_SIZE, size);\n        row.add(Document.COLUMN_MIME_TYPE, mimeType);\n        row.add(Document.COLUMN_LAST_MODIFIED, lastModified);\n        row.add(Document.COLUMN_FLAGS, flags);\n    }\n\n    /**\n     * Remove file extension from name, but only if exact MIME type mapping\n     * exists. This means we can reapply the extension later.\n     */\n    private static String removeExtension(String mimeType, String name) {\n        final int lastDot = name.lastIndexOf('.');\n        if (lastDot >= 0) {\n            final String extension = name.substring(lastDot + 1);\n            final String nameMime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);\n            if (mimeType.equals(nameMime)) {\n                return name.substring(0, lastDot);\n            }\n        }\n        return name;\n    }\n\n    /**\n     * Add file extension to name, but only if exact MIME type mapping exists.\n     */\n    private static String addExtension(String mimeType, String name) {\n        final String extension = MimeTypeMap.getSingleton()\n                .getExtensionFromMimeType(mimeType);\n        if (extension != null) {\n            return name + \".\" + extension;\n        }\n        return name;\n    }\n}\n","lineNo":255}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.Notification;\nimport android.app.PendingIntent;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.SparseLongArray;\n\nimport java.util.Collection;\nimport java.util.HashMap;\n\n/**\n * This class handles the updating of the Notification Manager for the\n * cases where there is an ongoing download. Once the download is complete\n * (be it successful or unsuccessful) it is no longer the responsibility\n * of this component to show the download in the notification manager.\n *\n */\nclass DownloadNotification {\n\n    Context mContext;\n    HashMap <String, NotificationItem> mNotifications;\n    private SystemFacade mSystemFacade;\n\n    /** Time when each {@link DownloadInfo#mId} was first shown. */\n    private SparseLongArray mFirstShown = new SparseLongArray();\n\n    static final String LOGTAG = \"DownloadNotification\";\n    static final String WHERE_RUNNING =\n        \"(\" + Downloads.Impl.COLUMN_STATUS + \" >= '100') AND (\" +\n        Downloads.Impl.COLUMN_STATUS + \" <= '199') AND (\" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" IS NULL OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE + \"' OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"')\";\n    static final String WHERE_COMPLETED =\n        Downloads.Impl.COLUMN_STATUS + \" >= '200' AND \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"'\";\n\n\n    /**\n     * This inner class is used to collate downloads that are owned by\n     * the same application. This is so that only one notification line\n     * item is used for all downloads of a given application.\n     *\n     */\n    static class NotificationItem {\n        // TODO: refactor to mNotifId and avoid building Uris based on it, since\n        // they can overflow\n        int mId;  // This first db _id for the download for the app\n        long mTotalCurrent = 0;\n        long mTotalTotal = 0;\n        int mTitleCount = 0;\n        String mPackageName;  // App package name\n        String mDescription;\n        String[] mTitles = new String[2]; // download titles.\n        String mPausedText = null;\n\n        /*\n         * Add a second download to this notification item.\n         */\n        void addItem(String title, long currentBytes, long totalBytes) {\n            mTotalCurrent += currentBytes;\n            if (totalBytes <= 0 || mTotalTotal == -1) {\n                mTotalTotal = -1;\n            } else {\n                mTotalTotal += totalBytes;\n            }\n            if (mTitleCount < 2) {\n                mTitles[mTitleCount] = title;\n            }\n            mTitleCount++;\n        }\n    }\n\n\n    /**\n     * Constructor\n     * @param ctx The context to use to obtain access to the\n     *            Notification Service\n     */\n    DownloadNotification(Context ctx, SystemFacade systemFacade) {\n        mContext = ctx;\n        mSystemFacade = systemFacade;\n        mNotifications = new HashMap<String, NotificationItem>();\n    }\n\n    /*\n     * Update the notification ui.\n     */\n    public void updateNotification(Collection<DownloadInfo> downloads) {\n        updateActiveNotification(downloads);\n        updateCompletedNotification(downloads);\n    }\n\n    private void updateActiveNotification(Collection<DownloadInfo> downloads) {\n        // Collate the notifications\n        mNotifications.clear();\n        for (DownloadInfo download : downloads) {\n            if (!isActiveAndVisible(download)) {\n                continue;\n            }\n            String packageName = download.mPackage;\n            long max = download.mTotalBytes;\n            long progress = download.mCurrentBytes;\n            long id = download.mId;\n            String title = download.mTitle;\n            if (title == null || title.length() == 0) {\n                title = mContext.getResources().getString(\n                        R.string.download_unknown_title);\n            }\n\n            NotificationItem item;\n            if (mNotifications.containsKey(packageName)) {\n                item = mNotifications.get(packageName);\n                item.addItem(title, progress, max);\n            } else {\n                item = new NotificationItem();\n                item.mId = (int) id;\n                item.mPackageName = packageName;\n                item.mDescription = download.mDescription;\n                item.addItem(title, progress, max);\n                mNotifications.put(packageName, item);\n            }\n            if (download.mStatus == Downloads.Impl.STATUS_QUEUED_FOR_WIFI\n                    && item.mPausedText == null) {\n                item.mPausedText = mContext.getResources().getString(\n                        R.string.notification_need_wifi_for_size);\n            }\n        }\n\n        // Add the notifications\n        for (NotificationItem item : mNotifications.values()) {\n            // Build the notification object\n            final Notification.Builder builder = new Notification.Builder(mContext);\n\n            boolean hasPausedText = (item.mPausedText != null);\n            int iconResource = android.R.drawable.stat_sys_download;\n            if (hasPausedText) {\n                iconResource = android.R.drawable.stat_sys_warning;\n            }\n            builder.setSmallIcon(iconResource);\n            builder.setOngoing(true);\n\n            // set notification \"when\" to be first time this DownloadInfo.mId\n            // was encountered, which avoids fighting with other notifs.\n            long firstShown = mFirstShown.get(item.mId, -1);\n            if (firstShown == -1) {\n                firstShown = System.currentTimeMillis();\n                mFirstShown.put(item.mId, firstShown);\n            }\n            builder.setWhen(firstShown);\n\n            boolean hasContentText = false;\n            StringBuilder title = new StringBuilder(item.mTitles[0]);\n            if (item.mTitleCount > 1) {\n                title.append(mContext.getString(R.string.notification_filename_separator));\n                title.append(item.mTitles[1]);\n                if (item.mTitleCount > 2) {\n                    title.append(mContext.getString(R.string.notification_filename_extras,\n                            new Object[] { Integer.valueOf(item.mTitleCount - 2) }));\n                }\n            } else if (!TextUtils.isEmpty(item.mDescription)) {\n                builder.setContentText(item.mDescription);\n                hasContentText = true;\n            }\n            builder.setContentTitle(title);\n\n            if (hasPausedText) {\n                builder.setContentText(item.mPausedText);\n            } else {\n                builder.setProgress(\n                        (int) item.mTotalTotal, (int) item.mTotalCurrent, item.mTotalTotal == -1);\n                if (hasContentText) {\n                    builder.setContentInfo(\n                            buildPercentageLabel(mContext, item.mTotalTotal, item.mTotalCurrent));\n                }\n            }\n\n            Intent intent = new Intent(Constants.ACTION_LIST);\n            intent.setClassName(\"com.android.providers.downloads\",\n                    DownloadReceiver.class.getName());\n            intent.setData(\n                    ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, item.mId));\n            intent.putExtra(\"multiple\", item.mTitleCount > 1);\n\n            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n            mSystemFacade.postNotification(item.mId, builder.getNotification());\n\n        }\n    }\n\n    private void updateCompletedNotification(Collection<DownloadInfo> downloads) {\n        for (DownloadInfo download : downloads) {\n            if (!isCompleteAndVisible(download)) {\n                continue;\n            }\n            notificationForCompletedDownload(download.mId, download.mTitle,\n                    download.mStatus, download.mDestination, download.mLastMod);\n        }\n    }\n    void notificationForCompletedDownload(long id, String title, int status,\n            int destination, long lastMod) {\n        // Add the notifications\n        Notification.Builder builder = new Notification.Builder(mContext);\n        builder.setSmallIcon(android.R.drawable.stat_sys_download_done);\n        if (title == null || title.length() == 0) {\n            title = mContext.getResources().getString(\n                    R.string.download_unknown_title);\n        }\n        Uri contentUri =\n            ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        String caption;\n        Intent intent;\n        if (Downloads.Impl.isStatusError(status)) {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_failed);\n            intent = new Intent(Constants.ACTION_LIST);\n        } else {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_complete);\n            if (destination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                intent = new Intent(Constants.ACTION_OPEN);\n            } else {\n                intent = new Intent(Constants.ACTION_LIST);\n            }\n        }\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n\n        builder.setWhen(lastMod);\n        builder.setContentTitle(title);\n        builder.setContentText(caption);\n        builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        intent = new Intent(Constants.ACTION_HIDE);\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n        builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        mSystemFacade.postNotification(id, builder.getNotification());\n    }\n\n    private boolean isActiveAndVisible(DownloadInfo download) {\n        return 100 <= download.mStatus && download.mStatus < 200\n                && download.mVisibility != Downloads.Impl.VISIBILITY_HIDDEN;\n    }\n\n    private boolean isCompleteAndVisible(DownloadInfo download) {\n        return download.mStatus >= 200\n                && download.mVisibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\n    }\n\n    private static String buildPercentageLabel(\n            Context context, long totalBytes, long currentBytes) {\n        if (totalBytes <= 0) {\n            return null;\n        } else {\n            final int percent = (int) (100 * currentBytes / totalBytes);\n            return context.getString(R.string.download_percent, percent);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.Notification;\nimport android.app.PendingIntent;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.SparseLongArray;\n\nimport java.util.Collection;\nimport java.util.HashMap;\n\n/**\n * This class handles the updating of the Notification Manager for the\n * cases where there is an ongoing download. Once the download is complete\n * (be it successful or unsuccessful) it is no longer the responsibility\n * of this component to show the download in the notification manager.\n *\n */\nclass DownloadNotification {\n\n    Context mContext;\n    HashMap <String, NotificationItem> mNotifications;\n    private SystemFacade mSystemFacade;\n\n    /** Time when each {@link DownloadInfo#mId} was first shown. */\n    private SparseLongArray mFirstShown = new SparseLongArray();\n\n    static final String LOGTAG = \"DownloadNotification\";\n    static final String WHERE_RUNNING =\n        \"(\" + Downloads.Impl.COLUMN_STATUS + \" >= '100') AND (\" +\n        Downloads.Impl.COLUMN_STATUS + \" <= '199') AND (\" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" IS NULL OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE + \"' OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"')\";\n    static final String WHERE_COMPLETED =\n        Downloads.Impl.COLUMN_STATUS + \" >= '200' AND \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"'\";\n\n\n    /**\n     * This inner class is used to collate downloads that are owned by\n     * the same application. This is so that only one notification line\n     * item is used for all downloads of a given application.\n     *\n     */\n    static class NotificationItem {\n        // TODO: refactor to mNotifId and avoid building Uris based on it, since\n        // they can overflow\n        int mId;  // This first db _id for the download for the app\n        long mTotalCurrent = 0;\n        long mTotalTotal = 0;\n        int mTitleCount = 0;\n        String mPackageName;  // App package name\n        String mDescription;\n        String[] mTitles = new String[2]; // download titles.\n        String mPausedText = null;\n\n        /*\n         * Add a second download to this notification item.\n         */\n        void addItem(String title, long currentBytes, long totalBytes) {\n            mTotalCurrent += currentBytes;\n            if (totalBytes <= 0 || mTotalTotal == -1) {\n                mTotalTotal = -1;\n            } else {\n                mTotalTotal += totalBytes;\n            }\n            if (mTitleCount < 2) {\n                mTitles[mTitleCount] = title;\n            }\n            mTitleCount++;\n        }\n    }\n\n\n    /**\n     * Constructor\n     * @param ctx The context to use to obtain access to the\n     *            Notification Service\n     */\n    DownloadNotification(Context ctx, SystemFacade systemFacade) {\n        mContext = ctx;\n        mSystemFacade = systemFacade;\n        mNotifications = new HashMap<String, NotificationItem>();\n    }\n\n    /*\n     * Update the notification ui.\n     */\n    public void updateNotification(Collection<DownloadInfo> downloads) {\n        updateActiveNotification(downloads);\n        updateCompletedNotification(downloads);\n    }\n\n    private void updateActiveNotification(Collection<DownloadInfo> downloads) {\n        // Collate the notifications\n        mNotifications.clear();\n        for (DownloadInfo download : downloads) {\n            if (!isActiveAndVisible(download)) {\n                continue;\n            }\n            String packageName = download.mPackage;\n            long max = download.mTotalBytes;\n            long progress = download.mCurrentBytes;\n            long id = download.mId;\n            String title = download.mTitle;\n            if (title == null || title.length() == 0) {\n                title = mContext.getResources().getString(\n                        R.string.download_unknown_title);\n            }\n\n            NotificationItem item;\n            if (mNotifications.containsKey(packageName)) {\n                item = mNotifications.get(packageName);\n                item.addItem(title, progress, max);\n            } else {\n                item = new NotificationItem();\n                item.mId = (int) id;\n                item.mPackageName = packageName;\n                item.mDescription = download.mDescription;\n                item.addItem(title, progress, max);\n                mNotifications.put(packageName, item);\n            }\n            if (download.mStatus == Downloads.Impl.STATUS_QUEUED_FOR_WIFI\n                    && item.mPausedText == null) {\n                item.mPausedText = mContext.getResources().getString(\n                        R.string.notification_need_wifi_for_size);\n            }\n        }\n\n        // Add the notifications\n        for (NotificationItem item : mNotifications.values()) {\n            // Build the notification object\n            final Notification.Builder builder = new Notification.Builder(mContext);\n\n            boolean hasPausedText = (item.mPausedText != null);\n            int iconResource = android.R.drawable.stat_sys_download;\n            if (hasPausedText) {\n                iconResource = android.R.drawable.stat_sys_warning;\n            }\n            builder.setSmallIcon(iconResource);\n            builder.setOngoing(true);\n\n            // set notification \"when\" to be first time this DownloadInfo.mId\n            // was encountered, which avoids fighting with other notifs.\n            long firstShown = mFirstShown.get(item.mId, -1);\n            if (firstShown == -1) {\n                firstShown = System.currentTimeMillis();\n                mFirstShown.put(item.mId, firstShown);\n            }\n            builder.setWhen(firstShown);\n\n            boolean hasContentText = false;\n            StringBuilder title = new StringBuilder(item.mTitles[0]);\n            if (item.mTitleCount > 1) {\n                title.append(mContext.getString(R.string.notification_filename_separator));\n                title.append(item.mTitles[1]);\n                if (item.mTitleCount > 2) {\n                    title.append(mContext.getString(R.string.notification_filename_extras,\n                            new Object[] { Integer.valueOf(item.mTitleCount - 2) }));\n                }\n            } else if (!TextUtils.isEmpty(item.mDescription)) {\n                builder.setContentText(item.mDescription);\n                hasContentText = true;\n            }\n            builder.setContentTitle(title);\n\n            if (hasPausedText) {\n                builder.setContentText(item.mPausedText);\n            } else {\n                long max = item.mTotalTotal;\n                long progress = item.mTotalCurrent;\n                while(max > Integer.MAX_VALUE) {\n                    max = max / 1024;\n                    progress = progress / 1024;\n                }\n                builder.setProgress((int) max, (int) progress, item.mTotalTotal == -1);\n                if (hasContentText) {\n                    builder.setContentInfo(\n                            buildPercentageLabel(mContext, item.mTotalTotal, item.mTotalCurrent));\n                }\n            }\n\n            Intent intent = new Intent(Constants.ACTION_LIST);\n            intent.setClassName(\"com.android.providers.downloads\",\n                    DownloadReceiver.class.getName());\n            intent.setData(\n                    ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, item.mId));\n            intent.putExtra(\"multiple\", item.mTitleCount > 1);\n\n            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n            mSystemFacade.postNotification(item.mId, builder.getNotification());\n\n        }\n    }\n\n    private void updateCompletedNotification(Collection<DownloadInfo> downloads) {\n        for (DownloadInfo download : downloads) {\n            if (!isCompleteAndVisible(download)) {\n                continue;\n            }\n            notificationForCompletedDownload(download.mId, download.mTitle,\n                    download.mStatus, download.mDestination, download.mLastMod);\n        }\n    }\n    void notificationForCompletedDownload(long id, String title, int status,\n            int destination, long lastMod) {\n        // Add the notifications\n        Notification.Builder builder = new Notification.Builder(mContext);\n        builder.setSmallIcon(android.R.drawable.stat_sys_download_done);\n        if (title == null || title.length() == 0) {\n            title = mContext.getResources().getString(\n                    R.string.download_unknown_title);\n        }\n        Uri contentUri =\n            ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        String caption;\n        Intent intent;\n        if (Downloads.Impl.isStatusError(status)) {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_failed);\n            intent = new Intent(Constants.ACTION_LIST);\n        } else {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_complete);\n            if (destination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                intent = new Intent(Constants.ACTION_OPEN);\n            } else {\n                intent = new Intent(Constants.ACTION_LIST);\n            }\n        }\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n\n        builder.setWhen(lastMod);\n        builder.setContentTitle(title);\n        builder.setContentText(caption);\n        builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        intent = new Intent(Constants.ACTION_HIDE);\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n        builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        mSystemFacade.postNotification(id, builder.getNotification());\n    }\n\n    private boolean isActiveAndVisible(DownloadInfo download) {\n        return 100 <= download.mStatus && download.mStatus < 200\n                && download.mVisibility != Downloads.Impl.VISIBILITY_HIDDEN;\n    }\n\n    private boolean isCompleteAndVisible(DownloadInfo download) {\n        return download.mStatus >= 200\n                && download.mVisibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\n    }\n\n    private static String buildPercentageLabel(\n            Context context, long totalBytes, long currentBytes) {\n        if (totalBytes <= 0) {\n            return null;\n        } else {\n            final int percent = (int) (100 * currentBytes / totalBytes);\n            return context.getString(R.string.download_percent, percent);\n        }\n    }\n}\n","lineNo":194}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.Notification;\nimport android.app.PendingIntent;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.SparseLongArray;\n\nimport java.util.Collection;\nimport java.util.HashMap;\n\n/**\n * This class handles the updating of the Notification Manager for the\n * cases where there is an ongoing download. Once the download is complete\n * (be it successful or unsuccessful) it is no longer the responsibility\n * of this component to show the download in the notification manager.\n *\n */\nclass DownloadNotification {\n\n    Context mContext;\n    HashMap <String, NotificationItem> mNotifications;\n    private SystemFacade mSystemFacade;\n\n    /** Time when each {@link DownloadInfo#mId} was first shown. */\n    private SparseLongArray mFirstShown = new SparseLongArray();\n\n    static final String LOGTAG = \"DownloadNotification\";\n    static final String WHERE_RUNNING =\n        \"(\" + Downloads.Impl.COLUMN_STATUS + \" >= '100') AND (\" +\n        Downloads.Impl.COLUMN_STATUS + \" <= '199') AND (\" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" IS NULL OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE + \"' OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"')\";\n    static final String WHERE_COMPLETED =\n        Downloads.Impl.COLUMN_STATUS + \" >= '200' AND \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"'\";\n\n\n    /**\n     * This inner class is used to collate downloads that are owned by\n     * the same application. This is so that only one notification line\n     * item is used for all downloads of a given application.\n     *\n     */\n    static class NotificationItem {\n        // TODO: refactor to mNotifId and avoid building Uris based on it, since\n        // they can overflow\n        int mId;  // This first db _id for the download for the app\n        long mTotalCurrent = 0;\n        long mTotalTotal = 0;\n        int mTitleCount = 0;\n        String mPackageName;  // App package name\n        String mDescription;\n        String[] mTitles = new String[2]; // download titles.\n        String mPausedText = null;\n\n        /*\n         * Add a second download to this notification item.\n         */\n        void addItem(String title, long currentBytes, long totalBytes) {\n            mTotalCurrent += currentBytes;\n            if (totalBytes <= 0 || mTotalTotal == -1) {\n                mTotalTotal = -1;\n            } else {\n                mTotalTotal += totalBytes;\n            }\n            if (mTitleCount < 2) {\n                mTitles[mTitleCount] = title;\n            }\n            mTitleCount++;\n        }\n    }\n\n\n    /**\n     * Constructor\n     * @param ctx The context to use to obtain access to the\n     *            Notification Service\n     */\n    DownloadNotification(Context ctx, SystemFacade systemFacade) {\n        mContext = ctx;\n        mSystemFacade = systemFacade;\n        mNotifications = new HashMap<String, NotificationItem>();\n    }\n\n    /*\n     * Update the notification ui.\n     */\n    public void updateNotification(Collection<DownloadInfo> downloads) {\n        updateActiveNotification(downloads);\n        updateCompletedNotification(downloads);\n    }\n\n    private void updateActiveNotification(Collection<DownloadInfo> downloads) {\n        // Collate the notifications\n        mNotifications.clear();\n        for (DownloadInfo download : downloads) {\n            if (!isActiveAndVisible(download)) {\n                continue;\n            }\n            String packageName = download.mPackage;\n            long max = download.mTotalBytes;\n            long progress = download.mCurrentBytes;\n            long id = download.mId;\n            String title = download.mTitle;\n            if (title == null || title.length() == 0) {\n                title = mContext.getResources().getString(\n                        R.string.download_unknown_title);\n            }\n\n            NotificationItem item;\n            if (mNotifications.containsKey(packageName)) {\n                item = mNotifications.get(packageName);\n                item.addItem(title, progress, max);\n            } else {\n                item = new NotificationItem();\n                item.mId = (int) id;\n                item.mPackageName = packageName;\n                item.mDescription = download.mDescription;\n                item.addItem(title, progress, max);\n                mNotifications.put(packageName, item);\n            }\n            if (download.mStatus == Downloads.Impl.STATUS_QUEUED_FOR_WIFI\n                    && item.mPausedText == null) {\n                item.mPausedText = mContext.getResources().getString(\n                        R.string.notification_need_wifi_for_size);\n            }\n        }\n\n        // Add the notifications\n        for (NotificationItem item : mNotifications.values()) {\n            // Build the notification object\n            final Notification.Builder builder = new Notification.Builder(mContext);\n\n            boolean hasPausedText = (item.mPausedText != null);\n            int iconResource = android.R.drawable.stat_sys_download;\n            if (hasPausedText) {\n                iconResource = android.R.drawable.stat_sys_warning;\n            }\n            builder.setSmallIcon(iconResource);\n            builder.setOngoing(true);\n\n            // set notification \"when\" to be first time this DownloadInfo.mId\n            // was encountered, which avoids fighting with other notifs.\n            long firstShown = mFirstShown.get(item.mId, -1);\n            if (firstShown == -1) {\n                firstShown = System.currentTimeMillis();\n                mFirstShown.put(item.mId, firstShown);\n            }\n            builder.setWhen(firstShown);\n\n            boolean hasContentText = false;\n            StringBuilder title = new StringBuilder(item.mTitles[0]);\n            if (item.mTitleCount > 1) {\n                title.append(mContext.getString(R.string.notification_filename_separator));\n                title.append(item.mTitles[1]);\n                if (item.mTitleCount > 2) {\n                    title.append(mContext.getString(R.string.notification_filename_extras,\n                            new Object[] { Integer.valueOf(item.mTitleCount - 2) }));\n                }\n            } else if (!TextUtils.isEmpty(item.mDescription)) {\n                builder.setContentText(item.mDescription);\n                hasContentText = true;\n            }\n            builder.setContentTitle(title);\n\n            if (hasPausedText) {\n                builder.setContentText(item.mPausedText);\n            } else {\n                builder.setProgress(\n                        (int) item.mTotalTotal, (int) item.mTotalCurrent, item.mTotalTotal == -1);\n                if (hasContentText) {\n                    builder.setContentInfo(\n                            buildPercentageLabel(mContext, item.mTotalTotal, item.mTotalCurrent));\n                }\n            }\n\n            Intent intent = new Intent(Constants.ACTION_LIST);\n            intent.setClassName(\"com.android.providers.downloads\",\n                    DownloadReceiver.class.getName());\n            intent.setData(\n                    ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, item.mId));\n            intent.putExtra(\"multiple\", item.mTitleCount > 1);\n\n            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n            mSystemFacade.postNotification(item.mId, builder.getNotification());\n\n        }\n    }\n\n    private void updateCompletedNotification(Collection<DownloadInfo> downloads) {\n        for (DownloadInfo download : downloads) {\n            if (!isCompleteAndVisible(download)) {\n                continue;\n            }\n            notificationForCompletedDownload(download.mId, download.mTitle,\n                    download.mStatus, download.mDestination, download.mLastMod);\n        }\n    }\n    void notificationForCompletedDownload(long id, String title, int status,\n            int destination, long lastMod) {\n        // Add the notifications\n        Notification.Builder builder = new Notification.Builder(mContext);\n        builder.setSmallIcon(android.R.drawable.stat_sys_download_done);\n        if (title == null || title.length() == 0) {\n            title = mContext.getResources().getString(\n                    R.string.download_unknown_title);\n        }\n        Uri contentUri =\n            ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        String caption;\n        Intent intent;\n        if (Downloads.Impl.isStatusError(status)) {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_failed);\n            intent = new Intent(Constants.ACTION_LIST);\n        } else {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_complete);\n            if (destination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                intent = new Intent(Constants.ACTION_OPEN);\n            } else {\n                intent = new Intent(Constants.ACTION_LIST);\n            }\n        }\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n\n        builder.setWhen(lastMod);\n        builder.setContentTitle(title);\n        builder.setContentText(caption);\n        builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        intent = new Intent(Constants.ACTION_HIDE);\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n        builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        mSystemFacade.postNotification(id, builder.getNotification());\n    }\n\n    private boolean isActiveAndVisible(DownloadInfo download) {\n        return 100 <= download.mStatus && download.mStatus < 200\n                && download.mVisibility != Downloads.Impl.VISIBILITY_HIDDEN;\n    }\n\n    private boolean isCompleteAndVisible(DownloadInfo download) {\n        return download.mStatus >= 200\n                && download.mVisibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\n    }\n\n    private static String buildPercentageLabel(\n            Context context, long totalBytes, long currentBytes) {\n        if (totalBytes <= 0) {\n            return null;\n        } else {\n            final int percent = (int) (100 * currentBytes / totalBytes);\n            return context.getString(R.string.download_percent, percent);\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.Notification;\nimport android.app.PendingIntent;\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.SparseLongArray;\n\nimport java.util.Collection;\nimport java.util.HashMap;\n\n/**\n * This class handles the updating of the Notification Manager for the\n * cases where there is an ongoing download. Once the download is complete\n * (be it successful or unsuccessful) it is no longer the responsibility\n * of this component to show the download in the notification manager.\n *\n */\nclass DownloadNotification {\n\n    Context mContext;\n    HashMap <String, NotificationItem> mNotifications;\n    private SystemFacade mSystemFacade;\n\n    /** Time when each {@link DownloadInfo#mId} was first shown. */\n    private SparseLongArray mFirstShown = new SparseLongArray();\n\n    static final String LOGTAG = \"DownloadNotification\";\n    static final String WHERE_RUNNING =\n        \"(\" + Downloads.Impl.COLUMN_STATUS + \" >= '100') AND (\" +\n        Downloads.Impl.COLUMN_STATUS + \" <= '199') AND (\" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" IS NULL OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY + \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE + \"' OR \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"')\";\n    static final String WHERE_COMPLETED =\n        Downloads.Impl.COLUMN_STATUS + \" >= '200' AND \" +\n        Downloads.Impl.COLUMN_VISIBILITY +\n            \" == '\" + Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED + \"'\";\n\n\n    /**\n     * This inner class is used to collate downloads that are owned by\n     * the same application. This is so that only one notification line\n     * item is used for all downloads of a given application.\n     *\n     */\n    static class NotificationItem {\n        // TODO: refactor to mNotifId and avoid building Uris based on it, since\n        // they can overflow\n        int mId;  // This first db _id for the download for the app\n        long mTotalCurrent = 0;\n        long mTotalTotal = 0;\n        int mTitleCount = 0;\n        String mPackageName;  // App package name\n        String mDescription;\n        String[] mTitles = new String[2]; // download titles.\n        String mPausedText = null;\n\n        /*\n         * Add a second download to this notification item.\n         */\n        void addItem(String title, long currentBytes, long totalBytes) {\n            mTotalCurrent += currentBytes;\n            if (totalBytes <= 0 || mTotalTotal == -1) {\n                mTotalTotal = -1;\n            } else {\n                mTotalTotal += totalBytes;\n            }\n            if (mTitleCount < 2) {\n                mTitles[mTitleCount] = title;\n            }\n            mTitleCount++;\n        }\n    }\n\n\n    /**\n     * Constructor\n     * @param ctx The context to use to obtain access to the\n     *            Notification Service\n     */\n    DownloadNotification(Context ctx, SystemFacade systemFacade) {\n        mContext = ctx;\n        mSystemFacade = systemFacade;\n        mNotifications = new HashMap<String, NotificationItem>();\n    }\n\n    /*\n     * Update the notification ui.\n     */\n    public void updateNotification(Collection<DownloadInfo> downloads) {\n        updateActiveNotification(downloads);\n        updateCompletedNotification(downloads);\n    }\n\n    private void updateActiveNotification(Collection<DownloadInfo> downloads) {\n        // Collate the notifications\n        mNotifications.clear();\n        for (DownloadInfo download : downloads) {\n            if (!isActiveAndVisible(download)) {\n                continue;\n            }\n            String packageName = download.mPackage;\n            long max = download.mTotalBytes;\n            long progress = download.mCurrentBytes;\n            long id = download.mId;\n            String title = download.mTitle;\n            if (title == null || title.length() == 0) {\n                title = mContext.getResources().getString(\n                        R.string.download_unknown_title);\n            }\n\n            NotificationItem item;\n            if (mNotifications.containsKey(packageName)) {\n                item = mNotifications.get(packageName);\n                item.addItem(title, progress, max);\n            } else {\n                item = new NotificationItem();\n                item.mId = (int) id;\n                item.mPackageName = packageName;\n                item.mDescription = download.mDescription;\n                item.addItem(title, progress, max);\n                mNotifications.put(packageName, item);\n            }\n            if (download.mStatus == Downloads.Impl.STATUS_QUEUED_FOR_WIFI\n                    && item.mPausedText == null) {\n                item.mPausedText = mContext.getResources().getString(\n                        R.string.notification_need_wifi_for_size);\n            }\n        }\n\n        // Add the notifications\n        for (NotificationItem item : mNotifications.values()) {\n            // Build the notification object\n            final Notification.Builder builder = new Notification.Builder(mContext);\n\n            boolean hasPausedText = (item.mPausedText != null);\n            int iconResource = android.R.drawable.stat_sys_download;\n            if (hasPausedText) {\n                iconResource = android.R.drawable.stat_sys_warning;\n            }\n            builder.setSmallIcon(iconResource);\n            builder.setOngoing(true);\n\n            // set notification \"when\" to be first time this DownloadInfo.mId\n            // was encountered, which avoids fighting with other notifs.\n            long firstShown = mFirstShown.get(item.mId, -1);\n            if (firstShown == -1) {\n                firstShown = System.currentTimeMillis();\n                mFirstShown.put(item.mId, firstShown);\n            }\n            builder.setWhen(firstShown);\n\n            boolean hasContentText = false;\n            StringBuilder title = new StringBuilder(item.mTitles[0]);\n            if (item.mTitleCount > 1) {\n                title.append(mContext.getString(R.string.notification_filename_separator));\n                title.append(item.mTitles[1]);\n                if (item.mTitleCount > 2) {\n                    title.append(mContext.getString(R.string.notification_filename_extras,\n                            new Object[] { Integer.valueOf(item.mTitleCount - 2) }));\n                }\n            } else if (!TextUtils.isEmpty(item.mDescription)) {\n                builder.setContentText(item.mDescription);\n                hasContentText = true;\n            }\n            builder.setContentTitle(title);\n\n            if (hasPausedText) {\n                builder.setContentText(item.mPausedText);\n            } else {\n                long max = item.mTotalTotal;\n                long progress = item.mTotalCurrent;\n                while(max > Integer.MAX_VALUE) {\n                    max = max / 1024;\n                    progress = progress / 1024;\n                }\n                builder.setProgress((int) max, (int) progress, item.mTotalTotal == -1);\n                if (hasContentText) {\n                    builder.setContentInfo(\n                            buildPercentageLabel(mContext, item.mTotalTotal, item.mTotalCurrent));\n                }\n            }\n\n            Intent intent = new Intent(Constants.ACTION_LIST);\n            intent.setClassName(\"com.android.providers.downloads\",\n                    DownloadReceiver.class.getName());\n            intent.setData(\n                    ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, item.mId));\n            intent.putExtra(\"multiple\", item.mTitleCount > 1);\n\n            builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n            mSystemFacade.postNotification(item.mId, builder.getNotification());\n\n        }\n    }\n\n    private void updateCompletedNotification(Collection<DownloadInfo> downloads) {\n        for (DownloadInfo download : downloads) {\n            if (!isCompleteAndVisible(download)) {\n                continue;\n            }\n            notificationForCompletedDownload(download.mId, download.mTitle,\n                    download.mStatus, download.mDestination, download.mLastMod);\n        }\n    }\n    void notificationForCompletedDownload(long id, String title, int status,\n            int destination, long lastMod) {\n        // Add the notifications\n        Notification.Builder builder = new Notification.Builder(mContext);\n        builder.setSmallIcon(android.R.drawable.stat_sys_download_done);\n        if (title == null || title.length() == 0) {\n            title = mContext.getResources().getString(\n                    R.string.download_unknown_title);\n        }\n        Uri contentUri =\n            ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        String caption;\n        Intent intent;\n        if (Downloads.Impl.isStatusError(status)) {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_failed);\n            intent = new Intent(Constants.ACTION_LIST);\n        } else {\n            caption = mContext.getResources()\n                    .getString(R.string.notification_download_complete);\n            if (destination != Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) {\n                intent = new Intent(Constants.ACTION_OPEN);\n            } else {\n                intent = new Intent(Constants.ACTION_LIST);\n            }\n        }\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n\n        builder.setWhen(lastMod);\n        builder.setContentTitle(title);\n        builder.setContentText(caption);\n        builder.setContentIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        intent = new Intent(Constants.ACTION_HIDE);\n        intent.setClassName(\"com.android.providers.downloads\",\n                DownloadReceiver.class.getName());\n        intent.setData(contentUri);\n        builder.setDeleteIntent(PendingIntent.getBroadcast(mContext, 0, intent, 0));\n\n        mSystemFacade.postNotification(id, builder.getNotification());\n    }\n\n    private boolean isActiveAndVisible(DownloadInfo download) {\n        return 100 <= download.mStatus && download.mStatus < 200\n                && download.mVisibility != Downloads.Impl.VISIBILITY_HIDDEN;\n    }\n\n    private boolean isCompleteAndVisible(DownloadInfo download) {\n        return download.mStatus >= 200\n                && download.mVisibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\n    }\n\n    private static String buildPercentageLabel(\n            Context context, long totalBytes, long currentBytes) {\n        if (totalBytes <= 0) {\n            return null;\n        } else {\n            final int percent = (int) (100 * currentBytes / totalBytes);\n            return context.getString(R.string.download_percent, percent);\n        }\n    }\n}\n","lineNo":193}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.NetworkInfo.DetailedState;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.provider.Downloads;\nimport android.provider.Downloads.Impl;\nimport android.text.TextUtils;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\n\n/**\n * Stores information about an individual download.\n */\npublic class DownloadInfo {\n    // TODO: move towards these in-memory objects being sources of truth, and\n    // periodically pushing to provider.\n\n    public static class Reader {\n        private ContentResolver mResolver;\n        private Cursor mCursor;\n\n        public Reader(ContentResolver resolver, Cursor cursor) {\n            mResolver = resolver;\n            mCursor = cursor;\n        }\n\n        public DownloadInfo newDownloadInfo(Context context, SystemFacade systemFacade,\n                StorageManager storageManager, DownloadNotifier notifier) {\n            final DownloadInfo info = new DownloadInfo(\n                    context, systemFacade, storageManager, notifier);\n            updateFromDatabase(info);\n            readRequestHeaders(info);\n            return info;\n        }\n\n        public void updateFromDatabase(DownloadInfo info) {\n            info.mId = getLong(Downloads.Impl._ID);\n            info.mUri = getString(Downloads.Impl.COLUMN_URI);\n            info.mNoIntegrity = getInt(Downloads.Impl.COLUMN_NO_INTEGRITY) == 1;\n            info.mHint = getString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n            info.mFileName = getString(Downloads.Impl._DATA);\n            info.mMimeType = getString(Downloads.Impl.COLUMN_MIME_TYPE);\n            info.mDestination = getInt(Downloads.Impl.COLUMN_DESTINATION);\n            info.mVisibility = getInt(Downloads.Impl.COLUMN_VISIBILITY);\n            info.mStatus = getInt(Downloads.Impl.COLUMN_STATUS);\n            info.mNumFailed = getInt(Downloads.Impl.COLUMN_FAILED_CONNECTIONS);\n            int retryRedirect = getInt(Constants.RETRY_AFTER_X_REDIRECT_COUNT);\n            info.mRetryAfter = retryRedirect & 0xfffffff;\n            info.mLastMod = getLong(Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            info.mPackage = getString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n            info.mClass = getString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n            info.mExtras = getString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS);\n            info.mCookies = getString(Downloads.Impl.COLUMN_COOKIE_DATA);\n            info.mUserAgent = getString(Downloads.Impl.COLUMN_USER_AGENT);\n            info.mReferer = getString(Downloads.Impl.COLUMN_REFERER);\n            info.mTotalBytes = getLong(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            info.mCurrentBytes = getLong(Downloads.Impl.COLUMN_CURRENT_BYTES);\n            info.mETag = getString(Constants.ETAG);\n            info.mUid = getInt(Constants.UID);\n            info.mMediaScanned = getInt(Constants.MEDIA_SCANNED);\n            info.mDeleted = getInt(Downloads.Impl.COLUMN_DELETED) == 1;\n            info.mMediaProviderUri = getString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n            info.mIsPublicApi = getInt(Downloads.Impl.COLUMN_IS_PUBLIC_API) != 0;\n            info.mAllowedNetworkTypes = getInt(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n            info.mAllowRoaming = getInt(Downloads.Impl.COLUMN_ALLOW_ROAMING) != 0;\n            info.mAllowMetered = getInt(Downloads.Impl.COLUMN_ALLOW_METERED) != 0;\n            info.mTitle = getString(Downloads.Impl.COLUMN_TITLE);\n            info.mDescription = getString(Downloads.Impl.COLUMN_DESCRIPTION);\n            info.mBypassRecommendedSizeLimit =\n                    getInt(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n\n            synchronized (this) {\n                info.mControl = getInt(Downloads.Impl.COLUMN_CONTROL);\n            }\n        }\n\n        private void readRequestHeaders(DownloadInfo info) {\n            info.mRequestHeaders.clear();\n            Uri headerUri = Uri.withAppendedPath(\n                    info.getAllDownloadsUri(), Downloads.Impl.RequestHeaders.URI_SEGMENT);\n            Cursor cursor = mResolver.query(headerUri, null, null, null, null);\n            try {\n                int headerIndex =\n                        cursor.getColumnIndexOrThrow(Downloads.Impl.RequestHeaders.COLUMN_HEADER);\n                int valueIndex =\n                        cursor.getColumnIndexOrThrow(Downloads.Impl.RequestHeaders.COLUMN_VALUE);\n                for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                    addHeader(info, cursor.getString(headerIndex), cursor.getString(valueIndex));\n                }\n            } finally {\n                cursor.close();\n            }\n\n            if (info.mCookies != null) {\n                addHeader(info, \"Cookie\", info.mCookies);\n            }\n            if (info.mReferer != null) {\n                addHeader(info, \"Referer\", info.mReferer);\n            }\n        }\n\n        private void addHeader(DownloadInfo info, String header, String value) {\n            info.mRequestHeaders.add(Pair.create(header, value));\n        }\n\n        private String getString(String column) {\n            int index = mCursor.getColumnIndexOrThrow(column);\n            String s = mCursor.getString(index);\n            return (TextUtils.isEmpty(s)) ? null : s;\n        }\n\n        private Integer getInt(String column) {\n            return mCursor.getInt(mCursor.getColumnIndexOrThrow(column));\n        }\n\n        private Long getLong(String column) {\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(column));\n        }\n    }\n\n    /**\n     * Constants used to indicate network state for a specific download, after\n     * applying any requested constraints.\n     */\n    public enum NetworkState {\n        /**\n         * The network is usable for the given download.\n         */\n        OK,\n\n        /**\n         * There is no network connectivity.\n         */\n        NO_CONNECTION,\n\n        /**\n         * The download exceeds the maximum size for this network.\n         */\n        UNUSABLE_DUE_TO_SIZE,\n\n        /**\n         * The download exceeds the recommended maximum size for this network,\n         * the user must confirm for this download to proceed without WiFi.\n         */\n        RECOMMENDED_UNUSABLE_DUE_TO_SIZE,\n\n        /**\n         * The current connection is roaming, and the download can't proceed\n         * over a roaming connection.\n         */\n        CANNOT_USE_ROAMING,\n\n        /**\n         * The app requesting the download specific that it can't use the\n         * current network connection.\n         */\n        TYPE_DISALLOWED_BY_REQUESTOR,\n\n        /**\n         * Current network is blocked for requesting application.\n         */\n        BLOCKED;\n    }\n\n    /**\n     * For intents used to notify the user that a download exceeds a size threshold, if this extra\n     * is true, WiFi is required for this download size; otherwise, it is only recommended.\n     */\n    public static final String EXTRA_IS_WIFI_REQUIRED = \"isWifiRequired\";\n\n    public long mId;\n    public String mUri;\n    public boolean mNoIntegrity;\n    public String mHint;\n    public String mFileName;\n    public String mMimeType;\n    public int mDestination;\n    public int mVisibility;\n    public int mControl;\n    public int mStatus;\n    public int mNumFailed;\n    public int mRetryAfter;\n    public long mLastMod;\n    public String mPackage;\n    public String mClass;\n    public String mExtras;\n    public String mCookies;\n    public String mUserAgent;\n    public String mReferer;\n    public long mTotalBytes;\n    public long mCurrentBytes;\n    public String mETag;\n    public int mUid;\n    public int mMediaScanned;\n    public boolean mDeleted;\n    public String mMediaProviderUri;\n    public boolean mIsPublicApi;\n    public int mAllowedNetworkTypes;\n    public boolean mAllowRoaming;\n    public boolean mAllowMetered;\n    public String mTitle;\n    public String mDescription;\n    public int mBypassRecommendedSizeLimit;\n\n    public int mFuzz;\n\n    private List<Pair<String, String>> mRequestHeaders = new ArrayList<Pair<String, String>>();\n\n    /**\n     * Result of last {@link DownloadThread} started by\n     * {@link #startIfReady(ExecutorService)}.\n     */\n    @GuardedBy(\"this\")\n    private Future<?> mActiveTask;\n\n    private final Context mContext;\n    private final SystemFacade mSystemFacade;\n    private final StorageManager mStorageManager;\n    private final DownloadNotifier mNotifier;\n\n    private DownloadInfo(Context context, SystemFacade systemFacade, StorageManager storageManager,\n            DownloadNotifier notifier) {\n        mContext = context;\n        mSystemFacade = systemFacade;\n        mStorageManager = storageManager;\n        mNotifier = notifier;\n        mFuzz = Helpers.sRandom.nextInt(1001);\n    }\n\n    public Collection<Pair<String, String>> getHeaders() {\n        return Collections.unmodifiableList(mRequestHeaders);\n    }\n\n    public void sendIntentIfRequested() {\n        if (mPackage == null) {\n            return;\n        }\n\n        Intent intent;\n        if (mIsPublicApi) {\n            intent = new Intent(DownloadManager.ACTION_DOWNLOAD_COMPLETE);\n            intent.setPackage(mPackage);\n            intent.putExtra(DownloadManager.EXTRA_DOWNLOAD_ID, mId);\n        } else { // legacy behavior\n            if (mClass == null) {\n                return;\n            }\n            intent = new Intent(Downloads.Impl.ACTION_DOWNLOAD_COMPLETED);\n            intent.setClassName(mPackage, mClass);\n            if (mExtras != null) {\n                intent.putExtra(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, mExtras);\n            }\n            // We only send the content: URI, for security reasons. Otherwise, malicious\n            //     applications would have an easier time spoofing download results by\n            //     sending spoofed intents.\n            intent.setData(getMyDownloadsUri());\n        }\n        mSystemFacade.sendBroadcast(intent);\n    }\n\n    /**\n     * Returns the time when a download should be restarted.\n     */\n    public long restartTime(long now) {\n        if (mNumFailed == 0) {\n            return now;\n        }\n        if (mRetryAfter > 0) {\n            return mLastMod + mRetryAfter;\n        }\n        return mLastMod +\n                Constants.RETRY_FIRST_DELAY *\n                    (1000 + mFuzz) * (1 << (mNumFailed - 1));\n    }\n\n    /**\n     * Returns whether this download should be enqueued.\n     */\n    private boolean isReadyToStart() {\n        if (mControl == Downloads.Impl.CONTROL_PAUSED) {\n            // the download is paused, so it's not going to start\n            return false;\n        }\n        switch (mStatus) {\n            case 0: // status hasn't been initialized yet, this is a new download\n            case Downloads.Impl.STATUS_PENDING: // download is explicit marked as ready to start\n            case Downloads.Impl.STATUS_RUNNING: // download interrupted (process killed etc) while\n                                                // running, without a chance to update the database\n                return true;\n\n            case Downloads.Impl.STATUS_WAITING_FOR_NETWORK:\n            case Downloads.Impl.STATUS_QUEUED_FOR_WIFI:\n                return checkCanUseNetwork() == NetworkState.OK;\n\n            case Downloads.Impl.STATUS_WAITING_TO_RETRY:\n                // download was waiting for a delayed restart\n                final long now = mSystemFacade.currentTimeMillis();\n                return restartTime(now) <= now;\n            case Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR:\n                // is the media mounted?\n                return Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);\n            case Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR:\n                // avoids repetition of retrying download\n                return false;\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether this download has a visible notification after\n     * completion.\n     */\n    public boolean hasCompletionNotification() {\n        if (!Downloads.Impl.isStatusCompleted(mStatus)) {\n            return false;\n        }\n        if (mVisibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether this download is allowed to use the network.\n     * @return one of the NETWORK_* constants\n     */\n    public NetworkState checkCanUseNetwork() {\n        final NetworkInfo info = mSystemFacade.getActiveNetworkInfo(mUid);\n        if (info == null || !info.isConnected()) {\n            return NetworkState.NO_CONNECTION;\n        }\n        if (DetailedState.BLOCKED.equals(info.getDetailedState())) {\n            return NetworkState.BLOCKED;\n        }\n        if (mSystemFacade.isNetworkRoaming() && !isRoamingAllowed()) {\n            return NetworkState.CANNOT_USE_ROAMING;\n        }\n        if (mSystemFacade.isActiveNetworkMetered() && !mAllowMetered) {\n            return NetworkState.TYPE_DISALLOWED_BY_REQUESTOR;\n        }\n        return checkIsNetworkTypeAllowed(info.getType());\n    }\n\n    private boolean isRoamingAllowed() {\n        if (mIsPublicApi) {\n            return mAllowRoaming;\n        } else { // legacy behavior\n            return mDestination != Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING;\n        }\n    }\n\n    /**\n     * Check if this download can proceed over the given network type.\n     * @param networkType a constant from ConnectivityManager.TYPE_*.\n     * @return one of the NETWORK_* constants\n     */\n    private NetworkState checkIsNetworkTypeAllowed(int networkType) {\n        if (mIsPublicApi) {\n            final int flag = translateNetworkTypeToApiFlag(networkType);\n            final boolean allowAllNetworkTypes = mAllowedNetworkTypes == ~0;\n            if (!allowAllNetworkTypes && (flag & mAllowedNetworkTypes) == 0) {\n                return NetworkState.TYPE_DISALLOWED_BY_REQUESTOR;\n            }\n        }\n        return checkSizeAllowedForNetwork(networkType);\n    }\n\n    /**\n     * Translate a ConnectivityManager.TYPE_* constant to the corresponding\n     * DownloadManager.Request.NETWORK_* bit flag.\n     */\n    private int translateNetworkTypeToApiFlag(int networkType) {\n        switch (networkType) {\n            case ConnectivityManager.TYPE_MOBILE:\n                return DownloadManager.Request.NETWORK_MOBILE;\n\n            case ConnectivityManager.TYPE_WIFI:\n                return DownloadManager.Request.NETWORK_WIFI;\n\n            case ConnectivityManager.TYPE_BLUETOOTH:\n                return DownloadManager.Request.NETWORK_BLUETOOTH;\n\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * Check if the download's size prohibits it from running over the current network.\n     * @return one of the NETWORK_* constants\n     */\n    private NetworkState checkSizeAllowedForNetwork(int networkType) {\n        if (mTotalBytes <= 0) {\n            return NetworkState.OK; // we don't know the size yet\n        }\n        if (networkType == ConnectivityManager.TYPE_WIFI) {\n            return NetworkState.OK; // anything goes over wifi\n        }\n        Long maxBytesOverMobile = mSystemFacade.getMaxBytesOverMobile();\n        if (maxBytesOverMobile != null && mTotalBytes > maxBytesOverMobile) {\n            return NetworkState.UNUSABLE_DUE_TO_SIZE;\n        }\n        if (mBypassRecommendedSizeLimit == 0) {\n            Long recommendedMaxBytesOverMobile = mSystemFacade.getRecommendedMaxBytesOverMobile();\n            if (recommendedMaxBytesOverMobile != null\n                    && mTotalBytes > recommendedMaxBytesOverMobile) {\n                return NetworkState.RECOMMENDED_UNUSABLE_DUE_TO_SIZE;\n            }\n        }\n        return NetworkState.OK;\n    }\n\n    /**\n     * If download is ready to start, and isn't already pending or executing,\n     * create a {@link DownloadThread} and enqueue it into given\n     * {@link Executor}.\n     */\n    public void startIfReady(ExecutorService executor) {\n        synchronized (this) {\n            final boolean isActive = mActiveTask != null && !mActiveTask.isDone();\n            if (isReadyToStart() && !isActive) {\n                if (mStatus != Impl.STATUS_RUNNING) {\n                    mStatus = Impl.STATUS_RUNNING;\n                    ContentValues values = new ContentValues();\n                    values.put(Impl.COLUMN_STATUS, mStatus);\n                    mContext.getContentResolver().update(getAllDownloadsUri(), values, null, null);\n                }\n\n                final DownloadThread task = new DownloadThread(\n                        mContext, mSystemFacade, this, mStorageManager, mNotifier);\n                mActiveTask = executor.submit(task);\n            }\n        }\n    }\n\n    public boolean isOnCache() {\n        return (mDestination == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                || mDestination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION\n                || mDestination == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                || mDestination == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n    }\n\n    public Uri getMyDownloadsUri() {\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, mId);\n    }\n\n    public Uri getAllDownloadsUri() {\n        return ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, mId);\n    }\n\n    public void dump(IndentingPrintWriter pw) {\n        pw.println(\"DownloadInfo:\");\n        pw.increaseIndent();\n\n        pw.printPair(\"mId\", mId);\n        pw.printPair(\"mLastMod\", mLastMod);\n        pw.printPair(\"mPackage\", mPackage);\n        pw.printPair(\"mUid\", mUid);\n        pw.println();\n\n        pw.printPair(\"mUri\", mUri);\n        pw.println();\n\n        pw.printPair(\"mMimeType\", mMimeType);\n        pw.printPair(\"mCookies\", (mCookies != null) ? \"yes\" : \"no\");\n        pw.printPair(\"mReferer\", (mReferer != null) ? \"yes\" : \"no\");\n        pw.printPair(\"mUserAgent\", mUserAgent);\n        pw.println();\n\n        pw.printPair(\"mFileName\", mFileName);\n        pw.printPair(\"mDestination\", mDestination);\n        pw.println();\n\n        pw.printPair(\"mStatus\", Downloads.Impl.statusToString(mStatus));\n        pw.printPair(\"mCurrentBytes\", mCurrentBytes);\n        pw.printPair(\"mTotalBytes\", mTotalBytes);\n        pw.println();\n\n        pw.printPair(\"mNumFailed\", mNumFailed);\n        pw.printPair(\"mRetryAfter\", mRetryAfter);\n        pw.printPair(\"mETag\", mETag);\n        pw.printPair(\"mIsPublicApi\", mIsPublicApi);\n        pw.println();\n\n        pw.printPair(\"mAllowedNetworkTypes\", mAllowedNetworkTypes);\n        pw.printPair(\"mAllowRoaming\", mAllowRoaming);\n        pw.printPair(\"mAllowMetered\", mAllowMetered);\n        pw.println();\n\n        pw.decreaseIndent();\n    }\n\n    /**\n     * Returns the amount of time (as measured from the \"now\" parameter)\n     * at which a download will be active.\n     * 0 = immediately - service should stick around to handle this download.\n     * -1 = never - service can go away without ever waking up.\n     * positive value - service must wake up in the future, as specified in ms from \"now\"\n     */\n    long nextAction(long now) {\n        if (Downloads.Impl.isStatusCompleted(mStatus)) {\n            return -1;\n        }\n        if (mStatus != Downloads.Impl.STATUS_WAITING_TO_RETRY) {\n            return 0;\n        }\n        long when = restartTime(now);\n        if (when <= now) {\n            return 0;\n        }\n        return when - now;\n    }\n\n    /**\n     * Returns whether a file should be scanned\n     */\n    boolean shouldScanFile() {\n        return (mMediaScanned == 0)\n                && (mDestination == Downloads.Impl.DESTINATION_EXTERNAL ||\n                        mDestination == Downloads.Impl.DESTINATION_FILE_URI ||\n                        mDestination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                && Downloads.Impl.isStatusSuccess(mStatus);\n    }\n\n    void notifyPauseDueToSize(boolean isWifiRequired) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(getAllDownloadsUri());\n        intent.setClassName(SizeLimitActivity.class.getPackage().getName(),\n                SizeLimitActivity.class.getName());\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.putExtra(EXTRA_IS_WIFI_REQUIRED, isWifiRequired);\n        mContext.startActivity(intent);\n    }\n\n    /**\n     * Query and return status of requested download.\n     */\n    public static int queryDownloadStatus(ContentResolver resolver, long id) {\n        final Cursor cursor = resolver.query(\n                ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                new String[] { Downloads.Impl.COLUMN_STATUS }, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                return cursor.getInt(0);\n            } else {\n                // TODO: increase strictness of value returned for unknown\n                // downloads; this is safe default for now.\n                return Downloads.Impl.STATUS_PENDING;\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.content.ContentResolver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.NetworkInfo.DetailedState;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.provider.Downloads;\nimport android.provider.Downloads.Impl;\nimport android.text.TextUtils;\nimport android.util.Pair;\n\nimport com.android.internal.annotations.GuardedBy;\nimport com.android.internal.util.IndentingPrintWriter;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\n\n/**\n * Stores information about an individual download.\n */\npublic class DownloadInfo {\n    // TODO: move towards these in-memory objects being sources of truth, and\n    // periodically pushing to provider.\n\n    public static class Reader {\n        private ContentResolver mResolver;\n        private Cursor mCursor;\n\n        public Reader(ContentResolver resolver, Cursor cursor) {\n            mResolver = resolver;\n            mCursor = cursor;\n        }\n\n        public DownloadInfo newDownloadInfo(Context context, SystemFacade systemFacade,\n                StorageManager storageManager, DownloadNotifier notifier) {\n            final DownloadInfo info = new DownloadInfo(\n                    context, systemFacade, storageManager, notifier);\n            updateFromDatabase(info);\n            readRequestHeaders(info);\n            return info;\n        }\n\n        public void updateFromDatabase(DownloadInfo info) {\n            info.mId = getLong(Downloads.Impl._ID);\n            info.mUri = getString(Downloads.Impl.COLUMN_URI);\n            info.mNoIntegrity = getInt(Downloads.Impl.COLUMN_NO_INTEGRITY) == 1;\n            info.mHint = getString(Downloads.Impl.COLUMN_FILE_NAME_HINT);\n            info.mFileName = getString(Downloads.Impl._DATA);\n            info.mMimeType = getString(Downloads.Impl.COLUMN_MIME_TYPE);\n            info.mDestination = getInt(Downloads.Impl.COLUMN_DESTINATION);\n            info.mVisibility = getInt(Downloads.Impl.COLUMN_VISIBILITY);\n            info.mStatus = getInt(Downloads.Impl.COLUMN_STATUS);\n            info.mNumFailed = getInt(Downloads.Impl.COLUMN_FAILED_CONNECTIONS);\n            int retryRedirect = getInt(Constants.RETRY_AFTER_X_REDIRECT_COUNT);\n            info.mRetryAfter = retryRedirect & 0xfffffff;\n            info.mLastMod = getLong(Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            info.mPackage = getString(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n            info.mClass = getString(Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n            info.mExtras = getString(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS);\n            info.mCookies = getString(Downloads.Impl.COLUMN_COOKIE_DATA);\n            info.mUserAgent = getString(Downloads.Impl.COLUMN_USER_AGENT);\n            info.mReferer = getString(Downloads.Impl.COLUMN_REFERER);\n            info.mTotalBytes = getLong(Downloads.Impl.COLUMN_TOTAL_BYTES);\n            info.mCurrentBytes = getLong(Downloads.Impl.COLUMN_CURRENT_BYTES);\n            info.mETag = getString(Constants.ETAG);\n            info.mUid = getInt(Constants.UID);\n            info.mMediaScanned = getInt(Constants.MEDIA_SCANNED);\n            info.mDeleted = getInt(Downloads.Impl.COLUMN_DELETED) == 1;\n            info.mMediaProviderUri = getString(Downloads.Impl.COLUMN_MEDIAPROVIDER_URI);\n            info.mIsPublicApi = getInt(Downloads.Impl.COLUMN_IS_PUBLIC_API) != 0;\n            info.mAllowedNetworkTypes = getInt(Downloads.Impl.COLUMN_ALLOWED_NETWORK_TYPES);\n            info.mAllowRoaming = getInt(Downloads.Impl.COLUMN_ALLOW_ROAMING) != 0;\n            info.mAllowMetered = getInt(Downloads.Impl.COLUMN_ALLOW_METERED) != 0;\n            info.mTitle = getString(Downloads.Impl.COLUMN_TITLE);\n            info.mDescription = getString(Downloads.Impl.COLUMN_DESCRIPTION);\n            info.mBypassRecommendedSizeLimit =\n                    getInt(Downloads.Impl.COLUMN_BYPASS_RECOMMENDED_SIZE_LIMIT);\n\n            synchronized (this) {\n                info.mControl = getInt(Downloads.Impl.COLUMN_CONTROL);\n            }\n        }\n\n        private void readRequestHeaders(DownloadInfo info) {\n            info.mRequestHeaders.clear();\n            Uri headerUri = Uri.withAppendedPath(\n                    info.getAllDownloadsUri(), Downloads.Impl.RequestHeaders.URI_SEGMENT);\n            Cursor cursor = mResolver.query(headerUri, null, null, null, null);\n            try {\n                int headerIndex =\n                        cursor.getColumnIndexOrThrow(Downloads.Impl.RequestHeaders.COLUMN_HEADER);\n                int valueIndex =\n                        cursor.getColumnIndexOrThrow(Downloads.Impl.RequestHeaders.COLUMN_VALUE);\n                for (cursor.moveToFirst(); !cursor.isAfterLast(); cursor.moveToNext()) {\n                    addHeader(info, cursor.getString(headerIndex), cursor.getString(valueIndex));\n                }\n            } finally {\n                cursor.close();\n            }\n\n            if (info.mCookies != null) {\n                addHeader(info, \"Cookie\", info.mCookies);\n            }\n            if (info.mReferer != null) {\n                addHeader(info, \"Referer\", info.mReferer);\n            }\n        }\n\n        private void addHeader(DownloadInfo info, String header, String value) {\n            info.mRequestHeaders.add(Pair.create(header, value));\n        }\n\n        private String getString(String column) {\n            int index = mCursor.getColumnIndexOrThrow(column);\n            String s = mCursor.getString(index);\n            return (TextUtils.isEmpty(s)) ? null : s;\n        }\n\n        private Integer getInt(String column) {\n            return mCursor.getInt(mCursor.getColumnIndexOrThrow(column));\n        }\n\n        private Long getLong(String column) {\n            return mCursor.getLong(mCursor.getColumnIndexOrThrow(column));\n        }\n    }\n\n    /**\n     * Constants used to indicate network state for a specific download, after\n     * applying any requested constraints.\n     */\n    public enum NetworkState {\n        /**\n         * The network is usable for the given download.\n         */\n        OK,\n\n        /**\n         * There is no network connectivity.\n         */\n        NO_CONNECTION,\n\n        /**\n         * The download exceeds the maximum size for this network.\n         */\n        UNUSABLE_DUE_TO_SIZE,\n\n        /**\n         * The download exceeds the recommended maximum size for this network,\n         * the user must confirm for this download to proceed without WiFi.\n         */\n        RECOMMENDED_UNUSABLE_DUE_TO_SIZE,\n\n        /**\n         * The current connection is roaming, and the download can't proceed\n         * over a roaming connection.\n         */\n        CANNOT_USE_ROAMING,\n\n        /**\n         * The app requesting the download specific that it can't use the\n         * current network connection.\n         */\n        TYPE_DISALLOWED_BY_REQUESTOR,\n\n        /**\n         * Current network is blocked for requesting application.\n         */\n        BLOCKED;\n    }\n\n    /**\n     * For intents used to notify the user that a download exceeds a size threshold, if this extra\n     * is true, WiFi is required for this download size; otherwise, it is only recommended.\n     */\n    public static final String EXTRA_IS_WIFI_REQUIRED = \"isWifiRequired\";\n\n    public long mId;\n    public String mUri;\n    public boolean mNoIntegrity;\n    public String mHint;\n    public String mFileName;\n    public String mMimeType;\n    public int mDestination;\n    public int mVisibility;\n    public int mControl;\n    public int mStatus;\n    public int mNumFailed;\n    public int mRetryAfter;\n    public long mLastMod;\n    public String mPackage;\n    public String mClass;\n    public String mExtras;\n    public String mCookies;\n    public String mUserAgent;\n    public String mReferer;\n    public long mTotalBytes;\n    public long mCurrentBytes;\n    public String mETag;\n    public int mUid;\n    public int mMediaScanned;\n    public boolean mDeleted;\n    public String mMediaProviderUri;\n    public boolean mIsPublicApi;\n    public int mAllowedNetworkTypes;\n    public boolean mAllowRoaming;\n    public boolean mAllowMetered;\n    public String mTitle;\n    public String mDescription;\n    public int mBypassRecommendedSizeLimit;\n\n    public int mFuzz;\n\n    private List<Pair<String, String>> mRequestHeaders = new ArrayList<Pair<String, String>>();\n\n    /**\n     * Result of last {@link DownloadThread} started by\n     * {@link #startDownloadIfReady(ExecutorService)}.\n     */\n    @GuardedBy(\"this\")\n    private Future<?> mActiveDownload;\n\n    private final Context mContext;\n    private final SystemFacade mSystemFacade;\n    private final StorageManager mStorageManager;\n    private final DownloadNotifier mNotifier;\n\n    private DownloadInfo(Context context, SystemFacade systemFacade, StorageManager storageManager,\n            DownloadNotifier notifier) {\n        mContext = context;\n        mSystemFacade = systemFacade;\n        mStorageManager = storageManager;\n        mNotifier = notifier;\n        mFuzz = Helpers.sRandom.nextInt(1001);\n    }\n\n    public Collection<Pair<String, String>> getHeaders() {\n        return Collections.unmodifiableList(mRequestHeaders);\n    }\n\n    public void sendIntentIfRequested() {\n        if (mPackage == null) {\n            return;\n        }\n\n        Intent intent;\n        if (mIsPublicApi) {\n            intent = new Intent(DownloadManager.ACTION_DOWNLOAD_COMPLETE);\n            intent.setPackage(mPackage);\n            intent.putExtra(DownloadManager.EXTRA_DOWNLOAD_ID, mId);\n        } else { // legacy behavior\n            if (mClass == null) {\n                return;\n            }\n            intent = new Intent(Downloads.Impl.ACTION_DOWNLOAD_COMPLETED);\n            intent.setClassName(mPackage, mClass);\n            if (mExtras != null) {\n                intent.putExtra(Downloads.Impl.COLUMN_NOTIFICATION_EXTRAS, mExtras);\n            }\n            // We only send the content: URI, for security reasons. Otherwise, malicious\n            //     applications would have an easier time spoofing download results by\n            //     sending spoofed intents.\n            intent.setData(getMyDownloadsUri());\n        }\n        mSystemFacade.sendBroadcast(intent);\n    }\n\n    /**\n     * Returns the time when a download should be restarted.\n     */\n    public long restartTime(long now) {\n        if (mNumFailed == 0) {\n            return now;\n        }\n        if (mRetryAfter > 0) {\n            return mLastMod + mRetryAfter;\n        }\n        return mLastMod +\n                Constants.RETRY_FIRST_DELAY *\n                    (1000 + mFuzz) * (1 << (mNumFailed - 1));\n    }\n\n    /**\n     * Returns whether this download should be enqueued.\n     */\n    private boolean isReadyToDownload() {\n        if (mControl == Downloads.Impl.CONTROL_PAUSED) {\n            // the download is paused, so it's not going to start\n            return false;\n        }\n        switch (mStatus) {\n            case 0: // status hasn't been initialized yet, this is a new download\n            case Downloads.Impl.STATUS_PENDING: // download is explicit marked as ready to start\n            case Downloads.Impl.STATUS_RUNNING: // download interrupted (process killed etc) while\n                                                // running, without a chance to update the database\n                return true;\n\n            case Downloads.Impl.STATUS_WAITING_FOR_NETWORK:\n            case Downloads.Impl.STATUS_QUEUED_FOR_WIFI:\n                return checkCanUseNetwork() == NetworkState.OK;\n\n            case Downloads.Impl.STATUS_WAITING_TO_RETRY:\n                // download was waiting for a delayed restart\n                final long now = mSystemFacade.currentTimeMillis();\n                return restartTime(now) <= now;\n            case Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR:\n                // is the media mounted?\n                return Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED);\n            case Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR:\n                // avoids repetition of retrying download\n                return false;\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether this download has a visible notification after\n     * completion.\n     */\n    public boolean hasCompletionNotification() {\n        if (!Downloads.Impl.isStatusCompleted(mStatus)) {\n            return false;\n        }\n        if (mVisibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * Returns whether this download is allowed to use the network.\n     * @return one of the NETWORK_* constants\n     */\n    public NetworkState checkCanUseNetwork() {\n        final NetworkInfo info = mSystemFacade.getActiveNetworkInfo(mUid);\n        if (info == null || !info.isConnected()) {\n            return NetworkState.NO_CONNECTION;\n        }\n        if (DetailedState.BLOCKED.equals(info.getDetailedState())) {\n            return NetworkState.BLOCKED;\n        }\n        if (mSystemFacade.isNetworkRoaming() && !isRoamingAllowed()) {\n            return NetworkState.CANNOT_USE_ROAMING;\n        }\n        if (mSystemFacade.isActiveNetworkMetered() && !mAllowMetered) {\n            return NetworkState.TYPE_DISALLOWED_BY_REQUESTOR;\n        }\n        return checkIsNetworkTypeAllowed(info.getType());\n    }\n\n    private boolean isRoamingAllowed() {\n        if (mIsPublicApi) {\n            return mAllowRoaming;\n        } else { // legacy behavior\n            return mDestination != Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING;\n        }\n    }\n\n    /**\n     * Check if this download can proceed over the given network type.\n     * @param networkType a constant from ConnectivityManager.TYPE_*.\n     * @return one of the NETWORK_* constants\n     */\n    private NetworkState checkIsNetworkTypeAllowed(int networkType) {\n        if (mIsPublicApi) {\n            final int flag = translateNetworkTypeToApiFlag(networkType);\n            final boolean allowAllNetworkTypes = mAllowedNetworkTypes == ~0;\n            if (!allowAllNetworkTypes && (flag & mAllowedNetworkTypes) == 0) {\n                return NetworkState.TYPE_DISALLOWED_BY_REQUESTOR;\n            }\n        }\n        return checkSizeAllowedForNetwork(networkType);\n    }\n\n    /**\n     * Translate a ConnectivityManager.TYPE_* constant to the corresponding\n     * DownloadManager.Request.NETWORK_* bit flag.\n     */\n    private int translateNetworkTypeToApiFlag(int networkType) {\n        switch (networkType) {\n            case ConnectivityManager.TYPE_MOBILE:\n                return DownloadManager.Request.NETWORK_MOBILE;\n\n            case ConnectivityManager.TYPE_WIFI:\n                return DownloadManager.Request.NETWORK_WIFI;\n\n            case ConnectivityManager.TYPE_BLUETOOTH:\n                return DownloadManager.Request.NETWORK_BLUETOOTH;\n\n            default:\n                return 0;\n        }\n    }\n\n    /**\n     * Check if the download's size prohibits it from running over the current network.\n     * @return one of the NETWORK_* constants\n     */\n    private NetworkState checkSizeAllowedForNetwork(int networkType) {\n        if (mTotalBytes <= 0) {\n            return NetworkState.OK; // we don't know the size yet\n        }\n        if (networkType == ConnectivityManager.TYPE_WIFI) {\n            return NetworkState.OK; // anything goes over wifi\n        }\n        Long maxBytesOverMobile = mSystemFacade.getMaxBytesOverMobile();\n        if (maxBytesOverMobile != null && mTotalBytes > maxBytesOverMobile) {\n            return NetworkState.UNUSABLE_DUE_TO_SIZE;\n        }\n        if (mBypassRecommendedSizeLimit == 0) {\n            Long recommendedMaxBytesOverMobile = mSystemFacade.getRecommendedMaxBytesOverMobile();\n            if (recommendedMaxBytesOverMobile != null\n                    && mTotalBytes > recommendedMaxBytesOverMobile) {\n                return NetworkState.RECOMMENDED_UNUSABLE_DUE_TO_SIZE;\n            }\n        }\n        return NetworkState.OK;\n    }\n\n    /**\n     * If download is ready to start, and isn't already pending or executing,\n     * create a {@link DownloadThread} and enqueue it into given\n     * {@link Executor}.\n     *\n     * @return If actively downloading.\n     */\n    public boolean startDownloadIfReady(ExecutorService executor) {\n        synchronized (this) {\n            final boolean isReady = isReadyToDownload();\n            final boolean isActive = mActiveDownload != null && !mActiveDownload.isDone();\n            if (isReady && !isActive) {\n                if (mStatus != Impl.STATUS_RUNNING) {\n                    mStatus = Impl.STATUS_RUNNING;\n                    ContentValues values = new ContentValues();\n                    values.put(Impl.COLUMN_STATUS, mStatus);\n                    mContext.getContentResolver().update(getAllDownloadsUri(), values, null, null);\n                }\n\n                final DownloadThread task = new DownloadThread(\n                        mContext, mSystemFacade, this, mStorageManager, mNotifier);\n                mActiveDownload = executor.submit(task);\n            }\n            return isReady;\n        }\n    }\n\n    /**\n     * If download is ready to be scanned, enqueue it into the given\n     * {@link DownloadScanner}.\n     *\n     * @return If actively scanning.\n     */\n    public boolean startScanIfReady(DownloadScanner scanner) {\n        synchronized (this) {\n            final boolean isReady = shouldScanFile();\n            if (isReady) {\n                scanner.requestScan(this);\n            }\n            return isReady;\n        }\n    }\n\n    public boolean isOnCache() {\n        return (mDestination == Downloads.Impl.DESTINATION_CACHE_PARTITION\n                || mDestination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION\n                || mDestination == Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING\n                || mDestination == Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n    }\n\n    public Uri getMyDownloadsUri() {\n        return ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, mId);\n    }\n\n    public Uri getAllDownloadsUri() {\n        return ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, mId);\n    }\n\n    public void dump(IndentingPrintWriter pw) {\n        pw.println(\"DownloadInfo:\");\n        pw.increaseIndent();\n\n        pw.printPair(\"mId\", mId);\n        pw.printPair(\"mLastMod\", mLastMod);\n        pw.printPair(\"mPackage\", mPackage);\n        pw.printPair(\"mUid\", mUid);\n        pw.println();\n\n        pw.printPair(\"mUri\", mUri);\n        pw.println();\n\n        pw.printPair(\"mMimeType\", mMimeType);\n        pw.printPair(\"mCookies\", (mCookies != null) ? \"yes\" : \"no\");\n        pw.printPair(\"mReferer\", (mReferer != null) ? \"yes\" : \"no\");\n        pw.printPair(\"mUserAgent\", mUserAgent);\n        pw.println();\n\n        pw.printPair(\"mFileName\", mFileName);\n        pw.printPair(\"mDestination\", mDestination);\n        pw.println();\n\n        pw.printPair(\"mStatus\", Downloads.Impl.statusToString(mStatus));\n        pw.printPair(\"mCurrentBytes\", mCurrentBytes);\n        pw.printPair(\"mTotalBytes\", mTotalBytes);\n        pw.println();\n\n        pw.printPair(\"mNumFailed\", mNumFailed);\n        pw.printPair(\"mRetryAfter\", mRetryAfter);\n        pw.printPair(\"mETag\", mETag);\n        pw.printPair(\"mIsPublicApi\", mIsPublicApi);\n        pw.println();\n\n        pw.printPair(\"mAllowedNetworkTypes\", mAllowedNetworkTypes);\n        pw.printPair(\"mAllowRoaming\", mAllowRoaming);\n        pw.printPair(\"mAllowMetered\", mAllowMetered);\n        pw.println();\n\n        pw.decreaseIndent();\n    }\n\n    /**\n     * Return time when this download will be ready for its next action, in\n     * milliseconds after given time.\n     *\n     * @return If {@code 0}, download is ready to proceed immediately. If\n     *         {@link Long#MAX_VALUE}, then download has no future actions.\n     */\n    public long nextActionMillis(long now) {\n        if (Downloads.Impl.isStatusCompleted(mStatus)) {\n            return Long.MAX_VALUE;\n        }\n        if (mStatus != Downloads.Impl.STATUS_WAITING_TO_RETRY) {\n            return 0;\n        }\n        long when = restartTime(now);\n        if (when <= now) {\n            return 0;\n        }\n        return when - now;\n    }\n\n    /**\n     * Returns whether a file should be scanned\n     */\n    public boolean shouldScanFile() {\n        return (mMediaScanned == 0)\n                && (mDestination == Downloads.Impl.DESTINATION_EXTERNAL ||\n                        mDestination == Downloads.Impl.DESTINATION_FILE_URI ||\n                        mDestination == Downloads.Impl.DESTINATION_NON_DOWNLOADMANAGER_DOWNLOAD)\n                && Downloads.Impl.isStatusSuccess(mStatus);\n    }\n\n    void notifyPauseDueToSize(boolean isWifiRequired) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(getAllDownloadsUri());\n        intent.setClassName(SizeLimitActivity.class.getPackage().getName(),\n                SizeLimitActivity.class.getName());\n        intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.putExtra(EXTRA_IS_WIFI_REQUIRED, isWifiRequired);\n        mContext.startActivity(intent);\n    }\n\n    /**\n     * Query and return status of requested download.\n     */\n    public static int queryDownloadStatus(ContentResolver resolver, long id) {\n        final Cursor cursor = resolver.query(\n                ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                new String[] { Downloads.Impl.COLUMN_STATUS }, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                return cursor.getInt(0);\n            } else {\n                // TODO: increase strictness of value returned for unknown\n                // downloads; this is safe default for now.\n                return Downloads.Impl.STATUS_PENDING;\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n}\n","lineNo":458}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static com.android.providers.downloads.Constants.TAG;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_UNAVAILABLE;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.drm.DrmManagerClient;\nimport android.drm.DrmOutputStream;\nimport android.net.INetworkPolicyListener;\nimport android.net.NetworkPolicyManager;\nimport android.net.TrafficStats;\nimport android.os.FileUtils;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Pair;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.SyncFailedException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\n\nimport libcore.io.IoUtils;\n\n/**\n * Thread which executes a given {@link DownloadInfo}: making network requests,\n * persisting data to disk, and updating {@link DownloadProvider}.\n */\npublic class DownloadThread extends Thread {\n\n    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n\n    private static final int DEFAULT_TIMEOUT = (int) MINUTE_IN_MILLIS;\n\n    private final Context mContext;\n    private final DownloadInfo mInfo;\n    private final SystemFacade mSystemFacade;\n    private final StorageManager mStorageManager;\n\n    private volatile boolean mPolicyDirty;\n\n    public DownloadThread(Context context, SystemFacade systemFacade, DownloadInfo info,\n            StorageManager storageManager) {\n        mContext = context;\n        mSystemFacade = systemFacade;\n        mInfo = info;\n        mStorageManager = storageManager;\n    }\n\n    /**\n     * Returns the user agent provided by the initiating app, or use the default one\n     */\n    private String userAgent() {\n        String userAgent = mInfo.mUserAgent;\n        if (userAgent == null) {\n            userAgent = Constants.DEFAULT_USER_AGENT;\n        }\n        return userAgent;\n    }\n\n    /**\n     * State for the entire run() method.\n     */\n    static class State {\n        public String mFilename;\n        public String mMimeType;\n        public boolean mCountRetry = false;\n        public int mRetryAfter = 0;\n        public boolean mGotData = false;\n        public String mRequestUri;\n        public long mTotalBytes = -1;\n        public long mCurrentBytes = 0;\n        public String mHeaderETag;\n        public boolean mContinuingDownload = false;\n        public long mBytesNotified = 0;\n        public long mTimeLastNotification = 0;\n\n        /** Historical bytes/second speed of this download. */\n        public long mSpeed;\n        /** Time when current sample started. */\n        public long mSpeedSampleStart;\n        /** Bytes transferred since current sample started. */\n        public long mSpeedSampleBytes;\n\n        public State(DownloadInfo info) {\n            mMimeType = Intent.normalizeMimeType(info.mMimeType);\n            mRequestUri = info.mUri;\n            mFilename = info.mFileName;\n            mTotalBytes = info.mTotalBytes;\n            mCurrentBytes = info.mCurrentBytes;\n        }\n    }\n\n    /**\n     * State within executeDownload()\n     */\n    private static class InnerState {\n        public long mContentLength;\n        public String mContentDisposition;\n        public String mContentLocation;\n    }\n\n    /**\n     * Executes the download in a separate thread\n     */\n    @Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        try {\n            runInternal();\n        } finally {\n            DownloadHandler.getInstance().dequeueDownload(mInfo.mId);\n        }\n    }\n\n    private void runInternal() {\n        // Skip when download already marked as finished; this download was\n        // probably started again while racing with UpdateThread.\n        if (DownloadInfo.queryDownloadStatus(mContext.getContentResolver(), mInfo.mId)\n                == Downloads.Impl.STATUS_SUCCESS) {\n            Log.d(TAG, \"Download \" + mInfo.mId + \" already finished; skipping\");\n            return;\n        }\n\n        State state = new State(mInfo);\n        PowerManager.WakeLock wakeLock = null;\n        int finalStatus = Downloads.Impl.STATUS_UNKNOWN_ERROR;\n        String errorMsg = null;\n\n        final NetworkPolicyManager netPolicy = NetworkPolicyManager.from(mContext);\n        final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n\n        try {\n            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, Constants.TAG);\n            wakeLock.acquire();\n\n            // while performing download, register for rules updates\n            netPolicy.registerListener(mPolicyListener);\n\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"initiating download for \" + mInfo.mUri);\n            }\n\n            // network traffic on this thread should be counted against the\n            // requesting uid, and is tagged with well-known value.\n            TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_DOWNLOAD);\n            TrafficStats.setThreadStatsUid(mInfo.mUid);\n\n            boolean finished = false;\n            while (!finished) {\n                Log.i(Constants.TAG, \"Initiating request for download \" + mInfo.mId);\n\n                final URL url = new URL(state.mRequestUri);\n                final HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setConnectTimeout(DEFAULT_TIMEOUT);\n                conn.setReadTimeout(DEFAULT_TIMEOUT);\n                try {\n                    executeDownload(state, conn);\n                    finished = true;\n                } finally {\n                    conn.disconnect();\n                }\n            }\n\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"download completed for \" + mInfo.mUri);\n            }\n            finalizeDestinationFile(state);\n            finalStatus = Downloads.Impl.STATUS_SUCCESS;\n        } catch (StopRequestException error) {\n            // remove the cause before printing, in case it contains PII\n            errorMsg = error.getMessage();\n            String msg = \"Aborting request for download \" + mInfo.mId + \": \" + errorMsg;\n            Log.w(Constants.TAG, msg);\n            if (Constants.LOGV) {\n                Log.w(Constants.TAG, msg, error);\n            }\n            finalStatus = error.mFinalStatus;\n            // fall through to finally block\n        } catch (Throwable ex) {\n            errorMsg = ex.getMessage();\n            String msg = \"Exception for id \" + mInfo.mId + \": \" + errorMsg;\n            Log.w(Constants.TAG, msg, ex);\n            finalStatus = Downloads.Impl.STATUS_UNKNOWN_ERROR;\n            // falls through to the code that reports an error\n        } finally {\n            TrafficStats.clearThreadStatsTag();\n            TrafficStats.clearThreadStatsUid();\n\n            cleanupDestination(state, finalStatus);\n            notifyDownloadCompleted(finalStatus, state.mCountRetry, state.mRetryAfter,\n                    state.mGotData, state.mFilename, state.mMimeType, errorMsg);\n\n            netPolicy.unregisterListener(mPolicyListener);\n\n            if (wakeLock != null) {\n                wakeLock.release();\n                wakeLock = null;\n            }\n        }\n        mStorageManager.incrementNumDownloadsSoFar();\n    }\n\n    /**\n     * Fully execute a single download request - setup and send the request, handle the response,\n     * and transfer the data to the destination file.\n     */\n    private void executeDownload(State state, HttpURLConnection conn) throws StopRequestException {\n        final InnerState innerState = new InnerState();\n\n        setupDestinationFile(state, innerState);\n        addRequestHeaders(state, conn);\n\n        // skip when already finished; remove after fixing race in 5217390\n        if (state.mCurrentBytes == state.mTotalBytes) {\n            Log.i(Constants.TAG, \"Skipping initiating request for download \" +\n                  mInfo.mId + \"; already completed\");\n            return;\n        }\n\n        // check just before sending the request to avoid using an invalid connection at all\n        checkConnectivity();\n\n        InputStream in = null;\n        OutputStream out = null;\n        DrmManagerClient drmClient = null;\n        try {\n            try {\n                // Asking for response code will execute the request\n                final int statusCode = conn.getResponseCode();\n                in = conn.getInputStream();\n\n                handleExceptionalStatus(state, innerState, conn, statusCode);\n                processResponseHeaders(state, innerState, conn);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_HTTP_DATA_ERROR, \"Request failed: \" + e, e);\n            }\n\n            try {\n                if (DownloadDrmHelper.isDrmConvertNeeded(state.mMimeType)) {\n                    drmClient = new DrmManagerClient(mContext);\n                    out = new DrmOutputStream(\n                            drmClient, new File(state.mFilename), state.mMimeType);\n                } else {\n                    out = new FileOutputStream(state.mFilename);\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_FILE_ERROR, \"Failed to open destination: \" + e, e);\n            }\n\n            transferData(state, innerState, in, out);\n\n        } finally {\n            if (drmClient != null) {\n                drmClient.release();\n            }\n            IoUtils.closeQuietly(in);\n            IoUtils.closeQuietly(out);\n        }\n    }\n\n    /**\n     * Check if current connectivity is valid for this request.\n     */\n    private void checkConnectivity() throws StopRequestException {\n        // checking connectivity will apply current policy\n        mPolicyDirty = false;\n\n        int networkUsable = mInfo.checkCanUseNetwork();\n        if (networkUsable != DownloadInfo.NETWORK_OK) {\n            int status = Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\n            if (networkUsable == DownloadInfo.NETWORK_UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(true);\n            } else if (networkUsable == DownloadInfo.NETWORK_RECOMMENDED_UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(false);\n            }\n            throw new StopRequestException(status,\n                    mInfo.getLogMessageForNetworkError(networkUsable));\n        }\n    }\n\n    /**\n     * Transfer as much data as possible from the HTTP response to the\n     * destination file.\n     */\n    private void transferData(State state, InnerState innerState, InputStream in, OutputStream out)\n            throws StopRequestException {\n        final byte data[] = new byte[Constants.BUFFER_SIZE];\n        for (;;) {\n            int bytesRead = readFromResponse(state, innerState, data, in);\n            if (bytesRead == -1) { // success, end of stream already reached\n                handleEndOfStream(state, innerState);\n                return;\n            }\n\n            state.mGotData = true;\n            writeDataToDestination(state, data, bytesRead, out);\n            state.mCurrentBytes += bytesRead;\n            reportProgress(state, innerState);\n\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"downloaded \" + state.mCurrentBytes + \" for \"\n                      + mInfo.mUri);\n            }\n\n            checkPausedOrCanceled(state);\n        }\n    }\n\n    /**\n     * Called after a successful completion to take any necessary action on the downloaded file.\n     */\n    private void finalizeDestinationFile(State state) {\n        if (state.mFilename != null) {\n            // make sure the file is readable\n            FileUtils.setPermissions(state.mFilename, 0644, -1, -1);\n            syncDestination(state);\n        }\n    }\n\n    /**\n     * Called just before the thread finishes, regardless of status, to take any necessary action on\n     * the downloaded file.\n     */\n    private void cleanupDestination(State state, int finalStatus) {\n        if (state.mFilename != null && Downloads.Impl.isStatusError(finalStatus)) {\n            if (Constants.LOGVV) {\n                Log.d(TAG, \"cleanupDestination() deleting \" + state.mFilename);\n            }\n            new File(state.mFilename).delete();\n            state.mFilename = null;\n        }\n    }\n\n    /**\n     * Sync the destination file to storage.\n     */\n    private void syncDestination(State state) {\n        FileOutputStream downloadedFileStream = null;\n        try {\n            downloadedFileStream = new FileOutputStream(state.mFilename, true);\n            downloadedFileStream.getFD().sync();\n        } catch (FileNotFoundException ex) {\n            Log.w(Constants.TAG, \"file \" + state.mFilename + \" not found: \" + ex);\n        } catch (SyncFailedException ex) {\n            Log.w(Constants.TAG, \"file \" + state.mFilename + \" sync failed: \" + ex);\n        } catch (IOException ex) {\n            Log.w(Constants.TAG, \"IOException trying to sync \" + state.mFilename + \": \" + ex);\n        } catch (RuntimeException ex) {\n            Log.w(Constants.TAG, \"exception while syncing file: \", ex);\n        } finally {\n            IoUtils.closeQuietly(downloadedFileStream);\n        }\n    }\n\n    /**\n     * Check if the download has been paused or canceled, stopping the request appropriately if it\n     * has been.\n     */\n    private void checkPausedOrCanceled(State state) throws StopRequestException {\n        synchronized (mInfo) {\n            if (mInfo.mControl == Downloads.Impl.CONTROL_PAUSED) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_PAUSED_BY_APP, \"download paused by owner\");\n            }\n            if (mInfo.mStatus == Downloads.Impl.STATUS_CANCELED) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANCELED, \"download canceled\");\n            }\n        }\n\n        // if policy has been changed, trigger connectivity check\n        if (mPolicyDirty) {\n            checkConnectivity();\n        }\n    }\n\n    /**\n     * Report download progress through the database if necessary.\n     */\n    private void reportProgress(State state, InnerState innerState) {\n        final long now = SystemClock.elapsedRealtime();\n\n        final long sampleDelta = now - state.mSpeedSampleStart;\n        if (sampleDelta > 500) {\n            final long sampleSpeed = ((state.mCurrentBytes - state.mSpeedSampleBytes) * 1000)\n                    / sampleDelta;\n\n            if (state.mSpeed == 0) {\n                state.mSpeed = sampleSpeed;\n            } else {\n                state.mSpeed = ((state.mSpeed * 3) + sampleSpeed) / 4;\n            }\n\n            state.mSpeedSampleStart = now;\n            state.mSpeedSampleBytes = state.mCurrentBytes;\n\n            DownloadHandler.getInstance().setCurrentSpeed(mInfo.mId, state.mSpeed);\n        }\n\n        if (state.mCurrentBytes - state.mBytesNotified > Constants.MIN_PROGRESS_STEP &&\n            now - state.mTimeLastNotification > Constants.MIN_PROGRESS_TIME) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n            state.mBytesNotified = state.mCurrentBytes;\n            state.mTimeLastNotification = now;\n        }\n    }\n\n    /**\n     * Write a data buffer to the destination file.\n     * @param data buffer containing the data to write\n     * @param bytesRead how many bytes to write from the buffer\n     */\n    private void writeDataToDestination(State state, byte[] data, int bytesRead, OutputStream out)\n            throws StopRequestException {\n        mStorageManager.verifySpaceBeforeWritingToFile(\n                mInfo.mDestination, state.mFilename, bytesRead);\n\n        boolean forceVerified = false;\n        while (true) {\n            try {\n                out.write(data, 0, bytesRead);\n                return;\n            } catch (IOException ex) {\n                // TODO: better differentiate between DRM and disk failures\n                if (!forceVerified) {\n                    // couldn't write to file. are we out of space? check.\n                    mStorageManager.verifySpace(mInfo.mDestination, state.mFilename, bytesRead);\n                    forceVerified = true;\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"Failed to write data: \" + ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Called when we've reached the end of the HTTP response stream, to update the database and\n     * check for consistency.\n     */\n    private void handleEndOfStream(State state, InnerState innerState) throws StopRequestException {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n        if (innerState.mContentLength == -1) {\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, state.mCurrentBytes);\n        }\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n\n        boolean lengthMismatched = (innerState.mContentLength != -1)\n                && (state.mCurrentBytes != innerState.mContentLength);\n        if (lengthMismatched) {\n            if (cannotResume(state)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                        \"mismatched content length; unable to resume\");\n            } else {\n                throw new StopRequestException(getFinalStatusForHttpError(state),\n                        \"closed socket before end of file\");\n            }\n        }\n    }\n\n    private boolean cannotResume(State state) {\n        return (state.mCurrentBytes > 0 && !mInfo.mNoIntegrity && state.mHeaderETag == null)\n                || DownloadDrmHelper.isDrmConvertNeeded(state.mMimeType);\n    }\n\n    /**\n     * Read some data from the HTTP response stream, handling I/O errors.\n     * @param data buffer to use to read data\n     * @param entityStream stream for reading the HTTP response entity\n     * @return the number of bytes actually read or -1 if the end of the stream has been reached\n     */\n    private int readFromResponse(State state, InnerState innerState, byte[] data,\n                                 InputStream entityStream) throws StopRequestException {\n        try {\n            return entityStream.read(data);\n        } catch (IOException ex) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n            if (cannotResume(state)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                        \"Failed reading response: \" + ex + \"; unable to resume\", ex);\n            } else {\n                throw new StopRequestException(getFinalStatusForHttpError(state),\n                        \"Failed reading response: \" + ex, ex);\n            }\n        }\n    }\n\n    /**\n     * Read HTTP response headers and take appropriate action, including setting up the destination\n     * file and updating the database.\n     */\n    private void processResponseHeaders(State state, InnerState innerState, HttpURLConnection conn)\n            throws StopRequestException {\n        if (state.mContinuingDownload) {\n            // ignore response headers on resume requests\n            return;\n        }\n\n        readResponseHeaders(state, innerState, conn);\n\n        state.mFilename = Helpers.generateSaveFile(\n                mContext,\n                mInfo.mUri,\n                mInfo.mHint,\n                innerState.mContentDisposition,\n                innerState.mContentLocation,\n                state.mMimeType,\n                mInfo.mDestination,\n                innerState.mContentLength,\n                mInfo.mIsPublicApi, mStorageManager);\n\n        updateDatabaseFromHeaders(state, innerState);\n        // check connectivity again now that we know the total size\n        checkConnectivity();\n    }\n\n    /**\n     * Update necessary database fields based on values of HTTP response headers that have been\n     * read.\n     */\n    private void updateDatabaseFromHeaders(State state, InnerState innerState) {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl._DATA, state.mFilename);\n        if (state.mHeaderETag != null) {\n            values.put(Constants.ETAG, state.mHeaderETag);\n        }\n        if (state.mMimeType != null) {\n            values.put(Downloads.Impl.COLUMN_MIME_TYPE, state.mMimeType);\n        }\n        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, mInfo.mTotalBytes);\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n    }\n\n    /**\n     * Read headers from the HTTP response and store them into local state.\n     */\n    private void readResponseHeaders(State state, InnerState innerState, HttpURLConnection conn)\n            throws StopRequestException {\n        innerState.mContentDisposition = conn.getHeaderField(\"Content-Disposition\");\n        innerState.mContentLocation = conn.getHeaderField(\"Content-Location\");\n\n        if (state.mMimeType == null) {\n            state.mMimeType = Intent.normalizeMimeType(conn.getContentType());\n        }\n\n        state.mHeaderETag = conn.getHeaderField(\"ETag\");\n\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        if (transferEncoding == null) {\n            innerState.mContentLength = getHeaderFieldLong(conn, \"Content-Length\", -1);\n        } else {\n            Log.i(TAG, \"Ignoring Content-Length since Transfer-Encoding is also defined\");\n            innerState.mContentLength = -1;\n        }\n\n        state.mTotalBytes = innerState.mContentLength;\n        mInfo.mTotalBytes = innerState.mContentLength;\n\n        final boolean noSizeInfo = innerState.mContentLength == -1\n                && (transferEncoding == null || !transferEncoding.equalsIgnoreCase(\"chunked\"));\n        if (!mInfo.mNoIntegrity && noSizeInfo) {\n            throw new StopRequestException(Downloads.Impl.STATUS_HTTP_DATA_ERROR,\n                    \"can't know size of download, giving up\");\n        }\n    }\n\n    /**\n     * Check the HTTP response status and handle anything unusual (e.g. not 200/206).\n     */\n    private void handleExceptionalStatus(\n            State state, InnerState innerState, HttpURLConnection conn, int statusCode)\n            throws StopRequestException {\n        if (statusCode == HTTP_UNAVAILABLE && mInfo.mNumFailed < Constants.MAX_RETRIES) {\n            handleServiceUnavailable(state, conn);\n        }\n\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"recevd_status = \" + statusCode +\n                    \", mContinuingDownload = \" + state.mContinuingDownload);\n        }\n        int expectedStatus = state.mContinuingDownload ? HTTP_PARTIAL : HTTP_OK;\n        if (statusCode != expectedStatus) {\n            handleOtherStatus(state, innerState, statusCode);\n        }\n    }\n\n    /**\n     * Handle a status that we don't know how to deal with properly.\n     */\n    private void handleOtherStatus(State state, InnerState innerState, int statusCode)\n            throws StopRequestException {\n        if (statusCode == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE) {\n            // range request failed. it should never fail.\n            throw new IllegalStateException(\"Http Range request failure: totalBytes = \" +\n                    state.mTotalBytes + \", bytes recvd so far: \" + state.mCurrentBytes);\n        }\n        int finalStatus;\n        if (statusCode >= 400 && statusCode < 600) {\n            finalStatus = statusCode;\n        } else if (statusCode >= 300 && statusCode < 400) {\n            finalStatus = Downloads.Impl.STATUS_UNHANDLED_REDIRECT;\n        } else if (state.mContinuingDownload && statusCode == HTTP_OK) {\n            finalStatus = Downloads.Impl.STATUS_CANNOT_RESUME;\n        } else {\n            finalStatus = Downloads.Impl.STATUS_UNHANDLED_HTTP_CODE;\n        }\n        throw new StopRequestException(finalStatus, \"http error \" +\n                statusCode + \", mContinuingDownload: \" + state.mContinuingDownload);\n    }\n\n    /**\n     * Handle a 503 Service Unavailable status by processing the Retry-After header.\n     */\n    private void handleServiceUnavailable(State state, HttpURLConnection conn)\n            throws StopRequestException {\n        state.mCountRetry = true;\n        state.mRetryAfter = conn.getHeaderFieldInt(\"Retry-After\", -1);\n        if (state.mRetryAfter < 0) {\n            state.mRetryAfter = 0;\n        } else {\n            if (state.mRetryAfter < Constants.MIN_RETRY_AFTER) {\n                state.mRetryAfter = Constants.MIN_RETRY_AFTER;\n            } else if (state.mRetryAfter > Constants.MAX_RETRY_AFTER) {\n                state.mRetryAfter = Constants.MAX_RETRY_AFTER;\n            }\n            state.mRetryAfter += Helpers.sRandom.nextInt(Constants.MIN_RETRY_AFTER + 1);\n            state.mRetryAfter *= 1000;\n        }\n\n        throw new StopRequestException(Downloads.Impl.STATUS_WAITING_TO_RETRY,\n                \"got 503 Service Unavailable, will retry later\");\n    }\n\n    private int getFinalStatusForHttpError(State state) {\n        int networkUsable = mInfo.checkCanUseNetwork();\n        if (networkUsable != DownloadInfo.NETWORK_OK) {\n            switch (networkUsable) {\n                case DownloadInfo.NETWORK_UNUSABLE_DUE_TO_SIZE:\n                case DownloadInfo.NETWORK_RECOMMENDED_UNUSABLE_DUE_TO_SIZE:\n                    return Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                default:\n                    return Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\n            }\n        } else if (mInfo.mNumFailed < Constants.MAX_RETRIES) {\n            state.mCountRetry = true;\n            return Downloads.Impl.STATUS_WAITING_TO_RETRY;\n        } else {\n            Log.w(Constants.TAG, \"reached max retries for \" + mInfo.mId);\n            return Downloads.Impl.STATUS_HTTP_DATA_ERROR;\n        }\n    }\n\n    /**\n     * Prepare the destination file to receive data.  If the file already exists, we'll set up\n     * appropriately for resumption.\n     */\n    private void setupDestinationFile(State state, InnerState innerState)\n            throws StopRequestException {\n        if (!TextUtils.isEmpty(state.mFilename)) { // only true if we've already run a thread for this download\n            if (Constants.LOGV) {\n                Log.i(Constants.TAG, \"have run thread before for id: \" + mInfo.mId +\n                        \", and state.mFilename: \" + state.mFilename);\n            }\n            if (!Helpers.isFilenameValid(state.mFilename,\n                    mStorageManager.getDownloadDataDirectory())) {\n                // this should never happen\n                throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                        \"found invalid internal destination filename\");\n            }\n            // We're resuming a download that got interrupted\n            File f = new File(state.mFilename);\n            if (f.exists()) {\n                if (Constants.LOGV) {\n                    Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                            \", and state.mFilename: \" + state.mFilename);\n                }\n                long fileLength = f.length();\n                if (fileLength == 0) {\n                    // The download hadn't actually started, we can restart from scratch\n                    if (Constants.LOGVV) {\n                        Log.d(TAG, \"setupDestinationFile() found fileLength=0, deleting \"\n                                + state.mFilename);\n                    }\n                    f.delete();\n                    state.mFilename = null;\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", BUT starting from scratch again: \");\n                    }\n                } else if (mInfo.mETag == null && !mInfo.mNoIntegrity) {\n                    // This should've been caught upon failure\n                    if (Constants.LOGVV) {\n                        Log.d(TAG, \"setupDestinationFile() unable to resume download, deleting \"\n                                + state.mFilename);\n                    }\n                    f.delete();\n                    throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                            \"Trying to resume a download that can't be resumed\");\n                } else {\n                    // All right, we'll be able to resume this download\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", and starting with file of length: \" + fileLength);\n                    }\n                    state.mCurrentBytes = (int) fileLength;\n                    if (mInfo.mTotalBytes != -1) {\n                        innerState.mContentLength = mInfo.mTotalBytes;\n                    }\n                    state.mHeaderETag = mInfo.mETag;\n                    state.mContinuingDownload = true;\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", state.mCurrentBytes: \" + state.mCurrentBytes +\n                                \", and setting mContinuingDownload to true: \");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add custom headers for this download to the HTTP request.\n     */\n    private void addRequestHeaders(State state, HttpURLConnection conn) {\n        conn.addRequestProperty(\"User-Agent\", userAgent());\n\n        for (Pair<String, String> header : mInfo.getHeaders()) {\n            conn.addRequestProperty(header.first, header.second);\n        }\n\n        if (state.mContinuingDownload) {\n            if (state.mHeaderETag != null) {\n                conn.addRequestProperty(\"If-Match\", state.mHeaderETag);\n            }\n            conn.addRequestProperty(\"Range\", \"bytes=\" + state.mCurrentBytes + \"-\");\n            if (Constants.LOGV) {\n                Log.i(Constants.TAG, \"Adding Range header: \" +\n                        \"bytes=\" + state.mCurrentBytes + \"-\");\n                Log.i(Constants.TAG, \"  totalBytes = \" + state.mTotalBytes);\n            }\n        }\n    }\n\n    /**\n     * Stores information about the completed download, and notifies the initiating application.\n     */\n    private void notifyDownloadCompleted(int status, boolean countRetry, int retryAfter,\n            boolean gotData, String filename, String mimeType, String errorMsg) {\n        notifyThroughDatabase(\n                status, countRetry, retryAfter, gotData, filename, mimeType, errorMsg);\n        if (Downloads.Impl.isStatusCompleted(status)) {\n            mInfo.sendIntentIfRequested();\n        }\n    }\n\n    private void notifyThroughDatabase(int status, boolean countRetry, int retryAfter,\n            boolean gotData, String filename, String mimeType, String errorMsg) {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl.COLUMN_STATUS, status);\n        values.put(Downloads.Impl._DATA, filename);\n        values.put(Downloads.Impl.COLUMN_MIME_TYPE, mimeType);\n        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, mSystemFacade.currentTimeMillis());\n        values.put(Constants.RETRY_AFTER_X_REDIRECT_COUNT, retryAfter);\n        if (!countRetry) {\n            values.put(Constants.FAILED_CONNECTIONS, 0);\n        } else if (gotData) {\n            values.put(Constants.FAILED_CONNECTIONS, 1);\n        } else {\n            values.put(Constants.FAILED_CONNECTIONS, mInfo.mNumFailed + 1);\n        }\n        // save the error message. could be useful to developers.\n        if (!TextUtils.isEmpty(errorMsg)) {\n            values.put(Downloads.Impl.COLUMN_ERROR_MSG, errorMsg);\n        }\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n    }\n\n    private INetworkPolicyListener mPolicyListener = new INetworkPolicyListener.Stub() {\n        @Override\n        public void onUidRulesChanged(int uid, int uidRules) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n\n        @Override\n        public void onMeteredIfacesChanged(String[] meteredIfaces) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onRestrictBackgroundChanged(boolean restrictBackground) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n    };\n\n    public static long getHeaderFieldLong(URLConnection conn, String field, long defaultValue) {\n        try {\n            return Long.parseLong(conn.getHeaderField(field));\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.text.format.DateUtils.MINUTE_IN_MILLIS;\nimport static com.android.providers.downloads.Constants.TAG;\nimport static java.net.HttpURLConnection.HTTP_OK;\nimport static java.net.HttpURLConnection.HTTP_PARTIAL;\nimport static java.net.HttpURLConnection.HTTP_UNAVAILABLE;\n\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.drm.DrmManagerClient;\nimport android.drm.DrmOutputStream;\nimport android.net.INetworkPolicyListener;\nimport android.net.NetworkPolicyManager;\nimport android.net.TrafficStats;\nimport android.os.FileUtils;\nimport android.os.PowerManager;\nimport android.os.Process;\nimport android.os.SystemClock;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Pair;\n\nimport java.io.File;\nimport java.io.FileDescriptor;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.RandomAccessFile;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.net.URLConnection;\n\nimport libcore.io.IoUtils;\n\n/**\n * Thread which executes a given {@link DownloadInfo}: making network requests,\n * persisting data to disk, and updating {@link DownloadProvider}.\n */\npublic class DownloadThread extends Thread {\n\n    private static final int HTTP_REQUESTED_RANGE_NOT_SATISFIABLE = 416;\n\n    private static final int DEFAULT_TIMEOUT = (int) MINUTE_IN_MILLIS;\n\n    private final Context mContext;\n    private final DownloadInfo mInfo;\n    private final SystemFacade mSystemFacade;\n    private final StorageManager mStorageManager;\n\n    private volatile boolean mPolicyDirty;\n\n    public DownloadThread(Context context, SystemFacade systemFacade, DownloadInfo info,\n            StorageManager storageManager) {\n        mContext = context;\n        mSystemFacade = systemFacade;\n        mInfo = info;\n        mStorageManager = storageManager;\n    }\n\n    /**\n     * Returns the user agent provided by the initiating app, or use the default one\n     */\n    private String userAgent() {\n        String userAgent = mInfo.mUserAgent;\n        if (userAgent == null) {\n            userAgent = Constants.DEFAULT_USER_AGENT;\n        }\n        return userAgent;\n    }\n\n    /**\n     * State for the entire run() method.\n     */\n    static class State {\n        public String mFilename;\n        public String mMimeType;\n        public boolean mCountRetry = false;\n        public int mRetryAfter = 0;\n        public boolean mGotData = false;\n        public String mRequestUri;\n        public long mTotalBytes = -1;\n        public long mCurrentBytes = 0;\n        public String mHeaderETag;\n        public boolean mContinuingDownload = false;\n        public long mBytesNotified = 0;\n        public long mTimeLastNotification = 0;\n\n        /** Historical bytes/second speed of this download. */\n        public long mSpeed;\n        /** Time when current sample started. */\n        public long mSpeedSampleStart;\n        /** Bytes transferred since current sample started. */\n        public long mSpeedSampleBytes;\n\n        public State(DownloadInfo info) {\n            mMimeType = Intent.normalizeMimeType(info.mMimeType);\n            mRequestUri = info.mUri;\n            mFilename = info.mFileName;\n            mTotalBytes = info.mTotalBytes;\n            mCurrentBytes = info.mCurrentBytes;\n        }\n    }\n\n    /**\n     * State within executeDownload()\n     */\n    private static class InnerState {\n        public long mContentLength;\n        public String mContentDisposition;\n        public String mContentLocation;\n    }\n\n    /**\n     * Executes the download in a separate thread\n     */\n    @Override\n    public void run() {\n        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);\n        try {\n            runInternal();\n        } finally {\n            DownloadHandler.getInstance().dequeueDownload(mInfo.mId);\n        }\n    }\n\n    private void runInternal() {\n        // Skip when download already marked as finished; this download was\n        // probably started again while racing with UpdateThread.\n        if (DownloadInfo.queryDownloadStatus(mContext.getContentResolver(), mInfo.mId)\n                == Downloads.Impl.STATUS_SUCCESS) {\n            Log.d(TAG, \"Download \" + mInfo.mId + \" already finished; skipping\");\n            return;\n        }\n\n        State state = new State(mInfo);\n        PowerManager.WakeLock wakeLock = null;\n        int finalStatus = Downloads.Impl.STATUS_UNKNOWN_ERROR;\n        String errorMsg = null;\n\n        final NetworkPolicyManager netPolicy = NetworkPolicyManager.from(mContext);\n        final PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);\n\n        try {\n            wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, Constants.TAG);\n            wakeLock.acquire();\n\n            // while performing download, register for rules updates\n            netPolicy.registerListener(mPolicyListener);\n\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"initiating download for \" + mInfo.mUri);\n            }\n\n            // network traffic on this thread should be counted against the\n            // requesting uid, and is tagged with well-known value.\n            TrafficStats.setThreadStatsTag(TrafficStats.TAG_SYSTEM_DOWNLOAD);\n            TrafficStats.setThreadStatsUid(mInfo.mUid);\n\n            boolean finished = false;\n            while (!finished) {\n                Log.i(Constants.TAG, \"Initiating request for download \" + mInfo.mId);\n\n                final URL url = new URL(state.mRequestUri);\n                final HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n                conn.setConnectTimeout(DEFAULT_TIMEOUT);\n                conn.setReadTimeout(DEFAULT_TIMEOUT);\n                try {\n                    executeDownload(state, conn);\n                    finished = true;\n                } finally {\n                    conn.disconnect();\n                }\n            }\n\n            if (Constants.LOGV) {\n                Log.v(Constants.TAG, \"download completed for \" + mInfo.mUri);\n            }\n            finalizeDestinationFile(state);\n            finalStatus = Downloads.Impl.STATUS_SUCCESS;\n        } catch (StopRequestException error) {\n            // remove the cause before printing, in case it contains PII\n            errorMsg = error.getMessage();\n            String msg = \"Aborting request for download \" + mInfo.mId + \": \" + errorMsg;\n            Log.w(Constants.TAG, msg);\n            if (Constants.LOGV) {\n                Log.w(Constants.TAG, msg, error);\n            }\n            finalStatus = error.mFinalStatus;\n            // fall through to finally block\n        } catch (Throwable ex) {\n            errorMsg = ex.getMessage();\n            String msg = \"Exception for id \" + mInfo.mId + \": \" + errorMsg;\n            Log.w(Constants.TAG, msg, ex);\n            finalStatus = Downloads.Impl.STATUS_UNKNOWN_ERROR;\n            // falls through to the code that reports an error\n        } finally {\n            TrafficStats.clearThreadStatsTag();\n            TrafficStats.clearThreadStatsUid();\n\n            cleanupDestination(state, finalStatus);\n            notifyDownloadCompleted(finalStatus, state.mCountRetry, state.mRetryAfter,\n                    state.mGotData, state.mFilename, state.mMimeType, errorMsg);\n\n            netPolicy.unregisterListener(mPolicyListener);\n\n            if (wakeLock != null) {\n                wakeLock.release();\n                wakeLock = null;\n            }\n        }\n        mStorageManager.incrementNumDownloadsSoFar();\n    }\n\n    /**\n     * Fully execute a single download request - setup and send the request, handle the response,\n     * and transfer the data to the destination file.\n     */\n    private void executeDownload(State state, HttpURLConnection conn) throws StopRequestException {\n        final InnerState innerState = new InnerState();\n\n        setupDestinationFile(state, innerState);\n        addRequestHeaders(state, conn);\n\n        // skip when already finished; remove after fixing race in 5217390\n        if (state.mCurrentBytes == state.mTotalBytes) {\n            Log.i(Constants.TAG, \"Skipping initiating request for download \" +\n                  mInfo.mId + \"; already completed\");\n            return;\n        }\n\n        // check just before sending the request to avoid using an invalid connection at all\n        checkConnectivity();\n\n        DrmManagerClient drmClient = null;\n        InputStream in = null;\n        OutputStream out = null;\n        FileDescriptor outFd = null;\n        try {\n            try {\n                // Asking for response code will execute the request\n                final int statusCode = conn.getResponseCode();\n                in = conn.getInputStream();\n\n                handleExceptionalStatus(state, innerState, conn, statusCode);\n                processResponseHeaders(state, innerState, conn);\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        getFinalStatusForHttpError(state), \"Request failed: \" + e, e);\n            }\n\n            try {\n                if (DownloadDrmHelper.isDrmConvertNeeded(state.mMimeType)) {\n                    drmClient = new DrmManagerClient(mContext);\n                    final RandomAccessFile file = new RandomAccessFile(\n                            new File(state.mFilename), \"rw\");\n                    out = new DrmOutputStream(drmClient, file, state.mMimeType);\n                    outFd = file.getFD();\n                } else {\n                    out = new FileOutputStream(state.mFilename, true);\n                    outFd = ((FileOutputStream) out).getFD();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_FILE_ERROR, \"Failed to open destination: \" + e, e);\n            }\n\n            transferData(state, innerState, in, out);\n\n            try {\n                if (out instanceof DrmOutputStream) {\n                    ((DrmOutputStream) out).finish();\n                }\n            } catch (IOException e) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_FILE_ERROR, \"Failed to finish: \" + e, e);\n            }\n\n        } finally {\n            if (drmClient != null) {\n                drmClient.release();\n            }\n\n            IoUtils.closeQuietly(in);\n\n            try {\n                if (out != null) out.flush();\n                if (outFd != null) outFd.sync();\n            } catch (IOException e) {\n            } finally {\n                IoUtils.closeQuietly(out);\n            }\n        }\n    }\n\n    /**\n     * Check if current connectivity is valid for this request.\n     */\n    private void checkConnectivity() throws StopRequestException {\n        // checking connectivity will apply current policy\n        mPolicyDirty = false;\n\n        int networkUsable = mInfo.checkCanUseNetwork();\n        if (networkUsable != DownloadInfo.NETWORK_OK) {\n            int status = Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\n            if (networkUsable == DownloadInfo.NETWORK_UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(true);\n            } else if (networkUsable == DownloadInfo.NETWORK_RECOMMENDED_UNUSABLE_DUE_TO_SIZE) {\n                status = Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                mInfo.notifyPauseDueToSize(false);\n            }\n            throw new StopRequestException(status,\n                    mInfo.getLogMessageForNetworkError(networkUsable));\n        }\n    }\n\n    /**\n     * Transfer as much data as possible from the HTTP response to the\n     * destination file.\n     */\n    private void transferData(State state, InnerState innerState, InputStream in, OutputStream out)\n            throws StopRequestException {\n        final byte data[] = new byte[Constants.BUFFER_SIZE];\n        for (;;) {\n            int bytesRead = readFromResponse(state, innerState, data, in);\n            if (bytesRead == -1) { // success, end of stream already reached\n                handleEndOfStream(state, innerState);\n                return;\n            }\n\n            state.mGotData = true;\n            writeDataToDestination(state, data, bytesRead, out);\n            state.mCurrentBytes += bytesRead;\n            reportProgress(state, innerState);\n\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"downloaded \" + state.mCurrentBytes + \" for \"\n                      + mInfo.mUri);\n            }\n\n            checkPausedOrCanceled(state);\n        }\n    }\n\n    /**\n     * Called after a successful completion to take any necessary action on the downloaded file.\n     */\n    private void finalizeDestinationFile(State state) {\n        if (state.mFilename != null) {\n            // make sure the file is readable\n            FileUtils.setPermissions(state.mFilename, 0644, -1, -1);\n        }\n    }\n\n    /**\n     * Called just before the thread finishes, regardless of status, to take any necessary action on\n     * the downloaded file.\n     */\n    private void cleanupDestination(State state, int finalStatus) {\n        if (state.mFilename != null && Downloads.Impl.isStatusError(finalStatus)) {\n            if (Constants.LOGVV) {\n                Log.d(TAG, \"cleanupDestination() deleting \" + state.mFilename);\n            }\n            new File(state.mFilename).delete();\n            state.mFilename = null;\n        }\n    }\n\n    /**\n     * Check if the download has been paused or canceled, stopping the request appropriately if it\n     * has been.\n     */\n    private void checkPausedOrCanceled(State state) throws StopRequestException {\n        synchronized (mInfo) {\n            if (mInfo.mControl == Downloads.Impl.CONTROL_PAUSED) {\n                throw new StopRequestException(\n                        Downloads.Impl.STATUS_PAUSED_BY_APP, \"download paused by owner\");\n            }\n            if (mInfo.mStatus == Downloads.Impl.STATUS_CANCELED) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANCELED, \"download canceled\");\n            }\n        }\n\n        // if policy has been changed, trigger connectivity check\n        if (mPolicyDirty) {\n            checkConnectivity();\n        }\n    }\n\n    /**\n     * Report download progress through the database if necessary.\n     */\n    private void reportProgress(State state, InnerState innerState) {\n        final long now = SystemClock.elapsedRealtime();\n\n        final long sampleDelta = now - state.mSpeedSampleStart;\n        if (sampleDelta > 500) {\n            final long sampleSpeed = ((state.mCurrentBytes - state.mSpeedSampleBytes) * 1000)\n                    / sampleDelta;\n\n            if (state.mSpeed == 0) {\n                state.mSpeed = sampleSpeed;\n            } else {\n                state.mSpeed = ((state.mSpeed * 3) + sampleSpeed) / 4;\n            }\n\n            state.mSpeedSampleStart = now;\n            state.mSpeedSampleBytes = state.mCurrentBytes;\n\n            DownloadHandler.getInstance().setCurrentSpeed(mInfo.mId, state.mSpeed);\n        }\n\n        if (state.mCurrentBytes - state.mBytesNotified > Constants.MIN_PROGRESS_STEP &&\n            now - state.mTimeLastNotification > Constants.MIN_PROGRESS_TIME) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n            state.mBytesNotified = state.mCurrentBytes;\n            state.mTimeLastNotification = now;\n        }\n    }\n\n    /**\n     * Write a data buffer to the destination file.\n     * @param data buffer containing the data to write\n     * @param bytesRead how many bytes to write from the buffer\n     */\n    private void writeDataToDestination(State state, byte[] data, int bytesRead, OutputStream out)\n            throws StopRequestException {\n        mStorageManager.verifySpaceBeforeWritingToFile(\n                mInfo.mDestination, state.mFilename, bytesRead);\n\n        boolean forceVerified = false;\n        while (true) {\n            try {\n                out.write(data, 0, bytesRead);\n                return;\n            } catch (IOException ex) {\n                // TODO: better differentiate between DRM and disk failures\n                if (!forceVerified) {\n                    // couldn't write to file. are we out of space? check.\n                    mStorageManager.verifySpace(mInfo.mDestination, state.mFilename, bytesRead);\n                    forceVerified = true;\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"Failed to write data: \" + ex);\n                }\n            }\n        }\n    }\n\n    /**\n     * Called when we've reached the end of the HTTP response stream, to update the database and\n     * check for consistency.\n     */\n    private void handleEndOfStream(State state, InnerState innerState) throws StopRequestException {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n        if (innerState.mContentLength == -1) {\n            values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, state.mCurrentBytes);\n        }\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n\n        boolean lengthMismatched = (innerState.mContentLength != -1)\n                && (state.mCurrentBytes != innerState.mContentLength);\n        if (lengthMismatched) {\n            if (cannotResume(state)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                        \"mismatched content length; unable to resume\");\n            } else {\n                throw new StopRequestException(getFinalStatusForHttpError(state),\n                        \"closed socket before end of file\");\n            }\n        }\n    }\n\n    private boolean cannotResume(State state) {\n        return (state.mCurrentBytes > 0 && !mInfo.mNoIntegrity && state.mHeaderETag == null)\n                || DownloadDrmHelper.isDrmConvertNeeded(state.mMimeType);\n    }\n\n    /**\n     * Read some data from the HTTP response stream, handling I/O errors.\n     * @param data buffer to use to read data\n     * @param entityStream stream for reading the HTTP response entity\n     * @return the number of bytes actually read or -1 if the end of the stream has been reached\n     */\n    private int readFromResponse(State state, InnerState innerState, byte[] data,\n                                 InputStream entityStream) throws StopRequestException {\n        try {\n            return entityStream.read(data);\n        } catch (IOException ex) {\n            // TODO: handle stream errors the same as other retries\n            if (\"unexpected end of stream\".equals(ex.getMessage())) {\n                return -1;\n            }\n\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_CURRENT_BYTES, state.mCurrentBytes);\n            mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n            if (cannotResume(state)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                        \"Failed reading response: \" + ex + \"; unable to resume\", ex);\n            } else {\n                throw new StopRequestException(getFinalStatusForHttpError(state),\n                        \"Failed reading response: \" + ex, ex);\n            }\n        }\n    }\n\n    /**\n     * Read HTTP response headers and take appropriate action, including setting up the destination\n     * file and updating the database.\n     */\n    private void processResponseHeaders(State state, InnerState innerState, HttpURLConnection conn)\n            throws StopRequestException {\n        if (state.mContinuingDownload) {\n            // ignore response headers on resume requests\n            return;\n        }\n\n        readResponseHeaders(state, innerState, conn);\n\n        state.mFilename = Helpers.generateSaveFile(\n                mContext,\n                mInfo.mUri,\n                mInfo.mHint,\n                innerState.mContentDisposition,\n                innerState.mContentLocation,\n                state.mMimeType,\n                mInfo.mDestination,\n                innerState.mContentLength,\n                mInfo.mIsPublicApi, mStorageManager);\n\n        updateDatabaseFromHeaders(state, innerState);\n        // check connectivity again now that we know the total size\n        checkConnectivity();\n    }\n\n    /**\n     * Update necessary database fields based on values of HTTP response headers that have been\n     * read.\n     */\n    private void updateDatabaseFromHeaders(State state, InnerState innerState) {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl._DATA, state.mFilename);\n        if (state.mHeaderETag != null) {\n            values.put(Constants.ETAG, state.mHeaderETag);\n        }\n        if (state.mMimeType != null) {\n            values.put(Downloads.Impl.COLUMN_MIME_TYPE, state.mMimeType);\n        }\n        values.put(Downloads.Impl.COLUMN_TOTAL_BYTES, mInfo.mTotalBytes);\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n    }\n\n    /**\n     * Read headers from the HTTP response and store them into local state.\n     */\n    private void readResponseHeaders(State state, InnerState innerState, HttpURLConnection conn)\n            throws StopRequestException {\n        innerState.mContentDisposition = conn.getHeaderField(\"Content-Disposition\");\n        innerState.mContentLocation = conn.getHeaderField(\"Content-Location\");\n\n        if (state.mMimeType == null) {\n            state.mMimeType = Intent.normalizeMimeType(conn.getContentType());\n        }\n\n        state.mHeaderETag = conn.getHeaderField(\"ETag\");\n\n        final String transferEncoding = conn.getHeaderField(\"Transfer-Encoding\");\n        if (transferEncoding == null) {\n            innerState.mContentLength = getHeaderFieldLong(conn, \"Content-Length\", -1);\n        } else {\n            Log.i(TAG, \"Ignoring Content-Length since Transfer-Encoding is also defined\");\n            innerState.mContentLength = -1;\n        }\n\n        state.mTotalBytes = innerState.mContentLength;\n        mInfo.mTotalBytes = innerState.mContentLength;\n\n        final boolean noSizeInfo = innerState.mContentLength == -1\n                && (transferEncoding == null || !transferEncoding.equalsIgnoreCase(\"chunked\"));\n        if (!mInfo.mNoIntegrity && noSizeInfo) {\n            throw new StopRequestException(Downloads.Impl.STATUS_HTTP_DATA_ERROR,\n                    \"can't know size of download, giving up\");\n        }\n    }\n\n    /**\n     * Check the HTTP response status and handle anything unusual (e.g. not 200/206).\n     */\n    private void handleExceptionalStatus(\n            State state, InnerState innerState, HttpURLConnection conn, int statusCode)\n            throws StopRequestException {\n        if (statusCode == HTTP_UNAVAILABLE && mInfo.mNumFailed < Constants.MAX_RETRIES) {\n            handleServiceUnavailable(state, conn);\n        }\n\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"recevd_status = \" + statusCode +\n                    \", mContinuingDownload = \" + state.mContinuingDownload);\n        }\n        int expectedStatus = state.mContinuingDownload ? HTTP_PARTIAL : HTTP_OK;\n        if (statusCode != expectedStatus) {\n            handleOtherStatus(state, innerState, statusCode);\n        }\n    }\n\n    /**\n     * Handle a status that we don't know how to deal with properly.\n     */\n    private void handleOtherStatus(State state, InnerState innerState, int statusCode)\n            throws StopRequestException {\n        if (statusCode == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE) {\n            // range request failed. it should never fail.\n            throw new IllegalStateException(\"Http Range request failure: totalBytes = \" +\n                    state.mTotalBytes + \", bytes recvd so far: \" + state.mCurrentBytes);\n        }\n        int finalStatus;\n        if (statusCode >= 400 && statusCode < 600) {\n            finalStatus = statusCode;\n        } else if (statusCode >= 300 && statusCode < 400) {\n            finalStatus = Downloads.Impl.STATUS_UNHANDLED_REDIRECT;\n        } else if (state.mContinuingDownload && statusCode == HTTP_OK) {\n            finalStatus = Downloads.Impl.STATUS_CANNOT_RESUME;\n        } else {\n            finalStatus = Downloads.Impl.STATUS_UNHANDLED_HTTP_CODE;\n        }\n        throw new StopRequestException(finalStatus, \"http error \" +\n                statusCode + \", mContinuingDownload: \" + state.mContinuingDownload);\n    }\n\n    /**\n     * Handle a 503 Service Unavailable status by processing the Retry-After header.\n     */\n    private void handleServiceUnavailable(State state, HttpURLConnection conn)\n            throws StopRequestException {\n        state.mCountRetry = true;\n        state.mRetryAfter = conn.getHeaderFieldInt(\"Retry-After\", -1);\n        if (state.mRetryAfter < 0) {\n            state.mRetryAfter = 0;\n        } else {\n            if (state.mRetryAfter < Constants.MIN_RETRY_AFTER) {\n                state.mRetryAfter = Constants.MIN_RETRY_AFTER;\n            } else if (state.mRetryAfter > Constants.MAX_RETRY_AFTER) {\n                state.mRetryAfter = Constants.MAX_RETRY_AFTER;\n            }\n            state.mRetryAfter += Helpers.sRandom.nextInt(Constants.MIN_RETRY_AFTER + 1);\n            state.mRetryAfter *= 1000;\n        }\n\n        throw new StopRequestException(Downloads.Impl.STATUS_WAITING_TO_RETRY,\n                \"got 503 Service Unavailable, will retry later\");\n    }\n\n    private int getFinalStatusForHttpError(State state) {\n        int networkUsable = mInfo.checkCanUseNetwork();\n        if (networkUsable != DownloadInfo.NETWORK_OK) {\n            switch (networkUsable) {\n                case DownloadInfo.NETWORK_UNUSABLE_DUE_TO_SIZE:\n                case DownloadInfo.NETWORK_RECOMMENDED_UNUSABLE_DUE_TO_SIZE:\n                    return Downloads.Impl.STATUS_QUEUED_FOR_WIFI;\n                default:\n                    return Downloads.Impl.STATUS_WAITING_FOR_NETWORK;\n            }\n        } else if (mInfo.mNumFailed < Constants.MAX_RETRIES) {\n            state.mCountRetry = true;\n            return Downloads.Impl.STATUS_WAITING_TO_RETRY;\n        } else {\n            Log.w(Constants.TAG, \"reached max retries for \" + mInfo.mId);\n            return Downloads.Impl.STATUS_HTTP_DATA_ERROR;\n        }\n    }\n\n    /**\n     * Prepare the destination file to receive data.  If the file already exists, we'll set up\n     * appropriately for resumption.\n     */\n    private void setupDestinationFile(State state, InnerState innerState)\n            throws StopRequestException {\n        if (!TextUtils.isEmpty(state.mFilename)) { // only true if we've already run a thread for this download\n            if (Constants.LOGV) {\n                Log.i(Constants.TAG, \"have run thread before for id: \" + mInfo.mId +\n                        \", and state.mFilename: \" + state.mFilename);\n            }\n            if (!Helpers.isFilenameValid(state.mFilename,\n                    mStorageManager.getDownloadDataDirectory())) {\n                // this should never happen\n                throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                        \"found invalid internal destination filename\");\n            }\n            // We're resuming a download that got interrupted\n            File f = new File(state.mFilename);\n            if (f.exists()) {\n                if (Constants.LOGV) {\n                    Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                            \", and state.mFilename: \" + state.mFilename);\n                }\n                long fileLength = f.length();\n                if (fileLength == 0) {\n                    // The download hadn't actually started, we can restart from scratch\n                    if (Constants.LOGVV) {\n                        Log.d(TAG, \"setupDestinationFile() found fileLength=0, deleting \"\n                                + state.mFilename);\n                    }\n                    f.delete();\n                    state.mFilename = null;\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", BUT starting from scratch again: \");\n                    }\n                } else if (mInfo.mETag == null && !mInfo.mNoIntegrity) {\n                    // This should've been caught upon failure\n                    if (Constants.LOGVV) {\n                        Log.d(TAG, \"setupDestinationFile() unable to resume download, deleting \"\n                                + state.mFilename);\n                    }\n                    f.delete();\n                    throw new StopRequestException(Downloads.Impl.STATUS_CANNOT_RESUME,\n                            \"Trying to resume a download that can't be resumed\");\n                } else {\n                    // All right, we'll be able to resume this download\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", and starting with file of length: \" + fileLength);\n                    }\n                    state.mCurrentBytes = (int) fileLength;\n                    if (mInfo.mTotalBytes != -1) {\n                        innerState.mContentLength = mInfo.mTotalBytes;\n                    }\n                    state.mHeaderETag = mInfo.mETag;\n                    state.mContinuingDownload = true;\n                    if (Constants.LOGV) {\n                        Log.i(Constants.TAG, \"resuming download for id: \" + mInfo.mId +\n                                \", state.mCurrentBytes: \" + state.mCurrentBytes +\n                                \", and setting mContinuingDownload to true: \");\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Add custom headers for this download to the HTTP request.\n     */\n    private void addRequestHeaders(State state, HttpURLConnection conn) {\n        conn.addRequestProperty(\"User-Agent\", userAgent());\n\n        for (Pair<String, String> header : mInfo.getHeaders()) {\n            conn.addRequestProperty(header.first, header.second);\n        }\n\n        if (state.mContinuingDownload) {\n            if (state.mHeaderETag != null) {\n                conn.addRequestProperty(\"If-Match\", state.mHeaderETag);\n            }\n            conn.addRequestProperty(\"Range\", \"bytes=\" + state.mCurrentBytes + \"-\");\n            if (Constants.LOGV) {\n                Log.i(Constants.TAG, \"Adding Range header: \" +\n                        \"bytes=\" + state.mCurrentBytes + \"-\");\n                Log.i(Constants.TAG, \"  totalBytes = \" + state.mTotalBytes);\n            }\n        }\n    }\n\n    /**\n     * Stores information about the completed download, and notifies the initiating application.\n     */\n    private void notifyDownloadCompleted(int status, boolean countRetry, int retryAfter,\n            boolean gotData, String filename, String mimeType, String errorMsg) {\n        notifyThroughDatabase(\n                status, countRetry, retryAfter, gotData, filename, mimeType, errorMsg);\n        if (Downloads.Impl.isStatusCompleted(status)) {\n            mInfo.sendIntentIfRequested();\n        }\n    }\n\n    private void notifyThroughDatabase(int status, boolean countRetry, int retryAfter,\n            boolean gotData, String filename, String mimeType, String errorMsg) {\n        ContentValues values = new ContentValues();\n        values.put(Downloads.Impl.COLUMN_STATUS, status);\n        values.put(Downloads.Impl._DATA, filename);\n        values.put(Downloads.Impl.COLUMN_MIME_TYPE, mimeType);\n        values.put(Downloads.Impl.COLUMN_LAST_MODIFICATION, mSystemFacade.currentTimeMillis());\n        values.put(Constants.RETRY_AFTER_X_REDIRECT_COUNT, retryAfter);\n        if (!countRetry) {\n            values.put(Constants.FAILED_CONNECTIONS, 0);\n        } else if (gotData) {\n            values.put(Constants.FAILED_CONNECTIONS, 1);\n        } else {\n            values.put(Constants.FAILED_CONNECTIONS, mInfo.mNumFailed + 1);\n        }\n        // save the error message. could be useful to developers.\n        if (!TextUtils.isEmpty(errorMsg)) {\n            values.put(Downloads.Impl.COLUMN_ERROR_MSG, errorMsg);\n        }\n        mContext.getContentResolver().update(mInfo.getAllDownloadsUri(), values, null, null);\n    }\n\n    private INetworkPolicyListener mPolicyListener = new INetworkPolicyListener.Stub() {\n        @Override\n        public void onUidRulesChanged(int uid, int uidRules) {\n            // caller is NPMS, since we only register with them\n            if (uid == mInfo.mUid) {\n                mPolicyDirty = true;\n            }\n        }\n\n        @Override\n        public void onMeteredIfacesChanged(String[] meteredIfaces) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n\n        @Override\n        public void onRestrictBackgroundChanged(boolean restrictBackground) {\n            // caller is NPMS, since we only register with them\n            mPolicyDirty = true;\n        }\n    };\n\n    public static long getHeaderFieldLong(URLConnection conn, String field, long defaultValue) {\n        try {\n            return Long.parseLong(conn.getHeaderField(field));\n        } catch (NumberFormatException e) {\n            return defaultValue;\n        }\n    }\n}\n","lineNo":274}
{"Smelly Sample":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.app.DownloadManager;\nimport android.app.NotificationManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\nimport android.provider.BaseColumns;\nimport android.provider.Downloads;\nimport android.util.Log;\n\nimport com.google.common.annotations.VisibleForTesting;\n\n/**\n * Receives system broadcasts (boot, network connectivity)\n */\npublic class DownloadReceiver extends BroadcastReceiver {\n    @VisibleForTesting\n    SystemFacade mSystemFacade = null;\n\n    @Override\n    public void onReceive(Context context, Intent intent) {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(context);\n        }\n\n        String action = intent.getAction();\n        if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"Received broadcast intent for \" +\n                        Intent.ACTION_BOOT_COMPLETED);\n            }\n            startService(context);\n        } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"Received broadcast intent for \" +\n                        Intent.ACTION_MEDIA_MOUNTED);\n            }\n            startService(context);\n        } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {\n            final ConnectivityManager connManager = (ConnectivityManager) context\n                    .getSystemService(Context.CONNECTIVITY_SERVICE);\n            final NetworkInfo info = connManager.getActiveNetworkInfo();\n            if (info != null && info.isConnected()) {\n                startService(context);\n            }\n        } else if (action.equals(Constants.ACTION_RETRY)) {\n            startService(context);\n        } else if (action.equals(Constants.ACTION_OPEN)\n                || action.equals(Constants.ACTION_LIST)\n                || action.equals(Constants.ACTION_HIDE)) {\n            handleNotificationBroadcast(context, intent);\n        }\n    }\n\n    /**\n     * Handle any broadcast related to a system notification.\n     */\n    private void handleNotificationBroadcast(Context context, Intent intent) {\n        Uri uri = intent.getData();\n        String action = intent.getAction();\n        if (Constants.LOGVV) {\n            if (action.equals(Constants.ACTION_OPEN)) {\n                Log.v(Constants.TAG, \"Receiver open for \" + uri);\n            } else if (action.equals(Constants.ACTION_LIST)) {\n                Log.v(Constants.TAG, \"Receiver list for \" + uri);\n            } else { // ACTION_HIDE\n                Log.v(Constants.TAG, \"Receiver hide for \" + uri);\n            }\n        }\n\n        Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        if (cursor == null) {\n            return;\n        }\n        try {\n            if (!cursor.moveToFirst()) {\n                return;\n            }\n\n            if (action.equals(Constants.ACTION_OPEN)) {\n                openDownload(context, cursor);\n                hideNotification(context, uri, cursor);\n            } else if (action.equals(Constants.ACTION_LIST)) {\n                sendNotificationClickedIntent(intent, cursor);\n            } else { // ACTION_HIDE\n                hideNotification(context, uri, cursor);\n            }\n        } finally {\n            cursor.close();\n        }\n    }\n\n    /**\n     * Hide a system notification for a download.\n     * @param uri URI to update the download\n     * @param cursor Cursor for reading the download's fields\n     */\n    private void hideNotification(Context context, Uri uri, Cursor cursor) {\n        final NotificationManager notifManager = (NotificationManager) context.getSystemService(\n                Context.NOTIFICATION_SERVICE);\n        notifManager.cancel((int) ContentUris.parseId(uri));\n\n        int statusColumn = cursor.getColumnIndexOrThrow(Downloads.Impl.COLUMN_STATUS);\n        int status = cursor.getInt(statusColumn);\n        int visibilityColumn =\n                cursor.getColumnIndexOrThrow(Downloads.Impl.COLUMN_VISIBILITY);\n        int visibility = cursor.getInt(visibilityColumn);\n        if (Downloads.Impl.isStatusCompleted(status)\n                && visibility == Downloads.Impl.VISIBILITY_VISIBLE_NOTIFY_COMPLETED) {\n            ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_VISIBILITY,\n                    Downloads.Impl.VISIBILITY_VISIBLE);\n            context.getContentResolver().update(uri, values, null, null);\n        }\n    }\n\n    /**\n     * Open the download that cursor is currently pointing to, since it's completed notification\n     * has been clicked.\n     */\n    private void openDownload(Context context, Cursor cursor) {\n        final long id = cursor.getLong(cursor.getColumnIndexOrThrow(BaseColumns._ID));\n        final Intent intent = OpenHelper.buildViewIntent(context, id);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        try {\n            context.startActivity(intent);\n        } catch (ActivityNotFoundException ex) {\n            Log.d(Constants.TAG, \"no activity for \" + intent, ex);\n        }\n    }\n\n    /**\n     * Notify the owner of a running download that its notification was clicked.\n     * @param intent the broadcast intent sent by the notification manager\n     * @param cursor Cursor for reading the download's fields\n     */\n    private void sendNotificationClickedIntent(Intent intent, Cursor cursor) {\n        String pckg = cursor.getString(\n                cursor.getColumnIndexOrThrow(Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE));\n        if (pckg == null) {\n            return;\n        }\n\n        String clazz = cursor.getString(\n                cursor.getColumnIndexOrThrow(Downloads.Impl.COLUMN_NOTIFICATION_CLASS));\n        boolean isPublicApi =\n                cursor.getInt(cursor.getColumnIndex(Downloads.Impl.COLUMN_IS_PUBLIC_API)) != 0;\n\n        Intent appIntent = null;\n        if (isPublicApi) {\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setPackage(pckg);\n            // send id of the items clicked on.\n            if (intent.getBooleanExtra(\"multiple\", false)) {\n                // broadcast received saying click occurred on a notification with multiple titles.\n                // don't include any ids at all - let the caller query all downloads belonging to it\n                // TODO modify the broadcast to include ids of those multiple notifications.\n            } else {\n                appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS,\n                        new long[] {\n                                cursor.getLong(cursor.getColumnIndexOrThrow(Downloads.Impl._ID))});\n            }\n        } else { // legacy behavior\n            if (clazz == null) {\n                return;\n            }\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setClassName(pckg, clazz);\n            if (intent.getBooleanExtra(\"multiple\", true)) {\n                appIntent.setData(Downloads.Impl.CONTENT_URI);\n            } else {\n                long downloadId = cursor.getLong(cursor.getColumnIndexOrThrow(Downloads.Impl._ID));\n                appIntent.setData(\n                        ContentUris.withAppendedId(Downloads.Impl.CONTENT_URI, downloadId));\n            }\n        }\n\n        mSystemFacade.sendBroadcast(appIntent);\n    }\n\n    private void startService(Context context) {\n        context.startService(new Intent(context, DownloadService.class));\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2008 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_COMPLETED;\nimport static android.app.DownloadManager.Request.VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION;\n\nimport android.app.DownloadManager;\nimport android.content.ActivityNotFoundException;\nimport android.content.BroadcastReceiver;\nimport android.content.ContentUris;\nimport android.content.ContentValues;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.database.Cursor;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.Uri;\nimport android.os.Handler;\nimport android.os.HandlerThread;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.widget.Toast;\n\nimport com.google.common.annotations.VisibleForTesting;\n\n/**\n * Receives system broadcasts (boot, network connectivity)\n */\npublic class DownloadReceiver extends BroadcastReceiver {\n    private static final String TAG = \"DownloadReceiver\";\n\n    private static Handler sAsyncHandler;\n\n    static {\n        final HandlerThread thread = new HandlerThread(TAG);\n        thread.start();\n        sAsyncHandler = new Handler(thread.getLooper());\n    }\n\n    @VisibleForTesting\n    SystemFacade mSystemFacade = null;\n\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        if (mSystemFacade == null) {\n            mSystemFacade = new RealSystemFacade(context);\n        }\n\n        String action = intent.getAction();\n        if (action.equals(Intent.ACTION_BOOT_COMPLETED)) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"Received broadcast intent for \" +\n                        Intent.ACTION_BOOT_COMPLETED);\n            }\n            startService(context);\n        } else if (action.equals(Intent.ACTION_MEDIA_MOUNTED)) {\n            if (Constants.LOGVV) {\n                Log.v(Constants.TAG, \"Received broadcast intent for \" +\n                        Intent.ACTION_MEDIA_MOUNTED);\n            }\n            startService(context);\n        } else if (action.equals(ConnectivityManager.CONNECTIVITY_ACTION)) {\n            final ConnectivityManager connManager = (ConnectivityManager) context\n                    .getSystemService(Context.CONNECTIVITY_SERVICE);\n            final NetworkInfo info = connManager.getActiveNetworkInfo();\n            if (info != null && info.isConnected()) {\n                startService(context);\n            }\n        } else if (action.equals(Constants.ACTION_RETRY)) {\n            startService(context);\n        } else if (action.equals(Constants.ACTION_OPEN)\n                || action.equals(Constants.ACTION_LIST)\n                || action.equals(Constants.ACTION_HIDE)) {\n\n            final PendingResult result = goAsync();\n            if (result == null) {\n                // TODO: remove this once test is refactored\n                handleNotificationBroadcast(context, intent);\n            } else {\n                sAsyncHandler.post(new Runnable() {\n                        @Override\n                    public void run() {\n                        handleNotificationBroadcast(context, intent);\n                        result.finish();\n                    }\n                });\n            }\n        }\n    }\n\n    /**\n     * Handle any broadcast related to a system notification.\n     */\n    private void handleNotificationBroadcast(Context context, Intent intent) {\n        final String action = intent.getAction();\n        if (Constants.ACTION_LIST.equals(action)) {\n            final long[] ids = intent.getLongArrayExtra(\n                    DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS);\n            sendNotificationClickedIntent(context, ids);\n\n        } else if (Constants.ACTION_OPEN.equals(action)) {\n            final long id = ContentUris.parseId(intent.getData());\n            openDownload(context, id);\n            hideNotification(context, id);\n\n        } else if (Constants.ACTION_HIDE.equals(action)) {\n            final long id = ContentUris.parseId(intent.getData());\n            hideNotification(context, id);\n        }\n    }\n\n    /**\n     * Mark the given {@link DownloadManager#COLUMN_ID} as being acknowledged by\n     * user so it's not renewed later.\n     */\n    private void hideNotification(Context context, long id) {\n        final int status;\n        final int visibility;\n\n        final Uri uri = ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id);\n        final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                status = getInt(cursor, Downloads.Impl.COLUMN_STATUS);\n                visibility = getInt(cursor, Downloads.Impl.COLUMN_VISIBILITY);\n            } else {\n                Log.w(TAG, \"Missing details for download \" + id);\n                return;\n            }\n        } finally {\n            cursor.close();\n        }\n\n        if (Downloads.Impl.isStatusCompleted(status) &&\n                (visibility == VISIBILITY_VISIBLE_NOTIFY_COMPLETED\n                || visibility == VISIBILITY_VISIBLE_NOTIFY_ONLY_COMPLETION)) {\n            final ContentValues values = new ContentValues();\n            values.put(Downloads.Impl.COLUMN_VISIBILITY,\n                    Downloads.Impl.VISIBILITY_VISIBLE);\n            context.getContentResolver().update(uri, values, null, null);\n        }\n    }\n\n    /**\n     * Start activity to display the file represented by the given\n     * {@link DownloadManager#COLUMN_ID}.\n     */\n    private void openDownload(Context context, long id) {\n        final Intent intent = OpenHelper.buildViewIntent(context, id);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        try {\n            context.startActivity(intent);\n        } catch (ActivityNotFoundException ex) {\n            Log.d(Constants.TAG, \"no activity for \" + intent, ex);\n            Toast.makeText(context, R.string.download_no_application_title, Toast.LENGTH_LONG)\n                    .show();\n        }\n    }\n\n    /**\n     * Notify the owner of a running download that its notification was clicked.\n     */\n    private void sendNotificationClickedIntent(Context context, long[] ids) {\n        final String packageName;\n        final String clazz;\n        final boolean isPublicApi;\n\n        final Uri uri = ContentUris.withAppendedId(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, ids[0]);\n        final Cursor cursor = context.getContentResolver().query(uri, null, null, null, null);\n        try {\n            if (cursor.moveToFirst()) {\n                packageName = getString(cursor, Downloads.Impl.COLUMN_NOTIFICATION_PACKAGE);\n                clazz = getString(cursor, Downloads.Impl.COLUMN_NOTIFICATION_CLASS);\n                isPublicApi = getInt(cursor, Downloads.Impl.COLUMN_IS_PUBLIC_API) != 0;\n            } else {\n                Log.w(TAG, \"Missing details for download \" + ids[0]);\n                return;\n            }\n        } finally {\n            cursor.close();\n        }\n\n        if (TextUtils.isEmpty(packageName)) {\n            Log.w(TAG, \"Missing package; skipping broadcast\");\n            return;\n        }\n\n        Intent appIntent = null;\n        if (isPublicApi) {\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setPackage(packageName);\n            appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, ids);\n\n        } else { // legacy behavior\n            if (TextUtils.isEmpty(clazz)) {\n                Log.w(TAG, \"Missing class; skipping broadcast\");\n                return;\n            }\n\n            appIntent = new Intent(DownloadManager.ACTION_NOTIFICATION_CLICKED);\n            appIntent.setClassName(packageName, clazz);\n            appIntent.putExtra(DownloadManager.EXTRA_NOTIFICATION_CLICK_DOWNLOAD_IDS, ids);\n\n            if (ids.length == 1) {\n                appIntent.setData(uri);\n            } else {\n                appIntent.setData(Downloads.Impl.CONTENT_URI);\n            }\n        }\n\n        mSystemFacade.sendBroadcast(appIntent);\n    }\n\n    private static String getString(Cursor cursor, String col) {\n        return cursor.getString(cursor.getColumnIndexOrThrow(col));\n    }\n\n    private static int getInt(Cursor cursor, String col) {\n        return cursor.getInt(cursor.getColumnIndexOrThrow(col));\n    }\n\n    private void startService(Context context) {\n        context.startService(new Intent(context, DownloadService.class));\n    }\n}\n","lineNo":184}
{"Smelly Sample":"package com.android.providers.downloads;\n\nimport android.content.Intent;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class FakeSystemFacade implements SystemFacade {\n    long mTimeMillis = 0;\n    Integer mActiveNetworkType = ConnectivityManager.TYPE_WIFI;\n    boolean mIsRoaming = false;\n    boolean mIsMetered = false;\n    Long mMaxBytesOverMobile = null;\n    Long mRecommendedMaxBytesOverMobile = null;\n    List<Intent> mBroadcastsSent = new ArrayList<Intent>();\n    Queue<Thread> mStartedThreads = new LinkedList<Thread>();\n    private boolean returnActualTime = false;\n\n    void incrementTimeMillis(long delta) {\n        mTimeMillis += delta;\n    }\n\n    public long currentTimeMillis() {\n        if (returnActualTime) {\n            return System.currentTimeMillis();\n        }\n        return mTimeMillis;\n    }\n\n    public NetworkInfo getActiveNetworkInfo(int uid) {\n        if (mActiveNetworkType == null) {\n            return null;\n        } else {\n            return new NetworkInfo(mActiveNetworkType, 0, null, null);\n        }\n    }\n\n    @Override\n    public boolean isActiveNetworkMetered() {\n        return mIsMetered;\n    }\n\n    public boolean isNetworkRoaming() {\n        return mIsRoaming;\n    }\n\n    public Long getMaxBytesOverMobile() {\n        return mMaxBytesOverMobile ;\n    }\n\n    public Long getRecommendedMaxBytesOverMobile() {\n        return mRecommendedMaxBytesOverMobile ;\n    }\n\n    @Override\n    public void sendBroadcast(Intent intent) {\n        mBroadcastsSent.add(intent);\n    }\n\n    @Override\n    public boolean userOwnsPackage(int uid, String pckg) throws NameNotFoundException {\n        return true;\n    }\n\n    public boolean startThreadsWithoutWaiting = false;\n    public void setStartThreadsWithoutWaiting(boolean flag) {\n        this.startThreadsWithoutWaiting = flag;\n    }\n\n    @Override\n    public void startThread(Thread thread) {\n        if (startThreadsWithoutWaiting) {\n            thread.start();\n        } else {\n            mStartedThreads.add(thread);\n        }\n    }\n\n    public void runAllThreads() {\n        while (!mStartedThreads.isEmpty()) {\n            mStartedThreads.poll().run();\n        }\n    }\n\n    public void setReturnActualTime(boolean flag) {\n        returnActualTime = flag;\n    }\n}\n","Method after Refactoring":"package com.android.providers.downloads;\n\nimport android.content.Intent;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.net.NetworkInfo.DetailedState;\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class FakeSystemFacade implements SystemFacade {\n    long mTimeMillis = 0;\n    Integer mActiveNetworkType = ConnectivityManager.TYPE_WIFI;\n    boolean mIsRoaming = false;\n    boolean mIsMetered = false;\n    Long mMaxBytesOverMobile = null;\n    Long mRecommendedMaxBytesOverMobile = null;\n    List<Intent> mBroadcastsSent = new ArrayList<Intent>();\n    Queue<Thread> mStartedThreads = new LinkedList<Thread>();\n    private boolean returnActualTime = false;\n\n    void incrementTimeMillis(long delta) {\n        mTimeMillis += delta;\n    }\n\n    public long currentTimeMillis() {\n        if (returnActualTime) {\n            return System.currentTimeMillis();\n        }\n        return mTimeMillis;\n    }\n\n    public NetworkInfo getActiveNetworkInfo(int uid) {\n        if (mActiveNetworkType == null) {\n            return null;\n        } else {\n            final NetworkInfo info = new NetworkInfo(mActiveNetworkType, 0, null, null);\n            info.setDetailedState(DetailedState.CONNECTED, null, null);\n            return info;\n        }\n    }\n\n    @Override\n    public boolean isActiveNetworkMetered() {\n        return mIsMetered;\n    }\n\n    public boolean isNetworkRoaming() {\n        return mIsRoaming;\n    }\n\n    public Long getMaxBytesOverMobile() {\n        return mMaxBytesOverMobile ;\n    }\n\n    public Long getRecommendedMaxBytesOverMobile() {\n        return mRecommendedMaxBytesOverMobile ;\n    }\n\n    @Override\n    public void sendBroadcast(Intent intent) {\n        mBroadcastsSent.add(intent);\n    }\n\n    @Override\n    public boolean userOwnsPackage(int uid, String pckg) throws NameNotFoundException {\n        return true;\n    }\n\n    public boolean startThreadsWithoutWaiting = false;\n    public void setStartThreadsWithoutWaiting(boolean flag) {\n        this.startThreadsWithoutWaiting = flag;\n    }\n\n    @Override\n    public void startThread(Thread thread) {\n        if (startThreadsWithoutWaiting) {\n            thread.start();\n        } else {\n            mStartedThreads.add(thread);\n        }\n    }\n\n    public void runAllThreads() {\n        while (!mStartedThreads.isEmpty()) {\n            mStartedThreads.poll().run();\n        }\n    }\n\n    public void setReturnActualTime(boolean flag) {\n        returnActualTime = flag;\n    }\n}\n","lineNo":40}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.StatFs;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.R;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Manages the storage space consumed by Downloads Data dir. When space falls below\n * a threshold limit (set in resource xml files), starts cleanup of the Downloads data dir\n * to free up space.\n */\nclass StorageManager {\n    /** the max amount of space allowed to be taken up by the downloads data dir */\n    private static final long sMaxdownloadDataDirSize =\n            Resources.getSystem().getInteger(R.integer.config_downloadDataDirSize) * 1024 * 1024;\n\n    /** threshold (in bytes) beyond which the low space warning kicks in and attempt is made to\n     * purge some downloaded files to make space\n     */\n    private static final long sDownloadDataDirLowSpaceThreshold =\n            Resources.getSystem().getInteger(\n                    R.integer.config_downloadDataDirLowSpaceThreshold)\n                    * sMaxdownloadDataDirSize / 100;\n\n    /** see {@link Environment#getExternalStorageDirectory()} */\n    private final File mExternalStorageDir;\n\n    /** see {@link Environment#getDownloadCacheDirectory()} */\n    private final File mSystemCacheDir;\n\n    /** The downloaded files are saved to this dir. it is the value returned by\n     * {@link Context#getCacheDir()}.\n     */\n    private final File mDownloadDataDir;\n\n    /** the Singleton instance of this class.\n     * TODO: once DownloadService is refactored into a long-living object, there is no need\n     * for this Singleton'ing.\n     */\n    private static StorageManager sSingleton = null;\n\n    /** how often do we need to perform checks on space to make sure space is available */\n    private static final int FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY = 1024 * 1024; // 1MB\n    private int mBytesDownloadedSinceLastCheckOnSpace = 0;\n\n    /** misc members */\n    private final Context mContext;\n\n    /**\n     * maintains Singleton instance of this class\n     */\n    synchronized static StorageManager getInstance(Context context) {\n        if (sSingleton == null) {\n            sSingleton = new StorageManager(context);\n        }\n        return sSingleton;\n    }\n\n    private StorageManager(Context context) { // constructor is private\n        mContext = context;\n        mDownloadDataDir = context.getCacheDir();\n        mExternalStorageDir = Environment.getExternalStorageDirectory();\n        mSystemCacheDir = Environment.getDownloadCacheDirectory();\n        startThreadToCleanupDatabaseAndPurgeFileSystem();\n    }\n\n    /** How often should database and filesystem be cleaned up to remove spurious files\n     * from the file system and\n     * The value is specified in terms of num of downloads since last time the cleanup was done.\n     */\n    private static final int FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP = 250;\n    private int mNumDownloadsSoFar = 0;\n\n    synchronized void incrementNumDownloadsSoFar() {\n        if (++mNumDownloadsSoFar % FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP == 0) {\n            startThreadToCleanupDatabaseAndPurgeFileSystem();\n        }\n    }\n    /* start a thread to cleanup the following\n     *      remove spurious files from the file system\n     *      remove excess entries from the database\n     */\n    private Thread mCleanupThread = null;\n    private synchronized void startThreadToCleanupDatabaseAndPurgeFileSystem() {\n        if (mCleanupThread != null && mCleanupThread.isAlive()) {\n            return;\n        }\n        mCleanupThread = new Thread() {\n            @Override public void run() {\n                removeSpuriousFiles();\n                trimDatabase();\n            }\n        };\n        mCleanupThread.start();\n    }\n\n    void verifySpaceBeforeWritingToFile(int destination, String path, long length)\n            throws StopRequestException {\n        // do this check only once for every 1MB of downloaded data\n        if (incrementBytesDownloadedSinceLastCheckOnSpace(length) <\n                FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY) {\n            return;\n        }\n        verifySpace(destination, path, length);\n    }\n\n    void verifySpace(int destination, String path, long length) throws StopRequestException {\n        resetBytesDownloadedSinceLastCheckOnSpace();\n        File dir = null;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in verifySpace, destination: \" + destination +\n                    \", path: \" + path + \", length: \" + length);\n        }\n        if (path == null) {\n            throw new IllegalArgumentException(\"path can't be null\");\n        }\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n                dir = mDownloadDataDir;\n                break;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                dir = mExternalStorageDir;\n                break;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                dir = mSystemCacheDir;\n                break;\n            case Downloads.Impl.DESTINATION_FILE_URI:\n                if (path.startsWith(mExternalStorageDir.getPath())) {\n                    dir = mExternalStorageDir;\n                } else if (path.startsWith(mDownloadDataDir.getPath())) {\n                    dir = mDownloadDataDir;\n                } else if (path.startsWith(mSystemCacheDir.getPath())) {\n                    dir = mSystemCacheDir;\n                }\n                break;\n         }\n        if (dir == null) {\n            throw new IllegalStateException(\"invalid combination of destination: \" + destination +\n                    \", path: \" + path);\n        }\n        findSpace(dir, length, destination);\n    }\n\n    /**\n     * finds space in the given filesystem (input param: root) to accommodate # of bytes\n     * specified by the input param(targetBytes).\n     * returns true if found. false otherwise.\n     */\n    private synchronized void findSpace(File root, long targetBytes, int destination)\n            throws StopRequestException {\n        if (targetBytes == 0) {\n            return;\n        }\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI ||\n                destination == Downloads.Impl.DESTINATION_EXTERNAL) {\n            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR,\n                        \"external media not mounted\");\n            }\n        }\n        // is there enough space in the file system of the given param 'root'.\n        long bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n        if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n            /* filesystem's available space is below threshold for low space warning.\n             * threshold typically is 10% of download data dir space quota.\n             * try to cleanup and see if the low space situation goes away.\n             */\n            discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n            removeSpuriousFiles();\n            bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                /*\n                 * available space is still below the threshold limit.\n                 *\n                 * If this is system cache dir, print a warning.\n                 * otherwise, don't allow downloading until more space\n                 * is available because downloadmanager shouldn't end up taking those last\n                 * few MB of space left on the filesystem.\n                 */\n                if (root.equals(mSystemCacheDir)) {\n                    Log.w(Constants.TAG, \"System cache dir ('/cache') is running low on space.\" +\n                            \"space available (in bytes): \" + bytesAvailable);\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                            \"space in the filesystem rooted at: \" + root +\n                            \" is below 10% availability. stopping this download.\");\n                }\n            }\n        }\n        if (root.equals(mDownloadDataDir)) {\n            // this download is going into downloads data dir. check space in that specific dir.\n            bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                // print a warning\n                Log.w(Constants.TAG, \"Downloads data dir: \" + root +\n                        \" is running low on space. space available (in bytes): \" + bytesAvailable);\n            }\n            if (bytesAvailable < targetBytes) {\n                // Insufficient space; make space.\n                discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n                removeSpuriousFiles();\n                bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            }\n        }\n        if (bytesAvailable < targetBytes) {\n            throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                    \"not enough free space in the filesystem rooted at: \" + root +\n                    \" and unable to free any more\");\n        }\n    }\n\n    /**\n     * returns the number of bytes available in the downloads data dir\n     * TODO this implementation is too slow. optimize it.\n     */\n    private long getAvailableBytesInDownloadsDataDir(File root) {\n        File[] files = root.listFiles();\n        long space = sMaxdownloadDataDirSize;\n        if (files == null) {\n            return space;\n        }\n        int size = files.length;\n        for (int i = 0; i < size; i++) {\n            space -= files[i].length();\n        }\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in downloads data dir: \" + space);\n        }\n        return space;\n    }\n\n    private long getAvailableBytesInFileSystemAtGivenRoot(File root) {\n        StatFs stat = new StatFs(root.getPath());\n        // put a bit of margin (in case creating the file grows the system by a few blocks)\n        long availableBlocks = (long) stat.getAvailableBlocks() - 4;\n        long size = stat.getBlockSize() * availableBlocks;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in filesystem rooted at: \" +\n                    root.getPath() + \" is: \" + size);\n        }\n        return size;\n    }\n\n    File locateDestinationDirectory(String mimeType, int destination, long contentLength)\n            throws StopRequestException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                return mDownloadDataDir;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                return mSystemCacheDir;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                File base = new File(mExternalStorageDir.getPath() + Constants.DEFAULT_DL_SUBDIR);\n                if (!base.isDirectory() && !base.mkdir()) {\n                    // Can't create download directory, e.g. because a file called \"download\"\n                    // already exists at the root level, or the SD card filesystem is read-only.\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"unable to create external downloads directory \" + base.getPath());\n                }\n                return base;\n            default:\n                throw new IllegalStateException(\"unexpected value for destination: \" + destination);\n        }\n    }\n\n    File getDownloadDataDirectory() {\n        return mDownloadDataDir;\n    }\n\n    /**\n     * Deletes purgeable files from the cache partition. This also deletes\n     * the matching database entries. Files are deleted in LRU order until\n     * the total byte size is greater than targetBytes\n     */\n    private long discardPurgeableFiles(int destination, long targetBytes) {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"discardPurgeableFiles: destination = \" + destination +\n                    \", targetBytes = \" + targetBytes);\n        }\n        String destStr  = (destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) ?\n                String.valueOf(destination) :\n                String.valueOf(Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n        String[] bindArgs = new String[]{destStr};\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                null,\n                \"( \" +\n                Downloads.Impl.COLUMN_STATUS + \" = '\" + Downloads.Impl.STATUS_SUCCESS + \"' AND \" +\n                Downloads.Impl.COLUMN_DESTINATION + \" = ? )\",\n                bindArgs,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        if (cursor == null) {\n            return 0;\n        }\n        long totalFreed = 0;\n        try {\n            final int dataIndex = cursor.getColumnIndex(Downloads.Impl._DATA);\n            while (cursor.moveToNext() && totalFreed < targetBytes) {\n                final String data = cursor.getString(dataIndex);\n                if (TextUtils.isEmpty(data)) continue;\n\n                File file = new File(data);\n                if (true || Constants.LOGV) {\n                    Slog.d(Constants.TAG, \"purging \" + file.getAbsolutePath() + \" for \" +\n                            file.length() + \" bytes\");\n                }\n                totalFreed += file.length();\n                file.delete();\n                long id = cursor.getLong(cursor.getColumnIndex(Downloads.Impl._ID));\n                mContext.getContentResolver().delete(\n                        ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                        null, null);\n            }\n        } finally {\n            cursor.close();\n        }\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"Purged files, freed \" + totalFreed + \" for \" +\n                    targetBytes + \" requested\");\n        }\n        return totalFreed;\n    }\n\n    /**\n     * Removes files in the systemcache and downloads data dir without corresponding entries in\n     * the downloads database.\n     * This can occur if a delete is done on the database but the file is not removed from the\n     * filesystem (due to sudden death of the process, for example).\n     * This is not a very common occurrence. So, do this only once in a while.\n     */\n    private void removeSpuriousFiles() {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"in removeSpuriousFiles\");\n        }\n        // get a list of all files in system cache dir and downloads data dir\n        List<File> files = new ArrayList<File>();\n        File[] listOfFiles = mSystemCacheDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        listOfFiles = mDownloadDataDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        if (files.size() == 0) {\n            return;\n        }\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._DATA }, null, null, null);\n        try {\n            if (cursor != null) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(0);\n                    if (!TextUtils.isEmpty(filename)) {\n                        if (true || Constants.LOGV) {\n                            Log.i(Constants.TAG, \"in removeSpuriousFiles, preserving file \" +\n                                    filename);\n                        }\n                        files.remove(new File(filename));\n                    }\n                }\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        // delete the files not found in the database\n        for (File file : files) {\n            if (file.getName().equals(Constants.KNOWN_SPURIOUS_FILENAME) ||\n                    file.getName().equalsIgnoreCase(Constants.RECOVERY_DIRECTORY)) {\n                continue;\n            }\n            if (true || Constants.LOGV) {\n                Slog.d(Constants.TAG, \"deleting spurious file \" + file.getAbsolutePath());\n            }\n            file.delete();\n        }\n    }\n\n    /**\n     * Drops old rows from the database to prevent it from growing too large\n     * TODO logic in this method needs to be optimized. maintain the number of downloads\n     * in memory - so that this method can limit the amount of data read.\n     */\n    private void trimDatabase() {\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in trimDatabase\");\n        }\n        Cursor cursor = null;\n        try {\n            cursor = mContext.getContentResolver().query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    new String[] { Downloads.Impl._ID },\n                    Downloads.Impl.COLUMN_STATUS + \" >= '200'\", null,\n                    Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            if (cursor == null) {\n                // This isn't good - if we can't do basic queries in our database,\n                // nothing's gonna work\n                Log.e(Constants.TAG, \"null cursor in trimDatabase\");\n                return;\n            }\n            if (cursor.moveToFirst()) {\n                int numDelete = cursor.getCount() - Constants.MAX_DOWNLOADS;\n                int columnId = cursor.getColumnIndexOrThrow(Downloads.Impl._ID);\n                while (numDelete > 0) {\n                    Uri downloadUri = ContentUris.withAppendedId(\n                            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, cursor.getLong(columnId));\n                    mContext.getContentResolver().delete(downloadUri, null, null);\n                    if (!cursor.moveToNext()) {\n                        break;\n                    }\n                    numDelete--;\n                }\n            }\n        } catch (SQLiteException e) {\n            // trimming the database raised an exception. alright, ignore the exception\n            // and return silently. trimming database is not exactly a critical operation\n            // and there is no need to propagate the exception.\n            Log.w(Constants.TAG, \"trimDatabase failed with exception: \" + e.getMessage());\n            return;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private synchronized int incrementBytesDownloadedSinceLastCheckOnSpace(long val) {\n        mBytesDownloadedSinceLastCheckOnSpace += val;\n        return mBytesDownloadedSinceLastCheckOnSpace;\n    }\n\n    private synchronized void resetBytesDownloadedSinceLastCheckOnSpace() {\n        mBytesDownloadedSinceLastCheckOnSpace = 0;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport static com.android.providers.downloads.Constants.LOGV;\nimport static com.android.providers.downloads.Constants.TAG;\n\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.StatFs;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.R;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nimport libcore.io.ErrnoException;\nimport libcore.io.Libcore;\nimport libcore.io.StructStat;\n\n/**\n * Manages the storage space consumed by Downloads Data dir. When space falls below\n * a threshold limit (set in resource xml files), starts cleanup of the Downloads data dir\n * to free up space.\n */\nclass StorageManager {\n    /** the max amount of space allowed to be taken up by the downloads data dir */\n    private static final long sMaxdownloadDataDirSize =\n            Resources.getSystem().getInteger(R.integer.config_downloadDataDirSize) * 1024 * 1024;\n\n    /** threshold (in bytes) beyond which the low space warning kicks in and attempt is made to\n     * purge some downloaded files to make space\n     */\n    private static final long sDownloadDataDirLowSpaceThreshold =\n            Resources.getSystem().getInteger(\n                    R.integer.config_downloadDataDirLowSpaceThreshold)\n                    * sMaxdownloadDataDirSize / 100;\n\n    /** see {@link Environment#getExternalStorageDirectory()} */\n    private final File mExternalStorageDir;\n\n    /** see {@link Environment#getDownloadCacheDirectory()} */\n    private final File mSystemCacheDir;\n\n    /** The downloaded files are saved to this dir. it is the value returned by\n     * {@link Context#getCacheDir()}.\n     */\n    private final File mDownloadDataDir;\n\n    /** the Singleton instance of this class.\n     * TODO: once DownloadService is refactored into a long-living object, there is no need\n     * for this Singleton'ing.\n     */\n    private static StorageManager sSingleton = null;\n\n    /** how often do we need to perform checks on space to make sure space is available */\n    private static final int FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY = 1024 * 1024; // 1MB\n    private int mBytesDownloadedSinceLastCheckOnSpace = 0;\n\n    /** misc members */\n    private final Context mContext;\n\n    /**\n     * maintains Singleton instance of this class\n     */\n    synchronized static StorageManager getInstance(Context context) {\n        if (sSingleton == null) {\n            sSingleton = new StorageManager(context);\n        }\n        return sSingleton;\n    }\n\n    private StorageManager(Context context) { // constructor is private\n        mContext = context;\n        mDownloadDataDir = context.getCacheDir();\n        mExternalStorageDir = Environment.getExternalStorageDirectory();\n        mSystemCacheDir = Environment.getDownloadCacheDirectory();\n        startThreadToCleanupDatabaseAndPurgeFileSystem();\n    }\n\n    /** How often should database and filesystem be cleaned up to remove spurious files\n     * from the file system and\n     * The value is specified in terms of num of downloads since last time the cleanup was done.\n     */\n    private static final int FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP = 250;\n    private int mNumDownloadsSoFar = 0;\n\n    synchronized void incrementNumDownloadsSoFar() {\n        if (++mNumDownloadsSoFar % FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP == 0) {\n            startThreadToCleanupDatabaseAndPurgeFileSystem();\n        }\n    }\n    /* start a thread to cleanup the following\n     *      remove spurious files from the file system\n     *      remove excess entries from the database\n     */\n    private Thread mCleanupThread = null;\n    private synchronized void startThreadToCleanupDatabaseAndPurgeFileSystem() {\n        if (mCleanupThread != null && mCleanupThread.isAlive()) {\n            return;\n        }\n        mCleanupThread = new Thread() {\n            @Override public void run() {\n                removeSpuriousFiles();\n                trimDatabase();\n            }\n        };\n        mCleanupThread.start();\n    }\n\n    void verifySpaceBeforeWritingToFile(int destination, String path, long length)\n            throws StopRequestException {\n        // do this check only once for every 1MB of downloaded data\n        if (incrementBytesDownloadedSinceLastCheckOnSpace(length) <\n                FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY) {\n            return;\n        }\n        verifySpace(destination, path, length);\n    }\n\n    void verifySpace(int destination, String path, long length) throws StopRequestException {\n        resetBytesDownloadedSinceLastCheckOnSpace();\n        File dir = null;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in verifySpace, destination: \" + destination +\n                    \", path: \" + path + \", length: \" + length);\n        }\n        if (path == null) {\n            throw new IllegalArgumentException(\"path can't be null\");\n        }\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n                dir = mDownloadDataDir;\n                break;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                dir = mExternalStorageDir;\n                break;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                dir = mSystemCacheDir;\n                break;\n            case Downloads.Impl.DESTINATION_FILE_URI:\n                if (path.startsWith(mExternalStorageDir.getPath())) {\n                    dir = mExternalStorageDir;\n                } else if (path.startsWith(mDownloadDataDir.getPath())) {\n                    dir = mDownloadDataDir;\n                } else if (path.startsWith(mSystemCacheDir.getPath())) {\n                    dir = mSystemCacheDir;\n                }\n                break;\n         }\n        if (dir == null) {\n            throw new IllegalStateException(\"invalid combination of destination: \" + destination +\n                    \", path: \" + path);\n        }\n        findSpace(dir, length, destination);\n    }\n\n    /**\n     * finds space in the given filesystem (input param: root) to accommodate # of bytes\n     * specified by the input param(targetBytes).\n     * returns true if found. false otherwise.\n     */\n    private synchronized void findSpace(File root, long targetBytes, int destination)\n            throws StopRequestException {\n        if (targetBytes == 0) {\n            return;\n        }\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI ||\n                destination == Downloads.Impl.DESTINATION_EXTERNAL) {\n            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR,\n                        \"external media not mounted\");\n            }\n        }\n        // is there enough space in the file system of the given param 'root'.\n        long bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n        if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n            /* filesystem's available space is below threshold for low space warning.\n             * threshold typically is 10% of download data dir space quota.\n             * try to cleanup and see if the low space situation goes away.\n             */\n            discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n            removeSpuriousFiles();\n            bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                /*\n                 * available space is still below the threshold limit.\n                 *\n                 * If this is system cache dir, print a warning.\n                 * otherwise, don't allow downloading until more space\n                 * is available because downloadmanager shouldn't end up taking those last\n                 * few MB of space left on the filesystem.\n                 */\n                if (root.equals(mSystemCacheDir)) {\n                    Log.w(Constants.TAG, \"System cache dir ('/cache') is running low on space.\" +\n                            \"space available (in bytes): \" + bytesAvailable);\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                            \"space in the filesystem rooted at: \" + root +\n                            \" is below 10% availability. stopping this download.\");\n                }\n            }\n        }\n        if (root.equals(mDownloadDataDir)) {\n            // this download is going into downloads data dir. check space in that specific dir.\n            bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                // print a warning\n                Log.w(Constants.TAG, \"Downloads data dir: \" + root +\n                        \" is running low on space. space available (in bytes): \" + bytesAvailable);\n            }\n            if (bytesAvailable < targetBytes) {\n                // Insufficient space; make space.\n                discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n                removeSpuriousFiles();\n                bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            }\n        }\n        if (bytesAvailable < targetBytes) {\n            throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                    \"not enough free space in the filesystem rooted at: \" + root +\n                    \" and unable to free any more\");\n        }\n    }\n\n    /**\n     * returns the number of bytes available in the downloads data dir\n     * TODO this implementation is too slow. optimize it.\n     */\n    private long getAvailableBytesInDownloadsDataDir(File root) {\n        File[] files = root.listFiles();\n        long space = sMaxdownloadDataDirSize;\n        if (files == null) {\n            return space;\n        }\n        int size = files.length;\n        for (int i = 0; i < size; i++) {\n            space -= files[i].length();\n        }\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in downloads data dir: \" + space);\n        }\n        return space;\n    }\n\n    private long getAvailableBytesInFileSystemAtGivenRoot(File root) {\n        StatFs stat = new StatFs(root.getPath());\n        // put a bit of margin (in case creating the file grows the system by a few blocks)\n        long availableBlocks = (long) stat.getAvailableBlocks() - 4;\n        long size = stat.getBlockSize() * availableBlocks;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in filesystem rooted at: \" +\n                    root.getPath() + \" is: \" + size);\n        }\n        return size;\n    }\n\n    File locateDestinationDirectory(String mimeType, int destination, long contentLength)\n            throws StopRequestException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                return mDownloadDataDir;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                return mSystemCacheDir;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                File base = new File(mExternalStorageDir.getPath() + Constants.DEFAULT_DL_SUBDIR);\n                if (!base.isDirectory() && !base.mkdir()) {\n                    // Can't create download directory, e.g. because a file called \"download\"\n                    // already exists at the root level, or the SD card filesystem is read-only.\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"unable to create external downloads directory \" + base.getPath());\n                }\n                return base;\n            default:\n                throw new IllegalStateException(\"unexpected value for destination: \" + destination);\n        }\n    }\n\n    File getDownloadDataDirectory() {\n        return mDownloadDataDir;\n    }\n\n    /**\n     * Deletes purgeable files from the cache partition. This also deletes\n     * the matching database entries. Files are deleted in LRU order until\n     * the total byte size is greater than targetBytes\n     */\n    private long discardPurgeableFiles(int destination, long targetBytes) {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"discardPurgeableFiles: destination = \" + destination +\n                    \", targetBytes = \" + targetBytes);\n        }\n        String destStr  = (destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) ?\n                String.valueOf(destination) :\n                String.valueOf(Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n        String[] bindArgs = new String[]{destStr};\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                null,\n                \"( \" +\n                Downloads.Impl.COLUMN_STATUS + \" = '\" + Downloads.Impl.STATUS_SUCCESS + \"' AND \" +\n                Downloads.Impl.COLUMN_DESTINATION + \" = ? )\",\n                bindArgs,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        if (cursor == null) {\n            return 0;\n        }\n        long totalFreed = 0;\n        try {\n            final int dataIndex = cursor.getColumnIndex(Downloads.Impl._DATA);\n            while (cursor.moveToNext() && totalFreed < targetBytes) {\n                final String data = cursor.getString(dataIndex);\n                if (TextUtils.isEmpty(data)) continue;\n\n                File file = new File(data);\n                if (true || Constants.LOGV) {\n                    Slog.d(Constants.TAG, \"purging \" + file.getAbsolutePath() + \" for \" +\n                            file.length() + \" bytes\");\n                }\n                totalFreed += file.length();\n                file.delete();\n                long id = cursor.getLong(cursor.getColumnIndex(Downloads.Impl._ID));\n                mContext.getContentResolver().delete(\n                        ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                        null, null);\n            }\n        } finally {\n            cursor.close();\n        }\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"Purged files, freed \" + totalFreed + \" for \" +\n                    targetBytes + \" requested\");\n        }\n        return totalFreed;\n    }\n\n    /**\n     * Removes files in the systemcache and downloads data dir without corresponding entries in\n     * the downloads database.\n     * This can occur if a delete is done on the database but the file is not removed from the\n     * filesystem (due to sudden death of the process, for example).\n     * This is not a very common occurrence. So, do this only once in a while.\n     */\n    private void removeSpuriousFiles() {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"in removeSpuriousFiles\");\n        }\n        // get a list of all files in system cache dir and downloads data dir\n        List<File> files = new ArrayList<File>();\n        File[] listOfFiles = mSystemCacheDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        listOfFiles = mDownloadDataDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        if (files.size() == 0) {\n            return;\n        }\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._DATA }, null, null, null);\n        try {\n            if (cursor != null) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(0);\n                    if (!TextUtils.isEmpty(filename)) {\n                        if (LOGV) {\n                            Log.i(Constants.TAG, \"in removeSpuriousFiles, preserving file \" +\n                                    filename);\n                        }\n                        files.remove(new File(filename));\n                    }\n                }\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n\n        // delete files owned by us, but that don't appear in our database\n        final int myUid = android.os.Process.myUid();\n        for (File file : files) {\n            final String path = file.getAbsolutePath();\n            try {\n                final StructStat stat = Libcore.os.stat(path);\n                if (stat.st_uid == myUid) {\n                    Slog.d(TAG, \"deleting spurious file \" + path);\n                    file.delete();\n                }\n            } catch (ErrnoException e) {\n                Log.w(TAG, \"stat(\" + path + \") result: \" + e);\n            }\n        }\n    }\n\n    /**\n     * Drops old rows from the database to prevent it from growing too large\n     * TODO logic in this method needs to be optimized. maintain the number of downloads\n     * in memory - so that this method can limit the amount of data read.\n     */\n    private void trimDatabase() {\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in trimDatabase\");\n        }\n        Cursor cursor = null;\n        try {\n            cursor = mContext.getContentResolver().query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    new String[] { Downloads.Impl._ID },\n                    Downloads.Impl.COLUMN_STATUS + \" >= '200'\", null,\n                    Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            if (cursor == null) {\n                // This isn't good - if we can't do basic queries in our database,\n                // nothing's gonna work\n                Log.e(Constants.TAG, \"null cursor in trimDatabase\");\n                return;\n            }\n            if (cursor.moveToFirst()) {\n                int numDelete = cursor.getCount() - Constants.MAX_DOWNLOADS;\n                int columnId = cursor.getColumnIndexOrThrow(Downloads.Impl._ID);\n                while (numDelete > 0) {\n                    Uri downloadUri = ContentUris.withAppendedId(\n                            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, cursor.getLong(columnId));\n                    mContext.getContentResolver().delete(downloadUri, null, null);\n                    if (!cursor.moveToNext()) {\n                        break;\n                    }\n                    numDelete--;\n                }\n            }\n        } catch (SQLiteException e) {\n            // trimming the database raised an exception. alright, ignore the exception\n            // and return silently. trimming database is not exactly a critical operation\n            // and there is no need to propagate the exception.\n            Log.w(Constants.TAG, \"trimDatabase failed with exception: \" + e.getMessage());\n            return;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private synchronized int incrementBytesDownloadedSinceLastCheckOnSpace(long val) {\n        mBytesDownloadedSinceLastCheckOnSpace += val;\n        return mBytesDownloadedSinceLastCheckOnSpace;\n    }\n\n    private synchronized void resetBytesDownloadedSinceLastCheckOnSpace() {\n        mBytesDownloadedSinceLastCheckOnSpace = 0;\n    }\n}\n","lineNo":415}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.StatFs;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.R;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Manages the storage space consumed by Downloads Data dir. When space falls below\n * a threshold limit (set in resource xml files), starts cleanup of the Downloads data dir\n * to free up space.\n */\nclass StorageManager {\n    /** the max amount of space allowed to be taken up by the downloads data dir */\n    private static final long sMaxdownloadDataDirSize =\n            Resources.getSystem().getInteger(R.integer.config_downloadDataDirSize) * 1024 * 1024;\n\n    /** threshold (in bytes) beyond which the low space warning kicks in and attempt is made to\n     * purge some downloaded files to make space\n     */\n    private static final long sDownloadDataDirLowSpaceThreshold =\n            Resources.getSystem().getInteger(\n                    R.integer.config_downloadDataDirLowSpaceThreshold)\n                    * sMaxdownloadDataDirSize / 100;\n\n    /** see {@link Environment#getExternalStorageDirectory()} */\n    private final File mExternalStorageDir;\n\n    /** see {@link Environment#getDownloadCacheDirectory()} */\n    private final File mSystemCacheDir;\n\n    /** The downloaded files are saved to this dir. it is the value returned by\n     * {@link Context#getCacheDir()}.\n     */\n    private final File mDownloadDataDir;\n\n    /** the Singleton instance of this class.\n     * TODO: once DownloadService is refactored into a long-living object, there is no need\n     * for this Singleton'ing.\n     */\n    private static StorageManager sSingleton = null;\n\n    /** how often do we need to perform checks on space to make sure space is available */\n    private static final int FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY = 1024 * 1024; // 1MB\n    private int mBytesDownloadedSinceLastCheckOnSpace = 0;\n\n    /** misc members */\n    private final Context mContext;\n\n    /**\n     * maintains Singleton instance of this class\n     */\n    synchronized static StorageManager getInstance(Context context) {\n        if (sSingleton == null) {\n            sSingleton = new StorageManager(context);\n        }\n        return sSingleton;\n    }\n\n    private StorageManager(Context context) { // constructor is private\n        mContext = context;\n        mDownloadDataDir = context.getCacheDir();\n        mExternalStorageDir = Environment.getExternalStorageDirectory();\n        mSystemCacheDir = Environment.getDownloadCacheDirectory();\n        startThreadToCleanupDatabaseAndPurgeFileSystem();\n    }\n\n    /** How often should database and filesystem be cleaned up to remove spurious files\n     * from the file system and\n     * The value is specified in terms of num of downloads since last time the cleanup was done.\n     */\n    private static final int FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP = 250;\n    private int mNumDownloadsSoFar = 0;\n\n    synchronized void incrementNumDownloadsSoFar() {\n        if (++mNumDownloadsSoFar % FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP == 0) {\n            startThreadToCleanupDatabaseAndPurgeFileSystem();\n        }\n    }\n    /* start a thread to cleanup the following\n     *      remove spurious files from the file system\n     *      remove excess entries from the database\n     */\n    private Thread mCleanupThread = null;\n    private synchronized void startThreadToCleanupDatabaseAndPurgeFileSystem() {\n        if (mCleanupThread != null && mCleanupThread.isAlive()) {\n            return;\n        }\n        mCleanupThread = new Thread() {\n            @Override public void run() {\n                removeSpuriousFiles();\n                trimDatabase();\n            }\n        };\n        mCleanupThread.start();\n    }\n\n    void verifySpaceBeforeWritingToFile(int destination, String path, long length)\n            throws StopRequestException {\n        // do this check only once for every 1MB of downloaded data\n        if (incrementBytesDownloadedSinceLastCheckOnSpace(length) <\n                FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY) {\n            return;\n        }\n        verifySpace(destination, path, length);\n    }\n\n    void verifySpace(int destination, String path, long length) throws StopRequestException {\n        resetBytesDownloadedSinceLastCheckOnSpace();\n        File dir = null;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in verifySpace, destination: \" + destination +\n                    \", path: \" + path + \", length: \" + length);\n        }\n        if (path == null) {\n            throw new IllegalArgumentException(\"path can't be null\");\n        }\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n                dir = mDownloadDataDir;\n                break;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                dir = mExternalStorageDir;\n                break;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                dir = mSystemCacheDir;\n                break;\n            case Downloads.Impl.DESTINATION_FILE_URI:\n                if (path.startsWith(mExternalStorageDir.getPath())) {\n                    dir = mExternalStorageDir;\n                } else if (path.startsWith(mDownloadDataDir.getPath())) {\n                    dir = mDownloadDataDir;\n                } else if (path.startsWith(mSystemCacheDir.getPath())) {\n                    dir = mSystemCacheDir;\n                }\n                break;\n         }\n        if (dir == null) {\n            throw new IllegalStateException(\"invalid combination of destination: \" + destination +\n                    \", path: \" + path);\n        }\n        findSpace(dir, length, destination);\n    }\n\n    /**\n     * finds space in the given filesystem (input param: root) to accommodate # of bytes\n     * specified by the input param(targetBytes).\n     * returns true if found. false otherwise.\n     */\n    private synchronized void findSpace(File root, long targetBytes, int destination)\n            throws StopRequestException {\n        if (targetBytes == 0) {\n            return;\n        }\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI ||\n                destination == Downloads.Impl.DESTINATION_EXTERNAL) {\n            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR,\n                        \"external media not mounted\");\n            }\n        }\n        // is there enough space in the file system of the given param 'root'.\n        long bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n        if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n            /* filesystem's available space is below threshold for low space warning.\n             * threshold typically is 10% of download data dir space quota.\n             * try to cleanup and see if the low space situation goes away.\n             */\n            discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n            removeSpuriousFiles();\n            bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                /*\n                 * available space is still below the threshold limit.\n                 *\n                 * If this is system cache dir, print a warning.\n                 * otherwise, don't allow downloading until more space\n                 * is available because downloadmanager shouldn't end up taking those last\n                 * few MB of space left on the filesystem.\n                 */\n                if (root.equals(mSystemCacheDir)) {\n                    Log.w(Constants.TAG, \"System cache dir ('/cache') is running low on space.\" +\n                            \"space available (in bytes): \" + bytesAvailable);\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                            \"space in the filesystem rooted at: \" + root +\n                            \" is below 10% availability. stopping this download.\");\n                }\n            }\n        }\n        if (root.equals(mDownloadDataDir)) {\n            // this download is going into downloads data dir. check space in that specific dir.\n            bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                // print a warning\n                Log.w(Constants.TAG, \"Downloads data dir: \" + root +\n                        \" is running low on space. space available (in bytes): \" + bytesAvailable);\n            }\n            if (bytesAvailable < targetBytes) {\n                // Insufficient space; make space.\n                discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n                removeSpuriousFiles();\n                bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            }\n        }\n        if (bytesAvailable < targetBytes) {\n            throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                    \"not enough free space in the filesystem rooted at: \" + root +\n                    \" and unable to free any more\");\n        }\n    }\n\n    /**\n     * returns the number of bytes available in the downloads data dir\n     * TODO this implementation is too slow. optimize it.\n     */\n    private long getAvailableBytesInDownloadsDataDir(File root) {\n        File[] files = root.listFiles();\n        long space = sMaxdownloadDataDirSize;\n        if (files == null) {\n            return space;\n        }\n        int size = files.length;\n        for (int i = 0; i < size; i++) {\n            space -= files[i].length();\n        }\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in downloads data dir: \" + space);\n        }\n        return space;\n    }\n\n    private long getAvailableBytesInFileSystemAtGivenRoot(File root) {\n        StatFs stat = new StatFs(root.getPath());\n        // put a bit of margin (in case creating the file grows the system by a few blocks)\n        long availableBlocks = (long) stat.getAvailableBlocks() - 4;\n        long size = stat.getBlockSize() * availableBlocks;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in filesystem rooted at: \" +\n                    root.getPath() + \" is: \" + size);\n        }\n        return size;\n    }\n\n    File locateDestinationDirectory(String mimeType, int destination, long contentLength)\n            throws StopRequestException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                return mDownloadDataDir;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                return mSystemCacheDir;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                File base = new File(mExternalStorageDir.getPath() + Constants.DEFAULT_DL_SUBDIR);\n                if (!base.isDirectory() && !base.mkdir()) {\n                    // Can't create download directory, e.g. because a file called \"download\"\n                    // already exists at the root level, or the SD card filesystem is read-only.\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"unable to create external downloads directory \" + base.getPath());\n                }\n                return base;\n            default:\n                throw new IllegalStateException(\"unexpected value for destination: \" + destination);\n        }\n    }\n\n    File getDownloadDataDirectory() {\n        return mDownloadDataDir;\n    }\n\n    /**\n     * Deletes purgeable files from the cache partition. This also deletes\n     * the matching database entries. Files are deleted in LRU order until\n     * the total byte size is greater than targetBytes\n     */\n    private long discardPurgeableFiles(int destination, long targetBytes) {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"discardPurgeableFiles: destination = \" + destination +\n                    \", targetBytes = \" + targetBytes);\n        }\n        String destStr  = (destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) ?\n                String.valueOf(destination) :\n                String.valueOf(Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n        String[] bindArgs = new String[]{destStr};\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                null,\n                \"( \" +\n                Downloads.Impl.COLUMN_STATUS + \" = '\" + Downloads.Impl.STATUS_SUCCESS + \"' AND \" +\n                Downloads.Impl.COLUMN_DESTINATION + \" = ? )\",\n                bindArgs,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        if (cursor == null) {\n            return 0;\n        }\n        long totalFreed = 0;\n        try {\n            while (cursor.moveToNext() && totalFreed < targetBytes) {\n                File file = new File(cursor.getString(cursor.getColumnIndex(Downloads.Impl._DATA)));\n                if (true || Constants.LOGV) {\n                    Slog.d(Constants.TAG, \"purging \" + file.getAbsolutePath() + \" for \" +\n                            file.length() + \" bytes\");\n                }\n                totalFreed += file.length();\n                file.delete();\n                long id = cursor.getLong(cursor.getColumnIndex(Downloads.Impl._ID));\n                mContext.getContentResolver().delete(\n                        ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                        null, null);\n            }\n        } finally {\n            cursor.close();\n        }\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"Purged files, freed \" + totalFreed + \" for \" +\n                    targetBytes + \" requested\");\n        }\n        return totalFreed;\n    }\n\n    /**\n     * Removes files in the systemcache and downloads data dir without corresponding entries in\n     * the downloads database.\n     * This can occur if a delete is done on the database but the file is not removed from the\n     * filesystem (due to sudden death of the process, for example).\n     * This is not a very common occurrence. So, do this only once in a while.\n     */\n    private void removeSpuriousFiles() {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"in removeSpuriousFiles\");\n        }\n        // get a list of all files in system cache dir and downloads data dir\n        List<File> files = new ArrayList<File>();\n        File[] listOfFiles = mSystemCacheDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        listOfFiles = mDownloadDataDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        if (files.size() == 0) {\n            return;\n        }\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._DATA }, null, null, null);\n        try {\n            if (cursor != null) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(0);\n                    if (!TextUtils.isEmpty(filename)) {\n                        if (true || Constants.LOGV) {\n                            Log.i(Constants.TAG, \"in removeSpuriousFiles, preserving file \" +\n                                    filename);\n                        }\n                        files.remove(new File(filename));\n                    }\n                }\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        // delete the files not found in the database\n        for (File file : files) {\n            if (file.getName().equals(Constants.KNOWN_SPURIOUS_FILENAME) ||\n                    file.getName().equalsIgnoreCase(Constants.RECOVERY_DIRECTORY)) {\n                continue;\n            }\n            if (true || Constants.LOGV) {\n                Slog.d(Constants.TAG, \"deleting spurious file \" + file.getAbsolutePath());\n            }\n            file.delete();\n        }\n    }\n\n    /**\n     * Drops old rows from the database to prevent it from growing too large\n     * TODO logic in this method needs to be optimized. maintain the number of downloads\n     * in memory - so that this method can limit the amount of data read.\n     */\n    private void trimDatabase() {\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in trimDatabase\");\n        }\n        Cursor cursor = null;\n        try {\n            cursor = mContext.getContentResolver().query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    new String[] { Downloads.Impl._ID },\n                    Downloads.Impl.COLUMN_STATUS + \" >= '200'\", null,\n                    Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            if (cursor == null) {\n                // This isn't good - if we can't do basic queries in our database,\n                // nothing's gonna work\n                Log.e(Constants.TAG, \"null cursor in trimDatabase\");\n                return;\n            }\n            if (cursor.moveToFirst()) {\n                int numDelete = cursor.getCount() - Constants.MAX_DOWNLOADS;\n                int columnId = cursor.getColumnIndexOrThrow(Downloads.Impl._ID);\n                while (numDelete > 0) {\n                    Uri downloadUri = ContentUris.withAppendedId(\n                            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, cursor.getLong(columnId));\n                    mContext.getContentResolver().delete(downloadUri, null, null);\n                    if (!cursor.moveToNext()) {\n                        break;\n                    }\n                    numDelete--;\n                }\n            }\n        } catch (SQLiteException e) {\n            // trimming the database raised an exception. alright, ignore the exception\n            // and return silently. trimming database is not exactly a critical operation\n            // and there is no need to propagate the exception.\n            Log.w(Constants.TAG, \"trimDatabase failed with exception: \" + e.getMessage());\n            return;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private synchronized int incrementBytesDownloadedSinceLastCheckOnSpace(long val) {\n        mBytesDownloadedSinceLastCheckOnSpace += val;\n        return mBytesDownloadedSinceLastCheckOnSpace;\n    }\n\n    private synchronized void resetBytesDownloadedSinceLastCheckOnSpace() {\n        mBytesDownloadedSinceLastCheckOnSpace = 0;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.StatFs;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.R;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Manages the storage space consumed by Downloads Data dir. When space falls below\n * a threshold limit (set in resource xml files), starts cleanup of the Downloads data dir\n * to free up space.\n */\nclass StorageManager {\n    /** the max amount of space allowed to be taken up by the downloads data dir */\n    private static final long sMaxdownloadDataDirSize =\n            Resources.getSystem().getInteger(R.integer.config_downloadDataDirSize) * 1024 * 1024;\n\n    /** threshold (in bytes) beyond which the low space warning kicks in and attempt is made to\n     * purge some downloaded files to make space\n     */\n    private static final long sDownloadDataDirLowSpaceThreshold =\n            Resources.getSystem().getInteger(\n                    R.integer.config_downloadDataDirLowSpaceThreshold)\n                    * sMaxdownloadDataDirSize / 100;\n\n    /** see {@link Environment#getExternalStorageDirectory()} */\n    private final File mExternalStorageDir;\n\n    /** see {@link Environment#getDownloadCacheDirectory()} */\n    private final File mSystemCacheDir;\n\n    /** The downloaded files are saved to this dir. it is the value returned by\n     * {@link Context#getCacheDir()}.\n     */\n    private final File mDownloadDataDir;\n\n    /** the Singleton instance of this class.\n     * TODO: once DownloadService is refactored into a long-living object, there is no need\n     * for this Singleton'ing.\n     */\n    private static StorageManager sSingleton = null;\n\n    /** how often do we need to perform checks on space to make sure space is available */\n    private static final int FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY = 1024 * 1024; // 1MB\n    private int mBytesDownloadedSinceLastCheckOnSpace = 0;\n\n    /** misc members */\n    private final Context mContext;\n\n    /**\n     * maintains Singleton instance of this class\n     */\n    synchronized static StorageManager getInstance(Context context) {\n        if (sSingleton == null) {\n            sSingleton = new StorageManager(context);\n        }\n        return sSingleton;\n    }\n\n    private StorageManager(Context context) { // constructor is private\n        mContext = context;\n        mDownloadDataDir = context.getCacheDir();\n        mExternalStorageDir = Environment.getExternalStorageDirectory();\n        mSystemCacheDir = Environment.getDownloadCacheDirectory();\n        startThreadToCleanupDatabaseAndPurgeFileSystem();\n    }\n\n    /** How often should database and filesystem be cleaned up to remove spurious files\n     * from the file system and\n     * The value is specified in terms of num of downloads since last time the cleanup was done.\n     */\n    private static final int FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP = 250;\n    private int mNumDownloadsSoFar = 0;\n\n    synchronized void incrementNumDownloadsSoFar() {\n        if (++mNumDownloadsSoFar % FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP == 0) {\n            startThreadToCleanupDatabaseAndPurgeFileSystem();\n        }\n    }\n    /* start a thread to cleanup the following\n     *      remove spurious files from the file system\n     *      remove excess entries from the database\n     */\n    private Thread mCleanupThread = null;\n    private synchronized void startThreadToCleanupDatabaseAndPurgeFileSystem() {\n        if (mCleanupThread != null && mCleanupThread.isAlive()) {\n            return;\n        }\n        mCleanupThread = new Thread() {\n            @Override public void run() {\n                removeSpuriousFiles();\n                trimDatabase();\n            }\n        };\n        mCleanupThread.start();\n    }\n\n    void verifySpaceBeforeWritingToFile(int destination, String path, long length)\n            throws StopRequestException {\n        // do this check only once for every 1MB of downloaded data\n        if (incrementBytesDownloadedSinceLastCheckOnSpace(length) <\n                FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY) {\n            return;\n        }\n        verifySpace(destination, path, length);\n    }\n\n    void verifySpace(int destination, String path, long length) throws StopRequestException {\n        resetBytesDownloadedSinceLastCheckOnSpace();\n        File dir = null;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in verifySpace, destination: \" + destination +\n                    \", path: \" + path + \", length: \" + length);\n        }\n        if (path == null) {\n            throw new IllegalArgumentException(\"path can't be null\");\n        }\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n                dir = mDownloadDataDir;\n                break;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                dir = mExternalStorageDir;\n                break;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                dir = mSystemCacheDir;\n                break;\n            case Downloads.Impl.DESTINATION_FILE_URI:\n                if (path.startsWith(mExternalStorageDir.getPath())) {\n                    dir = mExternalStorageDir;\n                } else if (path.startsWith(mDownloadDataDir.getPath())) {\n                    dir = mDownloadDataDir;\n                } else if (path.startsWith(mSystemCacheDir.getPath())) {\n                    dir = mSystemCacheDir;\n                }\n                break;\n         }\n        if (dir == null) {\n            throw new IllegalStateException(\"invalid combination of destination: \" + destination +\n                    \", path: \" + path);\n        }\n        findSpace(dir, length, destination);\n    }\n\n    /**\n     * finds space in the given filesystem (input param: root) to accommodate # of bytes\n     * specified by the input param(targetBytes).\n     * returns true if found. false otherwise.\n     */\n    private synchronized void findSpace(File root, long targetBytes, int destination)\n            throws StopRequestException {\n        if (targetBytes == 0) {\n            return;\n        }\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI ||\n                destination == Downloads.Impl.DESTINATION_EXTERNAL) {\n            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR,\n                        \"external media not mounted\");\n            }\n        }\n        // is there enough space in the file system of the given param 'root'.\n        long bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n        if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n            /* filesystem's available space is below threshold for low space warning.\n             * threshold typically is 10% of download data dir space quota.\n             * try to cleanup and see if the low space situation goes away.\n             */\n            discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n            removeSpuriousFiles();\n            bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                /*\n                 * available space is still below the threshold limit.\n                 *\n                 * If this is system cache dir, print a warning.\n                 * otherwise, don't allow downloading until more space\n                 * is available because downloadmanager shouldn't end up taking those last\n                 * few MB of space left on the filesystem.\n                 */\n                if (root.equals(mSystemCacheDir)) {\n                    Log.w(Constants.TAG, \"System cache dir ('/cache') is running low on space.\" +\n                            \"space available (in bytes): \" + bytesAvailable);\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                            \"space in the filesystem rooted at: \" + root +\n                            \" is below 10% availability. stopping this download.\");\n                }\n            }\n        }\n        if (root.equals(mDownloadDataDir)) {\n            // this download is going into downloads data dir. check space in that specific dir.\n            bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                // print a warning\n                Log.w(Constants.TAG, \"Downloads data dir: \" + root +\n                        \" is running low on space. space available (in bytes): \" + bytesAvailable);\n            }\n            if (bytesAvailable < targetBytes) {\n                // Insufficient space; make space.\n                discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n                removeSpuriousFiles();\n                bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            }\n        }\n        if (bytesAvailable < targetBytes) {\n            throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                    \"not enough free space in the filesystem rooted at: \" + root +\n                    \" and unable to free any more\");\n        }\n    }\n\n    /**\n     * returns the number of bytes available in the downloads data dir\n     * TODO this implementation is too slow. optimize it.\n     */\n    private long getAvailableBytesInDownloadsDataDir(File root) {\n        File[] files = root.listFiles();\n        long space = sMaxdownloadDataDirSize;\n        if (files == null) {\n            return space;\n        }\n        int size = files.length;\n        for (int i = 0; i < size; i++) {\n            space -= files[i].length();\n        }\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in downloads data dir: \" + space);\n        }\n        return space;\n    }\n\n    private long getAvailableBytesInFileSystemAtGivenRoot(File root) {\n        StatFs stat = new StatFs(root.getPath());\n        // put a bit of margin (in case creating the file grows the system by a few blocks)\n        long availableBlocks = (long) stat.getAvailableBlocks() - 4;\n        long size = stat.getBlockSize() * availableBlocks;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in filesystem rooted at: \" +\n                    root.getPath() + \" is: \" + size);\n        }\n        return size;\n    }\n\n    File locateDestinationDirectory(String mimeType, int destination, long contentLength)\n            throws StopRequestException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                return mDownloadDataDir;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                return mSystemCacheDir;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                File base = new File(mExternalStorageDir.getPath() + Constants.DEFAULT_DL_SUBDIR);\n                if (!base.isDirectory() && !base.mkdir()) {\n                    // Can't create download directory, e.g. because a file called \"download\"\n                    // already exists at the root level, or the SD card filesystem is read-only.\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"unable to create external downloads directory \" + base.getPath());\n                }\n                return base;\n            default:\n                throw new IllegalStateException(\"unexpected value for destination: \" + destination);\n        }\n    }\n\n    File getDownloadDataDirectory() {\n        return mDownloadDataDir;\n    }\n\n    /**\n     * Deletes purgeable files from the cache partition. This also deletes\n     * the matching database entries. Files are deleted in LRU order until\n     * the total byte size is greater than targetBytes\n     */\n    private long discardPurgeableFiles(int destination, long targetBytes) {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"discardPurgeableFiles: destination = \" + destination +\n                    \", targetBytes = \" + targetBytes);\n        }\n        String destStr  = (destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) ?\n                String.valueOf(destination) :\n                String.valueOf(Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n        String[] bindArgs = new String[]{destStr};\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                null,\n                \"( \" +\n                Downloads.Impl.COLUMN_STATUS + \" = '\" + Downloads.Impl.STATUS_SUCCESS + \"' AND \" +\n                Downloads.Impl.COLUMN_DESTINATION + \" = ? )\",\n                bindArgs,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        if (cursor == null) {\n            return 0;\n        }\n        long totalFreed = 0;\n        try {\n            final int dataIndex = cursor.getColumnIndex(Downloads.Impl._DATA);\n            while (cursor.moveToNext() && totalFreed < targetBytes) {\n                final String data = cursor.getString(dataIndex);\n                if (TextUtils.isEmpty(data)) continue;\n\n                File file = new File(data);\n                if (true || Constants.LOGV) {\n                    Slog.d(Constants.TAG, \"purging \" + file.getAbsolutePath() + \" for \" +\n                            file.length() + \" bytes\");\n                }\n                totalFreed += file.length();\n                file.delete();\n                long id = cursor.getLong(cursor.getColumnIndex(Downloads.Impl._ID));\n                mContext.getContentResolver().delete(\n                        ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                        null, null);\n            }\n        } finally {\n            cursor.close();\n        }\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"Purged files, freed \" + totalFreed + \" for \" +\n                    targetBytes + \" requested\");\n        }\n        return totalFreed;\n    }\n\n    /**\n     * Removes files in the systemcache and downloads data dir without corresponding entries in\n     * the downloads database.\n     * This can occur if a delete is done on the database but the file is not removed from the\n     * filesystem (due to sudden death of the process, for example).\n     * This is not a very common occurrence. So, do this only once in a while.\n     */\n    private void removeSpuriousFiles() {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"in removeSpuriousFiles\");\n        }\n        // get a list of all files in system cache dir and downloads data dir\n        List<File> files = new ArrayList<File>();\n        File[] listOfFiles = mSystemCacheDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        listOfFiles = mDownloadDataDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        if (files.size() == 0) {\n            return;\n        }\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._DATA }, null, null, null);\n        try {\n            if (cursor != null) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(0);\n                    if (!TextUtils.isEmpty(filename)) {\n                        if (true || Constants.LOGV) {\n                            Log.i(Constants.TAG, \"in removeSpuriousFiles, preserving file \" +\n                                    filename);\n                        }\n                        files.remove(new File(filename));\n                    }\n                }\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        // delete the files not found in the database\n        for (File file : files) {\n            if (file.getName().equals(Constants.KNOWN_SPURIOUS_FILENAME) ||\n                    file.getName().equalsIgnoreCase(Constants.RECOVERY_DIRECTORY)) {\n                continue;\n            }\n            if (true || Constants.LOGV) {\n                Slog.d(Constants.TAG, \"deleting spurious file \" + file.getAbsolutePath());\n            }\n            file.delete();\n        }\n    }\n\n    /**\n     * Drops old rows from the database to prevent it from growing too large\n     * TODO logic in this method needs to be optimized. maintain the number of downloads\n     * in memory - so that this method can limit the amount of data read.\n     */\n    private void trimDatabase() {\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in trimDatabase\");\n        }\n        Cursor cursor = null;\n        try {\n            cursor = mContext.getContentResolver().query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    new String[] { Downloads.Impl._ID },\n                    Downloads.Impl.COLUMN_STATUS + \" >= '200'\", null,\n                    Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            if (cursor == null) {\n                // This isn't good - if we can't do basic queries in our database,\n                // nothing's gonna work\n                Log.e(Constants.TAG, \"null cursor in trimDatabase\");\n                return;\n            }\n            if (cursor.moveToFirst()) {\n                int numDelete = cursor.getCount() - Constants.MAX_DOWNLOADS;\n                int columnId = cursor.getColumnIndexOrThrow(Downloads.Impl._ID);\n                while (numDelete > 0) {\n                    Uri downloadUri = ContentUris.withAppendedId(\n                            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, cursor.getLong(columnId));\n                    mContext.getContentResolver().delete(downloadUri, null, null);\n                    if (!cursor.moveToNext()) {\n                        break;\n                    }\n                    numDelete--;\n                }\n            }\n        } catch (SQLiteException e) {\n            // trimming the database raised an exception. alright, ignore the exception\n            // and return silently. trimming database is not exactly a critical operation\n            // and there is no need to propagate the exception.\n            Log.w(Constants.TAG, \"trimDatabase failed with exception: \" + e.getMessage());\n            return;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private synchronized int incrementBytesDownloadedSinceLastCheckOnSpace(long val) {\n        mBytesDownloadedSinceLastCheckOnSpace += val;\n        return mBytesDownloadedSinceLastCheckOnSpace;\n    }\n\n    private synchronized void resetBytesDownloadedSinceLastCheckOnSpace() {\n        mBytesDownloadedSinceLastCheckOnSpace = 0;\n    }\n}\n","lineNo":332}
{"Smelly Sample":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.StatFs;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.R;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Manages the storage space consumed by Downloads Data dir. When space falls below\n * a threshold limit (set in resource xml files), starts cleanup of the Downloads data dir\n * to free up space.\n */\nclass StorageManager {\n    /** the max amount of space allowed to be taken up by the downloads data dir */\n    private static final long sMaxdownloadDataDirSize =\n            Resources.getSystem().getInteger(R.integer.config_downloadDataDirSize) * 1024 * 1024;\n\n    /** threshold (in bytes) beyond which the low space warning kicks in and attempt is made to\n     * purge some downloaded files to make space\n     */\n    private static final long sDownloadDataDirLowSpaceThreshold =\n            Resources.getSystem().getInteger(\n                    R.integer.config_downloadDataDirLowSpaceThreshold)\n                    * sMaxdownloadDataDirSize / 100;\n\n    /** see {@link Environment#getExternalStorageDirectory()} */\n    private final File mExternalStorageDir;\n\n    /** see {@link Environment#getDownloadCacheDirectory()} */\n    private final File mSystemCacheDir;\n\n    /** The downloaded files are saved to this dir. it is the value returned by\n     * {@link Context#getCacheDir()}.\n     */\n    private final File mDownloadDataDir;\n\n    /** the Singleton instance of this class.\n     * TODO: once DownloadService is refactored into a long-living object, there is no need\n     * for this Singleton'ing.\n     */\n    private static StorageManager sSingleton = null;\n\n    /** how often do we need to perform checks on space to make sure space is available */\n    private static final int FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY = 1024 * 1024; // 1MB\n    private int mBytesDownloadedSinceLastCheckOnSpace = 0;\n\n    /** misc members */\n    private final Context mContext;\n\n    /**\n     * maintains Singleton instance of this class\n     */\n    synchronized static StorageManager getInstance(Context context) {\n        if (sSingleton == null) {\n            sSingleton = new StorageManager(context);\n        }\n        return sSingleton;\n    }\n\n    private StorageManager(Context context) { // constructor is private\n        mContext = context;\n        mDownloadDataDir = context.getCacheDir();\n        mExternalStorageDir = Environment.getExternalStorageDirectory();\n        mSystemCacheDir = Environment.getDownloadCacheDirectory();\n        startThreadToCleanupDatabaseAndPurgeFileSystem();\n    }\n\n    /** How often should database and filesystem be cleaned up to remove spurious files\n     * from the file system and\n     * The value is specified in terms of num of downloads since last time the cleanup was done.\n     */\n    private static final int FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP = 250;\n    private int mNumDownloadsSoFar = 0;\n\n    synchronized void incrementNumDownloadsSoFar() {\n        if (++mNumDownloadsSoFar % FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP == 0) {\n            startThreadToCleanupDatabaseAndPurgeFileSystem();\n        }\n    }\n    /* start a thread to cleanup the following\n     *      remove spurious files from the file system\n     *      remove excess entries from the database\n     */\n    private Thread mCleanupThread = null;\n    private synchronized void startThreadToCleanupDatabaseAndPurgeFileSystem() {\n        if (mCleanupThread != null && mCleanupThread.isAlive()) {\n            return;\n        }\n        mCleanupThread = new Thread() {\n            @Override public void run() {\n                removeSpuriousFiles();\n                trimDatabase();\n            }\n        };\n        mCleanupThread.start();\n    }\n\n    void verifySpaceBeforeWritingToFile(int destination, String path, long length)\n            throws StopRequestException {\n        // do this check only once for every 1MB of downloaded data\n        if (incrementBytesDownloadedSinceLastCheckOnSpace(length) <\n                FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY) {\n            return;\n        }\n        verifySpace(destination, path, length);\n    }\n\n    void verifySpace(int destination, String path, long length) throws StopRequestException {\n        resetBytesDownloadedSinceLastCheckOnSpace();\n        File dir = null;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in verifySpace, destination: \" + destination +\n                    \", path: \" + path + \", length: \" + length);\n        }\n        if (path == null) {\n            throw new IllegalArgumentException(\"path can't be null\");\n        }\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n                dir = mDownloadDataDir;\n                break;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                dir = mExternalStorageDir;\n                break;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                dir = mSystemCacheDir;\n                break;\n            case Downloads.Impl.DESTINATION_FILE_URI:\n                if (path.startsWith(mExternalStorageDir.getPath())) {\n                    dir = mExternalStorageDir;\n                } else if (path.startsWith(mDownloadDataDir.getPath())) {\n                    dir = mDownloadDataDir;\n                } else if (path.startsWith(mSystemCacheDir.getPath())) {\n                    dir = mSystemCacheDir;\n                }\n                break;\n         }\n        if (dir == null) {\n            throw new IllegalStateException(\"invalid combination of destination: \" + destination +\n                    \", path: \" + path);\n        }\n        findSpace(dir, length, destination);\n    }\n\n    /**\n     * finds space in the given filesystem (input param: root) to accommodate # of bytes\n     * specified by the input param(targetBytes).\n     * returns true if found. false otherwise.\n     */\n    private synchronized void findSpace(File root, long targetBytes, int destination)\n            throws StopRequestException {\n        if (targetBytes == 0) {\n            return;\n        }\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI ||\n                destination == Downloads.Impl.DESTINATION_EXTERNAL) {\n            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR,\n                        \"external media not mounted\");\n            }\n        }\n        // is there enough space in the file system of the given param 'root'.\n        long bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n        if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n            /* filesystem's available space is below threshold for low space warning.\n             * threshold typically is 10% of download data dir space quota.\n             * try to cleanup and see if the low space situation goes away.\n             */\n            discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n            removeSpuriousFiles();\n            bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                /*\n                 * available space is still below the threshold limit.\n                 *\n                 * If this is system cache dir, print a warning.\n                 * otherwise, don't allow downloading until more space\n                 * is available because downloadmanager shouldn't end up taking those last\n                 * few MB of space left on the filesystem.\n                 */\n                if (root.equals(mSystemCacheDir)) {\n                    Log.w(Constants.TAG, \"System cache dir ('/cache') is running low on space.\" +\n                            \"space available (in bytes): \" + bytesAvailable);\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                            \"space in the filesystem rooted at: \" + root +\n                            \" is below 10% availability. stopping this download.\");\n                }\n            }\n        }\n        if (root.equals(mDownloadDataDir)) {\n            // this download is going into downloads data dir. check space in that specific dir.\n            bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                // print a warning\n                Log.w(Constants.TAG, \"Downloads data dir: \" + root +\n                        \" is running low on space. space available (in bytes): \" + bytesAvailable);\n            }\n            if (bytesAvailable < targetBytes) {\n                // Insufficient space; make space.\n                discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n                removeSpuriousFiles();\n                bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            }\n        }\n        if (bytesAvailable < targetBytes) {\n            throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                    \"not enough free space in the filesystem rooted at: \" + root +\n                    \" and unable to free any more\");\n        }\n    }\n\n    /**\n     * returns the number of bytes available in the downloads data dir\n     * TODO this implementation is too slow. optimize it.\n     */\n    private long getAvailableBytesInDownloadsDataDir(File root) {\n        File[] files = root.listFiles();\n        long space = sMaxdownloadDataDirSize;\n        if (files == null) {\n            return space;\n        }\n        int size = files.length;\n        for (int i = 0; i < size; i++) {\n            space -= files[i].length();\n        }\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in downloads data dir: \" + space);\n        }\n        return space;\n    }\n\n    private long getAvailableBytesInFileSystemAtGivenRoot(File root) {\n        StatFs stat = new StatFs(root.getPath());\n        // put a bit of margin (in case creating the file grows the system by a few blocks)\n        long availableBlocks = (long) stat.getAvailableBlocks() - 4;\n        long size = stat.getBlockSize() * availableBlocks;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in filesystem rooted at: \" +\n                    root.getPath() + \" is: \" + size);\n        }\n        return size;\n    }\n\n    File locateDestinationDirectory(String mimeType, int destination, long contentLength)\n            throws StopRequestException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                return mDownloadDataDir;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                return mSystemCacheDir;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                File base = new File(mExternalStorageDir.getPath() + Constants.DEFAULT_DL_SUBDIR);\n                if (!base.isDirectory() && !base.mkdir()) {\n                    // Can't create download directory, e.g. because a file called \"download\"\n                    // already exists at the root level, or the SD card filesystem is read-only.\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"unable to create external downloads directory \" + base.getPath());\n                }\n                return base;\n            default:\n                throw new IllegalStateException(\"unexpected value for destination: \" + destination);\n        }\n    }\n\n    File getDownloadDataDirectory() {\n        return mDownloadDataDir;\n    }\n\n    /**\n     * Deletes purgeable files from the cache partition. This also deletes\n     * the matching database entries. Files are deleted in LRU order until\n     * the total byte size is greater than targetBytes\n     */\n    private long discardPurgeableFiles(int destination, long targetBytes) {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"discardPurgeableFiles: destination = \" + destination +\n                    \", targetBytes = \" + targetBytes);\n        }\n        String destStr  = (destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) ?\n                String.valueOf(destination) :\n                String.valueOf(Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n        String[] bindArgs = new String[]{destStr};\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                null,\n                \"( \" +\n                Downloads.Impl.COLUMN_STATUS + \" = '\" + Downloads.Impl.STATUS_SUCCESS + \"' AND \" +\n                Downloads.Impl.COLUMN_DESTINATION + \" = ? )\",\n                bindArgs,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        if (cursor == null) {\n            return 0;\n        }\n        long totalFreed = 0;\n        try {\n            while (cursor.moveToNext() && totalFreed < targetBytes) {\n                File file = new File(cursor.getString(cursor.getColumnIndex(Downloads.Impl._DATA)));\n                if (true || Constants.LOGV) {\n                    Slog.d(Constants.TAG, \"purging \" + file.getAbsolutePath() + \" for \" +\n                            file.length() + \" bytes\");\n                }\n                totalFreed += file.length();\n                file.delete();\n                long id = cursor.getLong(cursor.getColumnIndex(Downloads.Impl._ID));\n                mContext.getContentResolver().delete(\n                        ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                        null, null);\n            }\n        } finally {\n            cursor.close();\n        }\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"Purged files, freed \" + totalFreed + \" for \" +\n                    targetBytes + \" requested\");\n        }\n        return totalFreed;\n    }\n\n    /**\n     * Removes files in the systemcache and downloads data dir without corresponding entries in\n     * the downloads database.\n     * This can occur if a delete is done on the database but the file is not removed from the\n     * filesystem (due to sudden death of the process, for example).\n     * This is not a very common occurrence. So, do this only once in a while.\n     */\n    private void removeSpuriousFiles() {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"in removeSpuriousFiles\");\n        }\n        // get a list of all files in system cache dir and downloads data dir\n        List<File> files = new ArrayList<File>();\n        File[] listOfFiles = mSystemCacheDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        listOfFiles = mDownloadDataDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        if (files.size() == 0) {\n            return;\n        }\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._DATA }, null, null, null);\n        try {\n            if (cursor != null) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(0);\n                    if (!TextUtils.isEmpty(filename)) {\n                        if (true || Constants.LOGV) {\n                            Log.i(Constants.TAG, \"in removeSpuriousFiles, preserving file \" +\n                                    filename);\n                        }\n                        files.remove(new File(filename));\n                    }\n                }\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        // delete the files not found in the database\n        for (File file : files) {\n            if (file.getName().equals(Constants.KNOWN_SPURIOUS_FILENAME) ||\n                    file.getName().equalsIgnoreCase(Constants.RECOVERY_DIRECTORY)) {\n                continue;\n            }\n            if (true || Constants.LOGV) {\n                Slog.d(Constants.TAG, \"deleting spurious file \" + file.getAbsolutePath());\n            }\n            file.delete();\n        }\n    }\n\n    /**\n     * Drops old rows from the database to prevent it from growing too large\n     * TODO logic in this method needs to be optimized. maintain the number of downloads\n     * in memory - so that this method can limit the amount of data read.\n     */\n    private void trimDatabase() {\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in trimDatabase\");\n        }\n        Cursor cursor = null;\n        try {\n            cursor = mContext.getContentResolver().query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    new String[] { Downloads.Impl._ID },\n                    Downloads.Impl.COLUMN_STATUS + \" >= '200'\", null,\n                    Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            if (cursor == null) {\n                // This isn't good - if we can't do basic queries in our database,\n                // nothing's gonna work\n                Log.e(Constants.TAG, \"null cursor in trimDatabase\");\n                return;\n            }\n            if (cursor.moveToFirst()) {\n                int numDelete = cursor.getCount() - Constants.MAX_DOWNLOADS;\n                int columnId = cursor.getColumnIndexOrThrow(Downloads.Impl._ID);\n                while (numDelete > 0) {\n                    Uri downloadUri = ContentUris.withAppendedId(\n                            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, cursor.getLong(columnId));\n                    mContext.getContentResolver().delete(downloadUri, null, null);\n                    if (!cursor.moveToNext()) {\n                        break;\n                    }\n                    numDelete--;\n                }\n            }\n        } catch (SQLiteException e) {\n            // trimming the database raised an exception. alright, ignore the exception\n            // and return silently. trimming database is not exactly a critical operation\n            // and there is no need to propagate the exception.\n            Log.w(Constants.TAG, \"trimDatabase failed with exception: \" + e.getMessage());\n            return;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private synchronized int incrementBytesDownloadedSinceLastCheckOnSpace(long val) {\n        mBytesDownloadedSinceLastCheckOnSpace += val;\n        return mBytesDownloadedSinceLastCheckOnSpace;\n    }\n\n    private synchronized void resetBytesDownloadedSinceLastCheckOnSpace() {\n        mBytesDownloadedSinceLastCheckOnSpace = 0;\n    }\n}\n","Method after Refactoring":"/*\n * Copyright (C) 2010 The Android Open Source Project\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.android.providers.downloads;\n\nimport android.content.ContentUris;\nimport android.content.Context;\nimport android.content.res.Resources;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteException;\nimport android.net.Uri;\nimport android.os.Environment;\nimport android.os.StatFs;\nimport android.provider.Downloads;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.util.Slog;\n\nimport com.android.internal.R;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Manages the storage space consumed by Downloads Data dir. When space falls below\n * a threshold limit (set in resource xml files), starts cleanup of the Downloads data dir\n * to free up space.\n */\nclass StorageManager {\n    /** the max amount of space allowed to be taken up by the downloads data dir */\n    private static final long sMaxdownloadDataDirSize =\n            Resources.getSystem().getInteger(R.integer.config_downloadDataDirSize) * 1024 * 1024;\n\n    /** threshold (in bytes) beyond which the low space warning kicks in and attempt is made to\n     * purge some downloaded files to make space\n     */\n    private static final long sDownloadDataDirLowSpaceThreshold =\n            Resources.getSystem().getInteger(\n                    R.integer.config_downloadDataDirLowSpaceThreshold)\n                    * sMaxdownloadDataDirSize / 100;\n\n    /** see {@link Environment#getExternalStorageDirectory()} */\n    private final File mExternalStorageDir;\n\n    /** see {@link Environment#getDownloadCacheDirectory()} */\n    private final File mSystemCacheDir;\n\n    /** The downloaded files are saved to this dir. it is the value returned by\n     * {@link Context#getCacheDir()}.\n     */\n    private final File mDownloadDataDir;\n\n    /** the Singleton instance of this class.\n     * TODO: once DownloadService is refactored into a long-living object, there is no need\n     * for this Singleton'ing.\n     */\n    private static StorageManager sSingleton = null;\n\n    /** how often do we need to perform checks on space to make sure space is available */\n    private static final int FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY = 1024 * 1024; // 1MB\n    private int mBytesDownloadedSinceLastCheckOnSpace = 0;\n\n    /** misc members */\n    private final Context mContext;\n\n    /**\n     * maintains Singleton instance of this class\n     */\n    synchronized static StorageManager getInstance(Context context) {\n        if (sSingleton == null) {\n            sSingleton = new StorageManager(context);\n        }\n        return sSingleton;\n    }\n\n    private StorageManager(Context context) { // constructor is private\n        mContext = context;\n        mDownloadDataDir = context.getCacheDir();\n        mExternalStorageDir = Environment.getExternalStorageDirectory();\n        mSystemCacheDir = Environment.getDownloadCacheDirectory();\n        startThreadToCleanupDatabaseAndPurgeFileSystem();\n    }\n\n    /** How often should database and filesystem be cleaned up to remove spurious files\n     * from the file system and\n     * The value is specified in terms of num of downloads since last time the cleanup was done.\n     */\n    private static final int FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP = 250;\n    private int mNumDownloadsSoFar = 0;\n\n    synchronized void incrementNumDownloadsSoFar() {\n        if (++mNumDownloadsSoFar % FREQUENCY_OF_DATABASE_N_FILESYSTEM_CLEANUP == 0) {\n            startThreadToCleanupDatabaseAndPurgeFileSystem();\n        }\n    }\n    /* start a thread to cleanup the following\n     *      remove spurious files from the file system\n     *      remove excess entries from the database\n     */\n    private Thread mCleanupThread = null;\n    private synchronized void startThreadToCleanupDatabaseAndPurgeFileSystem() {\n        if (mCleanupThread != null && mCleanupThread.isAlive()) {\n            return;\n        }\n        mCleanupThread = new Thread() {\n            @Override public void run() {\n                removeSpuriousFiles();\n                trimDatabase();\n            }\n        };\n        mCleanupThread.start();\n    }\n\n    void verifySpaceBeforeWritingToFile(int destination, String path, long length)\n            throws StopRequestException {\n        // do this check only once for every 1MB of downloaded data\n        if (incrementBytesDownloadedSinceLastCheckOnSpace(length) <\n                FREQUENCY_OF_CHECKS_ON_SPACE_AVAILABILITY) {\n            return;\n        }\n        verifySpace(destination, path, length);\n    }\n\n    void verifySpace(int destination, String path, long length) throws StopRequestException {\n        resetBytesDownloadedSinceLastCheckOnSpace();\n        File dir = null;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in verifySpace, destination: \" + destination +\n                    \", path: \" + path + \", length: \" + length);\n        }\n        if (path == null) {\n            throw new IllegalArgumentException(\"path can't be null\");\n        }\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n                dir = mDownloadDataDir;\n                break;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                dir = mExternalStorageDir;\n                break;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                dir = mSystemCacheDir;\n                break;\n            case Downloads.Impl.DESTINATION_FILE_URI:\n                if (path.startsWith(mExternalStorageDir.getPath())) {\n                    dir = mExternalStorageDir;\n                } else if (path.startsWith(mDownloadDataDir.getPath())) {\n                    dir = mDownloadDataDir;\n                } else if (path.startsWith(mSystemCacheDir.getPath())) {\n                    dir = mSystemCacheDir;\n                }\n                break;\n         }\n        if (dir == null) {\n            throw new IllegalStateException(\"invalid combination of destination: \" + destination +\n                    \", path: \" + path);\n        }\n        findSpace(dir, length, destination);\n    }\n\n    /**\n     * finds space in the given filesystem (input param: root) to accommodate # of bytes\n     * specified by the input param(targetBytes).\n     * returns true if found. false otherwise.\n     */\n    private synchronized void findSpace(File root, long targetBytes, int destination)\n            throws StopRequestException {\n        if (targetBytes == 0) {\n            return;\n        }\n        if (destination == Downloads.Impl.DESTINATION_FILE_URI ||\n                destination == Downloads.Impl.DESTINATION_EXTERNAL) {\n            if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) {\n                throw new StopRequestException(Downloads.Impl.STATUS_DEVICE_NOT_FOUND_ERROR,\n                        \"external media not mounted\");\n            }\n        }\n        // is there enough space in the file system of the given param 'root'.\n        long bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n        if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n            /* filesystem's available space is below threshold for low space warning.\n             * threshold typically is 10% of download data dir space quota.\n             * try to cleanup and see if the low space situation goes away.\n             */\n            discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n            removeSpuriousFiles();\n            bytesAvailable = getAvailableBytesInFileSystemAtGivenRoot(root);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                /*\n                 * available space is still below the threshold limit.\n                 *\n                 * If this is system cache dir, print a warning.\n                 * otherwise, don't allow downloading until more space\n                 * is available because downloadmanager shouldn't end up taking those last\n                 * few MB of space left on the filesystem.\n                 */\n                if (root.equals(mSystemCacheDir)) {\n                    Log.w(Constants.TAG, \"System cache dir ('/cache') is running low on space.\" +\n                            \"space available (in bytes): \" + bytesAvailable);\n                } else {\n                    throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                            \"space in the filesystem rooted at: \" + root +\n                            \" is below 10% availability. stopping this download.\");\n                }\n            }\n        }\n        if (root.equals(mDownloadDataDir)) {\n            // this download is going into downloads data dir. check space in that specific dir.\n            bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            if (bytesAvailable < sDownloadDataDirLowSpaceThreshold) {\n                // print a warning\n                Log.w(Constants.TAG, \"Downloads data dir: \" + root +\n                        \" is running low on space. space available (in bytes): \" + bytesAvailable);\n            }\n            if (bytesAvailable < targetBytes) {\n                // Insufficient space; make space.\n                discardPurgeableFiles(destination, sDownloadDataDirLowSpaceThreshold);\n                removeSpuriousFiles();\n                bytesAvailable = getAvailableBytesInDownloadsDataDir(mDownloadDataDir);\n            }\n        }\n        if (bytesAvailable < targetBytes) {\n            throw new StopRequestException(Downloads.Impl.STATUS_INSUFFICIENT_SPACE_ERROR,\n                    \"not enough free space in the filesystem rooted at: \" + root +\n                    \" and unable to free any more\");\n        }\n    }\n\n    /**\n     * returns the number of bytes available in the downloads data dir\n     * TODO this implementation is too slow. optimize it.\n     */\n    private long getAvailableBytesInDownloadsDataDir(File root) {\n        File[] files = root.listFiles();\n        long space = sMaxdownloadDataDirSize;\n        if (files == null) {\n            return space;\n        }\n        int size = files.length;\n        for (int i = 0; i < size; i++) {\n            space -= files[i].length();\n        }\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in downloads data dir: \" + space);\n        }\n        return space;\n    }\n\n    private long getAvailableBytesInFileSystemAtGivenRoot(File root) {\n        StatFs stat = new StatFs(root.getPath());\n        // put a bit of margin (in case creating the file grows the system by a few blocks)\n        long availableBlocks = (long) stat.getAvailableBlocks() - 4;\n        long size = stat.getBlockSize() * availableBlocks;\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"available space (in bytes) in filesystem rooted at: \" +\n                    root.getPath() + \" is: \" + size);\n        }\n        return size;\n    }\n\n    File locateDestinationDirectory(String mimeType, int destination, long contentLength)\n            throws StopRequestException {\n        switch (destination) {\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE:\n            case Downloads.Impl.DESTINATION_CACHE_PARTITION_NOROAMING:\n                return mDownloadDataDir;\n            case Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION:\n                return mSystemCacheDir;\n            case Downloads.Impl.DESTINATION_EXTERNAL:\n                File base = new File(mExternalStorageDir.getPath() + Constants.DEFAULT_DL_SUBDIR);\n                if (!base.isDirectory() && !base.mkdir()) {\n                    // Can't create download directory, e.g. because a file called \"download\"\n                    // already exists at the root level, or the SD card filesystem is read-only.\n                    throw new StopRequestException(Downloads.Impl.STATUS_FILE_ERROR,\n                            \"unable to create external downloads directory \" + base.getPath());\n                }\n                return base;\n            default:\n                throw new IllegalStateException(\"unexpected value for destination: \" + destination);\n        }\n    }\n\n    File getDownloadDataDirectory() {\n        return mDownloadDataDir;\n    }\n\n    /**\n     * Deletes purgeable files from the cache partition. This also deletes\n     * the matching database entries. Files are deleted in LRU order until\n     * the total byte size is greater than targetBytes\n     */\n    private long discardPurgeableFiles(int destination, long targetBytes) {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"discardPurgeableFiles: destination = \" + destination +\n                    \", targetBytes = \" + targetBytes);\n        }\n        String destStr  = (destination == Downloads.Impl.DESTINATION_SYSTEMCACHE_PARTITION) ?\n                String.valueOf(destination) :\n                String.valueOf(Downloads.Impl.DESTINATION_CACHE_PARTITION_PURGEABLE);\n        String[] bindArgs = new String[]{destStr};\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                null,\n                \"( \" +\n                Downloads.Impl.COLUMN_STATUS + \" = '\" + Downloads.Impl.STATUS_SUCCESS + \"' AND \" +\n                Downloads.Impl.COLUMN_DESTINATION + \" = ? )\",\n                bindArgs,\n                Downloads.Impl.COLUMN_LAST_MODIFICATION);\n        if (cursor == null) {\n            return 0;\n        }\n        long totalFreed = 0;\n        try {\n            final int dataIndex = cursor.getColumnIndex(Downloads.Impl._DATA);\n            while (cursor.moveToNext() && totalFreed < targetBytes) {\n                final String data = cursor.getString(dataIndex);\n                if (TextUtils.isEmpty(data)) continue;\n\n                File file = new File(data);\n                if (true || Constants.LOGV) {\n                    Slog.d(Constants.TAG, \"purging \" + file.getAbsolutePath() + \" for \" +\n                            file.length() + \" bytes\");\n                }\n                totalFreed += file.length();\n                file.delete();\n                long id = cursor.getLong(cursor.getColumnIndex(Downloads.Impl._ID));\n                mContext.getContentResolver().delete(\n                        ContentUris.withAppendedId(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, id),\n                        null, null);\n            }\n        } finally {\n            cursor.close();\n        }\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"Purged files, freed \" + totalFreed + \" for \" +\n                    targetBytes + \" requested\");\n        }\n        return totalFreed;\n    }\n\n    /**\n     * Removes files in the systemcache and downloads data dir without corresponding entries in\n     * the downloads database.\n     * This can occur if a delete is done on the database but the file is not removed from the\n     * filesystem (due to sudden death of the process, for example).\n     * This is not a very common occurrence. So, do this only once in a while.\n     */\n    private void removeSpuriousFiles() {\n        if (true || Constants.LOGV) {\n            Log.i(Constants.TAG, \"in removeSpuriousFiles\");\n        }\n        // get a list of all files in system cache dir and downloads data dir\n        List<File> files = new ArrayList<File>();\n        File[] listOfFiles = mSystemCacheDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        listOfFiles = mDownloadDataDir.listFiles();\n        if (listOfFiles != null) {\n            files.addAll(Arrays.asList(listOfFiles));\n        }\n        if (files.size() == 0) {\n            return;\n        }\n        Cursor cursor = mContext.getContentResolver().query(\n                Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                new String[] { Downloads.Impl._DATA }, null, null, null);\n        try {\n            if (cursor != null) {\n                while (cursor.moveToNext()) {\n                    String filename = cursor.getString(0);\n                    if (!TextUtils.isEmpty(filename)) {\n                        if (true || Constants.LOGV) {\n                            Log.i(Constants.TAG, \"in removeSpuriousFiles, preserving file \" +\n                                    filename);\n                        }\n                        files.remove(new File(filename));\n                    }\n                }\n            }\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n        // delete the files not found in the database\n        for (File file : files) {\n            if (file.getName().equals(Constants.KNOWN_SPURIOUS_FILENAME) ||\n                    file.getName().equalsIgnoreCase(Constants.RECOVERY_DIRECTORY)) {\n                continue;\n            }\n            if (true || Constants.LOGV) {\n                Slog.d(Constants.TAG, \"deleting spurious file \" + file.getAbsolutePath());\n            }\n            file.delete();\n        }\n    }\n\n    /**\n     * Drops old rows from the database to prevent it from growing too large\n     * TODO logic in this method needs to be optimized. maintain the number of downloads\n     * in memory - so that this method can limit the amount of data read.\n     */\n    private void trimDatabase() {\n        if (Constants.LOGV) {\n            Log.i(Constants.TAG, \"in trimDatabase\");\n        }\n        Cursor cursor = null;\n        try {\n            cursor = mContext.getContentResolver().query(Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI,\n                    new String[] { Downloads.Impl._ID },\n                    Downloads.Impl.COLUMN_STATUS + \" >= '200'\", null,\n                    Downloads.Impl.COLUMN_LAST_MODIFICATION);\n            if (cursor == null) {\n                // This isn't good - if we can't do basic queries in our database,\n                // nothing's gonna work\n                Log.e(Constants.TAG, \"null cursor in trimDatabase\");\n                return;\n            }\n            if (cursor.moveToFirst()) {\n                int numDelete = cursor.getCount() - Constants.MAX_DOWNLOADS;\n                int columnId = cursor.getColumnIndexOrThrow(Downloads.Impl._ID);\n                while (numDelete > 0) {\n                    Uri downloadUri = ContentUris.withAppendedId(\n                            Downloads.Impl.ALL_DOWNLOADS_CONTENT_URI, cursor.getLong(columnId));\n                    mContext.getContentResolver().delete(downloadUri, null, null);\n                    if (!cursor.moveToNext()) {\n                        break;\n                    }\n                    numDelete--;\n                }\n            }\n        } catch (SQLiteException e) {\n            // trimming the database raised an exception. alright, ignore the exception\n            // and return silently. trimming database is not exactly a critical operation\n            // and there is no need to propagate the exception.\n            Log.w(Constants.TAG, \"trimDatabase failed with exception: \" + e.getMessage());\n            return;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n        }\n    }\n\n    private synchronized int incrementBytesDownloadedSinceLastCheckOnSpace(long val) {\n        mBytesDownloadedSinceLastCheckOnSpace += val;\n        return mBytesDownloadedSinceLastCheckOnSpace;\n    }\n\n    private synchronized void resetBytesDownloadedSinceLastCheckOnSpace() {\n        mBytesDownloadedSinceLastCheckOnSpace = 0;\n    }\n}\n","lineNo":334}
